{"code": "import java . io . * ; class GFG {", "nl": "Java program to convert centimeter to pixels"}
{"code": "static double Conversion ( double centi ) { double pixels = ( 96 * centi ) / 2.54 ; System . out . println ( pixels ) ; return 0 ; }", "nl": "Function to convert centimeters to pixels"}
{"code": "public static void main ( String args [ ] ) { int centi = 15 ; Conversion ( centi ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int xor_operations ( int N , int arr [ ] , int M , int K ) {", "nl": "Method that returns the corresponding output by taking the given inputs ."}
{"code": "if ( M < 0 M >= N ) return - 1 ;", "nl": "If this condition is satisfied , value of M is invalid"}
{"code": "if ( K < 0 K >= N - M ) return - 1 ;", "nl": "Check if index K is valid"}
{"code": "for ( int p = 0 ; p < M ; p ++ ) {", "nl": "Loop to perform M operations"}
{"code": "Vector < Integer > temp = new Vector < Integer > ( ) ;", "nl": "Creating a temporary list"}
{"code": "for ( int i = 0 ; i < N - 1 ; i ++ ) {", "nl": "Traversing the array"}
{"code": "int value = arr [ i ] ^ arr [ i + 1 ] ;", "nl": "Calculate XOR values of adjacent elements"}
{"code": "temp . add ( value ) ;", "nl": "Adding this value to the temporary list"}
{"code": "arr [ i ] = temp . get ( i ) ; } }", "nl": "Update the original array"}
{"code": "int ans = arr [ K ] ; return ans ; }", "nl": "Getting value at index K"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 5 ;", "nl": "Number of elements"}
{"code": "int arr [ ] = { 1 , 4 , 5 , 6 , 7 } ; int M = 1 , K = 2 ;", "nl": "Given array arr [ ]"}
{"code": "System . out . print ( xor_operations ( N , arr , M , K ) ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "public static void canBreakN ( long n ) {", "nl": "Function to find the K consecutive elements with a sum equal to N"}
{"code": "for ( long i = 2 ; ; i ++ ) {", "nl": "Iterate over [ 2 , INF ]"}
{"code": "long m = i * ( i + 1 ) / 2 ;", "nl": "Store the sum"}
{"code": "if ( m > n ) break ; long k = n - m ;", "nl": "If the sum exceeds N then break the loop"}
{"code": "if ( k % i != 0 ) continue ;", "nl": "Common difference should be divisible by number of terms"}
{"code": "System . out . println ( i ) ; return ; }", "nl": "Print value of i & return"}
{"code": "System . out . println ( \" - 1\" ) ; }", "nl": "Print \" - 1\" if not possible to break N"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "long N = 12 ;", "nl": "Given N"}
{"code": "canBreakN ( N ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find two coprime divisors of a given number such that both are greater than 1"}
{"code": "public static void findCoprimePair ( int N ) {", "nl": "Function which finds the required pair of divisors of N"}
{"code": "for ( int x = 2 ; x <= Math . sqrt ( N ) ; x ++ ) { if ( N % x == 0 ) {", "nl": "We iterate upto sqrt ( N ) as we can find all the divisors of N in this time"}
{"code": "while ( N % x == 0 ) { N /= x ; } if ( N > 1 ) {", "nl": "If x is a divisor of N keep dividing as long as possible"}
{"code": "System . out . println ( x + \" \u2581 \" + N ) ; return ; } } }", "nl": "We have found a required pair"}
{"code": "System . out . println ( - 1 ) ; }", "nl": "No such pair of divisors of N was found , hence print - 1"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int N = 45 ; findCoprimePair ( N ) ;", "nl": "Sample example 1"}
{"code": "N = 25 ; findCoprimePair ( N ) ; } }", "nl": "Sample example 2"}
{"code": "import java . util . * ; class GFG { static int MAX = 10000 ;", "nl": "Java program for the above approach"}
{"code": "static Vector < Integer > primes = new Vector < Integer > ( ) ;", "nl": "Array to store all prime less than and equal to MAX ."}
{"code": "static void sieveSundaram ( ) {", "nl": "Function for Sieve of Sundaram"}
{"code": "boolean marked [ ] = new boolean [ MAX / 2 + 1 ] ;", "nl": "Boolean Array"}
{"code": "for ( int i = 1 ; i <= ( Math . sqrt ( MAX ) - 1 ) / 2 ; i ++ ) { for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) { marked [ j ] = true ; } }", "nl": "Mark all numbers which do not generate prime number by 2 * i + 1"}
{"code": "primes . add ( 2 ) ;", "nl": "Since 2 is a prime number"}
{"code": "for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . add ( 2 * i + 1 ) ; }", "nl": "Print remaining primes are of the form 2 * i + 1 such that marked [ i ] is false ."}
{"code": "static boolean isWasteful ( int n ) { if ( n == 1 ) return false ;", "nl": "Function that returns true if n is a Wasteful number"}
{"code": "int original_no = n ; int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits ++ ; original_no = original_no / 10 ; } int pDigit = 0 , count_exp = 0 , p = 0 ;", "nl": "Count digits in original number"}
{"code": "for ( int i = 0 ; primes . get ( i ) <= n / 2 ; i ++ ) {", "nl": "Count all digits in prime factors of N pDigit is going to hold this value ."}
{"code": "while ( n % primes . get ( i ) == 0 ) {", "nl": "Count powers of p in n"}
{"code": "p = primes . get ( i ) ; n = n / p ;", "nl": "If primes [ i ] is a prime factor ,"}
{"code": "count_exp ++ ; }", "nl": "Count the power of prime factors"}
{"code": "while ( p > 0 ) { pDigit ++ ; p = p / 10 ; }", "nl": "Add its digits to pDigit"}
{"code": "while ( count_exp > 1 ) { pDigit ++ ; count_exp = count_exp / 10 ; } }", "nl": "Add digits of power of prime factors to pDigit ."}
{"code": "if ( n != 1 ) { while ( n > 0 ) { pDigit ++ ; n = n / 10 ; } }", "nl": "If n != 1 then one prime factor still to be summed up"}
{"code": "return ( pDigit > sumDigits ) ; }", "nl": "If digits in prime factors is more than digits in original number then return true . Else return false ."}
{"code": "static void Solve ( int N ) {", "nl": "Function to print Wasteful Number before N"}
{"code": "for ( int i = 1 ; i < N ; i ++ ) { if ( isWasteful ( i ) ) { System . out . print ( i + \" \u2581 \" ) ; } } }", "nl": "Iterate till N and check if i is wastefull or not"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "sieveSundaram ( ) ; int N = 10 ;", "nl": "Precompute prime numbers upto 10 ^ 6"}
{"code": "Solve ( N ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java simple recursive program to print Nth Hexanacci numbers ."}
{"code": "static int printhexaRec ( int n ) { if ( n == 0 n == 1 n == 2 n == 3 n == 4 n == 5 ) return 0 ; else if ( n == 6 ) return 1 ; else return ( printhexaRec ( n - 1 ) + printhexaRec ( n - 2 ) + printhexaRec ( n - 3 ) + printhexaRec ( n - 4 ) + printhexaRec ( n - 5 ) + printhexaRec ( n - 6 ) ) ; } static void printhexa ( int n ) { System . out . print ( printhexaRec ( n ) + \"NEW_LINE\"); }", "nl": "Function to print the Nth Hexanacci number"}
{"code": "public static void main ( String [ ] args ) { int n = 11 ; printhexa ( n ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation to print Nth term of hexanacci numbers ."}
{"code": "static void printhexa ( int n ) { if ( n < 0 ) return ;", "nl": "Function to print the Nth term of the Hexanacci number"}
{"code": "int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 0 ; int sixth = 1 ;", "nl": "Initialize first five numbers to base cases"}
{"code": "int curr = 0 ; if ( n < 6 ) System . out . println ( first ) ; else if ( n == 6 ) System . out . println ( sixth ) ; else {", "nl": "Declare a current variable"}
{"code": "for ( int i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } System . out . println ( curr ) ; }", "nl": "Loop to add previous five numbers for each number starting from 5 and then assign first , second , third , fourth fifth to second , third , fourth , fifth and curr to sixth respectively"}
{"code": "public static void main ( String [ ] args ) { int n = 11 ; printhexa ( n ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find the smallest number whose sum of digits is also N"}
{"code": "static void smallestNumber ( int N ) { System . out . print ( ( N % 9 + 1 ) * Math . pow ( 10 , ( N / 9 ) ) - 1 ) ; }", "nl": "Function to find the smallest number whose sum of digits is also N"}
{"code": "public static void main ( String [ ] args ) { int N = 10 ; smallestNumber ( N ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static Vector < Integer > compo = new Vector < Integer > ( ) ;", "nl": "Java program to find compositorial of composite numbers"}
{"code": "static boolean isComposite ( int n ) {", "nl": "Function to check if a number is composite ."}
{"code": "if ( n <= 3 ) return false ;", "nl": "Corner cases"}
{"code": "if ( n % 2 == 0 n % 3 == 0 ) return true ; int i = 5 ; while ( i * i <= n ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; i = i + 6 ; } return false ; }", "nl": "This is checked so that we can skip the middle five numbers in the below loop"}
{"code": "static void Compositorial_list ( int n ) { int l = 0 ; for ( int i = 4 ; i < 1000000 ; i ++ ) { if ( l < n ) { if ( isComposite ( i ) ) { compo . add ( i ) ; l += 1 ; } } } }", "nl": "This function stores all composite numbers less than N"}
{"code": "static int calculateCompositorial ( int n ) {", "nl": "Function to calculate the compositorial of n"}
{"code": "int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result = result * compo . get ( i ) ; return result ; }", "nl": "Multiply first n composite number"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ;", "nl": "Driver code"}
{"code": "Compositorial_list ( n ) ; System . out . print ( ( calculateCompositorial ( n ) ) ) ; } }", "nl": "Vector to store all the composite less than N"}
{"code": "class GFG {", "nl": "Java implementation to find out the powers of N that add upto K"}
{"code": "static int b [ ] = new int [ 50 ] ;", "nl": "Initializing the PowerArray with all 0 's"}
{"code": "static int PowerArray ( int n , int k ) {", "nl": "Function to find the powers of N that add up to K"}
{"code": "int count = 0 ;", "nl": "Initializing the counter"}
{"code": "while ( k > 0 ) { if ( k % n == 0 ) { k /= n ; count ++ ; }", "nl": "Executing the while loop until K is greater than 0"}
{"code": "else if ( k % n == 1 ) { k -= 1 ; b [ count ] ++ ;", "nl": "If K % N == 1 , then the power array is incremented by 1"}
{"code": "if ( b [ count ] > 1 ) { System . out . print ( - 1 ) ; return 0 ; } }", "nl": "Checking if any power is occurred more than once"}
{"code": "else { System . out . print ( - 1 ) ; return 0 ; } }", "nl": "For any other value , the sum of powers cannot be added up to K"}
{"code": "for ( int i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] != 0 ) { System . out . print ( i + \" , \u2581 \" ) ; } } return Integer . MIN_VALUE ; }", "nl": "Printing the powers of N that sum up to K"}
{"code": "public static void main ( String [ ] args ) { int N = 3 ; int K = 40 ; PowerArray ( N , K ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java Program to find the value 1 ^ K + 2 ^ K + 3 ^ K + . . + N ^ K"}
{"code": "static int findSum ( int N , int k ) {", "nl": "Function to find value of 1 ^ K + 2 ^ K + 3 ^ K + . . + N ^ K"}
{"code": "int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) {", "nl": "Initialise sum to 0"}
{"code": "sum += ( int ) Math . pow ( i , k ) ; }", "nl": "Find the value of pow ( i , 4 ) and then add it to the sum"}
{"code": "return sum ; }", "nl": "Return the sum"}
{"code": "public static void main ( String [ ] args ) { int N = 8 , k = 4 ;", "nl": "Drivers Code"}
{"code": "System . out . println ( findSum ( N , k ) ) ; } }", "nl": "Function call to find the sum"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int countIndices ( int arr [ ] , int n ) {", "nl": "Function to return the count of indices that satisfy the given condition"}
{"code": "int cnt = 0 ;", "nl": "To store the result"}
{"code": "int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "To store the current maximum Initialized to 0 since there are only positive elements in the array"}
{"code": "if ( max < arr [ i ] ) {", "nl": "i is a valid index"}
{"code": "max = arr [ i ] ;", "nl": "Update the maximum so far"}
{"code": "cnt ++ ; } } return cnt ; }", "nl": "Increment the counter"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; System . out . println ( countIndices ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static String bin [ ] = { \"000\" , \"001\" , \"010\" , \"011\" , \"100\" , \"101\" , \"110\" , \"111\" } ;", "nl": "Binary representation of the digits"}
{"code": "static int maxFreq ( String s ) {", "nl": "Function to return the maximum frequency of s modulo with a power of 2"}
{"code": "String binary = \" \" ;", "nl": "Store the binary representation"}
{"code": "for ( int i = 0 ; i < s . length ( ) ; i ++ ) { binary += bin [ s . charAt ( i ) - '0' ] ; }", "nl": "Convert the octal to binary"}
{"code": "binary = binary . substring ( 0 , binary . length ( ) - 1 ) ; int count = 1 , prev = - 1 , i , j = 0 ; for ( i = binary . length ( ) - 1 ; i >= 0 ; i -- , j ++ )", "nl": "Remove the LSB"}
{"code": "if ( binary . charAt ( i ) == '1' ) {", "nl": "If there is 1 in the binary representation"}
{"code": "count = Math . max ( count , j - prev ) ; prev = j ; } return count ; }", "nl": "Find the number of zeroes in between two 1 's in the binary representation"}
{"code": "public static void main ( String [ ] args ) { String octal = \"13\" ; System . out . println ( maxFreq ( octal ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static int sz = 100000 ; static boolean isPrime [ ] = new boolean [ sz + 1 ] ;", "nl": "Java implementation of the approach"}
{"code": "static void sieve ( ) { for ( int i = 0 ; i <= sz ; i ++ ) isPrime [ i ] = true ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }", "nl": "Function for Sieve of Eratosthenes"}
{"code": "static void findPrimesD ( int d ) {", "nl": "Function to print all the prime numbers with d digits"}
{"code": "int left = ( int ) Math . pow ( 10 , d - 1 ) ; int right = ( int ) Math . pow ( 10 , d ) - 1 ;", "nl": "Range to check integers"}
{"code": "for ( int i = left ; i <= right ; i ++ ) {", "nl": "For every integer in the range"}
{"code": "if ( isPrime [ i ] ) { System . out . print ( i + \" \u2581 \" ) ; } } }", "nl": "If the current integer is prime"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver code"}
{"code": "sieve ( ) ; int d = 1 ; findPrimesD ( d ) ; } }", "nl": "Generate primes"}
{"code": "class GFG {", "nl": "Java program to find number of cells in the table contains X"}
{"code": "public static int Cells ( int n , int x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; int i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; }", "nl": "Function to find number of cells in the table contains X"}
{"code": "public static void main ( String [ ] args ) { int n = 6 , x = 12 ;", "nl": "Driver code"}
{"code": "System . out . println ( Cells ( n , x ) ) ; } }", "nl": "Function call"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find the maximum possible value of the minimum value of modified array"}
{"code": "static int maxOfMin ( int a [ ] , int n , int S ) {", "nl": "Function to find the maximum possible value of the minimum value of the modified array"}
{"code": "int mi = Integer . MAX_VALUE ;", "nl": "To store minimum value of array"}
{"code": "int s1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s1 += a [ i ] ; mi = Math . min ( a [ i ] , mi ) ; }", "nl": "To store sum of elements of array"}
{"code": "if ( s1 < S ) return - 1 ;", "nl": "Solution is not possible"}
{"code": "if ( s1 == S ) return 0 ;", "nl": "zero is the possible value"}
{"code": "int low = 0 ;", "nl": "minimum possible value"}
{"code": "int high = mi ;", "nl": "maximum possible value"}
{"code": "int ans = 0 ;", "nl": "to store a required answer"}
{"code": "while ( low <= high ) { int mid = ( low + high ) / 2 ;", "nl": "Binary Search"}
{"code": "if ( s1 - ( mid * n ) >= S ) { ans = mid ; low = mid + 1 ; }", "nl": "If mid is possible then try to increase required answer"}
{"code": "else high = mid - 1 ; }", "nl": "If mid is not possible then decrease required answer"}
{"code": "return ans ; }", "nl": "Return required answer"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 10 , 10 , 10 , 10 , 10 } ; int S = 10 ; int n = a . length ; System . out . println ( maxOfMin ( a , n , S ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class solution {", "nl": "Java implementation of the approach"}
{"code": "static void Alphabet_N_Pattern ( int N ) { int index , side_index , size ;", "nl": "Function to print the desired Alphabet N Pattern"}
{"code": "int Right = 1 , Left = 1 , Diagonal = 2 ;", "nl": "Declaring the values of Right , Left and Diagonal values"}
{"code": "for ( index = 0 ; index < N ; index ++ ) {", "nl": "Main Loop for the rows"}
{"code": "System . out . print ( Left ++ ) ;", "nl": "For the left Values"}
{"code": "for ( side_index = 0 ; side_index < 2 * ( index ) ; side_index ++ ) System . out . print ( \" \u2581 \" ) ;", "nl": "Spaces for the diagonals"}
{"code": "if ( index != 0 && index != N - 1 ) System . out . print ( Diagonal ++ ) ; else System . out . print ( \" \u2581 \" ) ;", "nl": "Condition for the diagonals"}
{"code": "for ( side_index = 0 ; side_index < 2 * ( N - index - 1 ) ; side_index ++ ) System . out . print ( \" \u2581 \" ) ;", "nl": "Spaces for the Right Values"}
{"code": "System . out . print ( Right ++ ) ; System . out . println ( ) ; } }", "nl": "For the right values"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "int Size = 6 ;", "nl": "Size of the Pattern"}
{"code": "Alphabet_N_Pattern ( Size ) ; } }", "nl": "Calling the function to print the desired Pattern"}
{"code": "import java . util . * ; import java . lang . * ; class GFG {", "nl": "Java program to check if sum of digits of a number divides it"}
{"code": "static int isSumDivides ( int N ) { int temp = N ; int sum = 0 ;", "nl": "Function to check if sum of digits of a number divides it"}
{"code": "while ( temp > 0 ) { sum += temp % 10 ; temp /= 10 ; } if ( N % sum == 0 ) return 1 ; else return 0 ; }", "nl": "Calculate sum of all of digits of N"}
{"code": "public static void main ( String args [ ] ) { int N = 12 ; if ( isSumDivides ( N ) == 1 ) System . out . print ( \" YES \" ) ; else System . out . print ( \" NO \" ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to find sum of numbers from 1 to N which are divisible by 3 or 4"}
{"code": "static int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; }", "nl": "Function to calculate the sum of numbers divisible by 3 or 4"}
{"code": "public static void main ( String [ ] args ) { int N = 20 ; System . out . print ( sum ( 12 ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find next greater number than N with exactly one bit different in binary representation of N"}
{"code": "static int nextGreater ( int N ) { int power_of_2 = 1 , shift_count = 0 ;", "nl": "Function to find next greater number than N with exactly one bit different in binary representation of N"}
{"code": "while ( true ) {", "nl": "It is guaranteed that there is a bit zero in the number"}
{"code": "if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ;", "nl": "If the shifted bit is zero then break"}
{"code": "shift_count ++ ;", "nl": "increase the bit shift"}
{"code": "power_of_2 = power_of_2 * 2 ; }", "nl": "increase the power of 2"}
{"code": "return ( N + power_of_2 ) ; }", "nl": "set the lowest bit of the number"}
{"code": "public static void main ( String [ ] a ) { int N = 11 ;", "nl": "Driver code"}
{"code": "System . out . println ( \" The \u2581 next \u2581 number \u2581 is \u2581 = \u2581 \" + nextGreater ( N ) ) ; } }", "nl": "display the next number"}
{"code": "import java . io . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int countWays ( int n ) {", "nl": "Function to return the count of the total number of ways to cover the distance with 1 , 2 and 3 steps"}
{"code": "if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ;", "nl": "Base conditions"}
{"code": "int f0 = 1 , f1 = 1 , f2 = 2 ; int ans = 0 ;", "nl": "To store the last three stages"}
{"code": "for ( int i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; }", "nl": "Find the numbers of steps required to reach the distance i"}
{"code": "return ans ; }", "nl": "Return the required answer"}
{"code": "public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( countWays ( n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int n = 6 , m = 6 ;", "nl": "Java program for the above approach"}
{"code": "static void maxSum ( long arr [ ] [ ] ) {", "nl": "Function to find the maximum value"}
{"code": "long [ ] [ ] dp = new long [ n + 1 ] [ 3 ] ;", "nl": "Dp table"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Fill the dp in bottom up manner"}
{"code": "long m1 = 0 , m2 = 0 , m3 = 0 ; for ( int j = 0 ; j < m ; j ++ ) {", "nl": "Maximum of the three sections"}
{"code": "if ( ( j / ( m / 3 ) ) == 0 ) { m1 = Math . max ( m1 , arr [ i ] [ j ] ) ; }", "nl": "Maximum of the first section"}
{"code": "else if ( ( j / ( m / 3 ) ) == 1 ) { m2 = Math . max ( m2 , arr [ i ] [ j ] ) ; }", "nl": "Maximum of the second section"}
{"code": "else if ( ( j / ( m / 3 ) ) == 2 ) { m3 = Math . max ( m3 , arr [ i ] [ j ] ) ; } }", "nl": "Maximum of the third section"}
{"code": "dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; dp [ i + 1 ] [ 2 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; }", "nl": "If we choose element from section 1 , we cannot have selection from same section in adjacent rows"}
{"code": "System . out . print ( Math . max ( Math . max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) + \"NEW_LINE\"); }", "nl": "Print the maximum sum"}
{"code": "public static void main ( String [ ] args ) { long arr [ ] [ ] = { { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } } ; maxSum ( arr ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of above approach"}
{"code": "static void solve ( char [ ] s ) { int n = s . length ;", "nl": "Function to find the total palindromic odd length sub - sequences"}
{"code": "int [ ] [ ] dp = new int [ n ] [ n ] ;", "nl": "dp array to store the number of palindromic subsequences for 0 to i - 1 and j + 1 to n - 1"}
{"code": "for ( int len = n - 1 ; len >= 0 ; -- len ) {", "nl": "We will start with the largest distance between i and j"}
{"code": "for ( int i = 0 ; i + len < n ; ++ i ) {", "nl": "For each len , we fix our i"}
{"code": "int j = i + len ;", "nl": "For this i we will find our j"}
{"code": "if ( i == 0 && j == n - 1 ) { if ( s [ i ] == s [ j ] ) dp [ i ] [ j ] = 2 ; else if ( s [ i ] != s [ j ] ) dp [ i ] [ j ] = 1 ; } else { if ( s [ i ] == s [ j ] ) {", "nl": "Base cases"}
{"code": "if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 < 0 j + 1 >= n ) {", "nl": "If the characters are equal then look for out of bound index"}
{"code": "dp [ i ] [ j ] += 1 ; } } else if ( s [ i ] != s [ j ] ) {", "nl": "We have only 1 way that is to just pick these characters"}
{"code": "if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 >= 0 && j + 1 <= n - 1 ) {", "nl": "If the characters are not equal"}
{"code": "dp [ i ] [ j ] -= dp [ i - 1 ] [ j + 1 ] ; } } } } } Vector < Integer > ways = new Vector < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( i == 0 i == n - 1 ) {", "nl": "Subtract it as we have counted it twice"}
{"code": "ways . add ( 1 ) ; } else {", "nl": "We have just 1 palindrome sequence of length 1"}
{"code": "int total = dp [ i - 1 ] [ i + 1 ] ; ways . add ( total ) ; } } for ( int i = 0 ; i < ways . size ( ) ; ++ i ) { System . out . print ( ways . get ( i ) + \" \u2581 \" ) ; } }", "nl": "Else total ways would be sum of dp [ i - 1 ] [ i + 1 ] , that is number of palindrome sub - sequences from 1 to i - 1 + number of palindrome sub - sequences from i + 1 to n - 1"}
{"code": "public static void main ( String [ ] args ) { char [ ] s = \" xyxyx \" . toCharArray ( ) ; solve ( s ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; public class GFG {", "nl": "Java implementation of the approach"}
{"code": "static long getChicks ( int n ) {", "nl": "Function to return the number of chicks on the nth day"}
{"code": "int size = Math . max ( n , 7 ) ; long [ ] dp = new long [ size ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ;", "nl": "Size of dp [ ] has to be at least 6 ( 1 - based indexing )"}
{"code": "for ( int i = 2 ; i < 6 ; i ++ ) { dp [ i ] = dp [ i - 1 ] * 3 ; }", "nl": "Every day current population will be three times of the previous day"}
{"code": "dp [ 6 ] = 726 ;", "nl": "Manually calculated value"}
{"code": "for ( int i = 8 ; i <= n ; i ++ ) {", "nl": "From 8 th day onwards"}
{"code": "dp [ i ] = ( dp [ i - 1 ] - ( 2 * dp [ i - 6 ] / 3 ) ) * 3 ; } return dp [ n ] ; }", "nl": "Chick population decreases by 2 / 3 everyday . For 8 th day on [ i - 6 ] i . e 2 nd day population was 3 and so 2 new born die on the 6 th day and so on for the upcoming days"}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( getChicks ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int getChicks ( int n ) { int chicks = ( int ) Math . pow ( 3 , n - 1 ) ; return chicks ; }", "nl": "Function to return the number of chicks on the nth day"}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( getChicks ( n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int n = 3 ;", "nl": "Java implementation of the approach"}
{"code": "static int [ ] [ ] dp = new int [ n ] [ n ] ;", "nl": "2d array to store states of dp"}
{"code": "static int [ ] [ ] v = new int [ n ] [ n ] ;", "nl": "Array to determine whether a state has been solved before"}
{"code": "static int minSteps ( int i , int j , int arr [ ] [ ] ) {", "nl": "Function to return the minimum steps required"}
{"code": "if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 j > n - 1 ) { return 9999999 ; }", "nl": "Base cases"}
{"code": "if ( v [ i ] [ j ] == 1 ) { return dp [ i ] [ j ] ; } v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 9999999 ;", "nl": "If a state has been solved before it won 't be evaluated again"}
{"code": "for ( int k = Math . max ( 0 , arr [ i ] [ j ] + j - n + 1 ) ; k <= Math . min ( n - i - 1 , arr [ i ] [ j ] ) ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) ; } dp [ i ] [ j ] ++ ; return dp [ i ] [ j ] ; }", "nl": "Recurrence relation"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 4 , 1 , 2 } , { 1 , 1 , 1 } , { 2 , 1 , 1 } } ; int ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) { System . out . println ( - 1 ) ; } else { System . out . println ( ans ) ; } } }", "nl": "Driver code"}
{"code": "class GFG { static int n = 3 ;", "nl": "Java program to implement above approach"}
{"code": "static int dp [ ] [ ] = new int [ n ] [ n ] ;", "nl": "2d array to store states of dp"}
{"code": "static int [ ] [ ] v = new int [ n ] [ n ] ;", "nl": "array to determine whether a state has been solved before"}
{"code": "static int minSteps ( int i , int j , int arr [ ] [ ] ) {", "nl": "Function to find the minimum number of steps to reach the end of matrix"}
{"code": "if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 j > n - 1 ) { return 9999999 ; }", "nl": "base cases"}
{"code": "if ( v [ i ] [ j ] == 1 ) { return dp [ i ] [ j ] ; } v [ i ] [ j ] = 1 ;", "nl": "if a state has been solved before it won 't be evaluated again."}
{"code": "dp [ i ] [ j ] = 1 + Math . min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) ; return dp [ i ] [ j ] ; }", "nl": "recurrence relation"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 2 , 1 , 2 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int ans = minSteps ( 0 , 0 , arr ) ; if ( ans >= 9999999 ) { System . out . println ( - 1 ) ; } else { System . out . println ( ans ) ; } } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static int MAX = 1001 ; static int [ ] [ ] dp = new int [ MAX ] [ MAX ] ;", "nl": "A memoization based program to find maximum treasure that can be collected ."}
{"code": "static int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) {", "nl": "k is current index and col is previous color ."}
{"code": "return dp [ k ] [ col ] = 0 ; if ( dp [ k ] [ col ] != - 1 ) return dp [ k ] [ col ] ; int sum = 0 ;", "nl": "if ( k == n ) base case"}
{"code": "if ( col == color [ k ] ) sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ;", "nl": "check if color of this city is equal to prev visited city"}
{"code": "return dp [ k ] [ col ] = sum ; }", "nl": "return max of both options"}
{"code": "public static void main ( String [ ] args ) { int A = - 5 , B = 7 ; int treasure [ ] = { 4 , 8 , 2 , 9 } ; int color [ ] = { 2 , 2 , 6 , 2 } ; int n = color . length ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) dp [ i ] [ j ] = - 1 ; System . out . print ( MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "A DP based Java program to print the nth tetranacci number"}
{"code": "static void printTetra ( int n ) { int [ ] dp = new int [ n + 5 ] ;", "nl": "Function to print the N - th tetranacci number"}
{"code": "dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; System . out . print ( dp [ n ] ) ; }", "nl": "base cases"}
{"code": "public static void main ( String [ ] args ) { int n = 10 ; printTetra ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find maximum sum in a circular array such that no elements are adjacent in the sum ."}
{"code": "static int maxSum1 ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; int maxi = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) {", "nl": "Function to calculate the sum from 0 th position to ( n - 2 ) th position"}
{"code": "dp [ i ] = arr [ i ] ;", "nl": "copy the element of original array to dp [ ]"}
{"code": "if ( maxi < arr [ i ] ) maxi = arr [ i ] ; }", "nl": "find the maximum element in the array"}
{"code": "for ( int i = 2 ; i < n - 1 ; i ++ ) {", "nl": "start from 2 nd to n - 1 th pos"}
{"code": "for ( int j = 0 ; j < i - 1 ; j ++ ) {", "nl": "traverse for all pairs bottom - up approach"}
{"code": "if ( dp [ i ] < dp [ j ] + arr [ i ] ) { dp [ i ] = dp [ j ] + arr [ i ] ;", "nl": "dp - condition"}
{"code": "if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } }", "nl": "find maximum sum"}
{"code": "return maxi ; }", "nl": "return the maximum"}
{"code": "static int maxSum2 ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; int maxi = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; }", "nl": "Function to find the maximum sum from 1 st position to n - 1 - th position"}
{"code": "for ( int i = 3 ; i < n ; i ++ ) {", "nl": "Traverse from third to n - th pos"}
{"code": "for ( int j = 1 ; j < i - 1 ; j ++ ) {", "nl": "bootom - up approach"}
{"code": "if ( dp [ i ] < arr [ i ] + dp [ j ] ) { dp [ i ] = arr [ i ] + dp [ j ] ;", "nl": "dp condition"}
{"code": "if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } }", "nl": "find max sum"}
{"code": "return maxi ; } static int findMaxSum ( int arr [ ] , int n ) { int t = Math . max ( maxSum1 ( arr , n ) , maxSum2 ( arr , n ) ) ; return t ; }", "nl": "return max"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 1 } ; int n = arr . length ; System . out . println ( findMaxSum ( arr , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; import java . math . * ; class GFG {", "nl": "Java code for Dynamic Programming based solution that uses table P [ ] [ ] to calculate the Permutation Coefficient"}
{"code": "static int permutationCoeff ( int n , int k ) { int P [ ] [ ] = new int [ n + 2 ] [ k + 2 ] ;", "nl": "Returns value of Permutation Coefficient P ( n , k )"}
{"code": "for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , k ) ; j ++ ) {", "nl": "Calculate value of Permutation Coefficient in bottom up manner"}
{"code": "if ( j == 0 ) P [ i ] [ j ] = 1 ;", "nl": "Base Cases"}
{"code": "else P [ i ] [ j ] = P [ i - 1 ] [ j ] + ( j * P [ i - 1 ] [ j - 1 ] ) ;", "nl": "Calculate value using previosly stored values"}
{"code": "P [ i ] [ j + 1 ] = 0 ; } } return P [ n ] [ k ] ; }", "nl": "This step is important as P ( i , j ) = 0 for j > i"}
{"code": "public static void main ( String args [ ] ) { int n = 10 , k = 2 ; System . out . println ( \" Value \u2581 of \u2581 P ( \u2581 \" + n + \" , \" + k + \" ) \" + \" \u2581 is \u2581 \" + permutationCoeff ( n , k ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; public class GFG {", "nl": "A O ( n ) solution that uses table fact [ ] to calculate the Permutation Coefficient"}
{"code": "static int permutationCoeff ( int n , int k ) { int [ ] fact = new int [ n + 1 ] ;", "nl": "Returns value of Permutation Coefficient P ( n , k )"}
{"code": "fact [ 0 ] = 1 ;", "nl": "base case"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ;", "nl": "Calculate value factorials up to n"}
{"code": "return fact [ n ] / fact [ n - k ] ; }", "nl": "P ( n , k ) = n ! / ( n - k ) !"}
{"code": "static public void main ( String [ ] args ) { int n = 10 , k = 2 ; System . out . println ( \" Value \u2581 of \" + \" \u2581 P ( \u2581 \" + n + \" , \u2581 \" + k + \" ) \u2581 is \u2581 \" + permutationCoeff ( n , k ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "A recursive solution for subset sum problem"}
{"code": "static boolean isSubsetSum ( int set [ ] , int n , int sum ) {", "nl": "Returns true if there is a subset of set [ ] with sum equal to given sum"}
{"code": "if ( sum == 0 ) return true ; if ( n == 0 ) return false ;", "nl": "Base Cases"}
{"code": "if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ;", "nl": "If last element is greater than sum , then ignore it"}
{"code": "return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }", "nl": "else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element"}
{"code": "public static void main ( String args [ ] ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = set . length ; if ( isSubsetSum ( set , n , sum ) == true ) System . out . println ( \" Found \u2581 a \u2581 subset \" + \" \u2581 with \u2581 given \u2581 sum \" ) ; else System . out . println ( \" No \u2581 subset \u2581 with \" + \" \u2581 given \u2581 sum \" ) ; } }", "nl": "Driver code"}
{"code": "public class GFG {", "nl": "Java program to find bitwise XOR between binary string A and all the cyclic permutations of binary string B"}
{"code": "static void compute_z ( String s , int z [ ] ) { int l = 0 , r = 0 ; int n = s . length ( ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { if ( i > r ) { l = i ; r = i ; while ( r < n && s . charAt ( r - l ) == s . charAt ( r ) ) r ++ ; z [ i ] = r - l ; r -- ; } else { int k = i - l ; if ( z [ k ] < r - i + 1 ) { z [ i ] = z [ k ] ; } else { l = i ; while ( r < n && s . charAt ( r - l ) == s . charAt ( r ) ) r ++ ; z [ i ] = r - l ; r -- ; } } } }", "nl": "Implementation of Z - algorithm for linear time pattern searching"}
{"code": "static int countPermutation ( String a , String b ) {", "nl": "Function to get the count of the cyclic permutations of b that given 0 when XORed with a"}
{"code": "b = b + b ;", "nl": "concatenate b with b"}
{"code": "b = b . substring ( 0 , b . length ( ) - 1 ) ;", "nl": "new b now contains all the cyclic permutations of old b as it 's sub-strings"}
{"code": "int ans = 0 ; String s = a + \" $ \" + b ; int n = s . length ( ) ;", "nl": "concatenate pattern with text"}
{"code": "int z [ ] = new int [ n ] ; compute_z ( s , z ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) {", "nl": "Fill z array used in Z algorithm"}
{"code": "if ( z [ i ] == a . length ( ) ) ans ++ ; } return ans ; }", "nl": "pattern occurs at index i since z value of i equals pattern length"}
{"code": "public static void main ( String [ ] args ) { String a = \"101\" ; String b = \"101\" ; System . out . println ( countPermutation ( a , b ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void smallestSubsequence ( char [ ] S , int K ) {", "nl": "Function to find lexicographically smallest subsequence of size K"}
{"code": "int N = S . length ;", "nl": "Length of String"}
{"code": "Stack < Character > answer = new Stack < > ( ) ;", "nl": "Stores the minimum subsequence"}
{"code": "for ( int i = 0 ; i < N ; ++ i ) {", "nl": "Traverse the String S"}
{"code": "if ( answer . isEmpty ( ) ) { answer . add ( S [ i ] ) ; } else {", "nl": "If the stack is empty"}
{"code": "while ( ( ! answer . isEmpty ( ) ) && ( S [ i ] < answer . peek ( ) )", "nl": "Iterate till the current character is less than the the character at the top of stack"}
{"code": "&& ( answer . size ( ) - 1 + N - i >= K ) ) { answer . pop ( ) ; }", "nl": "Check if there are enough characters remaining to obtain length K"}
{"code": "if ( answer . isEmpty ( ) || answer . size ( ) < K ) {", "nl": "If stack size is < K"}
{"code": "answer . add ( S [ i ] ) ; } } }", "nl": "Push the current character into it"}
{"code": "String ret = \" \" ;", "nl": "Stores the resultant String"}
{"code": "while ( ! answer . isEmpty ( ) ) { ret += ( answer . peek ( ) ) ; answer . pop ( ) ; }", "nl": "Iterate until stack is empty"}
{"code": "ret = reverse ( ret ) ;", "nl": "Reverse the String"}
{"code": "System . out . print ( ret ) ; } static String reverse ( String input ) { char [ ] a = input . toCharArray ( ) ; int l , r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . valueOf ( a ) ; }", "nl": "Print the String"}
{"code": "public static void main ( String [ ] args ) { String S = \" aabdaabc \" ; int K = 3 ; smallestSubsequence ( S . toCharArray ( ) , K ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to check if the given string is right to left diagonal or not"}
{"code": "public static boolean is_rtol ( String s ) { int tmp = ( int ) ( Math . sqrt ( s . length ( ) ) ) - 1 ; char first = s . charAt ( tmp ) ;", "nl": "Function to check if the given string is right to left diagonal or not"}
{"code": "for ( int pos = tmp ; pos < s . length ( ) - 1 ; pos += tmp ) {", "nl": "Iterate over string"}
{"code": "if ( s . charAt ( pos ) != first ) { return false ; } } return true ; }", "nl": "If character is not same as the first character then return false"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "String str = \" abcxabxcaxbcxabc \" ;", "nl": "Given String str"}
{"code": "if ( is_rtol ( str ) ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java program to check if a given string can be split into substrings of size K having an equal sum of ASCII values ."}
{"code": "static boolean check ( String str , int K ) {", "nl": "Function for checking string"}
{"code": "if ( str . length ( ) % K == 0 ) { int sum = 0 , i ;", "nl": "Check if the string can be split into substrings of K length only"}
{"code": "for ( i = 0 ; i < K ; i ++ ) { sum += str . charAt ( i ) ; }", "nl": "Compute the sum of first substring of length K"}
{"code": "for ( int j = i ; j < str . length ( ) ; j += K ) { int s_comp = 0 ; for ( int p = j ; p < j + K ; p ++ ) s_comp += str . charAt ( p ) ;", "nl": "Compute the sum of remaining substrings"}
{"code": "if ( s_comp != sum )", "nl": "Check if sum is equal to that of the first substring"}
{"code": "return false ; }", "nl": "Since all sums are not equal , return false"}
{"code": "return true ; }", "nl": "All sums are equal , Return true"}
{"code": "return false ; }", "nl": "All substrings cannot be of size K"}
{"code": "public static void main ( String args [ ] ) { int K = 3 ; String str = \" abdcbbdba \" ; if ( check ( str , K ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int maxSum ( String str ) { int maximumSum = 0 ;", "nl": "Function to maximize the sum of the count of zeros and ones in the left and right substring"}
{"code": "int totalOnes = 0 ;", "nl": "To store the total ones"}
{"code": "for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '1' ) { totalOnes ++ ; } }", "nl": "Count the total numbers of ones in string str"}
{"code": "int zero = 0 , ones = 0 ;", "nl": "To store the count of zeros and ones while traversing string"}
{"code": "for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '0' ) { zero ++ ; } else { ones ++ ; }", "nl": "Iterate the given string and update the maximum sum"}
{"code": "maximumSum = Math . max ( maximumSum , zero + ( totalOnes - ones ) ) ; } return maximumSum ; }", "nl": "Update the maximum Sum"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "String str = \"011101\" ;", "nl": "Given binary string"}
{"code": "System . out . println ( maxSum ( str ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int maxLenSubStr ( String s ) {", "nl": "Function to return the length of the longest substring such that no three consecutive characters are same"}
{"code": "if ( s . length ( ) < 3 ) return s . length ( ) ;", "nl": "If the length of the given string is less than 3"}
{"code": "int temp = 2 ; int ans = 2 ;", "nl": "Initialize temporary and final ans to 2 as this is the minimum length of substring when length of the given string is greater than 2"}
{"code": "for ( int i = 2 ; i < s . length ( ) ; i ++ ) {", "nl": "Traverse the string from the third character to the last"}
{"code": "if ( s . charAt ( i ) != s . charAt ( i - 1 ) || s . charAt ( i ) != s . charAt ( i - 2 ) ) temp ++ ;", "nl": "If no three consecutive characters are same then increment temporary count"}
{"code": "else { ans = Math . max ( temp , ans ) ; temp = 2 ; } } ans = Math . max ( temp , ans ) ; return ans ; }", "nl": "Else update the final ans and reset the temporary count"}
{"code": "public static void main ( String [ ] args ) { String s = \" baaabbabbb \" ; System . out . println ( maxLenSubStr ( s ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class solution {", "nl": "Java program to count number of ways of removing a substring from a string such that all remaining characters are equal"}
{"code": "static int no_of_ways ( String s ) { int n = s . length ( ) ;", "nl": "Function to return the number of ways of removing a sub - string from s such that all the remaining characters are same"}
{"code": "int count_left = 0 , count_right = 0 ;", "nl": "To store the count of prefix and suffix"}
{"code": "for ( int i = 0 ; i < n ; ++ i ) { if ( s . charAt ( i ) == s . charAt ( 0 ) ) { ++ count_left ; } else break ; }", "nl": "Loop to count prefix"}
{"code": "for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s . charAt ( i ) == s . charAt ( n - 1 ) ) { ++ count_right ; } else break ; }", "nl": "Loop to count suffix"}
{"code": "if ( s . charAt ( 0 ) == s . charAt ( n - 1 ) ) return ( ( count_left + 1 ) * ( count_right + 1 ) ) ;", "nl": "First and last characters of the string are same"}
{"code": "else return ( count_left + count_right + 1 ) ; }", "nl": "Otherwise"}
{"code": "public static void main ( String args [ ] ) { String s = \" geeksforgeeks \" ; System . out . println ( no_of_ways ( s ) ) ; } }", "nl": "Driver function"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find substring with"}
{"code": "static void preCompute ( int n , String s , int pref [ ] ) { pref [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { pref [ i ] = pref [ i - 1 ] ; if ( s . charAt ( i - 1 ) == s . charAt ( i ) ) pref [ i ] ++ ; } }", "nl": "Function to create prefix array"}
{"code": "static int query ( int pref [ ] , int l , int r ) { return pref [ r ] - pref [ l ] ; }", "nl": "Function to return the result of the query"}
{"code": "public static void main ( String [ ] args ) { String s = \" ggggggg \" ; int n = s . length ( ) ; int pref [ ] = new int [ n ] ; preCompute ( n , s , pref ) ;", "nl": "Driver Code"}
{"code": "int l = 1 ; int r = 2 ; System . out . println ( query ( pref , l , r ) ) ;", "nl": "Query 1"}
{"code": "l = 1 ; r = 5 ; System . out . println ( query ( pref , l , r ) ) ; } }", "nl": "Query 2"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of above approach"}
{"code": "static String findDirection ( String s ) { int count = 0 ; String d = \" \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( 0 ) == 'NEW_LINE') return null ; if ( s . charAt ( i ) == ' L ' ) count -- ; else { if ( s . charAt ( i ) == ' R ' ) count ++ ; } }", "nl": "Function to find the final direction"}
{"code": "if ( count > 0 ) { if ( count % 4 == 0 ) d = \" N \" ; else if ( count % 4 == 1 ) d = \" E \" ; else if ( count % 4 == 2 ) d = \" S \" ; else if ( count % 4 == 3 ) d = \" W \" ; }", "nl": "if count is positive that implies resultant is clockwise direction"}
{"code": "if ( count < 0 ) { if ( count % 4 == 0 ) d = \" N \" ; else if ( count % 4 == - 1 ) d = \" W \" ; else if ( count % 4 == - 2 ) d = \" S \" ; else if ( count % 4 == - 3 ) d = \" E \" ; } return d ; }", "nl": "if count is negative that implies resultant is anti - clockwise direction"}
{"code": "public static void main ( String [ ] args ) { String s = \" LLRLRRL \" ; System . out . println ( findDirection ( s ) ) ; s = \" LL \" ; System . out . println ( findDirection ( s ) ) ; } }", "nl": "Driver code"}
{"code": "public class GFG {", "nl": "Java program to check if lowercase and uppercase characters are in same order"}
{"code": "static boolean isCheck ( String str ) { int len = str . length ( ) ; String lowerStr = \" \" , upperStr = \" \" ; char [ ] str1 = str . toCharArray ( ) ;", "nl": "Function to check if both the case follow the same order"}
{"code": "for ( int i = 0 ; i < len ; i ++ ) {", "nl": "Traverse the string"}
{"code": "if ( ( int ) ( str1 [ i ] ) >= 65 && ( int ) str1 [ i ] <= 91 ) upperStr = upperStr + str1 [ i ] ; else lowerStr = lowerStr + str1 [ i ] ; }", "nl": "Store both lowercase and uppercase in two different strings"}
{"code": "String transformStr = lowerStr . toUpperCase ( ) ; return ( transformStr . equals ( upperStr ) ) ; }", "nl": "transform lowerStr1 to upper"}
{"code": "public static void main ( String [ ] args ) { String str = \" geeGkEEsKS \" ; if ( isCheck ( str ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to move every character K times ahead in a given string"}
{"code": "static void encode ( String s , int k ) {", "nl": "Function to move string character"}
{"code": "String newS = \" \" ;", "nl": "changed string"}
{"code": "for ( int i = 0 ; i < s . length ( ) ; ++ i ) {", "nl": "iterate for every characters"}
{"code": "int val = s . charAt ( i ) ;", "nl": "ASCII value"}
{"code": "int dup = k ;", "nl": "store the duplicate"}
{"code": "if ( val + k > 122 ) { k -= ( 122 - val ) ; k = k % 26 ; newS += ( char ) ( 96 + k ) ; } else { newS += ( char ) ( val + k ) ; } k = dup ; }", "nl": "if k - th ahead character exceed ' z '"}
{"code": "System . out . println ( newS ) ; }", "nl": "print the new string"}
{"code": "public static void main ( String [ ] args ) { String str = \" abc \" ; int k = 28 ;", "nl": "Driver Code"}
{"code": "encode ( str , k ) ; } }", "nl": "function call"}
{"code": "import java . io . * ; import java . util . * ; import java . lang . * ; class GFG {", "nl": "Java program to remove all Vowels in between two consonants from the string"}
{"code": "static boolean isVowel ( char x ) { if ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) return true ; else return false ; }", "nl": "Function to check if the character x is a vowel or not"}
{"code": "static String updateSandwichedVowels ( String a ) { int n = a . length ( ) ;", "nl": "Returns the updated string formed after removing all the Sandwiched Vowels from the given string"}
{"code": "String updatedString = \" \" ;", "nl": "string to store the Updated String after removing the Sandwiched Vowels"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "traverse the string from left to right"}
{"code": "if ( i == 0 i == n - 1 ) { updatedString += a . charAt ( i ) ; continue ; }", "nl": "if the current character is the first or the last character of the string then , this needs to be appended to the updatedString , since the corner alphabet irrespective of it being a vowel or a consonant , is never ' Sandwiched '"}
{"code": "if ( isVowel ( a . charAt ( i ) ) == true && isVowel ( a . charAt ( i - 1 ) ) == false && isVowel ( a . charAt ( i + 1 ) ) == false ) { continue ; }", "nl": "Check if the current character of the string is a vowel and both the previous and the next characters are consonants , if so then this is a sandwiched vowel , thus is ignored and not appended to the updated string"}
{"code": "updatedString += a . charAt ( i ) ; } return updatedString ; }", "nl": "if this character is not a sandwiched Vowel append it to the updated String"}
{"code": "public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ;", "nl": "Driver Code"}
{"code": "String updatedString = updateSandwichedVowels ( str ) ; System . out . print ( updatedString ) ; } }", "nl": "Remove all the Sandwitched Vowels"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to print paths with maximum element in the path greater than K"}
{"code": "static class Node { int data ; Node left , right ; } ; static int ans ;", "nl": "A Binary Tree node"}
{"code": "static Node newNode ( int data ) { Node newNode = new Node ( ) ; newNode . data = data ; newNode . left = newNode . right = null ; return ( newNode ) ; }", "nl": "A utility function to create a new node"}
{"code": "static void findPathUtil ( Node root , int k , Vector < Integer > path , int flag ) { if ( root == null ) return ;", "nl": "A recursive function to print the paths whose maximum element is greater than or equal to K ."}
{"code": "if ( root . data >= k ) flag = 1 ;", "nl": "If the current node value is greater than or equal to k , then all the subtrees following that node will get printed , flag = 1 indicates to print the required path"}
{"code": "if ( root . left == null && root . right == null ) { if ( flag == 1 ) { ans = 1 ; System . out . print ( \" ( \" ) ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { System . out . print ( path . get ( i ) + \" , \u2581 \" ) ; } System . out . print ( root . data + \" ) , \u2581 \" ) ; } return ; }", "nl": "If the leaf node is encountered , then the path is printed if the size of the path vector is greater than 0"}
{"code": "path . add ( root . data ) ;", "nl": "Append the node to the path vector"}
{"code": "findPathUtil ( root . left , k , path , flag ) ; findPathUtil ( root . right , k , path , flag ) ;", "nl": "Recur left and right subtrees"}
{"code": "path . remove ( path . size ( ) - 1 ) ; }", "nl": "Backtracking to return the vector and print the path if the flag is 1"}
{"code": "static void findPath ( Node root , int k ) {", "nl": "Function to initialize the variables and call the utility function to print the paths with maximum values greater than or equal to K"}
{"code": "int flag = 0 ;", "nl": "Initialize flag"}
{"code": "ans = 0 ; Vector < Integer > v = new Vector < Integer > ( ) ;", "nl": "ans is used to check empty condition"}
{"code": "findPathUtil ( root , k , v , flag ) ;", "nl": "Call function that print path"}
{"code": "if ( ans == 0 ) System . out . print ( \" - 1\" ) ; }", "nl": "If the path doesn 't exist"}
{"code": "public static void main ( String [ ] args ) { int K = 25 ;", "nl": "Driver code"}
{"code": "Node root = newNode ( 10 ) ; root . left = newNode ( 5 ) ; root . right = newNode ( 8 ) ; root . left . left = newNode ( 29 ) ; root . left . right = newNode ( 2 ) ; root . right . right = newNode ( 98 ) ; root . right . left = newNode ( 1 ) ; root . right . right . right = newNode ( 50 ) ; root . left . left . left = newNode ( 20 ) ; findPath ( root , K ) ; } }", "nl": "Constructing the following tree : 10 / \\ 5 8 / \\ / \\ 29 2 1 98 / \\ 20 50"}
{"code": "class GFG {", "nl": "Java program to find N - th tridecagonal number"}
{"code": "static int Tridecagonal_num ( int n ) {", "nl": "Function to find N - th tridecagonal number"}
{"code": "return ( 11 * n * n - 9 * n ) / 2 ; }", "nl": "Formula to calculate nth tridecagonal number"}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( Tridecagonal_num ( n ) + \"NEW_LINE\"); n = 10 ; System . out . print ( Tridecagonal_num ( n ) + \"NEW_LINE\"); } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to checks if a binary tree is max heap or not"}
{"code": "static class Node { int data ; Node left ; Node right ; } ;", "nl": "Tree node structure"}
{"code": "static Node newNode ( int k ) { Node node = new Node ( ) ; node . data = k ; node . right = node . left = null ; return node ; } static boolean isHeap ( Node root ) { Queue < Node > q = new LinkedList < > ( ) ; q . add ( root ) ; boolean nullish = false ; while ( ! q . isEmpty ( ) ) { Node temp = q . peek ( ) ; q . remove ( ) ; if ( temp . left != null ) { if ( nullish temp . left . data >= temp . data ) { return false ; } q . add ( temp . left ) ; } else { nullish = true ; } if ( temp . right != null ) { if ( nullish temp . right . data >= temp . data ) { return false ; } q . add ( temp . right ) ; } else { nullish = true ; } } return true ; }", "nl": "To add a new node"}
{"code": "public static void main ( String [ ] args ) { Node root = null ; root = newNode ( 10 ) ; root . left = newNode ( 9 ) ; root . right = newNode ( 8 ) ; root . left . left = newNode ( 7 ) ; root . left . right = newNode ( 6 ) ; root . right . left = newNode ( 5 ) ; root . right . right = newNode ( 4 ) ; root . left . left . left = newNode ( 3 ) ; root . left . left . right = newNode ( 2 ) ; root . left . right . left = newNode ( 1 ) ;", "nl": "Driver code"}
{"code": "if ( isHeap ( root ) ) System . out . print ( \"Given binary tree is a HeapNEW_LINE\"); else System . out . print ( \"Given binary tree is not a HeapNEW_LINE\"); } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java program to find total possible numbers with n digits and weight w"}
{"code": "static int findNumbers ( int n , int w ) { int x = 0 , sum = 0 ;", "nl": "Function to find total possible numbers with n digits and weight w"}
{"code": "if ( w >= 0 && w <= 8 ) {", "nl": "When Weight of an integer is Positive"}
{"code": "x = 9 - w ; }", "nl": "Subtract the weight from 9"}
{"code": "else if ( w >= - 9 && w <= - 1 ) {", "nl": "When weight of an integer is negative"}
{"code": "x = 10 + w ; } sum = ( int ) Math . pow ( 10 , n - 2 ) ; sum = ( x * sum ) ; return sum ; }", "nl": "add the weight to 10 to make it positive"}
{"code": "public static void main ( String args [ ] ) { int n , w ;", "nl": "Driver code"}
{"code": "n = 3 ; w = 4 ;", "nl": "number of digits in an integer and w as weight"}
{"code": "System . out . println ( findNumbers ( n , w ) ) ; } }", "nl": "print the total possible numbers with n digits and weight w"}
{"code": "import java . io . * ; class GFG { static int MaximumHeight ( int [ ] a , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) {", "nl": "Java program to find the maximum height of Pyramidal Arrangement of array values"}
{"code": "int y = ( i * ( i + 1 ) ) / 2 ;", "nl": "Just checking whether ith level is possible or not if possible then we must have atleast ( i * ( i + 1 ) ) / 2 elements in the array"}
{"code": "if ( y < n ) result = i ;", "nl": "updating the result value each time"}
{"code": "else break ; } return result ; }", "nl": "otherwise we have exceeded n value"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 40 , 100 , 20 , 30 } ; int n = arr . length ; System . out . println ( MaximumHeight ( arr , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static int findK ( int n , int k ) { ArrayList < Integer > a = new ArrayList < Integer > ( n ) ;", "nl": "Java program to find k - th element in the Odd - Even sequence ."}
{"code": "for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 1 ) a . add ( i ) ;", "nl": "insert all the odd numbers from 1 to n ."}
{"code": "for ( int i = 1 ; i < n ; i ++ ) if ( i % 2 == 0 ) a . add ( i ) ; return ( a . get ( k - 1 ) ) ; }", "nl": "insert all the even numbers from 1 to n ."}
{"code": "public static void main ( String [ ] args ) { int n = 10 , k = 3 ; System . out . println ( findK ( n , k ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static int factorial ( int n ) {", "nl": "Java program to find factorial of given number"}
{"code": "return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }", "nl": "single line to find factorial"}
{"code": "public static void main ( String [ ] args ) { int num = 5 ; System . out . println ( \" Factorial \u2581 of \u2581 \" + num + \" \u2581 is \u2581 \" + factorial ( num ) ) ; } }", "nl": "Driver Code"}
{"code": "class PellNumber {", "nl": "Iterative Pell Number Series in Java"}
{"code": "public static int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c ; for ( int i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }", "nl": "calculate nth pell number"}
{"code": "public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( pell ( n ) ) ; } }", "nl": "driver function"}
{"code": "class Fibonacci {", "nl": "A simple Java program to check if n - th Fibonacci number is multiple of 10."}
{"code": "static boolean isMultipleOf10 ( int n ) { if ( n % 15 == 0 ) return true ; return false ; }", "nl": "Returns true if n - th Fibonacci number is multiple of 10."}
{"code": "public static void main ( String [ ] args ) { int n = 30 ; if ( isMultipleOf10 ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "main function"}
{"code": "public class Politeness {", "nl": "Java program to find politeness of a number"}
{"code": "static int countOddPrimeFactors ( int n ) { int result = 1 ;", "nl": "A function to count all odd prime factors of a given number n"}
{"code": "while ( n % 2 == 0 ) n /= 2 ;", "nl": "Eliminate all even prime factor of number of n"}
{"code": "for ( int i = 3 ; i * i <= n ; i += 2 ) { int divCount = 0 ;", "nl": "n must be odd at this point , so iterate for only odd numbers till sqrt ( n )"}
{"code": "while ( n % i == 0 ) { n /= i ; ++ divCount ; } result *= divCount + 1 ; }", "nl": "if i divides n , then start counting of Odd divisors"}
{"code": "if ( n > 2 ) result *= 2 ; return result ; } static int politness ( int n ) { return countOddPrimeFactors ( n ) - 1 ; }", "nl": "If n odd prime still remains then count it"}
{"code": "public static void main ( String [ ] args ) { int n = 90 ; System . out . println ( \" Politness \u2581 of \u2581 \" + n + \" \u2581 = \u2581 \" + politness ( n ) ) ; n = 15 ; System . out . println ( \" Politness \u2581 of \u2581 \" + n + \" \u2581 = \u2581 \" + politness ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static int MAX = 1000000 ;", "nl": "Java program to find the nearest prime to n ."}
{"code": "static ArrayList < Integer > primes = new ArrayList < Integer > ( ) ;", "nl": "array to store all primes less than 10 ^ 6"}
{"code": "static void Sieve ( ) { int n = MAX ;", "nl": "Utility function of Sieve of Sundaram"}
{"code": "int nNew = ( int ) Math . sqrt ( n ) ;", "nl": "In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x"}
{"code": "int [ ] marked = new int [ n / 2 + 500 ] ;", "nl": "This array is used to separate numbers of the form i + j + 2 ij from others where 1 <= i <= j"}
{"code": "for ( int i = 1 ; i <= ( nNew - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= n / 2 ; j = j + 2 * i + 1 ) marked [ j ] = 1 ;", "nl": "eliminate indexes which does not produce primes"}
{"code": "primes . add ( 2 ) ;", "nl": "Since 2 is a prime number"}
{"code": "for ( int i = 1 ; i <= n / 2 ; i ++ ) if ( marked [ i ] == 0 ) primes . add ( 2 * i + 1 ) ; }", "nl": "Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false ."}
{"code": "static int binarySearch ( int left , int right , int n ) { if ( left <= right ) { int mid = ( left + right ) / 2 ;", "nl": "modified binary search to find nearest prime less than N"}
{"code": "if ( mid == 0 || mid == primes . size ( ) - 1 ) return primes . get ( mid ) ;", "nl": "base condition is , if we are reaching at left corner or right corner of primes [ ] array then return that corner element because before or after that we don 't have any prime number in  primes array"}
{"code": "if ( primes . get ( mid ) == n ) return primes . get ( mid - 1 ) ;", "nl": "now if n is itself a prime so it will be present in primes array and here we have to find nearest prime less than n so we will return primes [ mid - 1 ]"}
{"code": "if ( primes . get ( mid ) < n && primes . get ( mid + 1 ) > n ) return primes . get ( mid ) ; if ( n < primes . get ( mid ) ) return binarySearch ( left , mid - 1 , n ) ; else return binarySearch ( mid + 1 , right , n ) ; } return 0 ; }", "nl": "now if primes [ mid ] < n and primes [ mid + 1 ] > n that mean we reached at nearest prime"}
{"code": "public static void main ( String [ ] args ) { Sieve ( ) ; int n = 17 ; System . out . println ( binarySearch ( 0 , primes . size ( ) - 1 , n ) ) ; } }", "nl": "Driver code"}
{"code": "class Test {", "nl": "Java program to find factorial of given number"}
{"code": "static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }", "nl": "method to find factorial of given number"}
{"code": "public static void main ( String [ ] args ) { int num = 5 ; System . out . println ( \" Factorial \u2581 of \u2581 \" + num + \" \u2581 is \u2581 \" + factorial ( 5 ) ) ; } }", "nl": "Driver method"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to unset the rightmost set bit"}
{"code": "static int FlipBits ( int n ) { return n -= ( n & ( - n ) ) ; }", "nl": "Unsets the rightmost set bit of n and returns the result"}
{"code": "public static void main ( String [ ] args ) { int N = 12 ; System . out . print ( \" The \u2581 number \u2581 after \u2581 unsetting \u2581 the \u2581 \" ) ; System . out . print ( \" rightmost \u2581 set \u2581 bit : \u2581 \" + FlipBits ( N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . HashSet ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void Maximum_xor_Triplet ( int n , int a [ ] ) {", "nl": "function to count maximum XOR value for a triplet"}
{"code": "HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) {", "nl": "set is used to avoid repetitions"}
{"code": "s . add ( a [ i ] ^ a [ j ] ) ; } } int ans = 0 ; for ( Integer i : s ) { for ( int j = 0 ; j < n ; j ++ ) {", "nl": "store all possible unique XOR value of pairs"}
{"code": "ans = Math . max ( ans , i ^ a [ j ] ) ; } } System . out . println ( ans ) ; }", "nl": "store maximum value"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 8 , 15 } ; int n = a . length ; Maximum_xor_Triplet ( n , a ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Arrays ; public class PrintMissing {", "nl": "A sorting based Java program to find missing elements from an array"}
{"code": "static void printMissing ( int ar [ ] , int low , int high ) { Arrays . sort ( ar ) ;", "nl": "Print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ]"}
{"code": "int index = ceilindex ( ar , low , 0 , ar . length - 1 ) ; int x = low ;", "nl": "Do binary search for ' low ' in sorted array and find index of first element which either equal to or greater than low ."}
{"code": "while ( index < ar . length && x <= high ) {", "nl": "Start from the found index and linearly search every range element x after this index in arr [ ]"}
{"code": "if ( ar [ index ] != x ) { System . out . print ( x + \" \u2581 \" ) ; }", "nl": "If x doesn 't math with current element  print it"}
{"code": "else index ++ ;", "nl": "If x matches , move to next element in arr [ ]"}
{"code": "x ++ ; }", "nl": "Move to next element in range [ low , high ]"}
{"code": "while ( x <= high ) { System . out . print ( x + \" \u2581 \" ) ; x ++ ; } }", "nl": "Print range elements thar are greater than the last element of sorted array ."}
{"code": "static int ceilindex ( int ar [ ] , int val , int low , int high ) { if ( val < ar [ 0 ] ) return 0 ; if ( val > ar [ ar . length - 1 ] ) return ar . length ; int mid = ( low + high ) / 2 ; if ( ar [ mid ] == val ) return mid ; if ( ar [ mid ] < val ) { if ( mid + 1 < high && ar [ mid + 1 ] >= val ) return mid + 1 ; return ceilindex ( ar , val , mid + 1 , high ) ; } else { if ( mid - 1 >= low && ar [ mid - 1 ] < val ) return mid ; return ceilindex ( ar , val , low , mid - 1 ) ; } }", "nl": "Utility function to find ceil index of given element"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int low = 1 , high = 10 ; printMissing ( arr , low , high ) ; } }", "nl": "Driver program to test above function"}
{"code": "import java . util . Arrays ; public class Print {", "nl": "An array based Java program to find missing elements from an array"}
{"code": "static void printMissing ( int arr [ ] , int low , int high ) {", "nl": "Print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ]"}
{"code": "boolean [ ] points_of_range = new boolean [ high - low + 1 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) {", "nl": "Create boolean array of size high - low + 1 , each index i representing wether ( i + low ) th element found or not ."}
{"code": "if ( low <= arr [ i ] && arr [ i ] <= high ) points_of_range [ arr [ i ] - low ] = true ; }", "nl": "if ith element of arr is in range low to high then mark corresponding index as true in array"}
{"code": "for ( int x = 0 ; x <= high - low ; x ++ ) { if ( points_of_range [ x ] == false ) System . out . print ( ( low + x ) + \" \u2581 \" ) ; } }", "nl": "Traverse through the range and print all elements whose value is false"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int low = 1 , high = 10 ; printMissing ( arr , low , high ) ; } }", "nl": "Driver program to test above function"}
{"code": "import java . util . Arrays ; import java . util . HashSet ; public class Print {", "nl": "A hashing based Java program to find missing elements from an array"}
{"code": "static void printMissing ( int ar [ ] , int low , int high ) { HashSet < Integer > hs = new HashSet < > ( ) ;", "nl": "Print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ]"}
{"code": "for ( int i = 0 ; i < ar . length ; i ++ ) hs . add ( ar [ i ] ) ;", "nl": "Insert all elements of arr [ ] in set"}
{"code": "for ( int i = low ; i <= high ; i ++ ) { if ( ! hs . contains ( i ) ) { System . out . print ( i + \" \u2581 \" ) ; } } }", "nl": "Traverse throught the range an print all missing elements"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int low = 1 , high = 10 ; printMissing ( arr , low , high ) ; } }", "nl": "Driver program to test above function"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find the k - th missing element in a given sequence"}
{"code": "static int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) {", "nl": "Returns k - th missing element . It returns - 1 if no k is more than number of missing elements ."}
{"code": "LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) s . add ( b [ i ] ) ;", "nl": "Insert all elements of givens sequence b [ ] ."}
{"code": "int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( ! s . contains ( a [ i ] ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return - 1 ; }", "nl": "Traverse through increasing sequence and keep track of count of missing numbers ."}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 15 } ; int b [ ] = { 4 , 10 , 6 , 8 , 12 } ; int n1 = a . length ; int n2 = b . length ; int k = 3 ; System . out . println ( find ( a , b , k , n1 , n2 ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java code for above approach"}
{"code": "static void findString ( String S , int N ) {", "nl": "Function to find the minimum number of string required to generate the original string"}
{"code": "int [ ] amounts = new int [ 26 ] ;", "nl": "Stores the frequency of each character of string S"}
{"code": "for ( int i = 0 ; i < 26 ; i ++ ) { amounts [ i ] = 0 ; }", "nl": "Iterate over the range [ 0 , 25 ]"}
{"code": "for ( int i = 0 ; i < S . length ( ) ; i ++ ) { amounts [ ( int ) ( S . charAt ( i ) - 97 ) ] ++ ; } int count = 0 ;", "nl": "Stores the frequency of each character of string S"}
{"code": "for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) count ++ ; }", "nl": "Count unique characters in S"}
{"code": "if ( count > N ) { System . out . print ( \" - 1\" ) ; }", "nl": "If unique characters is greater then N , then return - 1"}
{"code": "else { String ans = \" \" ; int high = 100001 ; int low = 0 ; int mid , total ;", "nl": "Otherwise"}
{"code": "while ( ( high - low ) > 1 ) { total = 0 ;", "nl": "Perform Binary Search"}
{"code": "mid = ( high + low ) / 2 ;", "nl": "Find the value of mid"}
{"code": "for ( int i = 0 ; i < 26 ; i ++ ) {", "nl": "Iterate over the range [ 0 , 26 ]"}
{"code": "if ( amounts [ i ] > 0 ) { total += ( amounts [ i ] - 1 ) / mid + 1 ; } }", "nl": "If the amount [ i ] is greater than 0"}
{"code": "if ( total <= N ) { high = mid ; } else { low = mid ; } } System . out . print ( high + \" \u2581 \" ) ; total = 0 ;", "nl": "Update the ranges"}
{"code": "for ( int i = 0 ; i < 26 ; i ++ ) { if ( amounts [ i ] > 0 ) { total += ( amounts [ i ] - 1 ) / high + 1 ; for ( int j = 0 ; j < ( ( amounts [ i ] - 1 ) / high + 1 ) ; j ++ ) {", "nl": "Find the resultant string"}
{"code": "ans += ( char ) ( i + 97 ) ; } } }", "nl": "Generate the subsequence"}
{"code": "for ( int i = total ; i < N ; i ++ ) { ans += ' a ' ; } String reverse = \" \" ; int Len = ans . length ( ) - 1 ; while ( Len >= 0 ) { reverse = reverse + ans . charAt ( Len ) ; Len -- ; }", "nl": "If the length of resultant string is less than N than add a character ' a '"}
{"code": "System . out . print ( reverse ) ; } }", "nl": "Print the string"}
{"code": "public static void main ( String [ ] args ) { String S = \" toffee \" ; int K = 4 ; findString ( S , K ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class Main {", "nl": "Java program to find first repeating element in arr [ ]"}
{"code": "static void printFirstRepeating ( int arr [ ] ) {", "nl": "This function prints the first repeating element in arr [ ]"}
{"code": "int min = - 1 ;", "nl": "Initialize index of first repeating element"}
{"code": "HashSet < Integer > set = new HashSet < > ( ) ;", "nl": "Creates an empty hashset"}
{"code": "for ( int i = arr . length - 1 ; i >= 0 ; i -- ) {", "nl": "Traverse the input array from right to left"}
{"code": "if ( set . contains ( arr [ i ] ) ) min = i ;", "nl": "If element is already in hash set , update min"}
{"code": "else set . add ( arr [ i ] ) ; }", "nl": "Else add element to hash set"}
{"code": "if ( min != - 1 ) System . out . println ( \" The \u2581 first \u2581 repeating \u2581 element \u2581 is \u2581 \" + arr [ min ] ) ; else System . out . println ( \" There \u2581 are \u2581 no \u2581 repeating \u2581 elements \" ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) throws java . lang . Exception { int arr [ ] = { 10 , 5 , 3 , 4 , 3 , 5 , 6 } ; printFirstRepeating ( arr ) ; } }", "nl": "Driver method to test above method"}
{"code": "public class GFG {", "nl": "Java program to find first repeating element in arr [ ]"}
{"code": "static void printFirstRepeating ( int [ ] arr , int n ) {", "nl": "This function prints the first repeating element in arr [ ]"}
{"code": "int k = 0 ;", "nl": "This will set k = 1 , if any repeating element found"}
{"code": "int max = n ; for ( int i = 0 ; i < n ; i ++ ) if ( max < arr [ i ] ) max = arr [ i ] ;", "nl": "max = maximum from ( all elements & n )"}
{"code": "int [ ] a = new int [ max + 1 ] ;", "nl": "Array a is for storing 1 st time occurence of element initialized by 0"}
{"code": "int [ ] b = new int [ max + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Store 1 in array b if element is duplicate initialized by 0"}
{"code": "if ( a [ arr [ i ] ] != 0 ) { b [ arr [ i ] ] = 1 ; k = 1 ; continue ; } else", "nl": "Duplicate element found"}
{"code": "a [ arr [ i ] ] = i ; } if ( k == 0 ) System . out . println ( \" No \u2581 repeating \u2581 element \u2581 found \" ) ; else { int min = max + 1 ;", "nl": "storing 1 st occurence of arr [ i ]"}
{"code": "for ( int i = 0 ; i < max + 1 ; i ++ ) if ( a [ i ] != 0 && min > a [ i ] && b [ i ] != 0 ) min = a [ i ] ; System . out . print ( arr [ min ] ) ; } System . out . println ( ) ; }", "nl": "trace array a & find repeating element with min index"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 10 , 5 , 3 , 4 , 3 , 5 , 6 } ; int n = arr . length ; printFirstRepeating ( arr , n ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to print k - th distinct element in a given array"}
{"code": "static int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Returns k - th distinct element in arr ."}
{"code": "int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ;", "nl": "Check if current element is present somewhere else ."}
{"code": "if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }", "nl": "If element is unique"}
{"code": "public static void main ( String [ ] args ) { int ar [ ] = { 1 , 2 , 1 , 3 , 4 , 2 } ; int n = ar . length ; int k = 2 ; System . out . print ( printKDistinct ( ar , n , k ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Vector ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void countSubarrays ( int [ ] A ) {", "nl": "Function to count subarrays having equal count of 0 s and 1 s with all 0 s and all 1 s grouped together"}
{"code": "int res = 0 ;", "nl": "Stores the count"}
{"code": "int curr = A [ 0 ] ; int [ ] cnt = new int [ A . length ] ; cnt [ 0 ] = 1 ; for ( int c = 1 ; c < A . length ; c ++ ) {", "nl": "Initialize cur with first element"}
{"code": "if ( A == curr )", "nl": "If the next element is same as the current element"}
{"code": "cnt ++ ; else", "nl": "Increment count"}
{"code": "curr = A ; cnt = 1 ; }", "nl": "Update curr"}
{"code": "for ( int i = 1 ; i < cnt . length ; i ++ ) {", "nl": "Iterate over the array count"}
{"code": "res += Math . min ( cnt [ i - 1 ] , cnt [ i ] ) ; } System . out . println ( res - 1 ) ; }", "nl": "Consider the minimum"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int [ ] A = { 1 , 1 , 0 , 0 , 1 , 0 } ;", "nl": "Given arr [ ]"}
{"code": "countSubarrays ( A ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GfG {", "nl": "Java Program for the above approach"}
{"code": "static class Node { int val ; Node left , right ; }", "nl": "Tree node"}
{"code": "static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . val = data ; temp . left = null ; temp . right = null ; return temp ; }", "nl": "Function to return new tree node"}
{"code": "public static boolean isEvenOddBinaryTree ( Node root ) { if ( root == null ) return true ;", "nl": "Function to check if the tree is even - odd tree"}
{"code": "Queue < Node > q = new LinkedList < > ( ) ; q . add ( root ) ;", "nl": "Stores nodes of each level"}
{"code": "int level = 0 ;", "nl": "Store the current level of the binary tree"}
{"code": "while ( ! q . isEmpty ( ) ) {", "nl": "Traverse until the queue is empty"}
{"code": "int size = q . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Node node = q . poll ( ) ;", "nl": "Stores the number of nodes present in the current level"}
{"code": "if ( level % 2 == 0 ) { if ( node . val % 2 == 1 ) return false ; } else if ( level % 2 == 1 ) { if ( node . val % 2 == 0 ) return false ; }", "nl": "Check if the level is even or odd"}
{"code": "if ( node . left != null ) { q . add ( node . left ) ; } if ( node . right != null ) { q . add ( node . right ) ; } }", "nl": "Add the nodes of the next level into the queue"}
{"code": "level ++ ; } return true ; }", "nl": "Increment the level count"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "Node root = null ; root = newNode ( 2 ) ; root . left = newNode ( 3 ) ; root . right = newNode ( 9 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 10 ) ; root . right . right = newNode ( 6 ) ;", "nl": "Construct a Binary Tree"}
{"code": "if ( isEvenOddBinaryTree ( root ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }", "nl": "Check if the binary tree is even - odd tree or not"}
{"code": "class GFG { static int findMaxLen ( int a [ ] , int n ) {", "nl": "Java program to implement the above approach"}
{"code": "int freq [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) { freq [ a [ i ] ] ++ ; } int maxFreqElement = Integer . MIN_VALUE ; int maxFreqCount = 1 ; for ( int i = 1 ; i <= n ; ++ i ) {", "nl": "Stores the frequency of array elements"}
{"code": "if ( freq [ i ] > maxFreqElement ) { maxFreqElement = freq [ i ] ; maxFreqCount = 1 ; }", "nl": "Find the highest frequency in the array"}
{"code": "else if ( freq [ i ] == maxFreqElement ) maxFreqCount ++ ; } int ans ;", "nl": "Increase count of max frequent element"}
{"code": "if ( maxFreqElement == 1 ) ans = 0 ; else {", "nl": "If no repetition is present"}
{"code": "ans = ( ( n - maxFreqCount ) / ( maxFreqElement - 1 ) ) ; }", "nl": "Find the maximum distance"}
{"code": "return ans ; }", "nl": "Return the max distance"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 1 , 2 } ; int n = a . length ; System . out . print ( findMaxLen ( a , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java Program to implement the above approach"}
{"code": "static int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; }", "nl": "Function to obtain the middle index of the range"}
{"code": "static int MaxUtil ( int [ ] st , int ss , int se , int l , int r , int node ) {", "nl": "Recursive function to get the sum of values in the given range from the array . The following are parameters for this function . st . Pointer to segment tree node . Index of current node in the segment tree ss & se . Starting and ending indexes of the segment represented by current node , i . e . , st [ node ] l & r . Starting and ending indexes of range query"}
{"code": "if ( l <= ss && r >= se )", "nl": "If the segment of this node lies completely within the given range"}
{"code": "return st [ node ] ;", "nl": "Return maximum in the segment"}
{"code": "if ( se < l ss > r ) return - 1 ;", "nl": "If the segment of this node lies outside the given range"}
{"code": "int mid = getMid ( ss , se ) ; return Math . max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) ; }", "nl": "If segment of this node lies partially in the given range"}
{"code": "static int getMax ( int [ ] st , int n , int l , int r ) {", "nl": "Function to return the maximum in the range from [ l , r ]"}
{"code": "if ( l < 0 r > n - 1 l > r ) { System . out . printf ( \" Invalid \u2581 Input \" ) ; return - 1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; }", "nl": "Check for erroneous input values"}
{"code": "static int constructSTUtil ( int arr [ ] , int ss , int se , int [ ] st , int si ) {", "nl": "Function to conSegment Tree for the subarray [ ss . . se ]"}
{"code": "if ( ss == se ) { st [ si ] = arr [ ss ] ; return arr [ ss ] ; }", "nl": "For a single element"}
{"code": "int mid = getMid ( ss , se ) ;", "nl": "Otherwise"}
{"code": "st [ si ] = Math . max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) ,", "nl": "Recur for left subtree"}
{"code": "constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) ; return st [ si ] ; }", "nl": "Recur for right subtree"}
{"code": "static int [ ] constructST ( int arr [ ] , int n ) {", "nl": "Function to conSegment Tree from the given array"}
{"code": "int x = ( int ) ( Math . ceil ( Math . log ( n ) ) ) ;", "nl": "Height of Segment Tree"}
{"code": "int max_size = 2 * ( int ) Math . pow ( 2 , x ) - 1 ;", "nl": "Maximum size of Segment Tree"}
{"code": "int [ ] st = new int [ max_size ] ;", "nl": "Allocate memory"}
{"code": "constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ;", "nl": "Fill the allocated memory"}
{"code": "return st ; }", "nl": "Return the constructed Segment Tree"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 0 } ; int n = arr . length ;", "nl": "Driver Code"}
{"code": "int [ ] st = constructST ( arr , n ) ; int [ ] [ ] Q = { { 1 , 3 } , { 0 , 2 } } ; for ( int i = 0 ; i < Q . length ; i ++ ) { int max = getMax ( st , n , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) ; int ok = 0 ; for ( int j = 30 ; j >= 0 ; j -- ) { if ( ( max & ( 1 << j ) ) != 0 ) ok = 1 ; if ( ok <= 0 ) continue ; max |= ( 1 << j ) ; } System . out . print ( max + \" \u2581 \" ) ; } } }", "nl": "Build the Segment Tree from the given array"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find number of pairs in an array such that their XOR is 0"}
{"code": "static int calculate ( int a [ ] , int n ) {", "nl": "Function to calculate the count"}
{"code": "Arrays . sort ( a ) ; int count = 1 ; int answer = 0 ;", "nl": "Sorting the list using built in function"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) {", "nl": "Traversing through the elements"}
{"code": "count += 1 ; } else {", "nl": "Counting frequency of each elements"}
{"code": "answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; }", "nl": "Adding the contribution of the frequency to the answer"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 1 , 2 , 4 } ; int n = a . length ;", "nl": "Driver Code"}
{"code": "System . out . println ( calculate ( a , n ) ) ; } }", "nl": "Print the count"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find number of pairs in an array such that their XOR is 0"}
{"code": "static int calculate ( int a [ ] , int n ) {", "nl": "Function to calculate the answer"}
{"code": "int maximum = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ;", "nl": "Finding the maximum of the array"}
{"code": "int frequency [ ] = new int [ maximum + 1 ] ;", "nl": "Creating frequency array With initial value 0"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traversing through the array"}
{"code": "frequency [ a [ i ] ] += 1 ; } int answer = 0 ;", "nl": "Counting frequency"}
{"code": "for ( int i = 0 ; i < ( maximum ) + 1 ; i ++ ) {", "nl": "Traversing through the frequency array"}
{"code": "answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return answer / 2 ; }", "nl": "Calculating answer"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 1 , 2 , 4 } ; int n = a . length ;", "nl": "Driver Code"}
{"code": "System . out . println ( calculate ( a , n ) ) ; } }", "nl": "Function calling"}
{"code": "int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 , startindex = 0 ; int endindex = 0 ;", "nl": "This function Prints the starting and ending indexes of the largest subarray with equal number of 0 s and 1 s . Also returns the size of such subarray ."}
{"code": "for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ;", "nl": "Pick a starting point as i"}
{"code": "for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ;", "nl": "Consider all subarrays starting from i"}
{"code": "if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) System . out . println ( \" No \u2581 such \u2581 subarray \" ) ; else System . out . println ( startindex + \" \u2581 to \u2581 \" + endindex ) ; return maxsize ; }", "nl": "If this is a 0 sum subarray , then compare it with maximum size subarray calculated so far"}
{"code": "public static void main ( String [ ] args ) { LargestSubArray sub ; sub = new LargestSubArray ( ) ; int arr [ ] = { 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int size = arr . length ; sub . findSubArray ( arr , size ) ; } }", "nl": "Driver program to test the above functions"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int findMax ( int arr [ ] , int low , int high ) {", "nl": "Function to return the maximum element"}
{"code": "if ( high == low ) return arr [ low ] ;", "nl": "If there is only one element left"}
{"code": "int mid = low + ( high - low ) / 2 ;", "nl": "Find mid"}
{"code": "if ( mid == 0 && arr [ mid ] > arr [ mid + 1 ] ) { return arr [ mid ] ; }", "nl": "Check if mid reaches 0 , it is greater than next element or not"}
{"code": "if ( arr [ low ] > arr [ mid ] ) { return findMax ( arr , low , mid - 1 ) ; } else { return findMax ( arr , mid + 1 , high ) ; } }", "nl": "Decide whether we need to go to the left half or the right half"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 6 , 5 , 4 , 3 , 2 , 1 } ; int n = arr . length ; System . out . println ( findMax ( arr , 0 , n - 1 ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to illustrate the iterative approach to ternary search"}
{"code": "static int ternarySearch ( int l , int r , int key , int ar [ ] ) { while ( r >= l ) {", "nl": "Function to perform Ternary Search"}
{"code": "int mid1 = l + ( r - l ) / 3 ; int mid2 = r - ( r - l ) / 3 ;", "nl": "Find the mid1 mid2"}
{"code": "if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; }", "nl": "Check if key is present at any mid"}
{"code": "if ( key < ar [ mid1 ] ) {", "nl": "Since key is not present at mid , check in which region it is present then repeat the Search operation in that region"}
{"code": "r = mid1 - 1 ; } else if ( key > ar [ mid2 ] ) {", "nl": "The key lies in between l and mid1"}
{"code": "l = mid2 + 1 ; } else {", "nl": "The key lies in between mid2 and r"}
{"code": "l = mid1 + 1 ; r = mid2 - 1 ; } }", "nl": "The key lies in between mid1 and mid2"}
{"code": "return - 1 ; }", "nl": "Key not found"}
{"code": "public static void main ( String args [ ] ) { int l , r , p , key ;", "nl": "Driver code"}
{"code": "int ar [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ;", "nl": "Get the array Sort the array if not sorted"}
{"code": "l = 0 ;", "nl": "Starting index"}
{"code": "r = 9 ;", "nl": "length of array"}
{"code": "key = 5 ;", "nl": "Key to be searched in the array"}
{"code": "p = ternarySearch ( l , r , key , ar ) ;", "nl": "Search the key using ternarySearch"}
{"code": "System . out . println ( \" Index \u2581 of \u2581 \" + key + \" \u2581 is \u2581 \" + p ) ;", "nl": "Print the result"}
{"code": "key = 50 ;", "nl": "Key to be searched in the array"}
{"code": "p = ternarySearch ( l , r , key , ar ) ;", "nl": "Search the key using ternarySearch"}
{"code": "System . out . println ( \" Index \u2581 of \u2581 \" + key + \" \u2581 is \u2581 \" + p ) ; } }", "nl": "Print the result"}
{"code": "static int majorityNumber ( int arr [ ] , int n ) { int ans = - 1 ; HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . containsKey ( arr [ i ] ) ) { freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } if ( freq . get ( arr [ i ] ) > n / 2 ) ans = arr [ i ] ; } return ans ; }", "nl": "function to print the majority Number"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 2 , 2 , 1 , 1 , 1 , 2 , 2 } ; int n = a . length ; System . out . println ( majorityNumber ( a , n ) ) ; } }", "nl": "Driver code"}
{"code": "class Main {", "nl": "Java program to search an element in sorted and rotated array using single pass of Binary Search"}
{"code": "static int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ;", "nl": "Returns index of key in arr [ l . . h ] if key is present , otherwise returns - 1"}
{"code": "if ( arr [ l ] <= arr [ mid ] ) {", "nl": "If arr [ l ... mid ] first subarray is sorted"}
{"code": "if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ;", "nl": "As this subarray is sorted , we can quickly check if key lies in half or other half"}
{"code": "return search ( arr , mid + 1 , h , key ) ; }", "nl": "If key not lies in first half subarray , Divide other half into two subarrays , such that we can quickly check if key lies in other half"}
{"code": "if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }", "nl": "If arr [ l . . mid ] first subarray is not sorted , then arr [ mid ... h ] must be sorted subarry"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 } ; int n = arr . length ; int key = 6 ; int i = search ( arr , 0 , n - 1 , key ) ; if ( i != - 1 ) System . out . println ( \" Index : \u2581 \" + i ) ; else System . out . println ( \" Key \u2581 not \u2581 found \" ) ; } }", "nl": "main function"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class Minimum { static int findMin ( int arr [ ] , int low , int high ) {", "nl": "Java program to find minimum element in a sorted and rotated array"}
{"code": "if ( high < low ) return arr [ 0 ] ;", "nl": "This condition is needed to handle the case when array is not rotated at all"}
{"code": "if ( high == low ) return arr [ low ] ;", "nl": "If there is only one element left"}
{"code": "int mid = low + ( high - low ) / 2 ;", "nl": "Find mid"}
{"code": "if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ;", "nl": "Check if element ( mid + 1 ) is minimum element . Consider the cases like { 3 , 4 , 5 , 1 , 2 }"}
{"code": "if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ;", "nl": "Check if mid itself is minimum element"}
{"code": "if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }", "nl": "Decide whether we need to go to left half or right half"}
{"code": "public static void main ( String [ ] args ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = arr1 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr1 , 0 , n1 - 1 ) ) ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = arr2 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr2 , 0 , n2 - 1 ) ) ; int arr3 [ ] = { 1 } ; int n3 = arr3 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr3 , 0 , n3 - 1 ) ) ; int arr4 [ ] = { 1 , 2 } ; int n4 = arr4 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr4 , 0 , n4 - 1 ) ) ; int arr5 [ ] = { 2 , 1 } ; int n5 = arr5 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr5 , 0 , n5 - 1 ) ) ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = arr6 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr6 , 0 , n6 - 1 ) ) ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = arr7 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr7 , 0 , n7 - 1 ) ) ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = arr8 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr8 , 0 , n8 - 1 ) ) ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = arr9 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr9 , 0 , n9 - 1 ) ) ; } }", "nl": "Driver Program"}
{"code": "import java . util . * ; import java . lang . * ; class GFG {", "nl": "Java program to find minimum element in a sorted and rotated array contating duplicate elements ."}
{"code": "public static int findMin ( int arr [ ] , int low , int high ) { while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; }", "nl": "Function to find minimum element"}
{"code": "public static void main ( String args [ ] ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = arr1 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr1 , 0 , n1 - 1 ) ) ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = arr2 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr2 , 0 , n2 - 1 ) ) ; int arr3 [ ] = { 1 } ; int n3 = arr3 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr3 , 0 , n3 - 1 ) ) ; int arr4 [ ] = { 1 , 2 } ; int n4 = arr4 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr4 , 0 , n4 - 1 ) ) ; int arr5 [ ] = { 2 , 1 } ; int n5 = arr5 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr5 , 0 , n5 - 1 ) ) ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = arr6 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr6 , 0 , n6 - 1 ) ) ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = arr7 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr7 , 0 , n7 - 1 ) ) ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = arr8 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr8 , 0 , n8 - 1 ) ) ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = arr9 . length ; System . out . println ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + findMin ( arr9 , 0 , n9 - 1 ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Scanner ; import java . util . Arrays ; class GFG {", "nl": "Java program to find k - th absolute difference between two elements"}
{"code": "static int countPairs ( int [ ] a , int n , int mid ) { int res = 0 , value ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "returns number of pairs with absolute difference less than or equal to mid"}
{"code": "int ub = upperbound ( a , n , a [ i ] + mid ) ; res += ( ub - ( i - 1 ) ) ; } return res ; }", "nl": "Upper bound returns pointer to position of next higher number than a [ i ] + mid in a [ i . . n - 1 ] . We subtract ( ub + i + 1 ) from this position to count"}
{"code": "static int upperbound ( int a [ ] , int n , int value ) { int low = 0 ; int high = n ; while ( low < high ) { final int mid = ( low + high ) / 2 ; if ( value >= a [ mid ] ) low = mid + 1 ; else high = mid ; } return low ; }", "nl": "returns the upper bound"}
{"code": "static int kthDiff ( int a [ ] , int n , int k ) {", "nl": "Returns k - th absolute difference"}
{"code": "Arrays . sort ( a ) ;", "nl": "Sort array"}
{"code": "int low = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i <= n - 2 ; ++ i ) low = Math . min ( low , a [ i + 1 ] - a [ i ] ) ;", "nl": "Minimum absolute difference"}
{"code": "int high = a [ n - 1 ] - a [ 0 ] ;", "nl": "Maximum absolute difference"}
{"code": "while ( low < high ) { int mid = ( low + high ) >> 1 ; if ( countPairs ( a , n , mid ) < k ) low = mid + 1 ; else high = mid ; } return low ; }", "nl": "Do binary search for k - th absolute difference"}
{"code": "public static void main ( String args [ ] ) { Scanner s = new Scanner ( System . in ) ; int k = 3 ; int a [ ] = { 1 , 2 , 3 , 4 } ; int n = a . length ; System . out . println ( kthDiff ( a , n , k ) ) ; } }", "nl": "Driver function to check the above functions"}
{"code": "import java . io . * ; class SecondSmallest {", "nl": "Java program to find smallest and second smallest elements"}
{"code": "static void print2Smallest ( int arr [ ] ) { int first , second , arr_size = arr . length ;", "nl": "Function to print first smallest and second smallest elements"}
{"code": "if ( arr_size < 2 ) { System . out . println ( \" \u2581 Invalid \u2581 Input \u2581 \" ) ; return ; } first = second = Integer . MAX_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) {", "nl": "There should be atleast two elements"}
{"code": "if ( arr [ i ] < first ) { second = first ; first = arr [ i ] ; }", "nl": "If current element is smaller than first then update both first and second"}
{"code": "else if ( arr [ i ] < second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == Integer . MAX_VALUE ) System . out . println ( \" There \u2581 is \u2581 no \u2581 second \" + \" smallest \u2581 element \" ) ; else System . out . println ( \" The \u2581 smallest \u2581 element \u2581 is \u2581 \" + first + \" \u2581 and \u2581 second \u2581 Smallest \" + \" \u2581 element \u2581 is \u2581 \" + second ) ; }", "nl": "If arr [ i ] is in between first and second then update second"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 1 } ; print2Smallest ( arr ) ; } }", "nl": "Driver program to test above functions"}
{"code": "class GFG { static final int MAX = 1000 ;", "nl": "LCM of given range queries using Segment Tree"}
{"code": "static int tree [ ] = new int [ 4 * MAX ] ;", "nl": "allocate space for tree"}
{"code": "static int arr [ ] = new int [ MAX ] ;", "nl": "declaring the array globally"}
{"code": "static int gcd ( int a , int b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; }", "nl": "Function to return gcd of a and b"}
{"code": "static int lcm ( int a , int b ) { return a * b / gcd ( a , b ) ; }", "nl": "utility function to find lcm"}
{"code": "static void build ( int node , int start , int end ) {", "nl": "Function to build the segment tree Node starts beginning index of current subtree . start and end are indexes in arr [ ] which is global"}
{"code": "if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } int mid = ( start + end ) / 2 ;", "nl": "If there is only one element in current subarray"}
{"code": "build ( 2 * node , start , mid ) ; build ( 2 * node + 1 , mid + 1 , end ) ;", "nl": "build left and right segments"}
{"code": "int left_lcm = tree [ 2 * node ] ; int right_lcm = tree [ 2 * node + 1 ] ; tree [ node ] = lcm ( left_lcm , right_lcm ) ; }", "nl": "build the parent"}
{"code": "static int query ( int node , int start , int end , int l , int r ) {", "nl": "Function to make queries for array range ) l , r ) . Node is index of root of current segment in segment tree ( Note that indexes in segment tree begin with 1 for simplicity ) . start and end are indexes of subarray covered by root of current segment ."}
{"code": "if ( end < l start > r ) { return 1 ; }", "nl": "Completely outside the segment , returning 1 will not affect the lcm ;"}
{"code": "if ( l <= start && r >= end ) { return tree [ node ] ; }", "nl": "completely inside the segment"}
{"code": "int mid = ( start + end ) / 2 ; int left_lcm = query ( 2 * node , start , mid , l , r ) ; int right_lcm = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return lcm ( left_lcm , right_lcm ) ; }", "nl": "partially inside"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "arr [ 0 ] = 5 ; arr [ 1 ] = 7 ; arr [ 2 ] = 5 ; arr [ 3 ] = 2 ; arr [ 4 ] = 10 ; arr [ 5 ] = 12 ; arr [ 6 ] = 11 ; arr [ 7 ] = 17 ; arr [ 8 ] = 14 ; arr [ 9 ] = 1 ; arr [ 10 ] = 44 ;", "nl": "initialize the array"}
{"code": "build ( 1 , 0 , 10 ) ;", "nl": "build the segment tree"}
{"code": "System . out . println ( query ( 1 , 0 , 10 , 2 , 5 ) ) ;", "nl": "Now we can answer each query efficiently Print LCM of ( 2 , 5 )"}
{"code": "System . out . println ( query ( 1 , 0 , 10 , 5 , 10 ) ) ;", "nl": "Print LCM of ( 5 , 10 )"}
{"code": "System . out . println ( query ( 1 , 0 , 10 , 0 , 10 ) ) ; } }", "nl": "Print LCM of ( 0 , 10 )"}
{"code": "import java . io . * ; class GFG { static int M = 1000000007 ; static int waysOfDecoding ( String s ) { long [ ] dp = new long [ s . length ( ) + 1 ] ; dp [ 0 ] = 1 ;", "nl": "Java program for the above approach"}
{"code": "dp [ 1 ] = s . charAt ( 0 ) == ' * ' ? 9 : s . charAt ( 0 ) == '0' ? 0 : 1 ;", "nl": "check the first character of the string if it is ' * ' then 9 ways"}
{"code": "for ( int i = 1 ; i < s . length ( ) ; i ++ ) {", "nl": "traverse the string"}
{"code": "if ( s . charAt ( i ) == ' * ' ) { dp [ i + 1 ] = 9 * dp [ i ] ;", "nl": "If s [ i ] = = ' * ' there can be 9 possible values of *"}
{"code": "if ( s . charAt ( i - 1 ) == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ;", "nl": "If previous character is 1 then words that can be formed are K ( 11 ) , L ( 12 ) , M ( 13 ) , N ( 14 ) O ( 15 ) , P ( 16 ) , Q ( 17 ) , R ( 18 ) , S ( 19 )"}
{"code": "else if ( s . charAt ( i - 1 ) == '2' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ;", "nl": "If previous character is 2 then the words that can be formed are U ( 21 ) , V ( 22 ) , W ( 23 ) , X ( 24 ) Y ( 25 ) , Z ( 26 )"}
{"code": "else if ( s . charAt ( i - 1 ) == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else {", "nl": "If the previous digit is * then all 15 2 - digit characters can be formed"}
{"code": "dp [ i + 1 ] = s . charAt ( i ) != '0' ? dp [ i ] : 0 ;", "nl": "taking the value from previous step"}
{"code": "if ( s . charAt ( i - 1 ) == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ;", "nl": "If previous character is 1 then the i - 1 th character and ith character can be decoded in a single character therefore , adding dp [ i - 1 ] ."}
{"code": "else if ( s . charAt ( i - 1 ) == '2' && s . charAt ( i ) <= '6' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ;", "nl": "If previous character is 2 and ith character is less than 6 then the i - 1 th character and ith character can be decoded in a single character therefore , adding dp [ i - 1 ] ."}
{"code": "else if ( s . charAt ( i - 1 ) == ' * ' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s . charAt ( i ) <= '6' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return ( int ) dp [ s . length ( ) ] ; }", "nl": "If previous character is * then it will contain the above 2 cases"}
{"code": "public static void main ( String [ ] args ) { String s = \"12\" ; System . out . println ( waysOfDecoding ( s ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; public class GFG {", "nl": "Java program for the above approach"}
{"code": "static int countSubset ( int [ ] arr , int n , int diff ) {", "nl": "Function to count the number of ways to divide the array into two subsets and such that the difference between their sums is equal to diff"}
{"code": "int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum += diff ; sum = sum / 2 ;", "nl": "Store the sum of the set S1"}
{"code": "int t [ ] [ ] = new int [ n + 1 ] [ sum + 1 ] ;", "nl": "Initializing the matrix"}
{"code": "for ( int j = 0 ; j <= sum ; j ++ ) t [ 0 ] [ j ] = 0 ;", "nl": "Number of ways to get sum using 0 elements is 0"}
{"code": "for ( int i = 0 ; i <= n ; i ++ ) t [ i ] [ 0 ] = 1 ;", "nl": "Number of ways to get sum 0 using i elements is 1"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) {", "nl": "Traverse the 2D array"}
{"code": "if ( arr [ i - 1 ] > j ) t [ i ] [ j ] = t [ i - 1 ] [ j ] ; else { t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } }", "nl": "If the value is greater than the sum store the value of previous state"}
{"code": "return t [ n ] [ sum ] ; }", "nl": "Return the result"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int diff = 1 , n = 4 ; int arr [ ] = { 1 , 1 , 2 , 3 } ;", "nl": "Given Input"}
{"code": "System . out . print ( countSubset ( arr , n , diff ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG { static float [ ] [ ] dp = new float [ 105 ] [ 605 ] ;", "nl": "Java program for above approach"}
{"code": "static float find ( int N , int a , int b ) { float probability = 0.0f ;", "nl": "Function to calculate probability that the sum of numbers on N throws of dice lies between A and B"}
{"code": "for ( int i = 1 ; i <= 6 ; i ++ ) dp [ 1 ] [ i ] = ( float ) ( 1.0 / 6 ) ; for ( int i = 2 ; i <= N ; i ++ ) { for ( int j = i ; j <= 6 * i ; j ++ ) { for ( int k = 1 ; k <= 6 && k <= j ; k ++ ) { dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] / 6 ; } } }", "nl": "Base case"}
{"code": "for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N ] [ sum ] ; return probability ; }", "nl": "Add the probability for all the numbers between a and b"}
{"code": "public static void main ( String [ ] args ) { int N = 4 , a = 13 , b = 17 ; float probability = find ( N , a , b ) ;", "nl": "Driver Code"}
{"code": "System . out . printf ( \" % .6f \" , probability ) ; } }", "nl": "Print the answer"}
{"code": "import java . util . * ; public class Main {", "nl": "Java code for max sum with adjacent levels not allowed"}
{"code": "static class Node { int data ; Node left , right ; Node ( int item ) { data = item ; left = right = null ; } }", "nl": "Tree node class for Binary Tree representation"}
{"code": "public static int getSumAlternate ( Node root ) { if ( root == null ) return 0 ; int sum = root . data ; if ( root . left != null ) { sum += getSum ( root . left . left ) ; sum += getSum ( root . left . right ) ; } if ( root . right != null ) { sum += getSum ( root . right . left ) ; sum += getSum ( root . right . right ) ; } return sum ; }", "nl": "Recursive function to find the maximum sum returned for a root node and its grandchildren"}
{"code": "public static int getSum ( Node root ) { if ( root == null ) return 0 ;", "nl": "Returns maximum sum with adjacent levels not allowed . This function mainly uses getSumAlternate ( )"}
{"code": "return Math . max ( getSumAlternate ( root ) , ( getSumAlternate ( root . left ) + getSumAlternate ( root . right ) ) ) ; }", "nl": "We compute sum of alternate levels starting first level and from second level . And return maximum of two values ."}
{"code": "public static void main ( String [ ] args ) { Node root = new Node ( 1 ) ; root . left = new Node ( 2 ) ; root . right = new Node ( 3 ) ; root . right . left = new Node ( 4 ) ; root . right . left . right = new Node ( 5 ) ; root . right . left . right . left = new Node ( 6 ) ; System . out . println ( getSum ( root ) ) ; } }", "nl": "Driver function"}
{"code": "public class Subset_sum {", "nl": "Java Program to get a subset with a with a sum provided by the user"}
{"code": "static boolean isSubsetSum ( int arr [ ] , int n , int sum ) {", "nl": "Returns true if there exists a subset with given sum in arr [ ]"}
{"code": "boolean subset [ ] [ ] = new boolean [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) {", "nl": "The value of subset [ i % 2 ] [ j ] will be true if there exists a subset of sum j in arr [ 0 , 1 , ... . , i - 1 ]"}
{"code": "if ( j == 0 ) subset [ i % 2 ] [ j ] = true ;", "nl": "A subset with sum 0 is always possible"}
{"code": "else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }", "nl": "If there exists no element no sum is possible"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 5 } ; int sum = 7 ; int n = arr . length ; if ( isSubsetSum ( arr , n , sum ) == true ) System . out . println ( \" There \u2581 exists \u2581 a \u2581 subset \u2581 with \" + \" given \u2581 sum \" ) ; else System . out . println ( \" No \u2581 subset \u2581 exists \u2581 with \" + \" given \u2581 sum \" ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "java program to find maximum equilibrium sum ."}
{"code": "static int findMaxSum ( int [ ] arr , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = Math . max ( res , prefix_sum ) ; } return res ; }", "nl": "Function to find maximum equilibrium sum ."}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 } ; int n = arr . length ; System . out . println ( findMaxSum ( arr , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; public class GFG {", "nl": "Java program to find maximum equilibrium sum ."}
{"code": "static int findMaxSum ( int [ ] arr , int n ) {", "nl": "Function to find maximum equilibrium sum ."}
{"code": "int [ ] preSum = new int [ n ] ;", "nl": "Array to store prefix sum ."}
{"code": "int [ ] suffSum = new int [ n ] ;", "nl": "Array to store suffix sum ."}
{"code": "int ans = Integer . MIN_VALUE ;", "nl": "Variable to store maximum sum ."}
{"code": "preSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ;", "nl": "Calculate prefix sum ."}
{"code": "suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . max ( ans , preSum [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . max ( ans , preSum [ i ] ) ; } return ans ; }", "nl": "Calculate suffix sum and compare it with prefix sum . Update ans accordingly ."}
{"code": "static public void main ( String [ ] args ) { int [ ] arr = { - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 } ; int n = arr . length ; System . out . println ( findMaxSum ( arr , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . lang . Math . * ; import java . util . stream . * ; class GFG {", "nl": "Java program to find maximum equilibrium sum ."}
{"code": "static int findMaxSum ( int arr [ ] , int n ) { int sum = IntStream . of ( arr ) . sum ( ) ; int prefix_sum = 0 , res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { prefix_sum += arr [ i ] ; if ( prefix_sum == sum ) res = Math . max ( res , prefix_sum ) ; sum -= arr [ i ] ; } return res ; }", "nl": "Function to find maximum equilibrium sum ."}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 } ; int n = arr . length ; System . out . print ( findMaxSum ( arr , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find Majority element in an array"}
{"code": "static void findMajority ( int arr [ ] , int n ) { int maxCount = 0 ;", "nl": "Function to find Majority element in an array"}
{"code": "int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; }", "nl": "sentinels"}
{"code": "if ( count > maxCount ) { maxCount = count ; index = i ; } }", "nl": "update maxCount if count of current element is greater"}
{"code": "if ( maxCount > n / 2 ) System . out . println ( arr [ index ] ) ; else System . out . println ( \" No \u2581 Majority \u2581 Element \" ) ; }", "nl": "if maxCount is greater than n / 2 return the corresponding element"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = arr . length ;", "nl": "Driver code"}
{"code": "findMajority ( arr , n ) ; } }", "nl": "Function calling"}
{"code": "import java . io . * ; class Node { int key ; int c = 0 ; Node left , right ; } class GFG { static int ma = 0 ;", "nl": "Java program to demonstrate insert operation in binary search tree ."}
{"code": "static Node newNode ( int item ) { Node temp = new Node ( ) ; temp . key = item ; temp . c = 1 ; temp . left = temp . right = null ; return temp ; }", "nl": "A utility function to create a new BST node"}
{"code": "static Node insert ( Node node , int key ) {", "nl": "A utility function to insert a new node with given key in BST"}
{"code": "if ( node == null ) { if ( ma == 0 ) ma = 1 ; return newNode ( key ) ; }", "nl": "If the tree is empty , return a new node"}
{"code": "if ( key < node . key ) node . left = insert ( node . left , key ) ; else if ( key > node . key ) node . right = insert ( node . right , key ) ; else node . c ++ ;", "nl": "Otherwise , recur down the tree"}
{"code": "ma = Math . max ( ma , node . c ) ;", "nl": "Find the max count"}
{"code": "return node ; }", "nl": "Return the ( unchanged ) node pointer"}
{"code": "static void inorder ( Node root , int s ) { if ( root != null ) { inorder ( root . left , s ) ; if ( root . c > ( s / 2 ) ) System . out . println ( root . key + \"NEW_LINE\"); inorder ( root . right , s ) ; } }", "nl": "A utility function to do inorder traversal of BST"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 3 , 3 , 2 } ; int size = a . length ; Node root = null ; for ( int i = 0 ; i < size ; i ++ ) { root = insert ( root , a [ i ] ) ; }", "nl": "Driver Code"}
{"code": "if ( ma > ( size / 2 ) ) inorder ( root , size ) ; else System . out . println ( \"No majority elementNEW_LINE\"); } }", "nl": "Function call"}
{"code": "class MajorityElement {", "nl": "Program for finding out majority element in an array"}
{"code": "int findCandidate ( int a [ ] , int size ) { int maj_index = 0 , count = 1 ; int i ; for ( i = 1 ; i < size ; i ++ ) { if ( a [ maj_index ] == a [ i ] ) count ++ ; else count -- ; if ( count == 0 ) { maj_index = i ; count = 1 ; } } return a [ maj_index ] ; }", "nl": "Function to find the candidate for Majority"}
{"code": "boolean isMajority ( int a [ ] , int size , int cand ) { int i , count = 0 ; for ( i = 0 ; i < size ; i ++ ) { if ( a [ i ] == cand ) count ++ ; } if ( count > size / 2 ) return true ; else return false ; }", "nl": "Function to check if the candidate occurs more than n / 2 times"}
{"code": "void printMajority ( int a [ ] , int size ) {", "nl": "Function to print Majority Element"}
{"code": "int cand = findCandidate ( a , size ) ;", "nl": "Find the candidate for Majority"}
{"code": "if ( isMajority ( a , size , cand ) ) System . out . println ( \" \u2581 \" + cand + \" \u2581 \" ) ; else System . out . println ( \" No \u2581 Majority \u2581 Element \" ) ; }", "nl": "Print the candidate if it is Majority"}
{"code": "public static void main ( String [ ] args ) { MajorityElement majorelement = new MajorityElement ( ) ; int a [ ] = new int [ ] { 1 , 3 , 3 , 1 , 2 } ;", "nl": "Driver code"}
{"code": "int size = a . length ; majorelement . printMajority ( a , size ) ; } }", "nl": "Function call"}
{"code": "import java . util . HashMap ; class MajorityElement { private static void findMajority ( int [ ] arr ) { HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( map . containsKey ( arr [ i ] ) ) { int count = map . get ( arr [ i ] ) + 1 ; if ( count > arr . length / 2 ) { System . out . println ( \" Majority \u2581 found \u2581 : - \u2581 \" + arr [ i ] ) ; return ; } else map . put ( arr [ i ] , count ) ; } else map . put ( arr [ i ] , 1 ) ; } System . out . println ( \" \u2581 No \u2581 Majority \u2581 element \" ) ; }", "nl": "Program for finding out majority element in an array"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = new int [ ] { 2 , 2 , 2 , 2 , 5 , 5 , 2 , 3 , 3 } ;", "nl": "Driver program to test the above functions"}
{"code": "findMajority ( a ) ; } }", "nl": "Function calling"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program to find Majority element in an array"}
{"code": "public static int majorityElement ( int [ ] arr , int n ) {", "nl": "Function to find Majority element in an array it returns - 1 if there is no majority element"}
{"code": "Arrays . sort ( arr ) ; int count = 1 , max_ele = - 1 , temp = arr [ 0 ] , ele = 0 , f = 0 ; for ( int i = 1 ; i < n ; i ++ ) {", "nl": "Sort the array in O ( nlogn )"}
{"code": "if ( temp == arr [ i ] ) { count ++ ; } else { count = 1 ; temp = arr [ i ] ; }", "nl": "Increases the count if the same element occurs otherwise starts counting new element"}
{"code": "if ( max_ele < count ) { max_ele = count ; ele = arr [ i ] ; if ( max_ele > ( n / 2 ) ) { f = 1 ; break ; } } }", "nl": "Sets maximum count and stores maximum occured element so far if maximum count becomes greater than n / 2 it breaks out setting the flag"}
{"code": "return ( f == 1 ? ele : - 1 ) ; }", "nl": "Returns maximum occured element if there is no such element , returns - 1"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = 7 ;", "nl": "Driver code"}
{"code": "System . out . println ( majorityElement ( arr , n ) ) ; } }", "nl": "Function calling"}
{"code": "class GFG {", "nl": "A Dynamic Programming solution for subset sum problem"}
{"code": "static boolean isSubsetSum ( int set [ ] , int n , int sum ) {", "nl": "Returns true if there is a subset of set [ ] with sum equal to given sum"}
{"code": "boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ] ;", "nl": "The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i"}
{"code": "for ( int i = 0 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = true ;", "nl": "If sum is 0 , then answer is true"}
{"code": "for ( int i = 1 ; i <= sum ; i ++ ) subset [ i ] [ 0 ] = false ;", "nl": "If sum is not 0 and set is empty , then answer is false"}
{"code": "for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; } }", "nl": "Fill the subset table in bottom up manner"}
{"code": "for ( int i = 0 ; i <= sum ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) System . out . println ( subset [ i ] [ j ] ) ; } return subset [ sum ] [ n ] ; }", "nl": "uncomment this code to print table"}
{"code": "public static void main ( String args [ ] ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = set . length ; if ( isSubsetSum ( set , n , sum ) == true ) System . out . println ( \" Found \u2581 a \u2581 subset \" + \" \u2581 with \u2581 given \u2581 sum \" ) ; else System . out . println ( \" No \u2581 subset \u2581 with \" + \" \u2581 given \u2581 sum \" ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static int subsetSum ( int a [ ] , int n , int sum ) {", "nl": "Check if possible subset with given sum is possible or not"}
{"code": "int tab [ ] [ ] = new int [ n + 1 ] [ sum + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { tab [ i ] [ j ] = - 1 ; } }", "nl": "Storing the value - 1 to the matrix"}
{"code": "if ( sum == 0 ) return 1 ; if ( n <= 0 ) return 0 ;", "nl": "If the sum is zero it means we got our expected sum"}
{"code": "if ( tab [ n - 1 ] [ sum ] != - 1 ) return tab [ n - 1 ] [ sum ] ;", "nl": "If the value is not - 1 it means it already call the function with the same value . it will save our from the repetition ."}
{"code": "if ( a [ n - 1 ] > sum ) return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) ; else {", "nl": "if the value of a [ n - 1 ] is greater than the sum . we call for the next value"}
{"code": "if ( subsetSum ( a , n - 1 , sum ) != 0 || subsetSum ( a , n - 1 , sum - a [ n - 1 ] ) != 0 ) { return tab [ n - 1 ] [ sum ] = 1 ; } else return tab [ n - 1 ] [ sum ] = 0 ; } }", "nl": "Here we do two calls because we don ' t \u2581 know \u2581 which \u2581 value \u2581 is \u2581 \u2581 full - fill \u2581 our \u2581 criteria \u2581 \u2581 that ' s why we doing two calls"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; int a [ ] = { 1 , 5 , 3 , 7 , 4 } ; int sum = 12 ; if ( subsetSum ( a , n , sum ) != 0 ) { System . out . println ( \"YESNEW_LINE\"); } else System . out . println ( \"NONEW_LINE\"); } }", "nl": "Driver Code"}
{"code": "import java . io . * ; import java . lang . Math ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int binpow ( int a , int b ) { int res = 1 ; while ( b > 0 ) { if ( b % 2 == 1 ) res = res * a ; a = a * a ; b /= 2 ; } return res ; }", "nl": "Function to implement fast exponentiation"}
{"code": "static int find ( int x ) { if ( x == 0 ) return 0 ; int p = ( int ) ( Math . log ( x ) / Math . log ( 2 ) ) ; return binpow ( 2 , p + 1 ) - 1 ; }", "nl": "Function to return the value for powers of 2"}
{"code": "static String getBinary ( int n ) {", "nl": "Function to convert N into binary"}
{"code": "String ans = \" \" ;", "nl": "To store the binary representation"}
{"code": "while ( n > 0 ) { int dig = n % 2 ; ans += dig ; n /= 2 ; }", "nl": "Iterate each digit of n"}
{"code": "return ans ; }", "nl": "Return binary representation"}
{"code": "static int totalCountDifference ( int n ) {", "nl": "Function to find difference in bits"}
{"code": "String ans = getBinary ( n ) ;", "nl": "Get binary representation"}
{"code": "int req = 0 ;", "nl": "total number of bit differences from 0 to N"}
{"code": "for ( int i = 0 ; i < ans . length ( ) ; i ++ ) {", "nl": "Iterate over each binary bit"}
{"code": "if ( ans . charAt ( i ) == '1' ) { req += find ( binpow ( 2 , i ) ) ; } } return req ; }", "nl": "If current bit is '1' then add the count of current bit"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int n = 5 ;", "nl": "Given number"}
{"code": "System . out . print ( totalCountDifference ( n ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; public class Main {", "nl": "Java implementation of the approach"}
{"code": "public static int Maximum_Length ( Vector < Integer > a ) {", "nl": "Function to return the maximum length of the required prefix"}
{"code": "int [ ] counts = new int [ 11 ] ;", "nl": "Array to store the frequency of each element of the array"}
{"code": "int ans = 0 ; for ( int index = 0 ; index < a . size ( ) ; index ++ ) {", "nl": "Iterating for all the elements"}
{"code": "counts [ a . get ( index ) ] += 1 ;", "nl": "Update the frequency of the current element i . e . v"}
{"code": "Vector < Integer > k = new Vector < Integer > ( ) ; for ( int i : counts ) if ( i != 0 ) k . add ( i ) ; Collections . sort ( k ) ;", "nl": "Sorted positive values from counts array"}
{"code": "if ( k . size ( ) == 1 || ( k . get ( 0 ) == k . get ( k . size ( ) - 2 ) && k . get ( k . size ( ) - 1 ) - k . get ( k . size ( ) - 2 ) == 1 ) || ( k . get ( 0 ) == 1 && k . get ( 1 ) == k . get ( k . size ( ) - 1 ) ) ) ans = index ; }", "nl": "If current prefix satisfies the given conditions"}
{"code": "return ans + 1 ; }", "nl": "Return the maximum length"}
{"code": "public static void main ( String [ ] args ) { Vector < Integer > a = new Vector < Integer > ( ) ; a . add ( 1 ) ; a . add ( 1 ) ; a . add ( 1 ) ; a . add ( 2 ) ; a . add ( 2 ) ; a . add ( 2 ) ; System . out . println ( Maximum_Length ( a ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }", "nl": "returns the gcd after all updates in the array"}
{"code": "static void print_gcd_online ( int n , int m , int [ ] [ ] query , int [ ] arr ) {", "nl": "Function to calculate gcd of onine queries"}
{"code": "int max_gcd = 0 ; int i = 0 ;", "nl": "stores the gcd of the initial array elements"}
{"code": "for ( i = 0 ; i < n ; i ++ ) max_gcd = gcd ( max_gcd , arr [ i ] ) ;", "nl": "calculates the gcd"}
{"code": "for ( i = 0 ; i < m ; i ++ ) {", "nl": "performing online queries"}
{"code": "query [ i ] [ 0 ] -- ;", "nl": "index is 1 based"}
{"code": "arr [ query [ i ] [ 0 ] ] /= query [ i ] [ 1 ] ;", "nl": "divide the array element"}
{"code": "max_gcd = gcd ( arr [ query [ i ] [ 0 ] ] , max_gcd ) ;", "nl": "calculates the current gcd"}
{"code": "System . out . println ( max_gcd ) ; } }", "nl": "print the gcd after each step"}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; int m = 3 ; int [ ] [ ] query = new int [ m ] [ 2 ] ; int [ ] arr = new int [ ] { 36 , 24 , 72 } ; query [ 0 ] [ 0 ] = 1 ; query [ 0 ] [ 1 ] = 3 ; query [ 1 ] [ 0 ] = 3 ; query [ 1 ] [ 1 ] = 12 ; query [ 2 ] [ 0 ] = 2 ; query [ 2 ] [ 1 ] = 4 ; print_gcd_online ( n , m , query , arr ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static final int MAX = 1000000 ;", "nl": "Java implementation of the approach"}
{"code": "static boolean [ ] prime = new boolean [ MAX + 1 ] ;", "nl": "stores whether the number is prime or not"}
{"code": "static int [ ] sum = new int [ MAX + 1 ] ;", "nl": "stores the count of prime numbers less than or equal to the index"}
{"code": "static void SieveOfEratosthenes ( ) {", "nl": "create the sieve"}
{"code": "for ( int i = 0 ; i <= MAX ; i ++ ) prime [ i ] = true ; for ( int i = 0 ; i <= MAX ; i ++ ) sum [ i ] = 0 ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) {", "nl": "Create a boolean array \" prime [ 0 . . n ] \" and initialize all the entries as true . A value in prime [ i ] will finally be false if ' i ' is Not a prime , else true ."}
{"code": "if ( prime [ p ] ) {", "nl": "If prime [ p ] is not changed , then it is a prime"}
{"code": "for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } }", "nl": "Update all multiples of p"}
{"code": "for ( int i = 1 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) sum [ i ] = 1 ; sum [ i ] += sum [ i - 1 ] ; } }", "nl": "stores the prefix sum of number of primes less than or equal to ' i '"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "SieveOfEratosthenes ( ) ;", "nl": "create the sieve"}
{"code": "int l = 3 , r = 9 ;", "nl": "' l ' and ' r ' are the lower and upper bounds of the range"}
{"code": "int c = ( sum [ r ] - sum [ l - 1 ] ) ;", "nl": "get the value of count"}
{"code": "System . out . println ( \" Count : \u2581 \" + c ) ; } }", "nl": "display the count"}
{"code": "import java . io . * ; class GFG {", "nl": "Java Program to find the area of the circle inscribed within the rectangle which in turn is inscribed in a semicircle"}
{"code": "static float area ( float r ) {", "nl": "Function to find the area of the circle"}
{"code": "if ( r < 0 ) return - 1 ;", "nl": "radius cannot be negative"}
{"code": "float area = ( float ) ( 3.14 * Math . pow ( r / ( 2 * Math . sqrt ( 2 ) ) , 2 ) ) ; return area ; }", "nl": "area of the circle"}
{"code": "public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( area ( a ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static int N = 100005 ;", "nl": "Java program to count almost prime numbers from 1 to n"}
{"code": "static boolean prime [ ] = new boolean [ N ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < N ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < N ; p ++ ) {", "nl": "Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true ."}
{"code": "if ( prime [ p ] == true ) {", "nl": "If prime [ p ] is not changed , then it is a prime"}
{"code": "for ( int i = p * 2 ; i < N ; i += p ) prime [ i ] = false ; } } }", "nl": "Update all multiples of p"}
{"code": "static int almostPrimes ( int n ) {", "nl": "Function to count almost prime numbers from 1 to n"}
{"code": "int ans = 0 ;", "nl": "to store required answer"}
{"code": "for ( int i = 6 ; i <= n ; i ++ ) {", "nl": "6 is first almost prime number"}
{"code": "int c = 0 ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) {", "nl": "to count prime factors"}
{"code": "if ( j * j == i ) { if ( prime [ j ] ) c ++ ; } else { if ( prime [ j ] ) c ++ ; if ( prime [ i / j ] ) c ++ ; } } }", "nl": "if it is perfect square"}
{"code": "if ( c == 2 ) ans ++ ; } return ans ; }", "nl": "if I is almost prime number"}
{"code": "public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 21 ; System . out . println ( almostPrimes ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {", "nl": "Java implementation of above approach Returns sum of digits of x"}
{"code": "static int sumOfDigitsSingle ( int x ) { int ans = 0 ; while ( x != 0 ) { ans += x % 10 ; x /= 10 ; } return ans ; }", "nl": "Returns sum of digits of x"}
{"code": "static int closest ( int x ) { int ans = 0 ; while ( ans * 10 + 9 <= x ) ans = ans * 10 + 9 ; return ans ; } static int sumOfDigitsTwoParts ( int N ) { int A = closest ( N ) ; return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) ; }", "nl": "Returns closest number to x in terms of 9 's."}
{"code": "public static void main ( String args [ ] ) { int N = 35 ; System . out . print ( sumOfDigitsTwoParts ( N ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to check for primality using Lucas - Lehmer series ."}
{"code": "static boolean isPrime ( int p ) {", "nl": "Function to check whether ( 2 ^ p - 1 ) is prime or not ."}
{"code": "double checkNumber = Math . pow ( 2 , p ) - 1 ;", "nl": "generate the number"}
{"code": "double nextval = 4 % checkNumber ;", "nl": "First number of the series"}
{"code": "for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ;", "nl": "Generate the rest ( p - 2 ) terms of the series ."}
{"code": "return ( nextval == 0 ) ; }", "nl": "now if the ( p - 1 ) th term is 0 return true else false ."}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Program"}
{"code": "int p = 7 ; double checkNumber = Math . pow ( 2 , p ) - 1 ; if ( isPrime ( p ) ) System . out . println ( ( int ) checkNumber + \" \u2581 is \u2581 Prime . \" ) ; else System . out . println ( ( int ) checkNumber + \" \u2581 is \u2581 not \u2581 Prime . \" ) ; } }", "nl": "Check whether 2 ^ p - 1 is prime or not ."}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program to print all sophie german \u007f prime number till n ."}
{"code": "static void sieve ( int n , boolean prime [ ] ) { for ( int p = 2 ; p * p <= n ; p ++ ) {", "nl": "function to detect prime number here we have used sieve method https : www . geeksforgeeks . org / sieve - of - eratosthenes / to detect prime number"}
{"code": "if ( prime [ p ] == true ) {", "nl": "If prime [ p ] is not changed , then it is a prime"}
{"code": "for ( int i = p * 2 ; i < n ; i += p ) prime [ i ] = false ; } } } static void printSophieGermanNumber ( int n ) {", "nl": "Update all multiples of p"}
{"code": "boolean prime [ ] = new boolean [ 2 * n + 1 ] ; Arrays . fill ( prime , true ) ; sieve ( 2 * n + 1 , prime ) ; for ( int i = 2 ; i < n ; ++ i ) {", "nl": "We have made array till 2 * n + 1 so that we can check prime number till that and conclude about sophie german prime ."}
{"code": "if ( prime [ i ] && prime [ 2 * i + 1 ] ) System . out . print ( i + \" \u2581 \" ) ; } }", "nl": "checking every i whether it is sophie german prime or not ."}
{"code": "public static void main ( String args [ ] ) { int n = 25 ; printSophieGermanNumber ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . text . * ; class GFG {", "nl": "Java Program to interpolate using Bessel 's interpolation"}
{"code": "static double ucal ( double u , int n ) { if ( n == 0 ) return 1 ; double temp = u ; for ( int i = 1 ; i <= n / 2 ; i ++ ) temp = temp * ( u - i ) ; for ( int i = 1 ; i < n / 2 ; i ++ ) temp = temp * ( u + i ) ; return temp ; }", "nl": "calculating u mentioned in the formula"}
{"code": "static int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; }", "nl": "calculating factorial of given number n"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int n = 6 ; double x [ ] = { 25 , 26 , 27 , 28 , 29 , 30 } ;", "nl": "Number of values given"}
{"code": "double [ ] [ ] y = new double [ n ] [ n ] ; y [ 0 ] [ 0 ] = 4.000 ; y [ 1 ] [ 0 ] = 3.846 ; y [ 2 ] [ 0 ] = 3.704 ; y [ 3 ] [ 0 ] = 3.571 ; y [ 4 ] [ 0 ] = 3.448 ; y [ 5 ] [ 0 ] = 3.333 ;", "nl": "y [ ] [ ] is used for difference table with y [ ] [ 0 ] used for input"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < n - i ; j ++ ) y [ j ] [ i ] = y [ j + 1 ] [ i - 1 ] - y [ j ] [ i - 1 ] ;", "nl": "Calculating the central difference table"}
{"code": "DecimalFormat df = new DecimalFormat ( \" # . # # # # # # # # \" ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - i ; j ++ ) System . out . print ( y [ i ] [ j ] + \" TABSYMBOL \" ) ; System . out . println ( \" \" ) ; }", "nl": "Displaying the central difference table"}
{"code": "double value = 27.4 ;", "nl": "value to interpolate at"}
{"code": "double sum = ( y [ 2 ] [ 0 ] + y [ 3 ] [ 0 ] ) / 2 ;", "nl": "Initializing u and sum"}
{"code": "int k ;", "nl": "k is origin thats is f ( 0 )"}
{"code": "k = n / 2 ; else", "nl": "if ( ( n % 2 ) > 0 ) origin for odd"}
{"code": "double u = ( value - x [ k ] ) / ( x [ 1 ] - x [ 0 ] ) ;", "nl": "k = n / 2 - 1 ; origin for even"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) { if ( ( i % 2 ) > 0 ) sum = sum + ( ( u - 0.5 ) * ucal ( u , i - 1 ) * y [ k ] [ i ] ) / fact ( i ) ; else sum = sum + ( ucal ( u , i ) * ( y [ k ] [ i ] + y [ -- k ] [ i ] ) / ( fact ( i ) * 2 ) ) ; } System . out . printf ( \" Value \u2581 at \u2581 \" + value + \" \u2581 is \u2581 % .5f \" , sum ) ; } }", "nl": "Solving using bessel 's formula"}
{"code": "class Fibonacci { static int fibonacci ( int n ) { int a = 0 ; int b = 1 ; int c = 0 ; if ( n <= 1 ) return n ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }", "nl": "A simple Java program to check if n - th Fibonacci number is multiple of 10."}
{"code": "static boolean isMultipleOf10 ( int n ) { int f = fibonacci ( 30 ) ; return ( f % 10 == 0 ) ; }", "nl": "Returns true if n - th Fibonacci number is multiple of 10."}
{"code": "public static void main ( String [ ] args ) { int n = 30 ; if ( isMultipleOf10 ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "main function"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static boolean powerOf2 ( int n ) {", "nl": "Function which checks whether a number is a power of 2"}
{"code": "if ( n == 1 ) return true ;", "nl": "base cases '1' is the only odd number which is a power of 2 ( 2 ^ 0 )"}
{"code": "else if ( n % 2 != 0 n == 0 ) return false ;", "nl": "all other odd numbers are not powers of 2"}
{"code": "return powerOf2 ( n / 2 ) ; }", "nl": "recursive function call"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int n = 64 ;", "nl": "True"}
{"code": "int m = 12 ; if ( powerOf2 ( n ) == true ) System . out . print ( \" True \" + \"NEW_LINE\"); else System . out . print ( \" False \" + \"NEW_LINE\"); if ( powerOf2 ( m ) == true ) System . out . print ( \" True \" + \"NEW_LINE\"); else System . out . print ( \" False \" + \"NEW_LINE\"); } }", "nl": "False"}
{"code": "class Test {", "nl": "Java program to efficiently check for power for 2"}
{"code": "static boolean isPowerOfTwo ( int x ) {", "nl": "Method to check if x is power of 2"}
{"code": "return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }", "nl": "First x in the below expression is for the case when x is 0"}
{"code": "public static void main ( String [ ] args ) { System . out . println ( isPowerOfTwo ( 31 ) ? \" Yes \" : \" No \" ) ; System . out . println ( isPowerOfTwo ( 64 ) ? \" Yes \" : \" No \" ) ; } }", "nl": "Driver method"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program of the above approach"}
{"code": "static boolean isPowerofTwo ( int n ) { if ( n == 0 ) return false ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return true ; return false ; }", "nl": "Function to check if x is power of 2"}
{"code": "public static void main ( String [ ] args ) { if ( isPowerofTwo ( 30 ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; if ( isPowerofTwo ( 128 ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static int nextPowerOf2 ( int n ) {", "nl": "Function to find the nearest power of 2"}
{"code": "int p = 1 ;", "nl": "The number"}
{"code": "if ( n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ) return n ;", "nl": "If already a power of 2"}
{"code": "while ( p < n ) p <<= 1 ; return p ; }", "nl": "Find the next power of 2"}
{"code": "static int memoryUsed ( int arr [ ] , int n ) {", "nl": "Function to find the memory used"}
{"code": "int sum = 0 ;", "nl": "Sum of array"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ;", "nl": "Traverse and find the sum of array"}
{"code": "int nearest = nextPowerOf2 ( sum ) ; return nearest ; }", "nl": "Function call to find the nearest power of 2"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 2 } ; int n = arr . length ; System . out . println ( memoryUsed ( arr , n ) ) ; } }", "nl": "Driver Code"}
{"code": "class Toggle { static int toggleKthBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }", "nl": "Java program to toogle k - th bit of a number"}
{"code": "public static void main ( String [ ] args ) { int n = 5 , k = 1 ; System . out . println ( toggleKthBit ( n , k ) ) ; } }", "nl": "main function"}
{"code": "import java . io . * ; class GFG { static int nextPowerOf2 ( int n ) { int count = 0 ;", "nl": "Java program to find smallest power of 2 greater than or equal to n"}
{"code": "if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }", "nl": "First n in the below condition is for the case where n is 0"}
{"code": "public static void main ( String args [ ] ) { int n = 0 ; System . out . println ( nextPowerOf2 ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static int gcd ( int A , int B ) { if ( B == 0 ) return A ; return gcd ( B , A % B ) ; }", "nl": "Function to return the GCD of A and B"}
{"code": "static int lcm ( int A , int B ) { return ( A * B ) / gcd ( A , B ) ; }", "nl": "Function to return the LCM of A and B"}
{"code": "static int checkA ( int A , int B , int C , int K ) {", "nl": "Function to return the Kth element from the required set if it a multiple of A"}
{"code": "int start = 1 ; int end = K ;", "nl": "Start and End for Binary Search"}
{"code": "int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = A * mid ; int divA = mid - 1 ; int divB = ( value % B == 0 ) ? value / B - 1 : value / B ; int divC = ( value % C == 0 ) ? value / C - 1 : value / C ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ;", "nl": "If no answer found return - 1"}
{"code": "int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; }", "nl": "Inclusion and Exclusion"}
{"code": "else if ( elem > ( K - 1 ) ) { end = mid - 1 ; }", "nl": "Multiple should be smaller"}
{"code": "else { start = mid + 1 ; } } return ans ; }", "nl": "Multiple should be bigger"}
{"code": "static int checkB ( int A , int B , int C , int K ) {", "nl": "Function to return the Kth element from the required set if it a multiple of B"}
{"code": "int start = 1 ; int end = K ;", "nl": "Start and End for Binary Search"}
{"code": "int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = B * mid ; int divB = mid - 1 ; int divA = ( value % A == 0 ) ? value / A - 1 : value / A ; int divC = ( value % C == 0 ) ? value / C - 1 : value / C ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ;", "nl": "If no answer found return - 1"}
{"code": "int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; }", "nl": "Inclusion and Exclusion"}
{"code": "else if ( elem > ( K - 1 ) ) { end = mid - 1 ; }", "nl": "Multiple should be smaller"}
{"code": "else { start = mid + 1 ; } } return ans ; }", "nl": "Multiple should be bigger"}
{"code": "static int checkC ( int A , int B , int C , int K ) {", "nl": "Function to return the Kth element from the required set if it a multiple of C"}
{"code": "int start = 1 ; int end = K ;", "nl": "Start and End for Binary Search"}
{"code": "int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = C * mid ; int divC = mid - 1 ; int divB = ( value % B == 0 ) ? value / B - 1 : value / B ; int divA = ( value % A == 0 ) ? value / A - 1 : value / A ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ;", "nl": "If no answer found return - 1"}
{"code": "int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; }", "nl": "Inclusion and Exclusion"}
{"code": "else if ( elem > ( K - 1 ) ) { end = mid - 1 ; }", "nl": "Multiple should be smaller"}
{"code": "else { start = mid + 1 ; } } return ans ; }", "nl": "Multiple should be bigger"}
{"code": "static int findKthMultiple ( int A , int B , int C , int K ) {", "nl": "Function to return the Kth element from the set of multiples of A , B and C"}
{"code": "int res = checkA ( A , B , C , K ) ;", "nl": "Apply binary search on the multiples of A"}
{"code": "if ( res == - 1 ) res = checkB ( A , B , C , K ) ;", "nl": "If the required element is not a multiple of A then the multiples of B and C need to be checked"}
{"code": "if ( res == - 1 ) res = checkC ( A , B , C , K ) ; return res ; }", "nl": "If the required element is neither a multiple of A nor a multiple of B then the multiples of C need to be checked"}
{"code": "public static void main ( String args [ ] ) { int A = 2 , B = 4 , C = 5 , K = 5 ; System . out . println ( findKthMultiple ( A , B , C , K ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to sort the array by using the variation of the Stalin sort"}
{"code": "static void variationStalinsort ( Vector < Integer > arr ) { int j = 0 ; while ( true ) { int moved = 0 ; for ( int i = 0 ; i < ( arr . size ( ) - 1 - j ) ; i ++ ) { if ( arr . get ( i ) > arr . get ( i + 1 ) ) {", "nl": "Function to sort the array"}
{"code": "int index ; int temp ; index = arr . get ( i ) ; temp = arr . get ( i + 1 ) ; arr . removeElement ( index ) ; arr . add ( i , temp ) ; arr . removeElement ( temp ) ; arr . add ( i + 1 , index ) ; moved ++ ; } } j ++ ; if ( moved == 0 ) { break ; } } System . out . print ( arr ) ; }", "nl": "Iterator < Integer > index = arr . iterator ( ) ;"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 4 , 3 , 6 , 5 , 8 , 7 , 10 , 9 } ; Vector < Integer > arr1 = new Vector < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) arr1 . add ( arr [ i ] ) ;", "nl": "Driver Code"}
{"code": "variationStalinsort ( arr1 ) ; } }", "nl": "Function call"}
{"code": "class Main {", "nl": "Java program for the above approach"}
{"code": "public static void printArray ( int arr [ ] , int N ) {", "nl": "Function to print array element"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }", "nl": "Traverse the array"}
{"code": "public static void sortArray ( int arr [ ] , int N ) {", "nl": "Function to sort the array in O ( N )"}
{"code": "for ( int i = 0 ; i < N ; ) {", "nl": "Traverse the array"}
{"code": "if ( arr [ i ] == i + 1 ) { i ++ ; }", "nl": "If the current element is at correct position"}
{"code": "else {", "nl": "Else swap the current element with it 's correct position"}
{"code": "int temp1 = arr [ i ] ; int temp2 = arr [ arr [ i ] - 1 ] ; arr [ i ] = temp2 ; arr [ temp1 - 1 ] = temp1 ; } } }", "nl": "Swap the value of arr [ i ] and arr [ arr [ i ] - 1 ]"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 5 , 3 , 4 } ; int N = arr . length ;", "nl": "Driver Code"}
{"code": "sortArray ( arr , N ) ;", "nl": "Function call to sort the array"}
{"code": "printArray ( arr , N ) ; } }", "nl": "Function call to print the array"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java implementation for the above approach"}
{"code": "static int maximum ( int value [ ] , int weight [ ] , int weight1 , int flag , int K , int index ) {", "nl": "Function to find the maximum value"}
{"code": "if ( index >= value . length ) { return 0 ; }", "nl": "base condition"}
{"code": "if ( flag == K ) {", "nl": "K elements already reduced to half of their weight"}
{"code": "int skip = maximum ( value , weight , weight1 , flag , K , index + 1 ) ; int full = 0 ;", "nl": "Dont include item"}
{"code": "if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 ) ; }", "nl": "If weight of the item is less than or equal to the remaining weight then include the item"}
{"code": "return Math . max ( full , skip ) ; }", "nl": "Return the maximum of both cases"}
{"code": "else {", "nl": "If the weight reduction to half is possible"}
{"code": "int skip = maximum ( value , weight , weight1 , flag , K , index + 1 ) ; int full = 0 ; int half = 0 ;", "nl": "Skip the item"}
{"code": "if ( weight [ index ] <= weight1 ) { full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 ) ; }", "nl": "Include item with full weight if weight of the item is less than the remaining weight"}
{"code": "if ( weight [ index ] / 2 <= weight1 ) { half = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] / 2 , flag , K , index + 1 ) ; }", "nl": "Include item with half weight if half weight of the item is less than the remaining weight"}
{"code": "return Math . max ( full , Math . max ( skip , half ) ) ; } }", "nl": "Return the maximum of all 3 cases"}
{"code": "public static void main ( String [ ] args ) throws Exception { int value [ ] = { 17 , 20 , 10 , 15 } ; int weight [ ] = { 4 , 2 , 7 , 5 } ; int K = 1 ; int W = 4 ; System . out . println ( maximum ( value , weight , W , 0 , K , 0 ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static final int N = 1005 ;", "nl": "Java program to find the size of the minimum dominating set of the tree"}
{"code": "static class Node { int data ; Node left , right ; } ;", "nl": "Definition of a tree node"}
{"code": "static Node newNode ( int data ) { Node node = new Node ( ) ; node . data = data ; node . left = node . right = null ; return node ; }", "nl": "Helper function that allocates a new node"}
{"code": "static int [ ] [ ] [ ] dp = new int [ N ] [ 5 ] [ 5 ] ;", "nl": "DP array to precompute and store the results"}
{"code": "static int minDominatingSet ( Node root , int covered , int compulsory ) {", "nl": "minDominatingSettion to return the size of the minimum dominating set of the array"}
{"code": "if ( root == null ) return 0 ;", "nl": "Base case"}
{"code": "if ( root . left != null && root . right != null && covered > 0 ) compulsory = 1 ;", "nl": "Setting the compulsory value if needed"}
{"code": "if ( dp [ root . data ] [ covered ] [ compulsory ] != - 1 ) return dp [ root . data ] [ covered ] [ compulsory ] ;", "nl": "Check if the answer is already computed"}
{"code": "if ( compulsory > 0 ) {", "nl": "If it is compulsory to select the node"}
{"code": "return dp [ root . data ] [ covered ] [ compulsory ] = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; }", "nl": "Choose the node and set its children as covered"}
{"code": "if ( covered > 0 ) { return dp [ root . data ] [ covered ] [ compulsory ] = Math . min ( 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; }", "nl": "If it is covered"}
{"code": "int ans = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; if ( root . left != null ) { ans = Math . min ( ans , minDominatingSet ( root . left , 0 , 1 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; } if ( root . right != null ) { ans = Math . min ( ans , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 1 ) ) ; }", "nl": "If the current node is neither covered nor needs to be selected compulsorily"}
{"code": "return dp [ root . data ] [ covered ] [ compulsory ] = ans ; }", "nl": "Store the result"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < 5 ; j ++ ) { for ( int l = 0 ; l < 5 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } }", "nl": "Initialising the DP array"}
{"code": "Node root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . left . left = newNode ( 3 ) ; root . left . right = newNode ( 4 ) ; root . left . left . left = newNode ( 5 ) ; root . left . left . left . left = newNode ( 6 ) ; root . left . left . left . right = newNode ( 7 ) ; root . left . left . left . right . right = newNode ( 10 ) ; root . left . left . left . left . left = newNode ( 8 ) ; root . left . left . left . left . right = newNode ( 9 ) ; System . out . print ( minDominatingSet ( root , 0 , 0 ) + \"NEW_LINE\"); } }", "nl": "Constructing the tree"}
{"code": "class GFG { static int maxSum = 100 ; static int arrSize = 51 ;", "nl": "Java implementation of above approach"}
{"code": "static int [ ] [ ] dp = new int [ arrSize ] [ maxSum ] ; static boolean [ ] [ ] visit = new boolean [ arrSize ] [ maxSum ] ;", "nl": "variable to store states of dp"}
{"code": "static int SubsetCnt ( int i , int s , int arr [ ] , int n ) {", "nl": "To find the number of subsets with sum equal to 0 Since S can be negative , we will maxSum to it to make it positive"}
{"code": "if ( i == n ) { if ( s == 0 ) { return 1 ; } else { return 0 ; } }", "nl": "Base cases"}
{"code": "if ( visit [ i ] [ s + arrSize ] ) { return dp [ i ] [ s + arrSize ] ; }", "nl": "Returns the value if a state is already solved"}
{"code": "visit [ i ] [ s + arrSize ] = true ;", "nl": "If the state is not visited , then continue"}
{"code": "dp [ i ] [ s + arrSize ] = SubsetCnt ( i + 1 , s + arr [ i ] , arr , n ) + SubsetCnt ( i + 1 , s , arr , n ) ;", "nl": "Recurrence relation"}
{"code": "return dp [ i ] [ s + arrSize ] ; }", "nl": "Returning the value"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 2 , - 4 , - 4 } ; int n = arr . length ; System . out . println ( SubsetCnt ( 0 , 0 , arr , n ) ) ; } }", "nl": "Driver function"}
{"code": "class solution { static final int MAX = 1000 ;", "nl": "Java program to find the number of Bit Strings of length N with K adjacent set bits"}
{"code": "static int waysToKAdjacentSetBits ( int dp [ ] [ ] [ ] , int n , int k , int currentIndex , int adjacentSetBits , int lastBit ) {", "nl": "Function to find the number of Bit Strings of length N with K adjacent set bits"}
{"code": "if ( currentIndex == n ) {", "nl": "Base Case when we form bit string of length n"}
{"code": "if ( adjacentSetBits == k ) return 1 ; return 0 ; } if ( dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] != - 1 ) { return dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] ; } int noOfWays = 0 ;", "nl": "if f ( bit string ) = k , count this way"}
{"code": "if ( lastBit == 1 ) {", "nl": "Check if the last bit was set , if it was set then call for next index by incrementing the adjacent bit count else just call the next index with same value of adjacent bit count and either set the bit at current index or let it remain unset"}
{"code": "noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ;", "nl": "set the bit at currentIndex"}
{"code": "noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } else if ( lastBit == 0 ) { noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; noOfWays += waysToKAdjacentSetBits ( dp , n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } dp [ currentIndex ] [ adjacentSetBits ] [ lastBit ] = noOfWays ; return noOfWays ; }", "nl": "unset the bit at currentIndex"}
{"code": "public static void main ( String args [ ] ) { int n = 5 , k = 2 ;", "nl": "Driver Code"}
{"code": "int dp [ ] [ ] [ ] = new int [ MAX ] [ MAX ] [ 2 ] ;", "nl": "dp [ i ] [ j ] [ k ] represents bit strings of length i with f ( bit string ) = j and last bit as k"}
{"code": "for ( int i = 0 ; i < MAX ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) for ( int k1 = 0 ; k1 < 2 ; k1 ++ ) dp [ i ] [ j ] [ k1 ] = - 1 ;", "nl": "initialize the dp"}
{"code": "int totalWays = waysToKAdjacentSetBits ( dp , n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( dp , n , k , 1 , 0 , 0 ) ; System . out . print ( \" Number \u2581 of \u2581 ways \u2581 = \u2581 \" + totalWays + \"NEW_LINE\"); } }", "nl": "total ways = ( ways by placing 1 st bit as 1 + ways by placing 1 st bit as 0 )"}
{"code": "import java . io . * ; import java . util . * ; import java . lang . * ; class GFG {", "nl": "A space optimized based Java program to print the nth tetranacci number"}
{"code": "static void printTetra ( int n ) { if ( n < 0 ) return ;", "nl": "Function to print the N - th tetranacci number"}
{"code": "int first = 0 , second = 1 ; int third = 1 , fourth = 2 ;", "nl": "Initialize first four numbers to base cases"}
{"code": "int curr = 0 ; if ( n == 0 ) System . out . print ( first ) ; else if ( n == 1 n == 2 ) System . out . print ( second ) ; else if ( n == 3 ) System . out . print ( fourth ) ; else {", "nl": "declare a current variable"}
{"code": "for ( int i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } System . out . print ( curr ) ; } }", "nl": "Loop to add previous four numbers for each number starting from 4 and then assign first , second , third to second , third , fourth and curr to fourth respectively"}
{"code": "public static void main ( String [ ] args ) { int n = 10 ; printTetra ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . lang . * ; import java . util . * ; public class GfG {", "nl": "Program to find n - th stair using step size 1 or 2 or 3."}
{"code": "public static int countWays ( int n ) { int [ ] res = new int [ n + 1 ] ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; }", "nl": "A recursive function used by countWays"}
{"code": "public static void main ( String argc [ ] ) { int n = 4 ; System . out . println ( countWays ( n ) ) ; } }", "nl": "Driver function"}
{"code": "import java . io . * ; class GFG {", "nl": "A Java program to count number of ways to reach nth stair when"}
{"code": "static int countWays ( int n ) {", "nl": "A recursive function used by countWays"}
{"code": "int a = 1 , b = 2 , c = 4 ;", "nl": "Declaring three variables and holding the ways for first three stairs"}
{"code": "int d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ;", "nl": "Fourth variable"}
{"code": "for ( int i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; }", "nl": "Starting from 4 as already counted for 3 stairs"}
{"code": "public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( countWays ( n ) ) ; } }", "nl": "Driver code"}
{"code": "dp [ 0 ] = 1 ;", "nl": "initializing with 1 as sum 0 is always possible"}
{"code": "for ( int i = 0 ; i < elements . length ; i ++ ) {", "nl": "loop to go through every element of the elements array"}
{"code": "for ( int j = sum ; j >= elements [ i ] ; j -- ) { if ( dp [ j - elements [ i ] ] == 1 ) dp [ j ] = 1 ; } }", "nl": "to change the values of all possible sum values to 1"}
{"code": "if ( dp [ sum ] == 1 ) return true ; return false ; }", "nl": "if sum is possible then return 1"}
{"code": "public static void main ( String [ ] args ) throws Exception { int elements [ ] = { 6 , 2 , 5 } ; int sum = 7 ; if ( isPossible ( elements , sum ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "A naive recursive Java program to find maximum tasks ."}
{"code": "static int maxTasks ( int high [ ] , int low [ ] , int n ) {", "nl": "Returns maximum amount of task that can be done till day n"}
{"code": "if ( n <= 0 ) return 0 ;", "nl": "If n is less than equal to 0 , then no solution exists"}
{"code": "return Math . max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; }", "nl": "Determines which task to choose on day n , then returns the maximum till that day"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; int high [ ] = { 3 , 6 , 8 , 7 , 6 } ; int low [ ] = { 1 , 5 , 4 , 5 , 3 } ; System . out . println ( maxTasks ( high , low , n ) ) ; } }", "nl": "Driver code"}
{"code": "static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int nCr ( int n , int r ) {", "nl": "function to find gcd of two numbers in O ( log ( min ( a , b ) ) )"}
{"code": "if ( r > n ) return 0 ;", "nl": "base case"}
{"code": "if ( r > n - r ) C ( n , r ) = C ( n , n - r ) r = n - r ; int mod = 1000000007 ;", "nl": "better time complexity for lesser r value"}
{"code": "int [ ] arr = new int [ r ] ; for ( int i = n - r + 1 ; i <= n ; i ++ ) { arr [ i + r - n - 1 ] = i ; } long ans = 1 ;", "nl": "array of elements from n - r + 1 to n"}
{"code": "for ( int k = 1 ; k < r + 1 ; k ++ ) { int j = 0 , i = k ; while ( j < arr . length ) { int x = gcd ( i , arr [ j ] ) ; if ( x > 1 ) {", "nl": "for numbers from 1 to r find arr [ j ] such that gcd ( i , arr [ j ] ) > 1"}
{"code": "arr [ j ] /= x ; i /= x ; } if ( i == 1 )", "nl": "if gcd > 1 , divide both by gcd"}
{"code": "break ; j += 1 ; } }", "nl": "if i becomes 1 , no need to search arr"}
{"code": "ans = ( ans * i ) % mod ; return ( int ) ans ; }", "nl": "for ( int i : arr ) single pass to multiply the numerator"}
{"code": "public static void main ( String [ ] args ) { int n = 5 , r = 2 ; System . out . print ( \" Value \u2581 of \u2581 C ( \" + n + \" , \u2581 \" + r + \" ) \u2581 is \u2581 \" + nCr ( n , r ) + \"NEW_LINE\"); } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static char FindKthChar ( String str , int K , int X ) {", "nl": "Function to find the Kth character after X days"}
{"code": "char ans = ' \u2581 ' ; int sum = 0 ;", "nl": "Variable to store the KthChar"}
{"code": "for ( int i = 0 ; i < str . length ( ) ; i ++ ) {", "nl": "Traverse the string"}
{"code": "int digit = ( int ) str . charAt ( i ) - 48 ;", "nl": "Convert char into int"}
{"code": "int range = ( int ) Math . pow ( digit , X ) ; sum += range ;", "nl": "Calculate characters"}
{"code": "if ( K <= sum ) { ans = str . charAt ( i ) ; break ; } }", "nl": "If K is less than sum than ans = str [ i ]"}
{"code": "return ans ; }", "nl": "Return answer"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "String str = \"123\" ; int K = 9 ; int X = 3 ;", "nl": "Given Input"}
{"code": "char ans = FindKthChar ( str , K , X ) ; System . out . println ( ans ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int totalPairs ( String s1 , String s2 ) { int count = 0 ; int [ ] arr1 = new int [ 7 ] ; int [ ] arr2 = new int [ 7 ] ;", "nl": "Function to return the count of valid pairs"}
{"code": "for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { int set_bits = Integer . bitCount ( s1 . charAt ( i ) ) ; arr1 [ set_bits ] ++ ; }", "nl": "Default Initialise both arrays 0 Store frequency of number of set bits for s1"}
{"code": "for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { int set_bits = Integer . bitCount ( s2 . charAt ( i ) ) ; arr2 [ set_bits ] ++ ; }", "nl": "Store frequency of number of set bits for s2"}
{"code": "for ( int i = 1 ; i <= 6 ; i ++ ) { count += ( arr1 [ i ] * arr2 [ i ] ) ; }", "nl": "Calculate total pairs"}
{"code": "return count ; }", "nl": "Return the count of valid pairs"}
{"code": "public static void main ( String [ ] args ) { String s1 = \" geeks \" ; String s2 = \" forgeeks \" ; System . out . println ( totalPairs ( s1 , s2 ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {", "nl": "Java implementation to count substrings starting with character X and ending with character Y"}
{"code": "static int countSubstr ( String str , int n , char x , char y ) {", "nl": "function to count substrings starting with character X and ending with character Y"}
{"code": "int tot_count = 0 ;", "nl": "to store total count of required substrings"}
{"code": "int count_x = 0 ;", "nl": "to store count of character ' x ' up to the point the string ' str ' has been traversed so far"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "traverse ' str ' form left to right"}
{"code": "if ( str . charAt ( i ) == x ) count_x ++ ;", "nl": "if true , increment ' count _ x '"}
{"code": "if ( str . charAt ( i ) == y ) tot_count += count_x ; }", "nl": "if true accumulate ' count _ x ' to ' tot _ count '"}
{"code": "return tot_count ; }", "nl": "required count"}
{"code": "public static void main ( String args [ ] ) { String str = \" abbcaceghcak \" ; int n = str . length ( ) ; char x = ' a ' , y = ' c ' ; System . out . print ( \" Count \u2581 = \u2581 \" + countSubstr ( str , n , x , y ) ) ; } }", "nl": "Driver code"}
{"code": "public class GFG { static final int OUT = 0 ; static final int IN = 1 ;", "nl": "Java program to count no of words from given input string ."}
{"code": "static int countWords ( String str ) { int state = OUT ;", "nl": "returns number of words in str"}
{"code": "int wc = 0 ; int i = 0 ;", "nl": "word count"}
{"code": "while ( i < str . length ( ) ) {", "nl": "Scan all characters one by one"}
{"code": "if ( str . charAt ( i ) == ' \u2581 ' || str . charAt ( i ) == 'NEW_LINE' || str . charAt ( i ) == ' TABSYMBOL ' ) state = OUT ;", "nl": "If next character is a separator , set the state as OUT"}
{"code": "else if ( state == OUT ) { state = IN ; ++ wc ; }", "nl": "If next character is not a word separator and state is OUT , then set the state as IN and increment word count"}
{"code": "++ i ; } return wc ; }", "nl": "Move to next character"}
{"code": "public static void main ( String args [ ] ) { String str = \"One twothree four five \"; System . out . println ( \" No \u2581 of \u2581 words \u2581 : \u2581 \" + countWords ( str ) ) ; } }", "nl": "Driver program to test above functions"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find nth Enneadecagonal number"}
{"code": "static int nthEnneadecagonal ( int n ) {", "nl": "Function to calculate Enneadecagonal number"}
{"code": "return ( 17 * n * n - 15 * n ) / 2 ; }", "nl": "Formula for finding nth Enneadecagonal number"}
{"code": "public static void main ( String [ ] args ) { int n = 6 ; System . out . print ( n + \" th \u2581 Enneadecagonal \u2581 number \u2581 : \" ) ; System . out . println ( nthEnneadecagonal ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class Gfg {", "nl": "Java program to calculate area of a circumscribed circle - square"}
{"code": "static float areacircumscribed ( float a ) { float PI = 3.14159265f ; return ( a * a * ( PI / 2 ) ) ; }", "nl": "Utility Function"}
{"code": "public static void main ( String arg [ ] ) { float a = 6 ; System . out . print ( \" Area \u2581 of \u2581 an \u2581 circumscribed \" + \" circle \u2581 is \u2581 : \" ) ; System . out . println ( areacircumscribed ( a ) ) ; } }", "nl": "Driver Function"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int itemType ( int n ) {", "nl": "Function to find the type of the item given out according to the given rules"}
{"code": "int count = 0 ; int day = 1 ;", "nl": "Stores the count of item given out at each step"}
{"code": "while ( count + day * ( day + 1 ) / 2 < n ) {", "nl": "Iterate to find the Nth day present is given out"}
{"code": "count += day * ( day + 1 ) / 2 ; day ++ ; } for ( int type = day ; type > 0 ; type -- ) {", "nl": "Find the number of presents given on day is day * ( day + 1 ) / 2"}
{"code": "count += type ;", "nl": "Iterate over the type"}
{"code": "if ( count >= n ) { return type ; } } return 0 ; }", "nl": "Return the resultant type"}
{"code": "public static void main ( String [ ] args ) { int N = 10 ; System . out . println ( itemType ( N ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to check Linked List is sorted in descending order or not"}
{"code": "static class Node { int data ; Node next ; } ;", "nl": "Linked list node"}
{"code": "static boolean isSortedDesc ( Node head ) { if ( head == null ) return true ;", "nl": "function to Check Linked List is sorted in descending order or not"}
{"code": "for ( Node t = head ; t . next != null ; t = t . next ) if ( t . data <= t . next . data ) return false ; return true ; } static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . next = null ; temp . data = data ; return temp ; }", "nl": "Traverse the list till last node and return false if a node is smaller than or equal its next ."}
{"code": "public static void main ( String [ ] args ) { Node head = newNode ( 7 ) ; head . next = newNode ( 5 ) ; head . next . next = newNode ( 4 ) ; head . next . next . next = newNode ( 3 ) ; if ( isSortedDesc ( head ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver Code"}
{"code": "public class GFG {", "nl": "Java program for the above approach"}
{"code": "static int maxLength ( String str , int n , char c , int k ) {", "nl": "Function to find the maximum length continuos segment of character c after flipping at most K characters"}
{"code": "int ans = - 1 ;", "nl": "Stores the maximum length"}
{"code": "int cnt = 0 ;", "nl": "Stores the count of char ' c '"}
{"code": "int left = 0 ; for ( int right = 0 ; right < n ; right ++ ) { if ( str . charAt ( right ) == c ) { cnt ++ ; }", "nl": "Start of window"}
{"code": "while ( cnt > k ) { if ( str . charAt ( left ) == c ) { cnt -- ; }", "nl": "Remove the extra ' c ' from left"}
{"code": "left ++ ; }", "nl": "Increment the value of the left"}
{"code": "ans = Math . max ( ans , right - left + 1 ) ; } return ans ; }", "nl": "Update the resultant maximum length of character ch"}
{"code": "static int maxConsecutiveSegment ( String S , int K ) { int N = S . length ( ) ;", "nl": "Function to find the maximum length of consecutive 0 s or 1 s by flipping at most K characters of the string"}
{"code": "return Math . max ( maxLength ( S , N , '0' , K ) , maxLength ( S , N , '1' , K ) ) ; }", "nl": "Print the maximum of the maximum length of 0 s or 1 s"}
{"code": "int main ( ) { return 0 ; } public static void main ( String [ ] args ) { String S = \"1001\" ; int K = 1 ; System . out . println ( maxConsecutiveSegment ( S , K ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void find ( int N ) { int T , F , O ;", "nl": "Function to find minimum count of { 1 , 2 , 5 } valued coins required to make a change of all values in the range [ 1 , N ]"}
{"code": "F = ( int ) ( ( N - 4 ) / 5 ) ;", "nl": "Number of 5 valueds coins required"}
{"code": "if ( ( ( N - 5 * F ) % 2 ) == 0 ) { O = 2 ; } else { O = 1 ; }", "nl": "Number of 1 valued coins required"}
{"code": "T = ( int ) Math . floor ( ( N - 5 * F - O ) / 2 ) ; System . out . println ( \" Count \u2581 of \u2581 5 \u2581 valueds \u2581 coins : \u2581 \" + F ) ; System . out . println ( \" Count \u2581 of \u2581 2 \u2581 valueds \u2581 coins : \u2581 \" + T ) ; System . out . println ( \" Count \u2581 of \u2581 1 \u2581 valueds \u2581 coins : \u2581 \" + O ) ; }", "nl": "Number of 2 valued coins required"}
{"code": "public static void main ( String args [ ] ) { int N = 8 ; find ( N ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void findMaxOccurence ( char [ ] str , int N ) {", "nl": "Function to maximize count of 0 and 10 by replacing character ' ? ' to '0' or '1'"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the given String"}
{"code": "if ( str [ i ] == ' ? ' ) {", "nl": "If current character is ' ? '"}
{"code": "str [ i ] = '0' ; } } System . out . print ( str ) ; }", "nl": "Replace str [ i ] to '0'"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "String str = \"10?0?11\" ; int N = str . length ( ) ; findMaxOccurence ( str . toCharArray ( ) , N ) ; } }", "nl": "Given String"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "public static void checkInfinite ( String s ) {", "nl": "Function checks if a given string is valid or not and prints the output"}
{"code": "boolean flag = true ; int N = s . length ( ) ;", "nl": "Boolean flag variable to mark if given string is valid"}
{"code": "for ( int i = 0 ; i < N - 1 ; i ++ ) {", "nl": "Traverse the given string"}
{"code": "if ( s . charAt ( i ) == ( char ) ( ( int ) ( s . charAt ( i + 1 ) ) + 1 ) ) { continue ; }", "nl": "If adjacent character differ by 1"}
{"code": "else if ( s . charAt ( i ) == ' a ' && s . charAt ( i + 1 ) == ' z ' ) { continue ; }", "nl": "If character ' a ' is followed by 4"}
{"code": "else { flag = false ; break ; } }", "nl": "Else flip the flag and break from the loop"}
{"code": "if ( ! flag ) System . out . print ( \" NO \" ) ; else System . out . print ( \" YES \" ) ; }", "nl": "Output according to flag variable"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "String s = \" ecbaz \" ;", "nl": "Given string"}
{"code": "checkInfinite ( s ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static int minChangeInLane ( int barrier [ ] , int n ) { int dp [ ] = { 1 , 0 , 1 } ; for ( int j = 0 ; j < n ; j ++ ) {", "nl": "Function to find the minimum number of changes of lane required"}
{"code": "int val = barrier [ j ] ; if ( val > 0 ) { dp [ val - 1 ] = ( int ) 1e6 ; } for ( int i = 0 ; i < 3 ; i ++ ) {", "nl": "If there is a barrier , then add very large value"}
{"code": "if ( val != i + 1 ) { dp [ i ] = Math . min ( dp [ i ] , Math . min ( dp [ ( i + 1 ) % 3 ] , dp [ ( i + 2 ) % 3 ] ) + 1 ) ; } } }", "nl": "Add the minimum value to move forword with or without crossing barrier"}
{"code": "return Math . min ( dp [ 0 ] , Math . min ( dp [ 1 ] , dp [ 2 ] ) ) ; }", "nl": "Return the minimum value of dp [ 0 ] , dp [ 1 ] and dp [ 2 ]"}
{"code": "public static void main ( String [ ] args ) { int barrier [ ] = { 0 , 1 , 2 , 3 , 0 } ; int N = barrier . length ; System . out . print ( minChangeInLane ( barrier , N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; public class Main {", "nl": "Java program for the above approach"}
{"code": "public static void numWays ( int [ ] [ ] ratings , int queries [ ] [ ] , int n , int k ) {", "nl": "Function to count number of ways to get given sum groups"}
{"code": "int dp [ ] [ ] = new int [ n ] [ 10000 + 2 ] ;", "nl": "Initialise dp array"}
{"code": "for ( int i = 0 ; i < k ; i ++ ) dp [ 0 ] [ ratings [ 0 ] [ i ] ] += 1 ;", "nl": "Mark all 1 st row values as 1 since the mat [ 0 ] [ i ] is all possible sums in first row"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) {", "nl": "Fix the ith row"}
{"code": "for ( int sum = 0 ; sum <= 10000 ; sum ++ ) {", "nl": "Fix the sum"}
{"code": "for ( int j = 0 ; j < k ; j ++ ) {", "nl": "Iterate through all values of ith row"}
{"code": "if ( sum >= ratings [ i ] [ j ] ) dp [ i ] [ sum ] += dp [ i - 1 ] [ sum - ratings [ i ] [ j ] ] ; } } }", "nl": "If sum can be obtained"}
{"code": "for ( int sum = 1 ; sum <= 10000 ; sum ++ ) { dp [ n - 1 ] [ sum ] += dp [ n - 1 ] [ sum - 1 ] ; }", "nl": "Find the prefix sum of last row"}
{"code": "for ( int q = 0 ; q < queries . length ; q ++ ) { int a = queries [ q ] [ 0 ] ; int b = queries [ q ] [ 1 ] ;", "nl": "Traverse each query"}
{"code": "System . out . print ( dp [ n - 1 ] [ b ] - dp [ n - 1 ] [ a - 1 ] + \" \u2581 \" ) ; } }", "nl": "No of ways to form groups"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "int N = 2 , K = 3 ;", "nl": "Given N batches and K students"}
{"code": "int ratings [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } } ;", "nl": "Given ratings"}
{"code": "int queries [ ] [ ] = { { 6 , 6 } , { 1 , 6 } } ;", "nl": "Given Queries"}
{"code": "numWays ( ratings , queries , N , K ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void numberOfPermWithKInversion ( int N , int K ) {", "nl": "Function to count permutations with K inversions"}
{"code": "int [ ] [ ] dp = new int [ 2 ] [ K + 1 ] ; int mod = 1000000007 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= K ; j ++ ) {", "nl": "Store number of permutations with K inversions"}
{"code": "if ( i == 1 ) { dp [ i % 2 ] [ j ] = ( j == 0 ) ? 1 : 0 ; }", "nl": "If N = 1 only 1 permutation with no inversion"}
{"code": "else if ( j == 0 ) dp [ i % 2 ] [ j ] = 1 ;", "nl": "For K = 0 only 1 permutation with no inversion"}
{"code": "else { int maxm = Math . max ( j - ( i - 1 ) ) ; dp [ i % 2 ] [ j ] = ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( Math . max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 ] [ maxm , 0 ) - 1 ] ) + mod ) % mod ) % mod ; } } }", "nl": "Otherwise Update each dp state as per the reccurrance relation formed"}
{"code": "System . out . println ( dp [ N % 2 ] [ K ] ) ; }", "nl": "Print final count"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 3 , K = 2 ;", "nl": "Given N and K"}
{"code": "numberOfPermWithKInversion ( N , K ) ; } }", "nl": "Function Call"}
{"code": "class GFG { static final int N = 100 ; static int n , m ;", "nl": "No of rows and columns"}
{"code": "static int a [ ] [ ] = new int [ N ] [ N ] ;", "nl": "Declaring the matrix of maximum 100 rows and 100 columns"}
{"code": "static int dp [ ] [ ] = new int [ N ] [ N ] ; static int visited [ ] [ ] = new int [ N ] [ N ] ;", "nl": "Variable visited is used to keep track of all the visited positions Variable dp is used to store maximum sum till current position"}
{"code": "static int current_sum = 0 ;", "nl": "For storing current sum"}
{"code": "static int total_sum = 0 ;", "nl": "For continuous update of maximum sum required"}
{"code": "static void inputMatrix ( ) { n = 3 ; m = 3 ; a [ 0 ] [ 0 ] = 500 ; a [ 0 ] [ 1 ] = 100 ; a [ 0 ] [ 2 ] = 230 ; a [ 1 ] [ 0 ] = 1000 ; a [ 1 ] [ 1 ] = 300 ; a [ 1 ] [ 2 ] = 100 ; a [ 2 ] [ 0 ] = 200 ; a [ 2 ] [ 1 ] = 1000 ; a [ 2 ] [ 2 ] = 200 ; }", "nl": "Function to Input the matrix of size n * m"}
{"code": "static int maximum_sum_path ( int i , int j ) {", "nl": "Function to calculate maximum sum of path"}
{"code": "if ( i == n - 1 && j == m - 1 ) return a [ i ] [ j ] ;", "nl": "Checking boundary condition"}
{"code": "if ( visited [ i ] [ j ] != 0 ) return dp [ i ] [ j ] ;", "nl": "Checking whether or not ( i , j ) is visited"}
{"code": "visited [ i ] [ j ] = 1 ; int total_sum = 0 ;", "nl": "Marking ( i , j ) is visited"}
{"code": "if ( i < n - 1 & j < m - 1 ) { int current_sum = Math . max ( maximum_sum_path ( i , j + 1 ) , Math . max ( maximum_sum_path ( i + 1 , j + 1 ) , maximum_sum_path ( i + 1 , j ) ) ) ; total_sum = a [ i ] [ j ] + current_sum ; }", "nl": "Checking whether the position hasn 't  visited the last row or the last column.  Making recursive call for all the possible  moves from the current cell and then adding the  maximum returned by the calls and updating it."}
{"code": "else if ( i == n - 1 ) total_sum = a [ i ] [ j ] + maximum_sum_path ( i , j + 1 ) ;", "nl": "Checking whether position has reached last row"}
{"code": "else total_sum = a [ i ] [ j ] + maximum_sum_path ( i + 1 , j ) ;", "nl": "If the position is in the last column"}
{"code": "dp [ i ] [ j ] = total_sum ;", "nl": "Updating the maximum sum till the current position in the dp"}
{"code": "return total_sum ; }", "nl": "Returning the updated maximum value"}
{"code": "public static void main ( String [ ] args ) { inputMatrix ( ) ;", "nl": "Driver Code"}
{"code": "int maximum_sum = maximum_sum_path ( 0 , 0 ) ; System . out . println ( maximum_sum ) ; } }", "nl": "Calling the implemented function"}
{"code": "class GFG { static int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { int sum = 0 ;", "nl": "k is current index and col is previous color ."}
{"code": "if ( k == n ) return 0 ;", "nl": "base case"}
{"code": "if ( col == color [ k ] ) sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ;", "nl": "check if color of this city is equal to prev visited city"}
{"code": "return sum ; }", "nl": "return max of both options"}
{"code": "public static void main ( String [ ] args ) { int A = - 5 , B = 7 ; int treasure [ ] = { 4 , 8 , 2 , 9 } ; int color [ ] = { 2 , 2 , 6 , 2 } ; int n = color . length ;", "nl": "Driver code"}
{"code": "System . out . print ( MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ) ; } }", "nl": "Initially begin with color 0"}
{"code": "class GFG {", "nl": "A simple recursive Java program to print the nth tetranacci numbers ."}
{"code": "static int printTetraRec ( int n ) {", "nl": "Function to return the N - th tetranacci number"}
{"code": "if ( n == 0 ) return 0 ;", "nl": "base cases"}
{"code": "if ( n == 1 n == 2 ) return 1 ;", "nl": "base cases"}
{"code": "if ( n == 3 ) return 2 ; else return printTetraRec ( n - 1 ) + printTetraRec ( n - 2 ) + printTetraRec ( n - 3 ) + printTetraRec ( n - 4 ) ; }", "nl": "base cases"}
{"code": "static void printTetra ( int n ) { System . out . println ( printTetraRec ( n ) + \" \u2581 \" ) ; }", "nl": "function to print the Nth tetranacci number"}
{"code": "public static void main ( String [ ] args ) { int n = 10 ; printTetra ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Program to find SOP of all combination taken ( 1 to N ) at a time using brute force"}
{"code": "static int sum = 0 ; static void Combination ( int [ ] a , int [ ] combi , int n , int r , int depth , int index ) {", "nl": "to store sum of every combination"}
{"code": "if ( index == r ) {", "nl": "if we have reached sufficient depth"}
{"code": "int product = 1 ; for ( int i = 0 ; i < r ; i ++ ) product = product * combi [ i ] ;", "nl": "find the product of combination"}
{"code": "sum += product ; return ; }", "nl": "add the product into sum"}
{"code": "for ( int i = depth ; i < n ; i ++ ) { combi [ index ] = a [ i ] ; Combination ( a , combi , n , r , i + 1 , index + 1 ) ; } }", "nl": "recursion to produce different combination"}
{"code": "static void allCombination ( int [ ] a , int n ) { for ( int i = 1 ; i <= n ; i ++ ) {", "nl": "function to print sum of products of all combination taken 1 - N at a time"}
{"code": "int [ ] combi = new int [ i ] ;", "nl": "creating temporary array for storing combination"}
{"code": "Combination ( a , combi , n , i , 0 , 0 ) ;", "nl": "call combination with r = i for combination taken i at a time"}
{"code": "System . out . print ( \" f ( \" + i + \" ) \u2581 - - > \u2581 \" + sum + \"NEW_LINE\"); sum = 0 ; } }", "nl": "displaying sum"}
{"code": "public static void main ( String args [ ] ) { int n = 5 ; int [ ] a = new int [ n ] ;", "nl": "Driver code"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) a [ i ] = i + 1 ;", "nl": "storing numbers from 1 - N in array"}
{"code": "allCombination ( a , n ) ; } }", "nl": "calling allCombination"}
{"code": "class GFG {", "nl": "A DP based Java program to find maximum tasks ."}
{"code": "static int max ( int x , int y ) { return ( x > y ? x : y ) ; }", "nl": "Returns the maximum among the 2 numbers"}
{"code": "static int maxTasks ( int [ ] high , int [ ] low , int n ) {", "nl": "Returns maximum amount of task that can be done till day n"}
{"code": "int [ ] task_dp = new int [ n + 1 ] ;", "nl": "An array task_dp that stores the maximum task done"}
{"code": "task_dp [ 0 ] = 0 ;", "nl": "If n = 0 , no solution exists"}
{"code": "task_dp [ 1 ] = high [ 0 ] ;", "nl": "If n = 1 , high effort task on that day will be the solution"}
{"code": "for ( int i = 2 ; i <= n ; i ++ ) task_dp [ i ] = Math . max ( high [ i - 1 ] + task_dp [ i - 2 ] , low [ i - 1 ] + task_dp [ i - 1 ] ) ; return task_dp [ n ] ; }", "nl": "Fill the entire array determining which task to choose on day i"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; int [ ] high = { 3 , 6 , 8 , 7 , 6 } ; int [ ] low = { 1 , 5 , 4 , 5 , 3 } ; System . out . println ( maxTasks ( high , low , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static int PermutationCoeff ( int n , int k ) { int Fn = 1 , Fk = 1 ;", "nl": "A O ( n ) time and O ( 1 ) extra space solution to calculate the Permutation Coefficient"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) { Fn *= i ; if ( i == n - k ) Fk = Fn ; } int coeff = Fn / Fk ; return coeff ; }", "nl": "Compute n ! and ( n - k ) !"}
{"code": "public static void main ( String args [ ] ) { int n = 10 , k = 2 ; System . out . println ( \" Value \u2581 of \u2581 P ( \u2581 \" + n + \" , \" + k + \" ) \u2581 is \u2581 \" + PermutationCoeff ( n , k ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class Partition {", "nl": "A dynamic programming based Java program for partition problem"}
{"code": "static boolean findPartition ( int arr [ ] , int n ) { int sum = 0 ; int i , j ;", "nl": "Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false"}
{"code": "for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; boolean part [ ] [ ] = new boolean [ sum / 2 + 1 ] [ n + 1 ] ;", "nl": "Calculate sum of all elements"}
{"code": "for ( i = 0 ; i <= n ; i ++ ) part [ 0 ] [ i ] = true ;", "nl": "initialize top row as true"}
{"code": "for ( i = 1 ; i <= sum / 2 ; i ++ ) part [ i ] [ 0 ] = false ;", "nl": "initialize leftmost column , except part [ 0 ] [ 0 ] , as 0"}
{"code": "for ( i = 1 ; i <= sum / 2 ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { part [ i ] [ j ] = part [ i ] [ j - 1 ] ; if ( i >= arr [ j - 1 ] ) part [ i ] [ j ] = part [ i ] [ j ] || part [ i - arr [ j - 1 ] ] [ j - 1 ] ; } }", "nl": "Fill the partition table in bottom up manner"}
{"code": "return part [ sum / 2 ] [ n ] ; }", "nl": "uncomment this part to print table"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 3 , 1 , 1 , 2 , 2 , 1 } ; int n = arr . length ;", "nl": "Driver code"}
{"code": "if ( findPartition ( arr , n ) == true ) System . out . println ( \" Can \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 \" \" subsets \u2581 of \u2581 equal \u2581 sum \" ) ; else System . out . println ( \" Can \u2581 not \u2581 be \u2581 divided \u2581 into \" \" \u2581 two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ) ; } }", "nl": "Function call"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void minimumOperations ( String orig_str , int m , int n ) {", "nl": "Function to find the minimum operations required to get the given string after appending m or n characters from the end to the front of the string in each operation"}
{"code": "String orig = orig_str ;", "nl": "Store the original string"}
{"code": "int turn = 1 ; int j = 1 ;", "nl": "Stores the count of operations"}
{"code": "for ( int i = 0 ; i < orig_str . length ( ) ; i ++ ) {", "nl": "Traverse the string"}
{"code": "String m_cut = orig_str . substring ( orig_str . length ( ) - m ) ; orig_str = orig_str . substring ( 0 , orig_str . length ( ) - m ) ;", "nl": "Cut m letters from end"}
{"code": "orig_str = m_cut + orig_str ;", "nl": "Add cut m letters to beginning"}
{"code": "j = j + 1 ;", "nl": "Update j"}
{"code": "if ( ! orig . equals ( orig_str ) ) { turn = turn + 1 ;", "nl": "Check if strings are the same"}
{"code": "String n_cut = orig_str . substring ( orig_str . length ( ) - n ) ; orig_str = orig_str . substring ( 0 , orig_str . length ( ) - n ) ;", "nl": "Cut n letters from end"}
{"code": "orig_str = n_cut + orig_str ;", "nl": "Add cut n letters to beginning"}
{"code": "j = j + 1 ; }", "nl": "Update j"}
{"code": "if ( orig . equals ( orig_str ) ) { break ; }", "nl": "Check if strings are the same"}
{"code": "turn = turn + 1 ; } System . out . println ( turn ) ; }", "nl": "Update the turn"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "String S = \" GeeksforGeeks \" ; int X = 5 , Y = 3 ;", "nl": "Given string S"}
{"code": "minimumOperations ( S , X , Y ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static int KMPSearch ( char [ ] pat , char [ ] txt ) { int M = pat . length ; int N = txt . length ;", "nl": "Prints occurrences of txt [ ] in pat [ ]"}
{"code": "int lps [ ] = new int [ M ] ;", "nl": "Create lps [ ] that will hold the longest prefix suffix values for pattern"}
{"code": "computeLPSArray ( pat , M , lps ) ;", "nl": "Preprocess the pattern ( calculate lps [ ] array )"}
{"code": "int i = 0 ; int j = 0 ; while ( i < N ) { if ( pat [ j ] == txt [ i ] ) { j ++ ; i ++ ; } if ( j == M ) { return i - j + 1 ; }", "nl": "Index for txt [ ] , index for pat [ ]"}
{"code": "else if ( i < N && pat [ j ] != txt [ i ] ) {", "nl": "Mismatch after j matches"}
{"code": "if ( j != 0 ) j = lps [ j - 1 ] ; else i = i + 1 ; } } return 0 ; }", "nl": "Do not match lps [ 0. . lps [ j - 1 ] ] characters , they will match anyway"}
{"code": "static void computeLPSArray ( char [ ] pat , int M , int [ ] lps ) {", "nl": "Fills lps [ ] for given pattern pat [ 0. . M - 1 ]"}
{"code": "int len = 0 ;", "nl": "Length of the previous longest prefix suffix"}
{"code": "lps [ 0 ] = 0 ;", "nl": "lps [ 0 ] is always 0"}
{"code": "int i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; }", "nl": "The loop calculates lps [ i ] for i = 1 to M - 1"}
{"code": "else {", "nl": "( pat [ i ] != pat [ len ] )"}
{"code": "if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } }", "nl": "This is tricky . Consider the example . AAACAAAA and i = 7. The idea is similar to search step ."}
{"code": "static int countRotations ( String s ) {", "nl": "Returns count of rotations to get the same String back"}
{"code": "String s1 = s . substring ( 1 , s . length ( ) - 1 ) + s ;", "nl": "Form a String excluding the first character and concatenating the String at the end"}
{"code": "char [ ] pat = s . toCharArray ( ) ; char [ ] text = s1 . toCharArray ( ) ;", "nl": "Convert the String to character array"}
{"code": "return 1 + KMPSearch ( pat , text ) ; }", "nl": "Use the KMP search algorithm to find it in O ( N ) time"}
{"code": "public static void main ( String [ ] args ) { String s1 = \" geeks \" ; System . out . print ( countRotations ( s1 ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement DFS that accepts all string that do not end with \" THE \""}
{"code": "static int dfa = 0 ;", "nl": "dfa tells the number associated with the present state"}
{"code": "static void start ( char c ) {", "nl": "This function is for the starting state ( zeroth ) of DFA"}
{"code": "if ( c == ' t ' c == ' T ' ) dfa = 1 ; }", "nl": "On receiving ' T ' or ' t ' goto first state ( 1 )"}
{"code": "static void state1 ( char c ) {", "nl": "This function is for the first state of DFA"}
{"code": "if ( c == ' t ' c == ' T ' ) dfa = 1 ;", "nl": "On receiving ' T ' or ' t ' goto first state ( 1 )"}
{"code": "else if ( c == ' h ' c == ' H ' ) dfa = 2 ;", "nl": "On receiving ' H ' or ' h ' goto second state ( 2 )"}
{"code": "else dfa = 0 ; }", "nl": "else goto starting state ( 0 )"}
{"code": "static void state2 ( char c ) {", "nl": "This function is for the second state of DFA"}
{"code": "if ( c == ' e ' c == ' E ' ) dfa = 3 ; else dfa = 0 ; }", "nl": "On receiving ' E ' or ' e ' goto third state ( 3 ) else goto starting state ( 0 )"}
{"code": "static void state3 ( char c ) {", "nl": "This function is for the third state of DFA"}
{"code": "if ( c == ' t ' c == ' T ' ) dfa = 1 ; else dfa = 0 ; } static boolean isAccepted ( char str [ ] ) {", "nl": "On receiving ' T ' or ' t ' goto first state ( 1 ) else goto starting state ( 0 )"}
{"code": "int len = str . length ; for ( int i = 0 ; i < len ; i ++ ) { if ( dfa == 0 ) start ( str [ i ] ) ; else if ( dfa == 1 ) state1 ( str [ i ] ) ; else if ( dfa == 2 ) state2 ( str [ i ] ) ; else state3 ( str [ i ] ) ; } return ( dfa != 3 ) ; }", "nl": "store length of string"}
{"code": "public static void main ( String [ ] args ) { char str [ ] = \" forTHEgeeks \" . toCharArray ( ) ; if ( isAccepted ( str ) == true ) System . out . println ( \"ACCEPTEDNEW_LINE\"); else System . out . println ( \"NOT ACCEPTEDNEW_LINE\"); } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static int [ ] parent = new int [ 26 ] ;", "nl": "Java implementation of the above approach ."}
{"code": "static int find ( int x ) { if ( x != parent [ x ] ) return parent [ x ] = find ( parent [ x ] ) ; return x ; }", "nl": "Function for find from Disjoint set algorithm"}
{"code": "static void join ( int x , int y ) { int px = find ( x ) ; int pz = find ( y ) ; if ( px != pz ) { parent [ pz ] = px ; } }", "nl": "Function for the union from Disjoint set algorithm"}
{"code": "static boolean convertible ( String s1 , String s2 ) {", "nl": "Function to check if one String can be converted to another ."}
{"code": "HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( ! mp . containsKey ( s1 . charAt ( i ) - ' a ' ) ) { mp . put ( s1 . charAt ( i ) - ' a ' , s2 . charAt ( i ) - ' a ' ) ; } else { if ( mp . get ( s1 . charAt ( i ) - ' a ' ) != s2 . charAt ( i ) - ' a ' ) return false ; } }", "nl": "All the characters are checked whether it 's either not replaced or replaced  by a similar character using a map."}
{"code": "for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { if ( it . getKey ( ) == it . getValue ( ) ) continue ; else { if ( find ( it . getKey ( ) ) == find ( it . getValue ( ) ) ) return false ; else join ( it . getKey ( ) , it . getValue ( ) ) ; } } return true ; }", "nl": "To check if there are cycles . If yes , then they are not convertible . Else , they are convertible ."}
{"code": "static void initialize ( ) { for ( int i = 0 ; i < 26 ; i ++ ) { parent [ i ] = i ; } }", "nl": "Function to initialize parent array for union and find algorithm ."}
{"code": "public static void main ( String [ ] args ) { String s1 , s2 ; s1 = \" abbcaa \" ; s2 = \" bccdbb \" ; initialize ( ) ; if ( convertible ( s1 , s2 ) ) System . out . print ( \" Yes \" + \"NEW_LINE\"); else System . out . print ( \" No \" + \"NEW_LINE\"); } }", "nl": "Driver code"}
{"code": "class GFG { static int SIZE = 26 ;", "nl": "Java implementation of the approach"}
{"code": "static void SieveOfEratosthenes ( boolean [ ] prime , int p_size ) {", "nl": "Function to create Sieve to check primes"}
{"code": "prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) {", "nl": "false here indicates that it is not prime"}
{"code": "if ( prime [ p ] ) {", "nl": "If prime [ p ] is not changed , then it is a prime"}
{"code": "for ( int i = p * 2 ; i < p_size ; i += p ) prime [ i ] = false ; } } }", "nl": "Update all multiples of p , set them to non - prime"}
{"code": "static void printChar ( String str , int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ;", "nl": "Function to print the prime frequency characters in the order of their occurrence"}
{"code": "SieveOfEratosthenes ( prime , str . length ( ) + 1 ) ;", "nl": "Function to create Sieve to check primes"}
{"code": "int [ ] freq = new int [ SIZE ] ;", "nl": "To store the frequency of each of the character of the string"}
{"code": "for ( int i = 0 ; i < SIZE ; i ++ ) freq [ i ] = 0 ;", "nl": "Initialize all elements of freq [ ] to 0"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ;", "nl": "Update the frequency of each character"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse str character by character"}
{"code": "if ( prime [ freq [ str . charAt ( i ) - ' a ' ] ] ) { System . out . print ( str . charAt ( i ) ) ; } } }", "nl": "If frequency of current character is prime"}
{"code": "public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; int n = str . length ( ) ; printChar ( str , n ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java code for the above approach"}
{"code": "static boolean prime ( int n ) { if ( n <= 1 ) return false ; int max_div = ( int ) Math . floor ( Math . sqrt ( n ) ) ; for ( int i = 2 ; i < 1 + max_div ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static void checkString ( String s ) {", "nl": "Function to check primes"}
{"code": "Map < Character , Integer > freq = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! freq . containsKey ( s . charAt ( i ) ) ) freq . put ( s . charAt ( i ) , 0 ) ; freq . put ( s . charAt ( i ) , freq . get ( s . charAt ( i ) ) + 1 ) ; }", "nl": "Counting the frequency of all character using Counter function"}
{"code": "for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( prime ( freq . get ( s . charAt ( i ) ) ) ) System . out . print ( s . charAt ( i ) ) ; } }", "nl": "Traversing string"}
{"code": "public static void main ( String [ ] args ) { String s = \" geeksforgeeks \" ;", "nl": "Driver code"}
{"code": "checkString ( s ) ; } }", "nl": "Passing string to checkString function"}
{"code": "import java . util . * ; class GFG { static int SIZE = 26 ;", "nl": "Java implementation of the approach"}
{"code": "static void printChar ( String str , int n ) {", "nl": "Function to print the even frequency characters in the order of their occurrence"}
{"code": "int [ ] freq = new int [ SIZE ] ;", "nl": "To store the frequency of each of the character of the string"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ;", "nl": "Update the frequency of each character"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse str character by character"}
{"code": "if ( freq [ str . charAt ( i ) - ' a ' ] % 2 == 0 ) { System . out . print ( str . charAt ( i ) ) ; } } }", "nl": "If frequency of current character is even"}
{"code": "public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; int n = str . length ( ) ; printChar ( str , n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static boolean CompareAlphanumeric ( char [ ] str1 , char [ ] str2 ) {", "nl": "Function to check alphanumeric equality of both strings"}
{"code": "int i , j ; i = 0 ; j = 0 ;", "nl": "variable declaration"}
{"code": "int len1 = str1 . length ;", "nl": "Length of first string"}
{"code": "int len2 = str2 . length ;", "nl": "Length of second string"}
{"code": "while ( i <= len1 && j <= len2 ) {", "nl": "To check each and every characters of both string"}
{"code": "while ( i < len1 && ( ! ( ( str1 [ i ] >= ' a ' && str1 [ i ] <= ' z ' ) || ( str1 [ i ] >= ' A ' && str1 [ i ] <= ' Z ' ) || ( str1 [ i ] >= '0' && str1 [ i ] <= '9' ) ) ) ) { i ++ ; }", "nl": "If the current character of the first string is not an alphanumeric character , increase the pointer i"}
{"code": "while ( j < len2 && ( ! ( ( str2 [ j ] >= ' a ' && str2 [ j ] <= ' z ' ) || ( str2 [ j ] >= ' A ' && str2 [ j ] <= ' Z ' ) || ( str2 [ j ] >= '0' && str2 [ j ] <= '9' ) ) ) ) { j ++ ; }", "nl": "If the current character of the second string is not an alphanumeric character , increase the pointer j"}
{"code": "if ( i == len1 && j == len2 ) { return true ; }", "nl": "if all alphanumeric characters of both strings are same then return true"}
{"code": "else if ( str1 [ i ] != str2 [ j ] ) { return false ; }", "nl": "if any alphanumeric characters of both strings are not same then return false"}
{"code": "else { i ++ ; j ++ ; } }", "nl": "If current character matched , increase both pointers to check the next character"}
{"code": "return false ; }", "nl": "If not same , then return false"}
{"code": "static void CompareAlphanumericUtil ( String str1 , String str2 ) { boolean res ;", "nl": "Function to print Equal or Unequal if strings are same or not"}
{"code": "res = CompareAlphanumeric ( str1 . toCharArray ( ) , str2 . toCharArray ( ) ) ;", "nl": "check alphanumeric equality of both strings"}
{"code": "if ( res == true ) { System . out . println ( \" Equal \" ) ; }", "nl": "if both are alphanumeric equal , print Equal"}
{"code": "else { System . out . println ( \" Unequal \" ) ; } }", "nl": "otherwise print Unequal"}
{"code": "public static void main ( String [ ] args ) { String str1 , str2 ; str1 = \" Ram , \u2581 Shyam \" ; str2 = \" \u2581 Ram \u2581 - \u2581 Shyam . \" ; CompareAlphanumericUtil ( str1 , str2 ) ; str1 = \" abc123\" ; str2 = \"123abc \" ; CompareAlphanumericUtil ( str1 , str2 ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find the sum of the addition of all possible subsets ."}
{"code": "static void solveQueries ( String str , int [ ] [ ] query ) {", "nl": "Function that answers all the queries"}
{"code": "int len = str . length ( ) ;", "nl": "Length of the string"}
{"code": "int Q = query . length ;", "nl": "Number of queries"}
{"code": "int [ ] [ ] pre = new int [ len ] [ 26 ] ;", "nl": "Prefix array"}
{"code": "for ( int i = 0 ; i < len ; i ++ ) {", "nl": "Iterate for all the characters"}
{"code": "pre [ i ] [ str . charAt ( i ) - ' a ' ] ++ ;", "nl": "Increase the count of the character"}
{"code": "if ( i > 0 ) {", "nl": "Presum array for all 26 characters"}
{"code": "for ( int j = 0 ; j < 26 ; j ++ ) pre [ i ] [ j ] += pre [ i - 1 ] [ j ] ; } }", "nl": "Update the prefix array"}
{"code": "for ( int i = 0 ; i < Q ; i ++ ) {", "nl": "Answer every query"}
{"code": "int l = query [ i ] [ 0 ] ; int r = query [ i ] [ 1 ] ; int maxi = 0 ; char c = ' a ' ;", "nl": "Range"}
{"code": "for ( int j = 0 ; j < 26 ; j ++ ) {", "nl": "Iterate for all characters"}
{"code": "int times = pre [ r ] [ j ] ;", "nl": "Times the lowercase character j occurs till r - th index"}
{"code": "if ( l > 0 ) times -= pre [ l - 1 ] [ j ] ;", "nl": "Subtract the times it occurred till ( l - 1 ) th index"}
{"code": "if ( times > maxi ) { maxi = times ; c = ( char ) ( ' a ' + j ) ; } }", "nl": "Max times it occurs"}
{"code": "System . out . println ( \" Query \" + ( i + 1 ) + \" : \u2581 \" + c ) ; } }", "nl": "Print the answer"}
{"code": "public static void main ( String [ ] args ) { String str = \" striver \" ; int [ ] [ ] query = { { 0 , 1 } , { 1 , 6 } , { 5 , 6 } } ; solveQueries ( str , query ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static boolean startsWith ( String str , String pre ) { int strLen = str . length ( ) ; int preLen = pre . length ( ) ; int i = 0 , j = 0 ;", "nl": "Function that return true if pre is a prefix of str"}
{"code": "while ( i < strLen && j < preLen ) {", "nl": "While there are characters to match"}
{"code": "if ( str . charAt ( i ) != pre . charAt ( j ) ) return false ; i ++ ; j ++ ; }", "nl": "If characters differ at any position"}
{"code": "return true ; }", "nl": "str starts with pre"}
{"code": "static boolean endsWith ( String str , String suff ) { int i = str . length ( ) - 1 ; int j = suff . length ( ) - 1 ;", "nl": "Function that return true if suff is a suffix of str"}
{"code": "while ( i >= 0 && j >= 0 ) {", "nl": "While there are characters to match"}
{"code": "if ( str . charAt ( i ) != suff . charAt ( j ) ) return false ; i -- ; j -- ; }", "nl": "If characters differ at any position"}
{"code": "return true ; }", "nl": "str ends with suff"}
{"code": "static boolean checkString ( String str , String a , String b ) {", "nl": "Function that returns true if str = a + b or str = b + a"}
{"code": "if ( str . length ( ) != a . length ( ) + b . length ( ) ) return false ;", "nl": "str cannot be generated by concatenating a and b"}
{"code": "if ( startsWith ( str , a ) ) {", "nl": "If str starts with a i . e . a is a prefix of str"}
{"code": "if ( endsWith ( str , b ) ) return true ; }", "nl": "Check if the rest of the characters are equal to b i . e . b is a suffix of str"}
{"code": "if ( startsWith ( str , b ) ) {", "nl": "If str starts with b i . e . b is a prefix of str"}
{"code": "if ( endsWith ( str , a ) ) return true ; } return false ; }", "nl": "Check if the rest of the characters are equal to a i . e . a is a suffix of str"}
{"code": "public static void main ( String args [ ] ) { String str = \" GeeksforGeeks \" ; String a = \" Geeksfo \" ; String b = \" rGeeks \" ; if ( checkString ( str , a , b ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "public static void printChar ( String str , int n ) {", "nl": "Function to print the odd frequency characters in the order of their occurrence"}
{"code": "int [ ] freq = new int [ 26 ] ;", "nl": "To store the frequency of each of the character of the string"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ;", "nl": "Update the frequency of each character"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse str character by character"}
{"code": "if ( freq [ str . charAt ( i ) - ' a ' ] % 2 == 1 ) { System . out . print ( str . charAt ( i ) ) ; } } }", "nl": "If frequency of current character is odd"}
{"code": "public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; int n = str . length ( ) ; printChar ( str , n ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int minOperations ( String str , int n ) {", "nl": "Function to return the minimum number of operations required"}
{"code": "int i , lastUpper = - 1 , firstLower = - 1 ;", "nl": "To store the indices of the last uppercase and the first lowercase character"}
{"code": "for ( i = n - 1 ; i >= 0 ; i -- ) { if ( Character . isUpperCase ( str . charAt ( i ) ) ) { lastUpper = i ; break ; } }", "nl": "Find the last uppercase character"}
{"code": "for ( i = 0 ; i < n ; i ++ ) { if ( Character . isLowerCase ( str . charAt ( i ) ) ) { firstLower = i ; break ; } }", "nl": "Find the first lowercase character"}
{"code": "if ( lastUpper == - 1 firstLower == - 1 ) return 0 ;", "nl": "If all the characters are either uppercase or lowercase"}
{"code": "int countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( Character . isUpperCase ( str . charAt ( i ) ) ) { countUpper ++ ; } }", "nl": "Count of uppercase characters that appear after the first lowercase character"}
{"code": "int countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( Character . isLowerCase ( str . charAt ( i ) ) ) { countLower ++ ; } }", "nl": "Count of lowercase characters that appear before the last uppercase character"}
{"code": "return Math . min ( countLower , countUpper ) ; }", "nl": "Return the minimum operations required"}
{"code": "public static void main ( String args [ ] ) { String str = \" geEksFOrGEekS \" ; int n = str . length ( ) ; System . out . println ( minOperations ( str , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find the sum of the all betrothed numbers up to N"}
{"code": "public static int Betrothed_Sum ( int n ) {", "nl": "Function to find the sum of the all betrothed numbers"}
{"code": "Vector < Integer > Set = new Vector < Integer > ( ) ; for ( int number_1 = 1 ; number_1 < n ; number_1 ++ ) {", "nl": "To store the betrothed numbers"}
{"code": "int sum_divisor_1 = 1 ;", "nl": "Calculate sum of number_1 's divisors   1 is always a divisor"}
{"code": "int i = 2 ; while ( i * i <= number_1 ) { if ( number_1 % i == 0 ) { sum_divisor_1 = sum_divisor_1 + i ; if ( i * i != number_1 ) sum_divisor_1 += number_1 / i ; } i ++ ; } if ( sum_divisor_1 > number_1 ) { int number_2 = sum_divisor_1 - 1 ; int sum_divisor_2 = 1 ; int j = 2 ; while ( j * j <= number_2 ) { if ( number_2 % j == 0 ) { sum_divisor_2 += j ; if ( j * j != number_2 ) sum_divisor_2 += number_2 / j ; } j = j + 1 ; } if ( sum_divisor_2 == number_1 + 1 && number_1 <= n && number_2 <= n ) { Set . add ( number_1 ) ; Set . add ( number_2 ) ; } } }", "nl": "i = 2 because we don 't   want to include   1 as a divisor."}
{"code": "int Summ = 0 ; for ( int i = 0 ; i < Set . size ( ) ; i ++ ) { if ( Set . get ( i ) <= n ) Summ += Set . get ( i ) ; } return Summ ; }", "nl": "Sum all betrothed numbers up to N"}
{"code": "public static void main ( String [ ] args ) { int n = 78 ; System . out . println ( Betrothed_Sum ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java code to find the probability of rain on n + 1 - th day when previous day 's data is given"}
{"code": "static float rainDayProbability ( int a [ ] , int n ) { float count = 0 , m ;", "nl": "Function to find the probability"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; }", "nl": "count 1"}
{"code": "m = count / n ; return m ; }", "nl": "find probability"}
{"code": "public static void main ( String args [ ] ) { int a [ ] = { 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 } ; int n = a . length ; System . out . print ( rainDayProbability ( a , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class Maths {", "nl": "Java program to calculate the following series"}
{"code": "static double Series ( int n ) { int i ; double sums = 0.0 , ser ; for ( i = 1 ; i <= n ; ++ i ) { ser = 1 / Math . pow ( i , i ) ; sums += ser ; } return sums ; }", "nl": "Function to calculate the following series"}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; double res = Series ( n ) ; res = Math . round ( res * 100000.0 ) / 100000.0 ; System . out . println ( res ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; public class Main {", "nl": "Java program for the above approach"}
{"code": "static String lexicographicallyMaximum ( String S , int N ) {", "nl": "Function to print the lexicographically the largest string obtained in process of obtaining a string containing first N lower case english alphabtes"}
{"code": "HashMap < Character , Integer > M = new HashMap < > ( ) ;", "nl": "Store the frequency of each character"}
{"code": "for ( int i = 0 ; i < N ; ++ i ) { if ( M . containsKey ( S . charAt ( i ) ) ) M . put ( S . charAt ( i ) , M . get ( S . charAt ( i ) ) + 1 ) ; else M . put ( S . charAt ( i ) , 1 ) ; }", "nl": "Traverse the string S"}
{"code": "Vector < Character > V = new Vector < Character > ( ) ; for ( char i = ' a ' ; i < ( char ) ( ' a ' + Math . min ( N , 25 ) ) ; ++ i ) { if ( M . containsKey ( i ) == false ) { V . add ( i ) ; } }", "nl": "Stores the characters which are not appearing in S"}
{"code": "int j = V . size ( ) - 1 ;", "nl": "Stores the index of the largest character in the array V , that need to be replaced"}
{"code": "for ( int i = 0 ; i < N ; ++ i ) {", "nl": "Traverse the string , S"}
{"code": "if ( S . charAt ( i ) >= ( ' a ' + Math . min ( N , 25 ) ) || ( M . containsKey ( S . charAt ( i ) ) && M . get ( S . charAt ( i ) ) > 1 ) ) { if ( V . get ( j ) < S . charAt ( i ) ) continue ;", "nl": "If frequency of S [ i ] is greater than 1 or it is outside the range"}
{"code": "M . put ( S . charAt ( i ) , M . get ( S . charAt ( i ) ) - 1 ) ;", "nl": "Decrement its frequency by 1"}
{"code": "S = S . substring ( 0 , i ) + V . get ( j ) + S . substring ( i + 1 ) ;", "nl": "Update S [ i ]"}
{"code": "j -- ; } if ( j < 0 ) break ; } int l = 0 ;", "nl": "Decrement j by 1"}
{"code": "for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( l > j ) break ; if ( S . charAt ( i ) >= ( ' a ' + Math . min ( N , 25 ) ) || M . containsKey ( S . charAt ( i ) ) && M . get ( S . charAt ( i ) ) > 1 ) {", "nl": "Traverse the string , S"}
{"code": "M . put ( S . charAt ( i ) , M . get ( S . charAt ( i ) ) - 1 ) ;", "nl": "Decrement its frequency by 1"}
{"code": "S = S . substring ( 0 , i ) + V . get ( l ) + S . substring ( i + 1 ) ;", "nl": "Update S [ i ]"}
{"code": "l ++ ; } }", "nl": "Increment l by 1"}
{"code": "return S ; }", "nl": "Return S"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "String S = \" abccefghh \" ; int N = S . length ( ) ;", "nl": "Given Input"}
{"code": "System . out . println ( lexicographicallyMaximum ( S , N ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static boolean isConsistingSubarrayUtil ( int arr [ ] , int n ) {", "nl": "A Utility Function to check if a subarray can be palindromic by replacing less than half of the elements present in it"}
{"code": "TreeMap < Integer , Integer > mp = new TreeMap < Integer , Integer > ( ) ;", "nl": "Stores frequency of array elements"}
{"code": "for ( int i = 0 ; i < n ; ++ i ) {", "nl": "Traverse the array"}
{"code": "mp . put ( arr [ i ] , mp . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; }", "nl": "Update frequency of each array element"}
{"code": "for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) {", "nl": "Iterator over the Map"}
{"code": "if ( it . getValue ( ) > 1 ) { return true ; } }", "nl": "If frequency of any element exceeds 1"}
{"code": "return false ; }", "nl": "If no repetition is found"}
{"code": "static void isConsistingSubarray ( int arr [ ] , int N ) { if ( isConsistingSubarrayUtil ( arr , N ) ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } }", "nl": "Function to check and print if any subarray can be made palindromic by replacing less than half of its elements"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 1 } ;", "nl": "Given array arr [ ]"}
{"code": "int N = arr . length ;", "nl": "Size of array"}
{"code": "isConsistingSubarray ( arr , N ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG { static boolean [ ] isPrime ;", "nl": "Java program to implement the above approach"}
{"code": "static HashSet < Integer > createhashmap ( int Max ) {", "nl": "Function to find all Fibonacci numbers up to Max"}
{"code": "HashSet < Integer > hashmap = new HashSet < > ( ) ;", "nl": "Store all Fibonacci numbers upto Max"}
{"code": "int curr = 1 ;", "nl": "Stores previous element of Fibonacci sequence"}
{"code": "int prev = 0 ;", "nl": "Stores previous element of Fibonacci sequence"}
{"code": "hashmap . add ( prev ) ;", "nl": "Insert prev into hashmap"}
{"code": "while ( curr < Max ) {", "nl": "Insert all the Fibonacci numbers up to Max"}
{"code": "hashmap . add ( curr ) ;", "nl": "Insert curr into hashmap"}
{"code": "int temp = curr ;", "nl": "Stores curr into temp"}
{"code": "curr = curr + prev ;", "nl": "Update curr"}
{"code": "prev = temp ; } return hashmap ; }", "nl": "Update prev"}
{"code": "static void SieveOfEratosthenes ( int Max ) {", "nl": "Function to find all Composite numbers up to Max"}
{"code": "isPrime = new boolean [ Max ] ; Arrays . fill ( isPrime , true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ;", "nl": "isPrime [ i ] : Stores if i is a prime number or not"}
{"code": "for ( int p = 2 ; p * p <= Max ; p ++ ) {", "nl": "Calculate all prime numbers up to Max using Sieve of Eratosthenes"}
{"code": "if ( isPrime [ p ] ) {", "nl": "If P is a prime number"}
{"code": "for ( int i = p * p ; i <= Max ; i += p ) {", "nl": "Set all multiple of P as non - prime"}
{"code": "isPrime [ i ] = false ; } } } }", "nl": "Update isPrime"}
{"code": "static void cntFibonacciPrime ( int arr [ ] , int N ) {", "nl": "Function to find the numbers which is both a composite and Fibonacci number"}
{"code": "int Max = arr [ 0 ] ;", "nl": "Stores the largest element of the array"}
{"code": "for ( int i = 1 ; i < N ; i ++ ) {", "nl": "Traverse the array arr [ ]"}
{"code": "Max = Math . max ( Max , arr [ i ] ) ; }", "nl": "Update Max"}
{"code": "SieveOfEratosthenes ( Max ) ;", "nl": "isPrim [ i ] check i is a prime number or not"}
{"code": "HashSet < Integer > hashmap = createhashmap ( Max ) ;", "nl": "Stores all the Fibonacci numbers"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array arr [ ]"}
{"code": "if ( arr [ i ] == 1 ) continue ;", "nl": "current element is not a composite number"}
{"code": "if ( ( hashmap . contains ( arr [ i ] ) ) && ! isPrime [ arr [ i ] ] ) {", "nl": "If current element is a Fibonacci and composite number"}
{"code": "System . out . print ( arr [ i ] + \" \u2581 \" ) ; } } }", "nl": "Print current element"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 13 , 55 , 7 , 3 , 5 , 21 , 233 , 144 , 89 } ; int N = arr . length ; cntFibonacciPrime ( arr , N ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; import java . util . * ; import java . lang . * ; public class Main {", "nl": "Java program of the above approach"}
{"code": "static int key ( int N ) {", "nl": "Function to find the key of the given number"}
{"code": "String num = \" \" + N ; int ans = 0 ; int j = 0 ;", "nl": "Convert the integer to String"}
{"code": "for ( j = 0 ; j < num . length ( ) ; j ++ ) {", "nl": "Iterate the num - string to get the result"}
{"code": "if ( ( num . charAt ( j ) - 48 ) % 2 == 0 ) { int add = 0 ; int i ;", "nl": "Check if digit is even or odd"}
{"code": "for ( i = j ; j < num . length ( ) ; j ++ ) { add += num . charAt ( j ) - 48 ;", "nl": "Iterate until odd sum is obtained by adding consecutive digits"}
{"code": "if ( add % 2 == 1 ) break ; } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) Math . floor ( Math . log10 ( add ) + 1 ) ; ans *= ( Math . pow ( 10 , digit ) ) ;", "nl": "Check if sum becomes odd"}
{"code": "ans += add ; }", "nl": "Add the result in ans"}
{"code": "i = j ; } else {", "nl": "Assign the digit index to num string"}
{"code": "int add = 0 ; int i ;", "nl": "If the number is odd"}
{"code": "for ( i = j ; j < num . length ( ) ; j ++ ) { add += num . charAt ( j ) - 48 ;", "nl": "Iterate until odd sum is obtained by adding consecutive digits"}
{"code": "if ( add % 2 == 0 ) { break ; } } if ( add == 0 ) { ans *= 10 ; } else { int digit = ( int ) Math . floor ( Math . log10 ( add ) + 1 ) ; ans *= ( Math . pow ( 10 , digit ) ) ;", "nl": "Check if sum becomes even"}
{"code": "ans += add ; }", "nl": "Add the result in ans"}
{"code": "i = j ; } }", "nl": "assign the digit index to main numstring"}
{"code": "if ( j + 1 >= num . length ( ) ) { return ans ; } else { return ans += num . charAt ( num . length ( ) - 1 ) - 48 ; } }", "nl": "Check if all digits are visited or not"}
{"code": "public static void main ( String [ ] args ) { int N = 1667848271 ; System . out . print ( key ( N ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void sentinelSearch ( int arr [ ] , int n , int key ) {", "nl": "Function to search x in the given array"}
{"code": "int last = arr [ n - 1 ] ;", "nl": "Last element of the array"}
{"code": "arr [ n - 1 ] = key ; int i = 0 ; while ( arr [ i ] != key ) i ++ ;", "nl": "Element to be searched is placed at the last index"}
{"code": "arr [ n - 1 ] = last ; if ( ( i < n - 1 ) || ( arr [ n - 1 ] == key ) ) System . out . println ( key + \" \u2581 is \u2581 present \u2581 at \u2581 index \u2581 \" + i ) ; else System . out . println ( \" Element \u2581 Not \u2581 found \" ) ; }", "nl": "Put the last element back"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 10 , 20 , 180 , 30 , 60 , 50 , 110 , 100 , 70 } ; int n = arr . length ; int key = 180 ; sentinelSearch ( arr , n , key ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int maximum_middle_value ( int n , int k , int arr [ ] ) {", "nl": "Function to calculate maximum possible middle value of the array after deleting exactly k elements"}
{"code": "int ans = - 1 ;", "nl": "Initialize answer as - 1"}
{"code": "int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ;", "nl": "Calculate range of elements that can give maximum possible middle value of the array since index of maximum possible middle value after deleting exactly k elements from array will lie in between low and high"}
{"code": "for ( int i = low ; i <= high ; i ++ ) {", "nl": "Find maximum element of the array in range low and high"}
{"code": "ans = Math . max ( ans , arr [ i - 1 ] ) ; }", "nl": "since indexing is 1 based so check element at index i - 1"}
{"code": "return ans ; }", "nl": "Return the maximum possible middle value of the array after deleting exactly k elements from the array"}
{"code": "public static void main ( String args [ ] ) { int n = 5 , k = 2 ; int arr [ ] = { 9 , 5 , 3 , 7 , 10 } ; System . out . println ( maximum_middle_value ( n , k , arr ) ) ; n = 9 ; k = 3 ; int arr1 [ ] = { 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 } ; System . out . println ( maximum_middle_value ( n , k , arr1 ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to illustrate recursive approach to ternary search"}
{"code": "static int ternarySearch ( int l , int r , int key , int ar [ ] ) { if ( r >= l ) {", "nl": "Function to perform Ternary Search"}
{"code": "int mid1 = l + ( r - l ) / 3 ; int mid2 = r - ( r - l ) / 3 ;", "nl": "Find the mid1 and mid2"}
{"code": "if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; }", "nl": "Check if key is present at any mid"}
{"code": "if ( key < ar [ mid1 ] ) {", "nl": "Since key is not present at mid , check in which region it is present then repeat the Search operation in that region"}
{"code": "return ternarySearch ( l , mid1 - 1 , key , ar ) ; } else if ( key > ar [ mid2 ] ) {", "nl": "The key lies in between l and mid1"}
{"code": "return ternarySearch ( mid2 + 1 , r , key , ar ) ; } else {", "nl": "The key lies in between mid2 and r"}
{"code": "return ternarySearch ( mid1 + 1 , mid2 - 1 , key , ar ) ; } }", "nl": "The key lies in between mid1 and mid2"}
{"code": "return - 1 ; }", "nl": "Key not found"}
{"code": "public static void main ( String args [ ] ) { int l , r , p , key ;", "nl": "Driver code"}
{"code": "int ar [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ;", "nl": "Get the array Sort the array if not sorted"}
{"code": "l = 0 ;", "nl": "Starting index"}
{"code": "r = 9 ;", "nl": "length of array"}
{"code": "key = 5 ;", "nl": "Key to be searched in the array"}
{"code": "p = ternarySearch ( l , r , key , ar ) ;", "nl": "Search the key using ternarySearch"}
{"code": "System . out . println ( \" Index \u2581 of \u2581 \" + key + \" \u2581 is \u2581 \" + p ) ;", "nl": "Print the result"}
{"code": "key = 50 ;", "nl": "Key to be searched in the array"}
{"code": "p = ternarySearch ( l , r , key , ar ) ;", "nl": "Search the key using ternarySearch"}
{"code": "System . out . println ( \" Index \u2581 of \u2581 \" + key + \" \u2581 is \u2581 \" + p ) ; } }", "nl": "Print the result"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find minimum points to be moved so that all points are on same side ."}
{"code": "static class Point { int x , y ; public Point ( int x , int y ) { this . x = x ; this . y = y ; } } ;", "nl": "Structure to store the coordinates of a point ."}
{"code": "static int findmin ( Point p [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Function to find the minimum number of points"}
{"code": "if ( p [ i ] . x <= 0 ) a ++ ;", "nl": "Number of points on the left of Y - axis ."}
{"code": "else if ( p [ i ] . x >= 0 ) b ++ ;", "nl": "Number of points on the right of Y - axis ."}
{"code": "if ( p [ i ] . y >= 0 ) c ++ ;", "nl": "Number of points above X - axis ."}
{"code": "else if ( p [ i ] . y <= 0 ) d ++ ; } return Math . min ( Math . min ( a , b ) , Math . min ( c , d ) ) ; }", "nl": "Number of points below X - axis ."}
{"code": "public static void main ( String [ ] args ) { Point p [ ] = { new Point ( 1 , 1 ) , new Point ( 2 , 2 ) , new Point ( - 1 , - 1 ) , new Point ( - 2 , 2 ) } ; int n = p . length ; System . out . println ( findmin ( p , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void maxOps ( int a , int b , int c ) {", "nl": "Function to count the maximum number of pair reductions possible on a given triplet"}
{"code": "int arr [ ] = { a , b , c } ;", "nl": "Convert them into an array"}
{"code": "int count = 0 ; while ( 1 != 0 ) {", "nl": "Stores count of operations"}
{"code": "Arrays . sort ( arr ) ;", "nl": "Sort the array"}
{"code": "if ( arr [ 0 ] == 0 && arr [ 1 ] == 0 ) break ;", "nl": "If the first two array elements reduce to 0"}
{"code": "arr [ 1 ] -= 1 ; arr [ 2 ] -= 1 ;", "nl": "Apply the operations"}
{"code": "count += 1 ; }", "nl": "Increment count"}
{"code": "System . out . print ( count ) ; }", "nl": "Print the maximum count"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int a = 4 , b = 3 , c = 2 ; maxOps ( a , b , c ) ; } }", "nl": "Given triplet"}
{"code": "import java . lang . Character ; class GFG { static int MAX = 26 ; public static String getSortedString ( StringBuilder s , int n ) {", "nl": "Java implementation of the approach"}
{"code": "int [ ] lower = new int [ MAX ] ; int [ ] upper = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "To store the frequencies of the lowercase and the uppercase characters in the given string"}
{"code": "if ( Character . isLowerCase ( s . charAt ( i ) ) ) lower [ s . charAt ( i ) - ' a ' ] ++ ;", "nl": "If current character is lowercase then increment its frequency in the lower [ ] array"}
{"code": "else if ( Character . isUpperCase ( s . charAt ( i ) ) ) upper [ s . charAt ( i ) - ' A ' ] ++ ; }", "nl": "Else increment in the upper [ ] array"}
{"code": "int i = 0 , j = 0 ; while ( i < MAX && lower [ i ] == 0 ) i ++ ; while ( j < MAX && upper [ j ] == 0 ) j ++ ;", "nl": "Pointers that point to the smallest lowercase and the smallest uppercase characters respectively in the given string"}
{"code": "for ( int k = 0 ; k < n ; k ++ ) {", "nl": "For every character in the given string"}
{"code": "if ( Character . isLowerCase ( s . charAt ( k ) ) ) { while ( lower [ i ] == 0 ) i ++ ; s . setCharAt ( k , ( char ) ( i + ' a ' ) ) ;", "nl": "If the current character is lowercase then replace it with the smallest lowercase character available"}
{"code": "lower [ i ] -- ; }", "nl": "Decrement the frequency of the used character"}
{"code": "else if ( Character . isUpperCase ( s . charAt ( k ) ) ) { while ( upper [ j ] == 0 ) j ++ ; s . setCharAt ( k , ( char ) ( j + ' A ' ) ) ;", "nl": "Else replace it with the smallest uppercase character available"}
{"code": "upper [ j ] -- ; } }", "nl": "Decrement the frequency of the used character"}
{"code": "return s . toString ( ) ; }", "nl": "Return the sorted string"}
{"code": "public static void main ( String [ ] args ) { StringBuilder s = new StringBuilder ( \" gEeksfOrgEEkS \" ) ; int n = s . length ( ) ; System . out . println ( getSortedString ( s , n ) ) ; } }", "nl": "Driver code"}
{"code": "public class Char_frequency { static final int SIZE = 26 ;", "nl": "Java implementation to print the character and its frequency in order of its occurrence"}
{"code": "static void printCharWithFreq ( String str ) {", "nl": "function to print the character and its frequency in order of its occurrence"}
{"code": "int n = str . length ( ) ;", "nl": "size of the string ' str '"}
{"code": "int [ ] freq = new int [ SIZE ] ;", "nl": "' freq [ ] ' implemented as hash table"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ;", "nl": "accumulate frequency of each character in ' str '"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "traverse ' str ' from left to right"}
{"code": "if ( freq [ str . charAt ( i ) - ' a ' ] != 0 ) {", "nl": "if frequency of character str . charAt ( i ) is not equal to 0"}
{"code": "System . out . print ( str . charAt ( i ) ) ; System . out . print ( freq [ str . charAt ( i ) - ' a ' ] + \" \u2581 \" ) ;", "nl": "print the character along with its frequency"}
{"code": "freq [ str . charAt ( i ) - ' a ' ] = 0 ; } } }", "nl": "update frequency of str . charAt ( i ) to 0 so that the same character is not printed again"}
{"code": "public static void main ( String args [ ] ) { String str = \" geeksforgeeks \" ; printCharWithFreq ( str ) ; } }", "nl": "Driver program to test above"}
{"code": "public class ReverseWords { public static void main ( String [ ] args ) { String s [ ] = \" i \u2581 like \u2581 this \u2581 program \u2581 very \u2581 much \" . split ( \" \u2581 \" ) ; String ans = \" \" ; for ( int i = s . length - 1 ; i >= 0 ; i -- ) { ans += s [ i ] + \" \u2581 \" ; } System . out . println ( \" Reversed \u2581 String : \" ) ; System . out . println ( ans . substring ( 0 , ans . length ( ) - 1 ) ) ; } }", "nl": "Java program to reverse a string s = input ( )"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static void SieveOfEratosthenes ( boolean [ ] prime , int n ) { for ( int p = 2 ; p * p <= n ; p ++ ) {", "nl": "Function to generate prime numbers using Sieve of Eratosthenes"}
{"code": "if ( prime [ p ] == true ) {", "nl": "If prime [ p ] is unchanged , then it is a prime"}
{"code": "for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } }", "nl": "Update all multiples of p"}
{"code": "public static void segregatePrimeNonPrime ( boolean [ ] prime , int arr [ ] , int N ) {", "nl": "Function to segregate the primes and non - primes"}
{"code": "SieveOfEratosthenes ( prime , 10000000 ) ;", "nl": "Generate all primes till 10 ^"}
{"code": "int left = 0 , right = N - 1 ;", "nl": "Initialize left and right"}
{"code": "while ( left < right ) {", "nl": "Traverse the array"}
{"code": "while ( prime [ arr [ left ] ] ) left ++ ;", "nl": "Increment left while array element at left is prime"}
{"code": "while ( ! prime [ arr [ right ] ] ) right -- ;", "nl": "Decrement right while array element at right is non - prime"}
{"code": "if ( left < right ) {", "nl": "If left < right , then swap arr [ left ] and arr [ right ]"}
{"code": "int temp = arr [ left ] ; arr [ left ] = arr [ right ] ; arr [ right ] = temp ; left ++ ; right -- ; } }", "nl": "Swap arr [ left ] and arr [ right ]"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) System . out . printf ( arr [ i ] + \" \u2581 \" ) ; }", "nl": "Print segregated array"}
{"code": "public static void main ( String [ ] args ) { boolean [ ] prime = new boolean [ 10000001 ] ; Arrays . fill ( prime , true ) ; int arr [ ] = { 2 , 3 , 4 , 6 , 7 , 8 , 9 , 10 } ; int N = arr . length ;", "nl": "Driver code"}
{"code": "segregatePrimeNonPrime ( prime , arr , N ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find height of full binary tree using preorder"}
{"code": "static int findDepthRec ( String tree , int n , int index ) { if ( index >= n || tree . charAt ( index ) == ' l ' ) return 0 ;", "nl": "function to return max of left subtree height or right subtree height"}
{"code": "index ++ ; int left = findDepthRec ( tree , n , index ) ;", "nl": "calc height of left subtree ( In preorder left subtree is processed before right )"}
{"code": "index ++ ; int right = findDepthRec ( tree , n , index ) ; return Math . max ( left , right ) + 1 ; }", "nl": "calc height of right subtree"}
{"code": "static int findDepth ( String tree , int n ) { int index = 0 ; return ( findDepthRec ( tree , n , index ) ) ; }", "nl": "Wrapper over findDepthRec ( )"}
{"code": "static public void main ( String [ ] args ) { String tree = \" nlnnlll \" ; int n = tree . length ( ) ; System . out . println ( findDepth ( tree , n ) ) ; } }", "nl": "Driver Code"}
{"code": "class GfG {", "nl": "Java code to find the largest value smaller than or equal to N"}
{"code": "static class Node { int key ; Node left , right ; }", "nl": "Node structure"}
{"code": "static Node newNode ( int item ) { Node temp = new Node ( ) ; temp . key = item ; temp . left = null ; temp . right = null ; return temp ; }", "nl": "To create new BST Node"}
{"code": "static Node insert ( Node node , int key ) {", "nl": "To insert a new node in BST"}
{"code": "if ( node == null ) return newNode ( key ) ;", "nl": "if tree is empty return new node"}
{"code": "if ( key < node . key ) node . left = insert ( node . left , key ) ; else if ( key > node . key ) node . right = insert ( node . right , key ) ;", "nl": "if key is less then or greater then node value then recur down the tree"}
{"code": "return node ; }", "nl": "return the ( unchanged ) node pointer"}
{"code": "static int findMaxforN ( Node root , int N ) {", "nl": "function to find max value less then N"}
{"code": "if ( root == null ) return - 1 ; if ( root . key == N ) return N ;", "nl": "Base cases"}
{"code": "else if ( root . key < N ) { int k = findMaxforN ( root . right , N ) ; if ( k == - 1 ) return root . key ; else return k ; }", "nl": "If root 's value is smaller, try in right  subtree"}
{"code": "else if ( root . key > N ) return findMaxforN ( root . left , N ) ; return - 1 ; }", "nl": "If root 's key is greater, return value  from left subtree."}
{"code": "public static void main ( String [ ] args ) { int N = 4 ;", "nl": "Driver code"}
{"code": "Node root = null ; root = insert ( root , 25 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 12 ) ; insert ( root , 9 ) ; insert ( root , 21 ) ; insert ( root , 19 ) ; insert ( root , 25 ) ; System . out . println ( findMaxforN ( root , N ) ) ; } }", "nl": "creating following BST 5 / \\ 2 12 / \\ / \\ 1 3 9 21 / \\ 19 25"}
{"code": "class Solution { static class Node { Node left , right ; int data ; }", "nl": "Java program to find maximum element in the path between two Nodes of Binary Search Tree ."}
{"code": "static Node createNode ( int x ) { Node p = new Node ( ) ; p . data = x ; p . left = p . right = null ; return p ; }", "nl": "Create and return a pointer of new Node ."}
{"code": "static void insertNode ( Node root , int x ) { Node p = root , q = null ; while ( p != null ) { q = p ; if ( p . data < x ) p = p . right ; else p = p . left ; } if ( q == null ) p = createNode ( x ) ; else { if ( q . data < x ) q . right = createNode ( x ) ; else q . left = createNode ( x ) ; } }", "nl": "Insert a new Node in Binary Search Tree ."}
{"code": "static int maxelpath ( Node q , int x ) { Node p = q ; int mx = - 1 ;", "nl": "Return the maximum element between a Node and its given ancestor ."}
{"code": "while ( p . data != x ) { if ( p . data > x ) { mx = Math . max ( mx , p . data ) ; p = p . left ; } else { mx = Math . max ( mx , p . data ) ; p = p . right ; } } return Math . max ( mx , x ) ; }", "nl": "Traversing the path between ansector and Node and finding maximum element ."}
{"code": "static int maximumElement ( Node root , int x , int y ) { Node p = root ;", "nl": "Return maximum element in the path between two given Node of BST ."}
{"code": "while ( ( x < p . data && y < p . data ) || ( x > p . data && y > p . data ) ) {", "nl": "Finding the LCA of Node x and Node y"}
{"code": "if ( x < p . data && y < p . data ) p = p . left ;", "nl": "Checking if both the Node lie on the left side of the parent p ."}
{"code": "else if ( x > p . data && y > p . data ) p = p . right ; }", "nl": "Checking if both the Node lie on the right side of the parent p ."}
{"code": "return Math . max ( maxelpath ( p , x ) , maxelpath ( p , y ) ) ; }", "nl": "Return the maximum of maximum elements occur in path from ancestor to both Node ."}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 18 , 36 , 9 , 6 , 12 , 10 , 1 , 8 } ; int a = 1 , b = 10 ; int n = arr . length ;", "nl": "Driver Code"}
{"code": "Node root = createNode ( arr [ 0 ] ) ;", "nl": "Creating the root of Binary Search Tree"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) insertNode ( root , arr [ i ] ) ; System . out . println ( maximumElement ( root , a , b ) ) ; } }", "nl": "Inserting Nodes in Binary Search Tree"}
{"code": "import java . util . * ; class solution { static class Node { Node left , right ; int info ;", "nl": "Java program Insertion in Threaded Binary Search Tree ."}
{"code": "boolean lthread ;", "nl": "True if left pointer points to predecessor in Inorder Traversal"}
{"code": "boolean rthread ; } ;", "nl": "True if right pointer points to successor in Inorder Traversal"}
{"code": "static Node insert ( Node root , int ikey ) {", "nl": "Insert a Node in Binary Threaded Tree"}
{"code": "Node ptr = root ;", "nl": "Searching for a Node with given value"}
{"code": "Node par = null ; while ( ptr != null ) {", "nl": "Parent of key to be inserted"}
{"code": "if ( ikey == ( ptr . info ) ) { System . out . printf ( \"Duplicate Key !NEW_LINE\"); return root ; }", "nl": "If key already exists , return"}
{"code": "par = ptr ;", "nl": "Update parent pointer"}
{"code": "if ( ikey < ptr . info ) { if ( ptr . lthread == false ) ptr = ptr . left ; else break ; }", "nl": "Moving on left subtree ."}
{"code": "else { if ( ptr . rthread == false ) ptr = ptr . right ; else break ; } }", "nl": "Moving on right subtree ."}
{"code": "Node tmp = new Node ( ) ; tmp . info = ikey ; tmp . lthread = true ; tmp . rthread = true ; if ( par == null ) { root = tmp ; tmp . left = null ; tmp . right = null ; } else if ( ikey < ( par . info ) ) { tmp . left = par . left ; tmp . right = par ; par . lthread = false ; par . left = tmp ; } else { tmp . left = par ; tmp . right = par . right ; par . rthread = false ; par . right = tmp ; } return root ; }", "nl": "Create a new node"}
{"code": "static Node inorderSuccessor ( Node ptr ) {", "nl": "Returns inorder successor using rthread"}
{"code": "if ( ptr . rthread == true ) return ptr . right ;", "nl": "If rthread is set , we can quickly find"}
{"code": "ptr = ptr . right ; while ( ptr . lthread == false ) ptr = ptr . left ; return ptr ; }", "nl": "Else return leftmost child of right subtree"}
{"code": "static void inorder ( Node root ) { if ( root == null ) System . out . printf ( \" Tree \u2581 is \u2581 empty \" ) ;", "nl": "Printing the threaded tree"}
{"code": "Node ptr = root ; while ( ptr . lthread == false ) ptr = ptr . left ;", "nl": "Reach leftmost node"}
{"code": "while ( ptr != null ) { System . out . printf ( \" % d \u2581 \" , ptr . info ) ; ptr = inorderSuccessor ( ptr ) ; } }", "nl": "One by one print successors"}
{"code": "public static void main ( String [ ] args ) { Node root = null ; root = insert ( root , 20 ) ; root = insert ( root , 10 ) ; root = insert ( root , 30 ) ; root = insert ( root , 5 ) ; root = insert ( root , 16 ) ; root = insert ( root , 14 ) ; root = insert ( root , 17 ) ; root = insert ( root , 13 ) ; inorder ( root ) ; } }", "nl": "Driver Program"}
{"code": "boolean lthread ;", "nl": "True if left pointer points to predecessor in Inorder Traversal"}
{"code": "boolean rthread ; } ;", "nl": "True if right pointer points to predecessor in Inorder Traversal"}
{"code": "Node caseA ( Node root , Node par , Node ptr ) {", "nl": "Here ' par ' is pointer to parent Node and ' ptr ' is pointer to current Node ."}
{"code": "if ( par == null ) root = null ;", "nl": "If Node to be deleted is root"}
{"code": "else if ( ptr == par . left ) { par . lthread = true ; par . left = ptr . left ; } else { par . rthread = true ; par . right = ptr . right ; } return root ; }", "nl": "If Node to be deleted is left of its parent"}
{"code": "static Node caseB ( Node root , Node par , Node ptr ) { Node child ;", "nl": "Here ' par ' is pointer to parent Node and ' ptr ' is pointer to current Node ."}
{"code": "if ( ptr . lthread == false ) child = ptr . left ;", "nl": "Initialize child Node to be deleted has left child ."}
{"code": "else child = ptr . right ;", "nl": "Node to be deleted has right child ."}
{"code": "if ( par == null ) root = child ;", "nl": "Node to be deleted is root Node ."}
{"code": "else if ( ptr == par . left ) par . left = child ; else par . right = child ;", "nl": "Node is left child of its parent ."}
{"code": "Node s = inSucc ( ptr ) ; Node p = inPred ( ptr ) ;", "nl": "Find successor and predecessor"}
{"code": "if ( ptr . lthread == false ) p . right = s ;", "nl": "If ptr has left subtree ."}
{"code": "else { if ( ptr . rthread == false ) s . left = p ; } return root ; }", "nl": "If ptr has right subtree ."}
{"code": "import java . util . * ; class solution { static class Node { Node left , right ; int info ;", "nl": "Complete Java program to demonstrate deletion in threaded BST"}
{"code": "boolean lthread ;", "nl": "True if left pointer points to predecessor in Inorder Traversal"}
{"code": "boolean rthread ; } ;", "nl": "True if right pointer points to predecessor in Inorder Traversal"}
{"code": "static Node insert ( Node root , int ikey ) {", "nl": "Insert a Node in Binary Threaded Tree"}
{"code": "Node ptr = root ;", "nl": "Searching for a Node with given value"}
{"code": "Node par = null ; while ( ptr != null ) {", "nl": "Parent of key to be inserted"}
{"code": "if ( ikey == ( ptr . info ) ) { System . out . printf ( \"Duplicate Key !NEW_LINE\"); return root ; }", "nl": "If key already exists , return"}
{"code": "par = ptr ;", "nl": "Update parent pointer"}
{"code": "if ( ikey < ptr . info ) { if ( ptr . lthread == false ) ptr = ptr . left ; else break ; }", "nl": "Moving on left subtree ."}
{"code": "else { if ( ptr . rthread == false ) ptr = ptr . right ; else break ; } }", "nl": "Moving on right subtree ."}
{"code": "Node tmp = new Node ( ) ; tmp . info = ikey ; tmp . lthread = true ; tmp . rthread = true ; if ( par == null ) { root = tmp ; tmp . left = null ; tmp . right = null ; } else if ( ikey < ( par . info ) ) { tmp . left = par . left ; tmp . right = par ; par . lthread = false ; par . left = tmp ; } else { tmp . left = par ; tmp . right = par . right ; par . rthread = false ; par . right = tmp ; } return root ; }", "nl": "Create a new Node"}
{"code": "static Node inSucc ( Node ptr ) { if ( ptr . rthread == true ) return ptr . right ; ptr = ptr . right ; while ( ptr . lthread == false ) ptr = ptr . left ; return ptr ; }", "nl": "Returns inorder successor using left and right children ( Used in deletion )"}
{"code": "static Node inorderSuccessor ( Node ptr ) {", "nl": "Returns inorder successor using rthread ( Used in inorder )"}
{"code": "if ( ptr . rthread == true ) return ptr . right ;", "nl": "If rthread is set , we can quickly find"}
{"code": "ptr = ptr . right ; while ( ptr . lthread == false ) ptr = ptr . left ; return ptr ; }", "nl": "Else return leftmost child of right subtree"}
{"code": "static void inorder ( Node root ) { if ( root == null ) System . out . printf ( \" Tree \u2581 is \u2581 empty \" ) ;", "nl": "Printing the threaded tree"}
{"code": "Node ptr = root ; while ( ptr . lthread == false ) ptr = ptr . left ;", "nl": "Reach leftmost Node"}
{"code": "while ( ptr != null ) { System . out . printf ( \" % d \u2581 \" , ptr . info ) ; ptr = inorderSuccessor ( ptr ) ; } } static Node inPred ( Node ptr ) { if ( ptr . lthread == true ) return ptr . left ; ptr = ptr . left ; while ( ptr . rthread == false ) ptr = ptr . right ; return ptr ; }", "nl": "One by one print successors"}
{"code": "static Node caseA ( Node root , Node par , Node ptr ) {", "nl": "Here ' par ' is pointer to parent Node and ' ptr ' is pointer to current Node ."}
{"code": "if ( par == null ) root = null ;", "nl": "If Node to be deleted is root"}
{"code": "else if ( ptr == par . left ) { par . lthread = true ; par . left = ptr . left ; } else { par . rthread = true ; par . right = ptr . right ; } return root ; }", "nl": "If Node to be deleted is left of its parent"}
{"code": "static Node caseB ( Node root , Node par , Node ptr ) { Node child ;", "nl": "Here ' par ' is pointer to parent Node and ' ptr ' is pointer to current Node ."}
{"code": "if ( ptr . lthread == false ) child = ptr . left ;", "nl": "Initialize child Node to be deleted has left child ."}
{"code": "else child = ptr . right ;", "nl": "Node to be deleted has right child ."}
{"code": "if ( par == null ) root = child ;", "nl": "Node to be deleted is root Node ."}
{"code": "else if ( ptr == par . left ) par . left = child ; else par . right = child ;", "nl": "Node is left child of its parent ."}
{"code": "Node s = inSucc ( ptr ) ; Node p = inPred ( ptr ) ;", "nl": "Find successor and predecessor"}
{"code": "if ( ptr . lthread == false ) p . right = s ;", "nl": "If ptr has left subtree ."}
{"code": "else { if ( ptr . rthread == false ) s . left = p ; } return root ; }", "nl": "If ptr has right subtree ."}
{"code": "static Node caseC ( Node root , Node par , Node ptr ) {", "nl": "Here ' par ' is pointer to parent Node and ' ptr ' is pointer to current Node ."}
{"code": "Node parsucc = ptr ; Node succ = ptr . right ;", "nl": "Find inorder successor and its parent ."}
{"code": "while ( succ . lthread == false ) { parsucc = succ ; succ = succ . left ; } ptr . info = succ . info ; if ( succ . lthread == true && succ . rthread == true ) root = caseA ( root , parsucc , succ ) ; else root = caseB ( root , parsucc , succ ) ; return root ; }", "nl": "Find leftmost child of successor"}
{"code": "static Node delThreadedBST ( Node root , int dkey ) {", "nl": "Deletes a key from threaded BST with given root and returns new root of BST ."}
{"code": "Node par = null , ptr = root ;", "nl": "Initialize parent as null and ptrent Node as root ."}
{"code": "int found = 0 ;", "nl": "Set true if key is found"}
{"code": "while ( ptr != null ) { if ( dkey == ptr . info ) { found = 1 ; break ; } par = ptr ; if ( dkey < ptr . info ) { if ( ptr . lthread == false ) ptr = ptr . left ; else break ; } else { if ( ptr . rthread == false ) ptr = ptr . right ; else break ; } } if ( found == 0 ) System . out . printf ( \"dkey not present in treeNEW_LINE\");", "nl": "Search key in BST : find Node and its parent ."}
{"code": "else if ( ptr . lthread == false && ptr . rthread == false ) root = caseC ( root , par , ptr ) ;", "nl": "Two Children"}
{"code": "else if ( ptr . lthread == false ) root = caseB ( root , par , ptr ) ;", "nl": "Only Left Child"}
{"code": "else if ( ptr . rthread == false ) root = caseB ( root , par , ptr ) ;", "nl": "Only Right Child"}
{"code": "else root = caseA ( root , par , ptr ) ; return root ; }", "nl": "No child"}
{"code": "public static void main ( String args [ ] ) { Node root = null ; root = insert ( root , 20 ) ; root = insert ( root , 10 ) ; root = insert ( root , 30 ) ; root = insert ( root , 5 ) ; root = insert ( root , 16 ) ; root = insert ( root , 14 ) ; root = insert ( root , 17 ) ; root = insert ( root , 13 ) ; root = delThreadedBST ( root , 20 ) ; inorder ( root ) ; } }", "nl": "Driver Program"}
{"code": "import java . io . * ; public class GFG { static void checkHV ( int [ ] [ ] arr , int N , int M ) {", "nl": "Java program to find if a matrix is symmetric ."}
{"code": "boolean horizontal = true ; boolean vertical = true ;", "nl": "Initializing as both horizontal and vertical symmetric ."}
{"code": "for ( int i = 0 , k = N - 1 ; i < N / 2 ; i ++ , k -- ) {", "nl": "Checking for Horizontal Symmetry . We compare first row with last row , second row with second last row and so on ."}
{"code": "for ( int j = 0 ; j < M ; j ++ ) {", "nl": "Checking each cell of a column ."}
{"code": "if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } }", "nl": "check if every cell is identical"}
{"code": "for ( int i = 0 , k = M - 1 ; i < M / 2 ; i ++ , k -- ) {", "nl": "Checking for Vertical Symmetry . We compare first column with last column , second xolumn with second last column and so on ."}
{"code": "for ( int j = 0 ; j < N ; j ++ ) {", "nl": "Checking each cell of a row ."}
{"code": "if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } } if ( ! horizontal && ! vertical ) System . out . println ( \" NO \" ) ; else if ( horizontal && ! vertical ) System . out . println ( \" HORIZONTAL \" ) ; else if ( vertical && ! horizontal ) System . out . println ( \" VERTICAL \" ) ; else System . out . println ( \" BOTH \" ) ; }", "nl": "check if every cell is identical"}
{"code": "static public void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 0 , 1 } , { 0 , 0 , 0 } , { 1 , 0 , 1 } } ; checkHV ( mat , 3 , 3 ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG { static int R = 3 ; static int C = 4 ;", "nl": "Java program to replace each each element with maximum of GCD of row or column ."}
{"code": "static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }", "nl": "returning the greatest common divisor of two number"}
{"code": "static void replacematrix ( int [ ] [ ] mat , int n , int m ) { int [ ] rgcd = new int [ R ] ; int [ ] cgcd = new int [ C ] ;", "nl": "Finding GCD of each row and column and replacing with each element with maximum of GCD of row or column ."}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i ] [ j ] ) ; cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i ] [ j ] ) ; } }", "nl": "Calculating GCD of each row and each column in O ( mn ) and store in arrays ."}
{"code": "for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) mat [ i ] [ j ] = Math . max ( rgcd [ i ] , cgcd [ j ] ) ; }", "nl": "Replacing matrix element"}
{"code": "static public void main ( String [ ] args ) { int [ ] [ ] m = { { 1 , 2 , 3 , 3 } , { 4 , 5 , 6 , 6 } , { 7 , 8 , 9 , 9 } , } ; replacematrix ( m , R , C ) ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) System . out . print ( m [ i ] [ j ] + \" \u2581 \" ) ; System . out . println ( ) ; } } }", "nl": "Driver program"}
{"code": "class GFG { static final int N = 4 ;", "nl": "Java program for addition of two matrices"}
{"code": "static void add ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; }", "nl": "This function adds A [ ] [ ] and B [ ] [ ] , and stores the result in C [ ] [ ]"}
{"code": "public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ ] [ ] = new int [ N ] [ N ] ; int i , j ; add ( A , B , C ) ; System . out . print ( \"Result matrix is NEW_LINE\"); for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) System . out . print ( C [ i ] [ j ] + \" \u2581 \" ) ; System . out . print ( \"NEW_LINE\"); } } }", "nl": "Driver code"}
{"code": "class GFG { static final int N = 4 ;", "nl": "Java program for subtraction of matrices"}
{"code": "static void subtract ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }", "nl": "This function subtracts B [ ] [ ] from A [ ] [ ] , and stores the result in C [ ] [ ]"}
{"code": "public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ ] [ ] = new int [ N ] [ N ] ; int i , j ; subtract ( A , B , C ) ; System . out . print ( \"Result matrix is NEW_LINE\"); for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) System . out . print ( C [ i ] [ j ] + \" \u2581 \" ) ; System . out . print ( \"NEW_LINE\"); } } }", "nl": "Driver code"}
{"code": "class Main { static int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; }", "nl": "Java program to check fixed point in an array using linear search"}
{"code": "return - 1 ; }", "nl": "If no fixed point present then return - 1"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = arr . length ; System . out . println ( \" Fixed \u2581 Point \u2581 is \u2581 \" + linearSearch ( arr , n ) ) ; } }", "nl": "main function"}
{"code": "class Main { static int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) {", "nl": "Java program to check fixed point in an array using binary search"}
{"code": "int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; }", "nl": "low + ( high - low ) / 2 ;"}
{"code": "return - 1 ; }", "nl": "Return - 1 if there is no Fixed Point"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = arr . length ; System . out . println ( \" Fixed \u2581 Point \u2581 is \u2581 \" + binarySearch ( arr , 0 , n - 1 ) ) ; } }", "nl": "main function"}
{"code": "import java . io . * ; class GFG { static int maxTripletSum ( int arr [ ] , int n ) {", "nl": "Java code to find maximum triplet sum"}
{"code": "int sum = - 1000000 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }", "nl": "Initialize sum with INT_MIN"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = arr . length ; System . out . println ( maxTripletSum ( arr , n ) ) ; } }", "nl": "Driven code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java code to find maximum triplet sum"}
{"code": "static int maxTripletSum ( int arr [ ] , int n ) {", "nl": "This function assumes that there are at least three elements in arr [ ] ."}
{"code": "Arrays . sort ( arr ) ;", "nl": "sort the given array"}
{"code": "return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }", "nl": "After sorting the array . Add last three element of the given array"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = arr . length ; System . out . println ( maxTripletSum ( arr , n ) ) ; } }", "nl": "Driven code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java code to find maximum triplet sum"}
{"code": "static int maxTripletSum ( int arr [ ] , int n ) {", "nl": "This function assumes that there are at least three elements in arr [ ] ."}
{"code": "int maxA = - 100000000 , maxB = - 100000000 ; int maxC = - 100000000 ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Initialize Maximum , second maximum and third maximum element"}
{"code": "if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; }", "nl": "Update Maximum , second maximum and third maximum element"}
{"code": "else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; }", "nl": "Update second maximum and third maximum element"}
{"code": "else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; } return ( maxA + maxB + maxC ) ; }", "nl": "Update third maximum element"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = arr . length ; System . out . println ( maxTripletSum ( arr , n ) ) ; } }", "nl": "Driven code"}
{"code": "class GFG { public static int search ( int arr [ ] , int x ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; }", "nl": "Java code for linearly searching x in arr [ ] . If x is present then return its location , otherwise return - 1"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ;", "nl": "Driver code"}
{"code": "int result = search ( arr , x ) ; if ( result == - 1 ) System . out . print ( \" Element \u2581 is \u2581 not \u2581 present \u2581 in \u2581 array \" ) ; else System . out . print ( \" Element \u2581 is \u2581 present \u2581 at \u2581 index \u2581 \" + result ) ; } }", "nl": "Function call"}
{"code": "import java . io . * ; class GFG { public static void search ( int arr [ ] , int search_Element ) { int left = 0 ; int length = arr . length ; int right = length - 1 ; int position = - 1 ;", "nl": "Java program for linear search"}
{"code": "for ( left = 0 ; left <= right ; ) {", "nl": "run loop from 0 to right"}
{"code": "if ( arr [ left ] == search_Element ) { position = left ; System . out . println ( \" Element \u2581 found \u2581 in \u2581 Array \u2581 at \u2581 \" + ( position + 1 ) + \" \u2581 Position \u2581 with \u2581 \" + ( left + 1 ) + \" \u2581 Attempt \" ) ; break ; }", "nl": "if search_element is found with left variable"}
{"code": "if ( arr [ right ] == search_Element ) { position = right ; System . out . println ( \" Element \u2581 found \u2581 in \u2581 Array \u2581 at \u2581 \" + ( position + 1 ) + \" \u2581 Position \u2581 with \u2581 \" + ( length - right ) + \" \u2581 Attempt \" ) ; break ; } left ++ ; right -- ; }", "nl": "if search_element is found with right variable"}
{"code": "if ( position == - 1 ) System . out . println ( \" Not \u2581 found \u2581 in \u2581 Array \u2581 with \u2581 \" + left + \" \u2581 Attempt \" ) ; }", "nl": "if element not found"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int search_element = 5 ;", "nl": "Driver code"}
{"code": "search ( arr , search_element ) ; } }", "nl": "Function call"}
{"code": "class CountingSort {", "nl": "Java implementation of Counting Sort"}
{"code": "void sort ( char arr [ ] ) { int n = arr . length ;", "nl": "The main function that sort the given string arr [ ] in alphabetical order"}
{"code": "char output [ ] = new char [ n ] ;", "nl": "The output character array that will have sorted arr"}
{"code": "int count [ ] = new int [ 256 ] ; for ( int i = 0 ; i < 256 ; ++ i ) count [ i ] = 0 ;", "nl": "Create a count array to store count of inidividul characters and initialize count array as 0"}
{"code": "for ( int i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] ] ;", "nl": "store count of each character"}
{"code": "for ( int i = 1 ; i <= 255 ; ++ i ) count [ i ] += count [ i - 1 ] ;", "nl": "Change count [ i ] so that count [ i ] now contains actual position of this character in output array"}
{"code": "for ( int i = n - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; }", "nl": "Build the output character array To make it stable we are operating in reverse order ."}
{"code": "for ( int i = 0 ; i < n ; ++ i ) arr [ i ] = output [ i ] ; }", "nl": "Copy the output array to arr , so that arr now contains sorted characters"}
{"code": "public static void main ( String args [ ] ) { CountingSort ob = new CountingSort ( ) ; char arr [ ] = { ' g ' , ' e ' , ' e ' , ' k ' , ' s ' , ' f ' , ' o ' , ' r ' , ' g ' , ' e ' , ' e ' , ' k ' , ' s ' } ; ob . sort ( arr ) ; System . out . print ( \" Sorted \u2581 character \u2581 array \u2581 is \u2581 \" ) ; for ( int i = 0 ; i < arr . length ; ++ i ) System . out . print ( arr [ i ] ) ; } }", "nl": "Driver method"}
{"code": "import java . util . * ; class GFG {", "nl": "Counting sort which takes negative numbers as well"}
{"code": "static void countSort ( int [ ] arr ) { int max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int min = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; int range = max - min + 1 ; int count [ ] = new int [ range ] ; int output [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { count [ arr [ i ] - min ] ++ ; } for ( int i = 1 ; i < count . length ; i ++ ) { count [ i ] += count [ i - 1 ] ; } for ( int i = arr . length - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] - min ] - 1 ] = arr [ i ] ; count [ arr [ i ] - min ] -- ; } for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = output [ i ] ; } }", "nl": "The function that sorts the given arr [ ]"}
{"code": "static void printArray ( int [ ] arr ) { for ( int i = 0 ; i < arr . length ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } System . out . println ( \" \" ) ; }", "nl": "function to print array"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { - 5 , - 10 , 0 , - 3 , 8 , 5 , - 1 , 10 } ; countSort ( arr ) ; printArray ( arr ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "JAVA Code for Dynamic Programming | Set 9 ( Binomial Coefficient )"}
{"code": "static int binomialCoeff ( int n , int k ) {", "nl": "Returns value of Binomial Coefficient C ( n , k )"}
{"code": "if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ;", "nl": "Base Cases"}
{"code": "return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }", "nl": "Recur"}
{"code": "public static void main ( String [ ] args ) { int n = 5 , k = 2 ; System . out . printf ( \" Value \u2581 of \u2581 C ( % d , \u2581 % d ) \u2581 is \u2581 % d \u2581 \" , n , k , binomialCoeff ( n , k ) ) ; } }", "nl": "Driver program to test above function"}
{"code": "import java . util . * ; class GFG { static int binomialCoeff ( int n , int k ) { int C [ ] = new int [ k + 1 ] ;", "nl": "JAVA Code for Dynamic Programming | Set 9 ( Binomial Coefficient )"}
{"code": "C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) {", "nl": "nC0 is 1"}
{"code": "for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }", "nl": "Compute next row of pascal triangle using the previous row"}
{"code": "public static void main ( String [ ] args ) { int n = 5 , k = 2 ; System . out . printf ( \" Value \u2581 of \u2581 C ( % d , \u2581 % d ) \u2581 is \u2581 % d \u2581 \" , n , k , binomialCoeff ( n , k ) ) ; } }", "nl": "Driver code"}
{"code": "static long pow ( long b , long exp , long mod ) { long ret = 1 ; while ( exp > 0 ) { if ( ( exp & 1 ) > 0 ) ret = ( ret * b ) % mod ; b = ( b * b ) % mod ; exp >>= 1 ; } return ret ; }", "nl": "pow ( base , exp , mod ) is used to find ( base ^ exp ) % mod fast -> O ( log ( exp ) )"}
{"code": "static int nCr ( int n , int r ) { if ( r > n ) return 0 ;", "nl": "base case"}
{"code": "if ( n - r > r ) r = n - r ;", "nl": "C ( n , r ) = C ( n , n - r ) Complexity for this code is lesser for lower n - r"}
{"code": "int [ ] SPF = new int [ n + 1 ] ;", "nl": "list to smallest prime factor of each number from 1 to n"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) SPF [ i ] = i ;", "nl": "set smallest prime factor of each number as itself"}
{"code": "for ( int i = 4 ; i <= n ; i += 2 ) SPF [ i ] = 2 ; for ( int i = 3 ; i * i < n + 1 ; i += 2 ) {", "nl": "set smallest prime factor of all even numbers as 2"}
{"code": "if ( SPF [ i ] == i ) {", "nl": "Check if i is prime"}
{"code": "for ( int j = i * i ; j < n + 1 ; j += i ) if ( SPF [ j ] == j ) { SPF [ j ] = i ; } } }", "nl": "All multiples of i are composite ( and divisible by i ) so add i to their prime factorization getpow ( j , i ) times"}
{"code": "Map < Integer , Integer > prime_pow = new HashMap < > ( ) ;", "nl": "Hash Map to store power of each prime in C ( n , r )"}
{"code": "for ( int i = r + 1 ; i < n + 1 ; i ++ ) { int t = i ;", "nl": "For numerator count frequency of each prime factor"}
{"code": "while ( t > 1 ) { prime_pow . put ( SPF [ t ] , prime_pow . getOrDefault ( SPF [ t ] , 0 ) + 1 ) ; t /= SPF [ t ] ; } }", "nl": "Recursive division to find prime factorization of i"}
{"code": "for ( int i = 1 ; i < n - r + 1 ; i ++ ) { int t = i ;", "nl": "For denominator subtract the power of each prime factor"}
{"code": "while ( t > 1 ) { prime_pow . put ( SPF [ t ] , prime_pow . get ( SPF [ t ] ) - 1 ) ; t /= SPF [ t ] ; } }", "nl": "Recursive division to find prime factorization of i"}
{"code": "long ans = 1 , mod = 1000000007 ;", "nl": "long because mod is large and a % mod * b % mod can overflow int"}
{"code": "for ( int i : prime_pow . keySet ( ) )", "nl": "use ( a * b ) % mod = ( a % mod * b % mod ) % mod"}
{"code": "ans = ( ans * pow ( i , prime_pow . get ( i ) , mod ) ) % mod ; return ( int ) ans ; }", "nl": "pow ( base , exp , mod ) is used to find ( base ^ exp ) % mod fast"}
{"code": "public static void main ( String [ ] args ) { int n = 5 , r = 2 ; System . out . print ( \" Value \u2581 of \u2581 C ( \" + n + \" , \u2581 \" + r + \" ) \u2581 is \u2581 \" + nCr ( n , r ) + \"NEW_LINE\"); } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "JAVA program for the above approach"}
{"code": "static int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long m = 1000000007 ; long inv [ ] = new long [ r + 1 ] ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ;", "nl": "Function to find binomial coefficient"}
{"code": "for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m / i ) * inv [ ( int ) ( m % i ) ] % m ; } int ans = 1 ;", "nl": "Getting the modular inversion for all the numbers from 2 to r with respect to m here m = 1000000007"}
{"code": "for ( int i = 2 ; i <= r ; i ++ ) { ans = ( int ) ( ( ( ans % m ) * ( inv [ i ] % m ) ) % m ) ; }", "nl": "for 1 / ( r ! ) part"}
{"code": "for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( int ) ( ( ( ans % m ) * ( i % m ) ) % m ) ; } return ans ; }", "nl": "for ( n ) * ( n - 1 ) * ( n - 2 ) * ... * ( n - r + 1 ) part"}
{"code": "public static void main ( String [ ] args ) { int n = 5 , r = 2 ; System . out . print ( \" Value \u2581 of \u2581 C ( \" + n + \" , \u2581 \" + r + \" ) \u2581 is \u2581 \" + binomialCoeff ( n , r ) + \"NEW_LINE\"); } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "A Dynamic Programming based Java program to partition problem"}
{"code": "public static boolean findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ;", "nl": "Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false"}
{"code": "for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; boolean [ ] part = new boolean [ sum / 2 + 1 ] ;", "nl": "Calculate sum of all elements"}
{"code": "for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = false ; }", "nl": "Initialze the part array as 0"}
{"code": "for ( i = 0 ; i < n ; i ++ ) {", "nl": "Fill the partition table in bottom up manner"}
{"code": "for ( j = sum / 2 ; j >= arr [ i ] ; j -- ) {", "nl": "The element to be included in the sum cannot be greater than the sum"}
{"code": "if ( part [ j - arr [ i ] ] == true j == arr [ i ] ) part [ j ] = true ; } } return part [ sum / 2 ] ; }", "nl": "Check if sum - arr [ i ] could be formed from a subset using elements before index i"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 3 , 2 , 3 , 2 } ; int n = 6 ;", "nl": "Driver code"}
{"code": "if ( findPartiion ( arr , n ) == true ) System . out . println ( \" Can \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 \" + \" subsets \u2581 of \u2581 equal \u2581 sum \" ) ; else System . out . println ( \" Can \u2581 not \u2581 be \u2581 divided \u2581 into \u2581 \" + \" two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "A recursive solution for subset sum problem"}
{"code": "static boolean isSubsetSum ( int set [ ] , int n , int sum ) {", "nl": "Returns true if there is a subset of set [ ] with sum equal to given sum"}
{"code": "if ( sum == 0 ) return true ; if ( n == 0 ) return false ;", "nl": "Base Cases"}
{"code": "if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ;", "nl": "If last element is greater than sum , then ignore it"}
{"code": "return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }", "nl": "else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element"}
{"code": "public static void main ( String args [ ] ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = set . length ; if ( isSubsetSum ( set , n , sum ) == true ) System . out . println ( \" Found \u2581 a \u2581 subset \" + \" \u2581 with \u2581 given \u2581 sum \" ) ; else System . out . println ( \" No \u2581 subset \u2581 with \" + \" \u2581 given \u2581 sum \" ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "A Dynamic Programming solution for subset sum problem"}
{"code": "static boolean isSubsetSum ( int set [ ] , int n , int sum ) {", "nl": "Returns true if there is a subset of set [ ] with sun equal to given sum"}
{"code": "boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ] ;", "nl": "The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i"}
{"code": "for ( int i = 0 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = true ;", "nl": "If sum is 0 , then answer is true"}
{"code": "for ( int i = 1 ; i <= sum ; i ++ ) subset [ i ] [ 0 ] = false ;", "nl": "If sum is not 0 and set is empty , then answer is false"}
{"code": "for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; } }", "nl": "Fill the subset table in botton up manner"}
{"code": "for ( int i = 0 ; i <= sum ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) System . out . println ( subset [ i ] [ j ] ) ; } return subset [ sum ] [ n ] ; }", "nl": "print table"}
{"code": "public static void main ( String args [ ] ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = set . length ; if ( isSubsetSum ( set , n , sum ) == true ) System . out . println ( \" Found \u2581 a \u2581 subset \" + \" \u2581 with \u2581 given \u2581 sum \" ) ; else System . out . println ( \" No \u2581 subset \u2581 with \" + \" \u2581 given \u2581 sum \" ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "A recursive Java program to print maximum number of A 's using  following four keys"}
{"code": "static int findoptimal ( int N ) {", "nl": "A recursive function that returns the optimal length string for N keystrokes"}
{"code": "if ( N <= 6 ) return N ;", "nl": "The optimal string length is N when N is smaller than 7"}
{"code": "int max = 0 ;", "nl": "Initialize result"}
{"code": "int b ; for ( b = N - 3 ; b >= 1 ; b -- ) {", "nl": "TRY ALL POSSIBLE BREAK - POINTS For any keystroke N , we need to loop from N - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have Ctrl - A , Ctrl - C and then only Ctrl - V all the way ."}
{"code": "int curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; }", "nl": "If the breakpoint is s at b 'th  keystroke then the optimal string  would have length  (n-b-1)*screen[b-1];"}
{"code": "public static void main ( String [ ] args ) { int N ;", "nl": "Driver program"}
{"code": "for ( N = 1 ; N <= 20 ; N ++ ) System . out . println ( \" Maximum \u2581 Number \u2581 of \u2581 A ' s \u2581 with \u2581 keystrokes \u2581 is \u2581 \" + N + findoptimal ( N ) ) ; } }", "nl": "for the rest of the array we will rely on the previous entries to compute new ones"}
{"code": "import java . io . * ; class GFG {", "nl": "A Dynamic Programming based C program to find maximum number of A 's that can be printed using  four keys"}
{"code": "static int findoptimal ( int N ) {", "nl": "this function returns the optimal length string for N keystrokes"}
{"code": "if ( N <= 6 ) return N ;", "nl": "The optimal string length is N when N is smaller than 7"}
{"code": "int screen [ ] = new int [ N ] ;", "nl": "An array to store result of subproblems"}
{"code": "int b ;", "nl": "To pick a breakpoint"}
{"code": "int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ;", "nl": "Initializing the optimal lengths array for uptil 6 input strokes"}
{"code": "for ( n = 7 ; n <= N ; n ++ ) {", "nl": "Solve all subproblems in bottom manner"}
{"code": "screen [ n - 1 ] = 0 ;", "nl": "Initialize length of optimal string for n keystrokes"}
{"code": "for ( b = n - 3 ; b >= 1 ; b -- ) {", "nl": "For any keystroke n , we need to loop from n - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have ctrl - a , ctrl - c and then only ctrl - v all the way ."}
{"code": "int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; }", "nl": "if the breakpoint is at b 'th keystroke then  the optimal string would  have length  (n-b-1)*screen[b-1];"}
{"code": "public static void main ( String [ ] args ) { int N ;", "nl": "Driver program"}
{"code": "for ( N = 1 ; N <= 20 ; N ++ ) System . out . println ( \" Maximum \u2581 Number \u2581 of \u2581 A ' s \u2581 with \u2581 keystrokes \u2581 is \u2581 \" + N + findoptimal ( N ) ) ; } }", "nl": "for the rest of the array we will rely on the previous entries to compute new ones"}
{"code": "class GFG {", "nl": "A Dynamic Programming based Java program to find maximum number of A 's that can be printed using four keys"}
{"code": "static int findoptimal ( int N ) {", "nl": "This function returns the optimal length string for N keystrokes"}
{"code": "if ( N <= 6 ) return N ;", "nl": "The optimal string length is N when N is smaller than 7"}
{"code": "int [ ] screen = new int [ N ] ;", "nl": "An array to store result of subproblems"}
{"code": "int b ;", "nl": "To pick a breakpoint"}
{"code": "int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ;", "nl": "Initializing the optimal lengths array for uptil 6 input strokes ."}
{"code": "for ( n = 7 ; n <= N ; n ++ ) {", "nl": "Solve all subproblems in bottom - up manner"}
{"code": "screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Math . max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; }", "nl": "for any keystroke n , we will need to choose between : - 1. pressing Ctrl - V once after copying the A ' s \u2581 obtained \u2581 by \u2581 n - 3 \u2581 keystrokes . \u2581 \u2581 2 . \u2581 pressing \u2581 Ctrl - V \u2581 twice \u2581 after \u2581 copying \u2581 the \u2581 A ' s obtained by n - 4 keystrokes . 3. pressing Ctrl - V thrice after copying the A 's  obtained by n-5 keystrokes."}
{"code": "public static void main ( String [ ] args ) { int N ;", "nl": "Driver Code"}
{"code": "for ( N = 1 ; N <= 20 ; N ++ ) System . out . printf ( \" Maximum \u2581 Number \u2581 of \u2581 A ' s \u2581 with \" + \" %d keystrokes is %dNEW_LINE\", N , findoptimal ( N ) ) ; } }", "nl": "for the rest of the array we will rely on the previous entries to compute new ones"}
{"code": "static int power ( int x , int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; }", "nl": "Function to calculate x raised to the power y"}
{"code": "public static void main ( String [ ] args ) { int x = 2 ; int y = 3 ; System . out . printf ( \" % d \" , power ( x , y ) ) ; } }", "nl": "Program to test function power"}
{"code": "static int power ( int x , int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }", "nl": "Function to calculate x raised to the power y in O ( logn )"}
{"code": "class GFG { static float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }", "nl": "Java code for extended version of power function that can work for float x and negative y"}
{"code": "public static void main ( String [ ] args ) { float x = 2 ; int y = - 3 ; System . out . printf ( \" % f \" , power ( x , y ) ) ; } }", "nl": "Program to test function power"}
{"code": "import java . io . * ; class GFG { public static int power ( int x , int y ) {", "nl": "Java program for the above approach"}
{"code": "if ( y == 0 ) return 1 ;", "nl": "If x ^ 0 return 1"}
{"code": "if ( x == 0 ) return 0 ;", "nl": "If we need to find of 0 ^ y"}
{"code": "return x * power ( x , y - 1 ) ; }", "nl": "For all other cases"}
{"code": "public static void main ( String [ ] args ) { int x = 2 ; int y = 3 ; System . out . println ( power ( x , y ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG { public static int power ( int x , int y ) {", "nl": "Java program for the above approach"}
{"code": "return ( int ) Math . pow ( x , y ) ; }", "nl": "Math . pow ( ) is a function that return floating number"}
{"code": "public static void main ( String [ ] args ) { int x = 2 ; int y = 3 ; System . out . println ( power ( x , y ) ) ; } }", "nl": "Driver Code"}
{"code": "static float squareRoot ( float n ) {", "nl": "Returns the square root of n . Note that the function"}
{"code": "float x = n ; float y = 1 ;", "nl": "We are using n itself as initial approximation This can definitely be improved"}
{"code": "double e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }", "nl": "e decides the accuracy level"}
{"code": "public static void main ( String [ ] args ) { int n = 50 ; System . out . printf ( \" Square \u2581 root \u2581 of \u2581 \" + n + \" \u2581 is \u2581 \" + squareRoot ( n ) ) ; } }", "nl": "Driver program to test above function"}
{"code": "class GFG {", "nl": "Java program to find average of a stream of numbers"}
{"code": "static float getAvg ( float prev_avg , float x , int n ) { return ( prev_avg * n + x ) / ( n + 1 ) ; }", "nl": "Returns the new average after including x"}
{"code": "static void streamAvg ( float arr [ ] , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( avg , arr [ i ] , i ) ; System . out . printf ( \"Average of %d numbers is %f NEW_LINE\", i + 1, avg); } return ; }", "nl": "Prints average of a stream of numbers"}
{"code": "public static void main ( String [ ] args ) { float arr [ ] = { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = arr . length ; streamAvg ( arr , n ) ; } }", "nl": "Driver program to test above functions"}
{"code": "class GFG { static int sum , n ;", "nl": "Java program to return Average of a stream of numbers"}
{"code": "static float getAvg ( int x ) { sum += x ; return ( ( ( float ) sum ) / ++ n ) ; }", "nl": "Returns the new average after including x"}
{"code": "static void streamAvg ( float [ ] arr , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( ( int ) arr [ i ] ) ; System . out . println ( \" Average \u2581 of \u2581 \" + ( i + 1 ) + \" \u2581 numbers \u2581 is \u2581 \" + avg ) ; } return ; }", "nl": "Prints average of a stream of numbers"}
{"code": "public static void main ( String [ ] args ) { float [ ] arr = new float [ ] { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = arr . length ; streamAvg ( arr , n ) ; } }", "nl": "Driver Code"}
{"code": "class BinomialCoefficient {", "nl": "Program to calculate C ( n , k ) in java"}
{"code": "static int binomialCoeff ( int n , int k ) { int res = 1 ;", "nl": "Returns value of Binomial Coefficient C ( n , k )"}
{"code": "if ( k > n - k ) k = n - k ;", "nl": "Since C ( n , k ) = C ( n , n - k )"}
{"code": "for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }", "nl": "Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- -- * 1 ]"}
{"code": "public static void main ( String [ ] args ) { int n = 8 ; int k = 2 ; System . out . println ( \" Value \u2581 of \u2581 C ( \" + n + \" , \u2581 \" + k + \" ) \u2581 \" + \" is \" + \" \u2581 \" + binomialCoeff ( n , k ) ) ; } }", "nl": "Driver program to test above function"}
{"code": "import java . io . * ; import java . lang . Math ; class GFG {", "nl": "Program to print all prime factors"}
{"code": "public static void primeFactors ( int n ) {", "nl": "A function to print all prime factors of a given number n"}
{"code": "while ( n % 2 == 0 ) { System . out . print ( 2 + \" \u2581 \" ) ; n /= 2 ; }", "nl": "Print the number of 2 s that divide n"}
{"code": "for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) {", "nl": "n must be odd at this point . So we can skip one element ( Note i = i + 2 )"}
{"code": "while ( n % i == 0 ) { System . out . print ( i + \" \u2581 \" ) ; n /= i ; } }", "nl": "While i divides n , print i and divide n"}
{"code": "if ( n > 2 ) System . out . print ( n ) ; }", "nl": "This condition is to handle the case whien n is a prime number greater than 2"}
{"code": "public static void main ( String [ ] args ) { int n = 315 ; primeFactors ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class Combination {", "nl": "Java program to print all combination of size r in an array of size n"}
{"code": "static void printCombination ( int arr [ ] , int n , int r ) {", "nl": "The main function that prints all combinations of size r in arr [ ] of size n . This function mainly uses combinationUtil ( )"}
{"code": "int data [ ] = new int [ r ] ;", "nl": "A temporary array to store all combination one by one"}
{"code": "combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; }", "nl": "Print all combination using temprary array ' data [ ] '"}
{"code": "static void combinationUtil ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) {", "nl": "arr [ ] -- -> Input Array data [ ] -- -> Temporary array to store current combination start & end -- -> Staring and Ending indexes in arr [ ] index -- -> Current index in data [ ] r -- -> Size of a combination to be printed"}
{"code": "if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) System . out . print ( data [ j ] + \" \u2581 \" ) ; System . out . println ( \" \" ) ; return ; }", "nl": "Current combination is ready to be printed , print it"}
{"code": "for ( int i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { data [ index ] = arr [ i ] ; combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; } }", "nl": "replace index with all possible elements . The condition \" end - i + 1 \u2581 > = \u2581 r - index \" makes sure that including one element at index will make a combination with remaining elements at remaining positions"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = arr . length ; printCombination ( arr , n , r ) ; } }", "nl": "Driver function to check for above function"}
{"code": "import java . io . * ; class Combination {", "nl": "Java program to print all combination of size r in an array of size n"}
{"code": "static void printCombination ( int arr [ ] , int n , int r ) {", "nl": "The main function that prints all combinations of size r in arr [ ] of size n . This function mainly uses combinationUtil ( )"}
{"code": "int data [ ] = new int [ r ] ;", "nl": "A temporary array to store all combination one by one"}
{"code": "combinationUtil ( arr , n , r , 0 , data , 0 ) ; }", "nl": "Print all combination using temprary array ' data [ ] '"}
{"code": "static void combinationUtil ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) {", "nl": "arr [ ] -- -> Input Array data [ ] -- -> Temporary array to store current combination start & end -- -> Staring and Ending indexes in arr [ ] index -- -> Current index in data [ ] r -- -> Size of a combination to be printed"}
{"code": "if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) System . out . print ( data [ j ] + \" \u2581 \" ) ; System . out . println ( \" \" ) ; return ; }", "nl": "Current combination is ready to be printed , print it"}
{"code": "if ( i >= n ) return ;", "nl": "When no more elements are there to put in data [ ]"}
{"code": "data [ index ] = arr [ i ] ; combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) ;", "nl": "current is included , put next at next location"}
{"code": "combinationUtil ( arr , n , r , index , data , i + 1 ) ; }", "nl": "current is excluded , replace it with next ( Note that i + 1 is passed , but index is not changed )"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = arr . length ; printCombination ( arr , n , r ) ; } }", "nl": "Driver function to check for above function"}
{"code": "class FindGroups {", "nl": "Java Program to count all possible groups of size 2 or 3 that have sum as multiple of 3"}
{"code": "int findgroups ( int arr [ ] , int n ) {", "nl": "Returns count of all possible groups that can be formed from elements of a [ ] ."}
{"code": "int c [ ] = new int [ ] { 0 , 0 , 0 } ; int i ;", "nl": "Create an array C [ 3 ] to store counts of elements with remainder 0 , 1 and 2. c [ i ] would store count of elements with remainder i"}
{"code": "int res = 0 ;", "nl": "To store the result"}
{"code": "for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ;", "nl": "Count elements with remainder 0 , 1 and 2"}
{"code": "res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ;", "nl": "Case 3. a : Count groups of size 2 from 0 remainder elements"}
{"code": "res += c [ 1 ] * c [ 2 ] ;", "nl": "Case 3. b : Count groups of size 2 with one element with 1 remainder and other with 2 remainder"}
{"code": "res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ;", "nl": "Case 4. a : Count groups of size 3 with all 0 remainder elements"}
{"code": "res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ;", "nl": "Case 4. b : Count groups of size 3 with all 1 remainder elements"}
{"code": "res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ;", "nl": "Case 4. c : Count groups of size 3 with all 2 remainder elements"}
{"code": "res += c [ 0 ] * c [ 1 ] * c [ 2 ] ;", "nl": "Case 4. c : Count groups of size 3 with different remainders"}
{"code": "return res ; }", "nl": "Return total count stored in res"}
{"code": "public static void main ( String [ ] args ) { FindGroups groups = new FindGroups ( ) ; int arr [ ] = { 3 , 6 , 7 , 2 , 9 } ; int n = arr . length ; System . out . println ( \" Required \u2581 number \u2581 of \u2581 groups \u2581 are \u2581 \" + groups . findgroups ( arr , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG { static int nextPowerOf2 ( int n ) { int count = 0 ;", "nl": "Java program to find smallest power of 2 greater than or equal to n"}
{"code": "if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }", "nl": "First n in the below condition is for the case where n is 0"}
{"code": "public static void main ( String args [ ] ) { int n = 0 ; System . out . println ( nextPowerOf2 ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG { static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; }", "nl": "Java program to find smallest power of 2 greater than or equal to n"}
{"code": "public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( nextPowerOf2 ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find smallest power of 2 greater than or equal to n"}
{"code": "static int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }", "nl": "Finds next power of two for n . If n itself is a power of two then returns n"}
{"code": "public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( nextPowerOf2 ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java code to Segregate 0 s and 1 s in an array"}
{"code": "static void segregate0and1 ( int arr [ ] , int n ) {", "nl": "function to segregate 0 s and 1 s"}
{"code": "int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) count ++ ; }", "nl": "counts the no of zeros in arr"}
{"code": "for ( int i = 0 ; i < count ; i ++ ) arr [ i ] = 0 ;", "nl": "loop fills the arr with 0 until count"}
{"code": "for ( int i = count ; i < n ; i ++ ) arr [ i ] = 1 ; }", "nl": "loop fills remaining arr space with 1"}
{"code": "static void print ( int arr [ ] , int n ) { System . out . print ( \" Array \u2581 after \u2581 segregation \u2581 is \u2581 \" ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }", "nl": "function to print segregated array"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 0 , 1 , 0 , 1 , 1 , 1 } ; int n = arr . length ; segregate0and1 ( arr , n ) ; print ( arr , n ) ; } }", "nl": "driver function"}
{"code": "void segregate0and1 ( int arr [ ] , int size ) {", "nl": "Function to put all 0 s on left and all 1 s on right"}
{"code": "int left = 0 , right = size - 1 ; while ( left < right ) {", "nl": "Initialize left and right indexes"}
{"code": "while ( arr [ left ] == 0 && left < right ) left ++ ;", "nl": "Increment left index while we see 0 at left"}
{"code": "while ( arr [ right ] == 1 && left < right ) right -- ;", "nl": "Decrement right index while we see 1 at right"}
{"code": "if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } }", "nl": "If left is smaller than right then there is a 1 at left and a 0 at right . Exchange arr [ left ] and arr [ right ]"}
{"code": "public static void main ( String [ ] args ) { Segregate seg = new Segregate ( ) ; int arr [ ] = new int [ ] { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_size = arr . length ; seg . segregate0and1 ( arr , arr_size ) ; System . out . print ( \" Array \u2581 after \u2581 segregation \u2581 is \u2581 \" ) ; for ( i = 0 ; i < 6 ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }", "nl": "Driver Program to test above functions"}
{"code": "import java . util . * ; class GFG {", "nl": "Java code to segregate 0 and 1"}
{"code": "static void segregate0and1 ( int arr [ ] ) { int type0 = 0 ; int type1 = arr . length - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type1 ] = arr [ type1 ] + arr [ type0 ] ; arr [ type0 ] = arr [ type1 ] - arr [ type0 ] ; arr [ type1 ] = arr [ type1 ] - arr [ type0 ] ; type1 -- ; } else { type0 ++ ; } } }", "nl": "* Method for segregation 0 and 1 given input array"}
{"code": "public static void main ( String [ ] args ) { int [ ] array = { 0 , 1 , 0 , 1 , 1 , 1 } ; segregate0and1 ( array ) ; for ( int a : array ) { System . out . print ( a + \" \u2581 \" ) ; } } }", "nl": "Driver program"}
{"code": "import java . io . * ; import java . util . HashMap ; import java . util . Map ; class GFG { static void distinctAdjacentElement ( int a [ ] , int n ) {", "nl": "Java program to check if we can make neighbors distinct ."}
{"code": "HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ;", "nl": "map used to count the frequency of each element occurring in the array"}
{"code": "for ( int i = 0 ; i < n ; ++ i ) { if ( m . containsKey ( a [ i ] ) ) { int x = m . get ( a [ i ] ) + 1 ; m . put ( a [ i ] , x ) ; } else { m . put ( a [ i ] , 1 ) ; } }", "nl": "In this loop we count the frequency of element through map m ."}
{"code": "int mx = 0 ;", "nl": "mx store the frequency of element which occurs most in array ."}
{"code": "for ( int i = 0 ; i < n ; ++ i ) if ( mx < m . get ( a [ i ] ) ) mx = m . get ( a [ i ] ) ;", "nl": "In this loop we calculate the maximum frequency and store it in variable mx ."}
{"code": "if ( mx > ( n + 1 ) / 2 ) System . out . println ( \" NO \" ) ; else System . out . println ( \" YES \" ) ; }", "nl": "By swapping we can adjust array only when the frequency of the element which occurs most is less than or equal to ( n + 1 ) / 2 ."}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 7 , 7 , 7 , 7 } ; int n = 4 ; distinctAdjacentElement ( a , n ) ; } }", "nl": "Driver program to test the above function"}
{"code": "class FindMaximum {", "nl": "Java program for the above approach"}
{"code": "int maxIndexDiff ( int arr [ ] , int n ) { int maxDiff = - 1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; }", "nl": "For a given array arr [ ] , returns the maximum j - i such that arr [ j ] > arr [ i ]"}
{"code": "public static void main ( String [ ] args ) { FindMaximum max = new FindMaximum ( ) ; int arr [ ] = { 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 } ; int n = arr . length ; int maxDiff = max . maxIndexDiff ( arr , n ) ; System . out . println ( maxDiff ) ; } }", "nl": "Driver program to test above functions"}
{"code": "import java . util . * ; class GFG { public static void main ( String [ ] args ) { int [ ] v = { 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 } ; int n = v . length ; int [ ] maxFromEnd = new int [ n + 1 ] ; Arrays . fill ( maxFromEnd , Integer . MIN_VALUE ) ;", "nl": "For a given array arr [ ] , calculates the maximum j a i such that arr [ j ] > arr [ i ]"}
{"code": "for ( int i = v . length - 1 ; i >= 0 ; i -- ) { maxFromEnd [ i ] = Math . max ( maxFromEnd [ i + 1 ] , v [ i ] ) ; } int result = 0 ; for ( int i = 0 ; i < v . length ; i ++ ) { int low = i + 1 , high = v . length - 1 , ans = i ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( v [ i ] <= maxFromEnd [ mid ] ) {", "nl": "Create an array maxfromEnd"}
{"code": "ans = Math . max ( ans , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } }", "nl": "We store this as current answer and look for further larger number to the right side"}
{"code": "result = Math . max ( result , ans - i ) ; } System . out . print ( result + \"NEW_LINE\"); } }", "nl": "Keeping a track of the maximum difference in indices"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java implementation of the hashmap approach"}
{"code": "static int maxIndexDiff ( ArrayList < Integer > arr , int n ) {", "nl": "Function to find maximum index difference"}
{"code": "Map < Integer , ArrayList < Integer > > hashmap = new HashMap < Integer , ArrayList < Integer > > ( ) ;", "nl": "Initilaise unordered_map"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( hashmap . containsKey ( arr . get ( i ) ) ) { hashmap . get ( arr . get ( i ) ) . add ( i ) ; } else { hashmap . put ( arr . get ( i ) , new ArrayList < Integer > ( ) ) ; hashmap . get ( arr . get ( i ) ) . add ( i ) ; } }", "nl": "Iterate from 0 to n - 1"}
{"code": "Collections . sort ( arr ) ; int maxDiff = Integer . MIN_VALUE ; int temp = n ;", "nl": "Sort arr"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( temp > hashmap . get ( arr . get ( i ) ) . get ( 0 ) ) { temp = hashmap . get ( arr . get ( i ) ) . get ( 0 ) ; } maxDiff = Math . max ( maxDiff , hashmap . get ( arr . get ( i ) ) . get ( hashmap . get ( arr . get ( i ) ) . size ( ) - 1 ) - temp ) ; } return maxDiff ; }", "nl": "Iterate from 0 to n - 1"}
{"code": "public static void main ( String [ ] args ) { int n = 9 ; ArrayList < Integer > arr = new ArrayList < Integer > ( Arrays . asList ( 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 ) ) ;", "nl": "Driver Code"}
{"code": "int ans = maxIndexDiff ( arr , n ) ; System . out . println ( \" The \u2581 maxIndexDiff \u2581 is \u2581 : \u2581 \" + ans ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; import java . util . * ; public class GFG { static void printRepeating ( Integer [ ] arr , int size ) {", "nl": "Java program to print sorted distinct elements ."}
{"code": "SortedSet < Integer > s = new TreeSet < > ( ) ; Collections . addAll ( s , arr ) ;", "nl": "Create a set using array elements"}
{"code": "System . out . print ( s ) ; }", "nl": "Print contents of the set ."}
{"code": "public static void main ( String args [ ] ) { Integer [ ] arr = { 1 , 3 , 2 , 2 , 1 } ; int n = arr . length ; printRepeating ( arr , n ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ;", "nl": "Java program to make an array same to another using minimum number of swap"}
{"code": "class GFG { static int minSwapsToSort ( int arr [ ] , int n ) {", "nl": "Function returns the minimum number of swaps required to sort the array This method is taken from below post www . geeksforgeeks . org / minimum - number - swaps - required - sort - array / https :"}
{"code": "ArrayList < ArrayList < Integer > > arrPos = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arrPos . add ( new ArrayList < Integer > ( Arrays . asList ( arr [ i ] , i ) ) ) ; }", "nl": "Create an array of pairs where first element is array element and second element is position of first element"}
{"code": "Collections . sort ( arrPos , new Comparator < ArrayList < Integer > > ( ) { @ Override public int compare ( ArrayList < Integer > o1 , ArrayList < Integer > o2 ) { return o1 . get ( 0 ) . compareTo ( o2 . get ( 0 ) ) ; } } ) ;", "nl": "Sort the array by array element values to get right position of every element as second element of pair ."}
{"code": "boolean [ ] vis = new boolean [ n ] ;", "nl": "To keep track of visited elements . Initialize all elements as not visited or false ."}
{"code": "int ans = 0 ;", "nl": "Initialize result"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse array elements"}
{"code": "if ( vis [ i ] || arrPos . get ( i ) . get ( 1 ) == i ) continue ;", "nl": "already swapped and corrected or already present at correct pos"}
{"code": "int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ;", "nl": "find out the number of node in this cycle and add in ans"}
{"code": "j = arrPos . get ( j ) . get ( 1 ) ; cycle_size ++ ; }", "nl": "move to next node"}
{"code": "ans += ( cycle_size - 1 ) ; }", "nl": "Update answer by adding current cycle ."}
{"code": "return ans ; }", "nl": "Return result"}
{"code": "static int minSwapToMakeArraySame ( int a [ ] , int b [ ] , int n ) {", "nl": "method returns minimum number of swap to make array B same as array A"}
{"code": "Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . put ( b [ i ] , i ) ; }", "nl": "map to store position of elements in array B we basically store element to index mapping ."}
{"code": "for ( int i = 0 ; i < n ; i ++ ) b [ i ] = mp . get ( a [ i ] ) ;", "nl": "now we 're storing position of array A elements  in array B."}
{"code": "return minSwapsToSort ( b , n ) ; }", "nl": "returing minimum swap for sorting in modified array B as final answer"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 3 , 6 , 4 , 8 } ; int b [ ] = { 4 , 6 , 8 , 3 } ; int n = a . length ; System . out . println ( minSwapToMakeArraySame ( a , b , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; public class GFG {", "nl": "Java program to check for even or odd"}
{"code": "static int missingK ( int [ ] a , int k , int n ) { int difference = 0 , ans = 0 , count = k ; boolean flag = false ;", "nl": "Function to find k - th missing element"}
{"code": "for ( int i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ;", "nl": "interating over the array"}
{"code": "if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) {", "nl": "check if i - th and ( i + 1 ) - th element are not consecutive"}
{"code": "difference += ( a [ i + 1 ] - a [ i ] ) - 1 ;", "nl": "save their difference"}
{"code": "if ( difference >= count ) { ans = a [ i ] + count ; flag = true ; break ; } else count -= difference ; } }", "nl": "check for difference and given k"}
{"code": "if ( flag ) return ans ; else return - 1 ; }", "nl": "if found"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver code"}
{"code": "int [ ] a = { 1 , 5 , 11 , 19 } ;", "nl": "Input array"}
{"code": "int k = 11 ; int n = a . length ;", "nl": "k - th missing element to be found in the array"}
{"code": "int missing = missingK ( a , k , n ) ; System . out . print ( missing ) ; } }", "nl": "calling function to find missing element"}
{"code": "public class GFG {", "nl": "Java program for above approach"}
{"code": "static int missingK ( int [ ] arr , int k ) { int n = arr . length ; int l = 0 , u = n - 1 , mid ; while ( l <= u ) { mid = ( l + u ) / 2 ; int numbers_less_than_mid = arr [ mid ] - ( mid + 1 ) ;", "nl": "Function to find kth missing number"}
{"code": "if ( numbers_less_than_mid == k ) {", "nl": "If the total missing number count is equal to k we can iterate backwards for the first missing number and that will be the answer ."}
{"code": "if ( mid > 0 && ( arr [ mid - 1 ] - ( mid ) ) == k ) { u = mid - 1 ; continue ; }", "nl": "To further optimize we check if the previous element ' s \u2581 \u2581 missing \u2581 number \u2581 count \u2581 is \u2581 equal \u2581 \u2581 to \u2581 k . \u2581 Eg : \u2581 arr \u2581 = \u2581 [ 4,5,6,7,8 ] \u2581 \u2581 If \u2581 you \u2581 observe \u2581 in \u2581 the \u2581 example \u2581 array , \u2581 \u2581 the \u2581 total \u2581 count \u2581 of \u2581 missing \u2581 numbers \u2581 for \u2581 all \u2581 \u2581 the \u2581 indices \u2581 are \u2581 same , \u2581 and \u2581 we \u2581 are \u2581 \u2581 aiming \u2581 to \u2581 narrow \u2581 down \u2581 the \u2581 \u2581 search \u2581 window \u2581 and \u2581 achieve \u2581 O ( logn ) \u2581 \u2581 time \u2581 complexity \u2581 which \u2581 \u2581 otherwise \u2581 would ' ve been O ( n ) ."}
{"code": "return arr [ mid ] - 1 ; }", "nl": "Else we return arr [ mid ] - 1."}
{"code": "if ( numbers_less_than_mid < k ) { l = mid + 1 ; } else if ( k < numbers_less_than_mid ) { u = mid - 1 ; } }", "nl": "Here we appropriately narrow down the search window ."}
{"code": "if ( u < 0 ) return k ;", "nl": "In case the upper limit is - ve it means the missing number set is 1 , 2 , . . , k and hence we directly return k ."}
{"code": "int less = arr [ u ] - ( u + 1 ) ; k -= less ;", "nl": "Else we find the residual count of numbers which we 'd then add to  arr[u] and get the missing kth number."}
{"code": "return arr [ u ] + k ; }", "nl": "Return arr [ u ] + k"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 7 , 11 } ; int k = 5 ;", "nl": "Driver code"}
{"code": "System . out . println ( \" Missing \u2581 kth \u2581 number \u2581 = \u2581 \" + missingK ( arr , k ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to rearrange nodes as alternate odd even nodes in a Singly Linked List"}
{"code": "static class Node { int data ; Node next ; }", "nl": "class node"}
{"code": "static void printList ( Node node ) { while ( node != null ) { System . out . print ( node . data + \" \u2581 \" ) ; node = node . next ; } System . out . println ( ) ; }", "nl": "A utility function to print linked list"}
{"code": "static Node newNode ( int key ) { Node temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; }", "nl": "Function to create newNode in a linkedlist"}
{"code": "static Node insertBeg ( Node head , int val ) { Node temp = newNode ( val ) ; temp . next = head ; head = temp ; return head ; }", "nl": "Function to insert at beginning"}
{"code": "static void rearrangeOddEven ( Node head ) { Stack < Node > odd = new Stack < Node > ( ) ; Stack < Node > even = new Stack < Node > ( ) ; int i = 1 ; while ( head != null ) { if ( head . data % 2 != 0 && i % 2 == 0 ) {", "nl": "Function to rearrange the odd and even nodes"}
{"code": "odd . push ( head ) ; } else if ( head . data % 2 == 0 && i % 2 != 0 ) {", "nl": "Odd Value in Even Position Add pointer to current node in odd stack"}
{"code": "even . push ( head ) ; } head = head . next ; i ++ ; } while ( odd . size ( ) > 0 && even . size ( ) > 0 ) {", "nl": "Even Value in Odd Position Add pointer to current node in even stack"}
{"code": "int k = odd . peek ( ) . data ; odd . peek ( ) . data = even . peek ( ) . data ; even . peek ( ) . data = k ; odd . pop ( ) ; even . pop ( ) ; } }", "nl": "Swap Data at the top of two stacks"}
{"code": "public static void main ( String args [ ] ) { Node head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 1 ) ; System . out . println ( \" Linked \u2581 List : \" ) ; printList ( head ) ; rearrangeOddEven ( head ) ; System . out . println ( \" Linked \u2581 List \u2581 after \u2581 \" + \" Rearranging : \" ) ; printList ( head ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to rearrange nodes as alternate odd even nodes in a Singly Linked List"}
{"code": "static class Node { int data ; Node next ; } ;", "nl": "Structure node"}
{"code": "static void printList ( Node node ) { while ( node != null ) { System . out . print ( node . data + \" \u2581 \" ) ; node = node . next ; } System . out . println ( ) ; }", "nl": "A utility function to print linked list"}
{"code": "static Node newNode ( int key ) { Node temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; }", "nl": "Function to create newNode in a linkedlist"}
{"code": "static Node insertBeg ( Node head , int val ) { Node temp = newNode ( val ) ; temp . next = head ; head = temp ; return head ; }", "nl": "Function to insert at beginning"}
{"code": "static Node rearrange ( Node head ) {", "nl": "Function to rearrange the odd and even nodes"}
{"code": "Node even ; Node temp , prev_temp ; Node i , j , k , l , ptr = null ;", "nl": "Step 1 : Segregate even and odd nodes Step 2 : Split odd and even lists Step 3 : Merge even list into odd list"}
{"code": "temp = ( head ) . next ; prev_temp = head ; while ( temp != null ) {", "nl": "Step 1 : Segregate Odd and Even Nodes"}
{"code": "Node x = temp . next ;", "nl": "Backup next pointer of temp"}
{"code": "if ( temp . data % 2 != 0 ) { prev_temp . next = x ; temp . next = ( head ) ; ( head ) = temp ; } else { prev_temp = temp ; }", "nl": "If temp is odd move the node to beginning of list"}
{"code": "temp = x ; }", "nl": "Advance Temp Pointer"}
{"code": "temp = ( head ) . next ; prev_temp = ( head ) ; while ( temp != null && temp . data % 2 != 0 ) { prev_temp = temp ; temp = temp . next ; } even = temp ;", "nl": "Step 2 Split the List into Odd and even"}
{"code": "prev_temp . next = null ;", "nl": "End the odd List ( Make last node null )"}
{"code": "i = head ; j = even ; while ( j != null && i != null ) {", "nl": "Step 3 : Merge Even List into odd"}
{"code": "k = i . next ; l = j . next ; i . next = j ; j . next = k ;", "nl": "While both lists are not exhausted Backup next pointers of i and j"}
{"code": "ptr = j ;", "nl": "ptr points to the latest node added"}
{"code": "i = k ; j = l ; } if ( i == null ) {", "nl": "Advance i and j pointers"}
{"code": "ptr . next = j ; }", "nl": "Odd list exhausts before even , append remainder of even list to odd ."}
{"code": "return head ; }", "nl": "The case where even list exhausts before odd list is automatically handled since we merge the even list into the odd list"}
{"code": "public static void main ( String args [ ] ) { Node head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 1 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 10 ) ; System . out . println ( \" Linked \u2581 List : \" ) ; printList ( head ) ; System . out . println ( \" Rearranged \u2581 List \" ) ; head = rearrange ( head ) ; printList ( head ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG {", "nl": "Java program for the above approach"}
{"code": "static void print ( int mat [ ] [ ] ) {", "nl": "Function to print the matrix"}
{"code": "for ( int i = 0 ; i < mat . length ; i ++ ) {", "nl": "Iterate over the rows"}
{"code": "for ( int j = 0 ; j < mat [ 0 ] . length ; j ++ )", "nl": "Iterate over the columns"}
{"code": "System . out . print ( mat [ i ] [ j ] + \" \u2581 \" ) ; System . out . println ( ) ; } }", "nl": "Print the value"}
{"code": "static void performSwap ( int mat [ ] [ ] , int i , int j ) { int N = mat . length ;", "nl": "Function to perform the swapping of matrix elements in clockwise manner"}
{"code": "int ei = N - 1 - i ;", "nl": "Stores the last row"}
{"code": "int ej = N - 1 - j ;", "nl": "Stores the last column"}
{"code": "int temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ ej ] [ i ] ; mat [ ej ] [ i ] = mat [ ei ] [ ej ] ; mat [ ei ] [ ej ] = mat [ j ] [ ei ] ; mat [ j ] [ ei ] = temp ; }", "nl": "Perform the swaps"}
{"code": "static void rotate ( int mat [ ] [ ] , int N , int K ) {", "nl": "Function to rotate non - diagonal elements of the matrix K times in clockwise direction"}
{"code": "K = K % 4 ;", "nl": "Update K to K % 4"}
{"code": "while ( K -- > 0 ) {", "nl": "Iterate until K is positive"}
{"code": "for ( int i = 0 ; i < N / 2 ; i ++ ) {", "nl": "Iterate each up to N / 2 - th row"}
{"code": "for ( int j = i ; j < N - i - 1 ; j ++ ) {", "nl": "Iterate each column from i to N - i - 1"}
{"code": "if ( i != j && ( i + j ) != N - 1 ) {", "nl": "Check if the element at i , j is not a diagonal element"}
{"code": "performSwap ( mat , i , j ) ; } } } }", "nl": "Perform the swapping"}
{"code": "print ( mat ) ; }", "nl": "Print the matrix"}
{"code": "public static void main ( String [ ] args ) { int K = 5 ; int mat [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 6 , 7 , 8 , 9 } , { 11 , 12 , 13 , 14 } , { 16 , 17 , 18 , 19 } , } ; int N = mat . length ; rotate ( mat , N , K ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to determine minimum number of rotations required to yield same string ."}
{"code": "static int findRotations ( String str ) {", "nl": "Returns count of rotations to get the same string back ."}
{"code": "String tmp = str + str ; int n = str . length ( ) ; for ( int i = 1 ; i <= n ; i ++ ) {", "nl": "tmp is the concatenated string ."}
{"code": "String substring = tmp . substring ( i , i + str . length ( ) ) ;", "nl": "substring from i index of original string size ."}
{"code": "if ( str . equals ( substring ) ) return i ; } return n ; }", "nl": "if substring matches with original string then we will come out of the loop ."}
{"code": "public static void main ( String [ ] args ) { String str = \" aaaa \" ; System . out . println ( findRotations ( str ) ) ; } }", "nl": "Driver Method"}
{"code": "import java . util . * ; class GFG { static final int MAX = 10000 ;", "nl": "Java implementation to find elements that are a power of two"}
{"code": "static int [ ] prefix = new int [ MAX + 1 ] ; static boolean isPowerOfTwo ( int x ) { if ( x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ) return true ; return false ; }", "nl": "prefix [ i ] is going to store the number of elements which are a power of two till i ( including i ) ."}
{"code": "static void computePrefix ( int n , int a [ ] ) {", "nl": "Function to find the maximum range whose sum is divisible by M ."}
{"code": "if ( isPowerOfTwo ( a [ 0 ] ) ) prefix [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] ; if ( isPowerOfTwo ( a [ i ] ) ) prefix [ i ] ++ ; } }", "nl": "Calculate the prefix sum"}
{"code": "static int query ( int L , int R ) { if ( L == 0 ) return prefix [ R ] ; return prefix [ R ] - prefix [ L - 1 ] ; }", "nl": "Function to return the number of elements which are a power of two in a subarray"}
{"code": "public static void main ( String [ ] args ) { int A [ ] = { 3 , 8 , 5 , 2 , 5 , 10 } ; int N = A . length ; int Q = 2 ; computePrefix ( N , A ) ; System . out . println ( query ( 0 , 4 ) ) ; System . out . println ( query ( 3 , 5 ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) { System . out . println ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) ; }", "nl": "Function to calculate the integral points inside a square"}
{"code": "public static void main ( String args [ ] ) { int x1 = 1 , y1 = 1 ; int x2 = 4 , y2 = 4 ; countIntgralPoints ( x1 , y1 , x2 , y2 ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation to find the next distinct digits number"}
{"code": "static void findNextNumber ( int n ) { int h [ ] = new int [ 10 ] ; int i = 0 , msb = n , rem = 0 ; int next_num = - 1 , count = 0 ;", "nl": "Function to find the next distinct digits number"}
{"code": "while ( msb > 9 ) { rem = msb % 10 ; h [ rem ] = 1 ; msb /= 10 ; count ++ ; } h [ msb ] = 1 ; count ++ ;", "nl": "Loop to find the distinct digits using hash array and the number of digits"}
{"code": "for ( i = msb + 1 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; break ; } }", "nl": "Loop to find the most significant distinct digit of the next number"}
{"code": "if ( next_num == - 1 ) { for ( i = 1 ; i < msb ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; count ++ ; break ; } } }", "nl": "Condition to check if the number is possible with the same number of digits count"}
{"code": "if ( next_num > 0 ) {", "nl": "Condition to check if the desired most siginificant distinct digit is found"}
{"code": "for ( i = 0 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { msb = i ; break ; } }", "nl": "Loop to find the minimum next digit which is not present in the number"}
{"code": "for ( i = 1 ; i < count ; i ++ ) { next_num = ( ( next_num * 10 ) + msb ) ; }", "nl": "Computation of the number"}
{"code": "if ( next_num > n ) System . out . print ( next_num + \"NEW_LINE\"); else System . out . print ( \"Not Possible NEW_LINE\"); } else { System . out . print ( \"Not Possible NEW_LINE\"); } }", "nl": "Condition to check if the number is greater than the given number"}
{"code": "public static void main ( String [ ] args ) { int n = 2019 ; findNextNumber ( n ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void CalculateValues ( int N ) { int A = 0 , B = 0 , C = 0 ;", "nl": "Function to find a triplet ( A , B , C ) such that 3 * A + 5 * B + 7 * C is N"}
{"code": "for ( C = 0 ; C < N / 7 ; C ++ ) {", "nl": "Iterate over the range [ 0 , N7 ]"}
{"code": "for ( B = 0 ; B < N / 5 ; B ++ ) {", "nl": "Iterate over the range [ 0 , N5 ]"}
{"code": "A = N - 7 * C - 5 * B ;", "nl": "Find the value of A"}
{"code": "if ( A >= 0 && A % 3 == 0 ) { System . out . print ( \" A \u2581 = \u2581 \" + A / 3 + \" , \u2581 B \u2581 = \u2581 \" + B + \" , \u2581 C \u2581 = \u2581 \" + C ) ; return ; } } }", "nl": "If A is greater than or equal to 0 and divisible by 3"}
{"code": "System . out . println ( - 1 ) ; }", "nl": "Otherwise , print - 1"}
{"code": "public static void main ( String [ ] args ) { int N = 19 ; CalculateValues ( 19 ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void minimumTime ( int [ ] arr , int n ) {", "nl": "Function to find the minimum time to visit all the cities such that both the person never meets"}
{"code": "int sum = 0 ;", "nl": "Initialize sum as 0"}
{"code": "int T = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ;", "nl": "Find the maximum element"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse the array"}
{"code": "sum += arr [ i ] ; }", "nl": "Increment sum by arr [ i ]"}
{"code": "System . out . println ( Math . max ( 2 * T , sum ) ) ; }", "nl": "Print maximum of 2 * T and sum"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 8 , 3 } ; int N = arr . length ;", "nl": "Driver code"}
{"code": "minimumTime ( arr , N ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void lexicographicallyMax ( String s ) {", "nl": "Function to find the lexicographically maximum string by reversing substrings having even numbers of 1 s"}
{"code": "int n = s . length ( ) ;", "nl": "Store size of string"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse the string"}
{"code": "int count = 0 ;", "nl": "Count the number of 1 s"}
{"code": "int beg = i ;", "nl": "Stores the starting index"}
{"code": "int end = i ;", "nl": "Stores the end index"}
{"code": "if ( s . charAt ( i ) == '1' ) count ++ ;", "nl": "Increment count , when 1 is encountered"}
{"code": "for ( int j = i + 1 ; j < n ; j ++ ) { if ( s . charAt ( j ) == '1' ) count ++ ; if ( count % 2 == 0 && count != 0 ) { end = j ; break ; } }", "nl": "Traverse the remaining string"}
{"code": "s = reverse ( s , beg , end + 1 ) ; }", "nl": "Reverse the string from starting and end index"}
{"code": "System . out . println ( s ) ; } static String reverse ( String s , int beg , int end ) { StringBuilder x = new StringBuilder ( \" \" ) ; for ( int i = 0 ; i < beg ; i ++ ) x . append ( s . charAt ( i ) ) ; for ( int i = end - 1 ; i >= beg ; i -- ) x . append ( s . charAt ( i ) ) ; for ( int i = end ; i < s . length ( ) ; i ++ ) x . append ( s . charAt ( i ) ) ; return x . toString ( ) ; }", "nl": "Printing the string"}
{"code": "public static void main ( String args [ ] ) { String S = \"0101\" ; lexicographicallyMax ( S ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static void maxPairs ( int [ ] nums , int k ) {", "nl": "Function to count the maximum number of pairs from given array with sum K"}
{"code": "Arrays . sort ( nums ) ;", "nl": "Sort array in increasing order"}
{"code": "int result = 0 ;", "nl": "Stores the final result"}
{"code": "int start = 0 , end = nums . length - 1 ;", "nl": "Initialize the left and right pointers"}
{"code": "while ( start < end ) { if ( nums [ start ] + nums [ end ] > k )", "nl": "Traverse array until start < end"}
{"code": "end -- ; else if ( nums [ start ] + nums [ end ] < k )", "nl": "Decrement right by 1"}
{"code": "start ++ ;", "nl": "Increment left by 1"}
{"code": "else { start ++ ; end -- ; result ++ ; } }", "nl": "Increment result and left pointer by 1 and decrement right pointer by 1"}
{"code": "System . out . println ( result ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int K = 5 ;", "nl": "Driver Code"}
{"code": "maxPairs ( arr , K ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static void maxPairs ( int [ ] nums , int k ) {", "nl": "Function to find the maximum number of pairs with a sum K such that same element can 't be used twice"}
{"code": "Map < Integer , Integer > map = new HashMap < > ( ) ;", "nl": "Initialize a hashmap"}
{"code": "int result = 0 ;", "nl": "Store the final result"}
{"code": "for ( int i : nums ) {", "nl": "Iterate over the array nums [ ]"}
{"code": "if ( map . containsKey ( i ) && map . get ( i ) > 0 ) { map . put ( i , map . get ( i ) - 1 ) ; result ++ ; }", "nl": "Decrement its frequency in map and increment the result by 1"}
{"code": "else { map . put ( k - i , map . getOrDefault ( k - i , 0 ) + 1 ) ; } }", "nl": "Increment its frequency by 1 if it is already present in map . Otherwise , set its frequency to 1"}
{"code": "System . out . println ( result ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int K = 5 ;", "nl": "Driver Code"}
{"code": "maxPairs ( arr , K ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void removeIndicesToMakeSumEqual ( int [ ] arr ) {", "nl": "Function to find indices of array elements whose removal makes the sum of odd and even indexed array elements equal"}
{"code": "int N = arr . length ;", "nl": "Stores size of array"}
{"code": "int [ ] odd = new int [ N ] ;", "nl": "Store prefix sum of odd index array elements"}
{"code": "int [ ] even = new int [ N ] ;", "nl": "Store prefix sum of even index array elements"}
{"code": "even [ 0 ] = arr [ 0 ] ;", "nl": "Update even [ 0 ]"}
{"code": "for ( int i = 1 ; i < N ; i ++ ) {", "nl": "Traverse the given array"}
{"code": "odd [ i ] = odd [ i - 1 ] ;", "nl": "Update odd [ i ]"}
{"code": "even [ i ] = even [ i - 1 ] ;", "nl": "Update even [ i ]"}
{"code": "if ( i % 2 == 0 ) {", "nl": "If the current index is an even number"}
{"code": "even [ i ] += arr [ i ] ; }", "nl": "Update even [ i ]"}
{"code": "else {", "nl": "If the current index is an odd number"}
{"code": "odd [ i ] += arr [ i ] ; } }", "nl": "Update odd [ i ]"}
{"code": "boolean find = false ;", "nl": "Check if at least one index found or not that satisfies the condition"}
{"code": "int p = odd [ N - 1 ] ;", "nl": "Store odd indices sum by removing 0 - th index"}
{"code": "int q = even [ N - 1 ] - arr [ 0 ] ;", "nl": "Store even indices sum by removing 0 - th index"}
{"code": "if ( p == q ) { System . out . print ( \"0 \u2581 \" ) ; find = true ; }", "nl": "If p and q are equal"}
{"code": "for ( int i = 1 ; i < N ; i ++ ) {", "nl": "Traverse the array arr [ ]"}
{"code": "if ( i % 2 == 0 ) {", "nl": "If i is an even number"}
{"code": "p = even [ N - 1 ] - even [ i - 1 ] - arr [ i ] + odd [ i - 1 ] ;", "nl": "Update p by removing the i - th element"}
{"code": "q = odd [ N - 1 ] - odd [ i - 1 ] + even [ i - 1 ] ; } else {", "nl": "Update q by removing the i - th element"}
{"code": "q = odd [ N - 1 ] - odd [ i - 1 ] - arr [ i ] + even [ i - 1 ] ;", "nl": "Update q by removing the i - th element"}
{"code": "p = even [ N - 1 ] - even [ i - 1 ] + odd [ i - 1 ] ; }", "nl": "Update p by removing the i - th element"}
{"code": "if ( p == q ) {", "nl": "If odd index values sum is equal to even index values sum"}
{"code": "find = true ;", "nl": "Set the find variable"}
{"code": "System . out . print ( i + \" \u2581 \" ) ; } }", "nl": "Print the current index"}
{"code": "if ( ! find ) {", "nl": "If no index found"}
{"code": "System . out . print ( - 1 ) ; } }", "nl": "Print not possible"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 4 , 1 , 6 , 2 } ; removeIndicesToMakeSumEqual ( arr ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void min_element_removal ( int arr [ ] , int N ) {", "nl": "Function to coutnt minimum array elements required to be removed to make an array bitonic"}
{"code": "int left [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) left [ i ] = 1 ;", "nl": "left [ i ] : Stores the length of LIS up to i - th index"}
{"code": "int right [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) right [ i ] = 1 ;", "nl": "right [ i ] : Stores the length of decreasing subsequence over the range [ i , N ]"}
{"code": "for ( int i = 1 ; i < N ; i ++ ) {", "nl": "Calculate the length of LIS up to i - th index"}
{"code": "for ( int j = 0 ; j < i ; j ++ ) {", "nl": "Traverse the array upto i - th index"}
{"code": "if ( arr [ j ] < arr [ i ] ) {", "nl": "If arr [ j ] is less than arr [ i ]"}
{"code": "left [ i ] = Math . max ( left [ i ] , left [ j ] + 1 ) ; } } }", "nl": "Update left [ i ]"}
{"code": "for ( int i = N - 2 ; i >= 0 ; i -- ) {", "nl": "Calculate the length of decreasing subsequence over the range [ i , N ]"}
{"code": "for ( int j = N - 1 ; j > i ; j -- ) {", "nl": "Traverse right [ ] array"}
{"code": "if ( arr [ i ] > arr [ j ] ) {", "nl": "If arr [ i ] is greater than arr [ j ]"}
{"code": "right [ i ] = Math . max ( right [ i ] , right [ j ] + 1 ) ; } } }", "nl": "Update right [ i ]"}
{"code": "int maxLen = 0 ;", "nl": "Stores length of the longest bitonic array"}
{"code": "for ( int i = 1 ; i < N - 1 ; i ++ ) {", "nl": "Traverse left [ ] and right [ ] array"}
{"code": "maxLen = Math . max ( maxLen , left [ i ] + right [ i ] - 1 ) ; } System . out . println ( N - maxLen ) ; }", "nl": "Update maxLen"}
{"code": "static void makeBitonic ( int arr [ ] , int N ) { if ( N == 1 ) { System . out . println ( \"0\" ) ; return ; } if ( N == 2 ) { if ( arr [ 0 ] != arr [ 1 ] ) System . out . println ( \"0\" ) ; else System . out . println ( \"1\" ) ; return ; } min_element_removal ( arr , N ) ; }", "nl": "Function to print minimum removals required to make given array bitonic"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 1 , 5 , 6 , 2 , 3 , 1 } ; int N = arr . length ; makeBitonic ( arr , N ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void countSubarrays ( int A [ ] , int N ) {", "nl": "Function to count subarrays having equal count of 0 s and 1 s with all 0 s and all 1 s grouped together"}
{"code": "int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) {", "nl": "Stores the count of subarrays"}
{"code": "if ( A [ i ] != A [ i + 1 ] ) {", "nl": "If current element is different from the next array element"}
{"code": "ans ++ ;", "nl": "Increment count"}
{"code": "for ( int j = i - 1 , k = i + 2 ; j >= 0 && k < N && A [ j ] == A [ i ] && A [ k ] == A [ i + 1 ] ; j -- , k ++ ) {", "nl": "Count the frequency of 1 s and 0 s"}
{"code": "ans ++ ; } } }", "nl": "Increment count"}
{"code": "System . out . print ( ans + \"NEW_LINE\"); }", "nl": "Print the final count"}
{"code": "public static void main ( String [ ] args ) { int A [ ] = { 1 , 1 , 0 , 0 , 1 , 0 } ; int N = A . length ;", "nl": "Driver Code"}
{"code": "countSubarrays ( A , N ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG { static int maxN = 2002 ;", "nl": "Java program of the above approach"}
{"code": "static int [ ] [ ] lcount = new int [ maxN ] [ maxN ] ;", "nl": "lcount [ i ] [ j ] : Stores the count of i on left of index j"}
{"code": "static int [ ] [ ] rcount = new int [ maxN ] [ maxN ] ;", "nl": "rcount [ i ] [ j ] : Stores the count of i on right of index j"}
{"code": "static void fill_counts ( int a [ ] , int n ) { int i , j ;", "nl": "Function to count unique elements on left and right of any index"}
{"code": "int maxA = a [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > maxA ) { maxA = a [ i ] ; } } for ( i = 0 ; i < n ; i ++ ) { lcount [ a [ i ] ] [ i ] = 1 ; rcount [ a [ i ] ] [ i ] = 1 ; } for ( i = 0 ; i <= maxA ; i ++ ) {", "nl": "Find the maximum array element"}
{"code": "for ( j = 1 ; j < n ; j ++ ) { lcount [ i ] [ j ] = lcount [ i ] [ j - 1 ] + lcount [ i ] [ j ] ; }", "nl": "Calculate prefix sum of counts of each value"}
{"code": "for ( j = n - 2 ; j >= 0 ; j -- ) { rcount [ i ] [ j ] = rcount [ i ] [ j + 1 ] + rcount [ i ] [ j ] ; } } }", "nl": "Calculate suffix sum of counts of each value"}
{"code": "static int countSubsequence ( int a [ ] , int n ) { int i , j ; fill_counts ( a , n ) ; int answer = 0 ; for ( i = 1 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n - 1 ; j ++ ) { answer += lcount [ a [ j ] ] [ i - 1 ] * rcount [ a [ i ] ] [ j + 1 ] ; } } return answer ; }", "nl": "Function to count quadruples of the required type"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 2 , 1 , 3 , 2 } ; System . out . print ( countSubsequence ( a , a . length ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static String removeOuterParentheses ( String S ) {", "nl": "Function to remove the outermost parentheses of every primitive substring from the given string"}
{"code": "String res = \" \" ;", "nl": "Stores the resultant string"}
{"code": "int count = 0 ;", "nl": "Stores the count of opened parentheses"}
{"code": "for ( int c = 0 ; c < S . length ( ) ; c ++ ) {", "nl": "Traverse the string"}
{"code": "if ( S . charAt ( c ) == ' ( ' && count ++ > 0 )", "nl": "If opening parenthesis is encountered and their count exceeds 0"}
{"code": "res += S . charAt ( c ) ;", "nl": "Include the character"}
{"code": "if ( S . charAt ( c ) == ' ) ' && count -- > 1 )", "nl": "If closing parenthesis is encountered and their count is less than count of opening parentheses"}
{"code": "res += S . charAt ( c ) ; }", "nl": "Include the character"}
{"code": "return res ; }", "nl": "Return the resultant string"}
{"code": "public static void main ( String [ ] args ) { String S = \" ( ( ) ( ) ) ( ( ) ) ( ) \" ; System . out . print ( removeOuterParentheses ( S ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation for the above approach"}
{"code": "public static int maxiConsecutiveSubarray ( int arr [ ] , int N ) {", "nl": "Function to find the longest subarray with increasing contiguous elements"}
{"code": "int maxi = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) {", "nl": "Stores the length of required longest subarray"}
{"code": "int cnt = 1 , j ; for ( j = i ; j < N - 1 ; j ++ ) {", "nl": "Stores the length of length of longest such subarray from ith index"}
{"code": "if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; }", "nl": "If consecutive elements are increasing and differ by 1"}
{"code": "else { break ; } }", "nl": "Otherwise"}
{"code": "maxi = Math . max ( maxi , cnt ) ; i = j ; }", "nl": "Update the longest subarray obtained so far"}
{"code": "return maxi ; }", "nl": "Return the length obtained"}
{"code": "public static void main ( String args [ ] ) { int N = 11 ; int arr [ ] = { 1 , 3 , 4 , 2 , 3 , 4 , 2 , 3 , 5 , 6 , 7 } ; System . out . println ( maxiConsecutiveSubarray ( arr , N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static int N = 100005 ;", "nl": "Java implementation of the above approach"}
{"code": "static void SieveOfEratosthenes ( boolean [ ] prime , int p_size ) {", "nl": "Function to generate prime numbers using Sieve of Eratosthenes"}
{"code": "prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) {", "nl": "Set 0 and 1 as non - prime"}
{"code": "if ( prime [ p ] ) {", "nl": "If p is a prime"}
{"code": "for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }", "nl": "Set all multiples of p as non - prime"}
{"code": "static int digitSum ( int number ) {", "nl": "Function to find the digit sum of a given number"}
{"code": "int sum = 0 ; while ( number > 0 ) {", "nl": "Stores the sum of digits"}
{"code": "sum += ( number % 10 ) ; number /= 10 ; }", "nl": "Extract digits and add to the sum"}
{"code": "return sum ; }", "nl": "Return the sum of the digits"}
{"code": "static void longestCompositeDigitSumSubsequence ( int [ ] arr , int n ) { int count = 0 ; boolean [ ] prime = new boolean [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , N ) ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Function to find the longest subsequence with sum of digits of each element equal to a composite number"}
{"code": "int res = digitSum ( arr [ i ] ) ;", "nl": "Calculate sum of digits of current array element"}
{"code": "if ( res == 1 ) { continue ; }", "nl": "If sum of digits equal to 1"}
{"code": "if ( prime [ res ] == false ) { count ++ ; } } System . out . println ( count ) ; }", "nl": "If sum of digits is a prime"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 13 , 55 , 7 , 3 , 5 , 1 , 10 , 21 , 233 , 144 , 89 } ; int n = arr . length ;", "nl": "Driver Code"}
{"code": "longestCompositeDigitSumSubsequence ( arr , n ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG { static int sum ;", "nl": "Java program for the above approach"}
{"code": "static class Node { int data ; Node left , right ; } ;", "nl": "Structure of Binary Tree"}
{"code": "static Node newnode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . left = null ; temp . right = null ;", "nl": "Function to create a new node"}
{"code": "return temp ; }", "nl": "Return the created node"}
{"code": "static Node insert ( String s , int i , int N , Node root , Node temp ) { if ( i == N ) return temp ;", "nl": "Function to insert a node in the tree"}
{"code": "if ( s . charAt ( i ) == ' L ' ) root . left = insert ( s , i + 1 , N , root . left , temp ) ;", "nl": "Left insertion"}
{"code": "else root . right = insert ( s , i + 1 , N , root . right , temp ) ;", "nl": "Right insertion"}
{"code": "return root ; }", "nl": "Return the root node"}
{"code": "static int SBTUtil ( Node root ) {", "nl": "Function to find sum of specially balanced nodes in the Tree"}
{"code": "if ( root == null ) return 0 ; if ( root . left == null && root . right == null ) return root . data ;", "nl": "Base Case"}
{"code": "int left = SBTUtil ( root . left ) ;", "nl": "Find the left subtree sum"}
{"code": "int right = SBTUtil ( root . right ) ;", "nl": "Find the right subtree sum"}
{"code": "if ( root . left != null && root . right != null ) {", "nl": "Condition of specially balanced node"}
{"code": "if ( ( left % 2 == 0 && right % 2 != 0 ) || ( left % 2 != 0 && right % 2 == 0 ) ) { sum += root . data ; } }", "nl": "Condition of specially balanced node"}
{"code": "return left + right + root . data ; }", "nl": "Return the sum"}
{"code": "static Node build_tree ( int R , int N , String str [ ] , int values [ ] ) {", "nl": "Function to build the binary tree"}
{"code": "Node root = newnode ( R ) ; int i ;", "nl": "Form root node of the tree"}
{"code": "for ( i = 0 ; i < N - 1 ; i ++ ) { String s = str [ i ] ; int x = values [ i ] ;", "nl": "Insert nodes into tree"}
{"code": "Node temp = newnode ( x ) ;", "nl": "Create a new Node"}
{"code": "root = insert ( s , 0 , s . length ( ) , root , temp ) ; }", "nl": "Insert the node"}
{"code": "return root ; }", "nl": "Return the root of the Tree"}
{"code": "static void speciallyBalancedNodes ( int R , int N , String str [ ] , int values [ ] ) {", "nl": "Function to find the sum of specially balanced nodes"}
{"code": "Node root = build_tree ( R , N , str , values ) ;", "nl": "Build Tree"}
{"code": "sum = 0 ;", "nl": "Stores the sum of specially balanced node"}
{"code": "SBTUtil ( root ) ;", "nl": "Function Call"}
{"code": "System . out . print ( sum + \" \u2581 \" ) ; }", "nl": "Print required sum"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 7 ;", "nl": "Given nodes"}
{"code": "int R = 12 ;", "nl": "Given root"}
{"code": "String str [ ] = { \" L \" , \" R \" , \" RL \" , \" RR \" , \" RLL \" , \" RLR \" } ;", "nl": "Given path info of nodes from root"}
{"code": "int values [ ] = { 17 , 16 , 4 , 9 , 2 , 3 } ;", "nl": "Given node values"}
{"code": "speciallyBalancedNodes ( R , N , str , values ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void position ( int arr [ ] [ ] , int N ) {", "nl": "Function to find the position of the pair that covers every pair in the array arr [ ] [ ]"}
{"code": "int pos = - 1 ;", "nl": "Stores the index of the resultant pair"}
{"code": "int count ;", "nl": "To count the occurences"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Iterate to check every pair"}
{"code": "count = 0 ; for ( int j = 0 ; j < N ; j ++ ) {", "nl": "Set count to 0"}
{"code": "if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] && arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) { count ++ ; } }", "nl": "Condition to checked for overlapping of pairs"}
{"code": "if ( count == N ) { pos = i ; } }", "nl": "If that pair can cover all other pairs then store its position"}
{"code": "if ( pos == - 1 ) { System . out . print ( pos ) ; }", "nl": "If position not found"}
{"code": "else { System . out . print ( pos + 1 ) ; } }", "nl": "Otherwise"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int arr [ ] [ ] = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = arr . length ;", "nl": "Given array of pairs"}
{"code": "position ( arr , N ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void position ( int arr [ ] [ ] , int N ) {", "nl": "Function to find the position of the pair that covers every pair in the array arr [ ] [ ]"}
{"code": "int pos = - 1 ;", "nl": "Position to store the index"}
{"code": "int right = Integer . MIN_VALUE ;", "nl": "Stores the maximum second value"}
{"code": "int left = Integer . MAX_VALUE ;", "nl": "Stores the minimum first value"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Iterate over the array of pairs"}
{"code": "if ( arr [ i ] [ 1 ] > right ) { right = arr [ i ] [ 1 ] ; }", "nl": "Update right maximum"}
{"code": "if ( arr [ i ] [ 0 ] < left ) { left = arr [ i ] [ 0 ] ; } }", "nl": "Update left minimum"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Iterate over the array of pairs"}
{"code": "if ( arr [ i ] [ 0 ] == left && arr [ i ] [ 1 ] == right ) { pos = i + 1 ; } }", "nl": "If any pair exists with value { left , right } then store it"}
{"code": "System . out . print ( pos + \"NEW_LINE\"); }", "nl": "Print the answer"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int arr [ ] [ ] = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = arr . length ;", "nl": "Given array of pairs"}
{"code": "position ( arr , N ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; import java . io . * ; import java . lang . Math ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int ctMinEdits ( String str1 , String str2 ) { int N1 = str1 . length ( ) ; int N2 = str2 . length ( ) ;", "nl": "Function to minimize the count of operations to make str1 and str2 permutations of each other"}
{"code": "int freq1 [ ] = new int [ 256 ] ; Arrays . fill ( freq1 , 0 ) ; for ( int i = 0 ; i < N1 ; i ++ ) { freq1 [ str1 . charAt ( i ) ] ++ ; }", "nl": "Store the frequency of each character of str1"}
{"code": "int freq2 [ ] = new int [ 256 ] ; Arrays . fill ( freq2 , 0 ) ; for ( int i = 0 ; i < N2 ; i ++ ) { freq2 [ str2 . charAt ( i ) ] ++ ; }", "nl": "Store the frequency of each character of str2"}
{"code": "for ( int i = 0 ; i < 256 ; i ++ ) {", "nl": "Traverse the freq1 [ ] and freq2 [ ]"}
{"code": "if ( freq1 [ i ] > freq2 [ i ] ) { freq1 [ i ] = freq1 [ i ] - freq2 [ i ] ; freq2 [ i ] = 0 ; }", "nl": "If frequency of character in str1 is greater than str2"}
{"code": "else { freq2 [ i ] = freq2 [ i ] - freq1 [ i ] ; freq1 [ i ] = 0 ; } }", "nl": "Otherwise"}
{"code": "int sum1 = 0 ;", "nl": "Store sum of freq1 [ ]"}
{"code": "int sum2 = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { sum1 += freq1 [ i ] ; sum2 += freq2 [ i ] ; } return Math . max ( sum1 , sum2 ) ; }", "nl": "Store sum of freq2 [ ]"}
{"code": "public static void main ( final String [ ] args ) { String str1 = \" geeksforgeeks \" ; String str2 = \" geeksforcoder \" ; System . out . println ( ctMinEdits ( str1 , str2 ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void CountPairs ( int a [ ] , int b [ ] , int n ) {", "nl": "Function to find the minimum number needed to be added so that the sum of the digits does not exceed K"}
{"code": "int C [ ] = new int [ n ] ;", "nl": "Stores the sum of element at each corresponding index"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { C [ i ] = a [ i ] + b [ i ] ; }", "nl": "Find the sum of each index of both array"}
{"code": "HashMap < Integer , Integer > freqCount = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! freqCount . containsKey ( C [ i ] ) ) freqCount . put ( C [ i ] , 1 ) ; else freqCount . put ( C [ i ] , freqCount . get ( C [ i ] ) + 1 ) ; }", "nl": "Stores frequency of each element present in sumArr map < int , int > freqCount ;"}
{"code": "int NoOfPairs = 0 ; for ( Map . Entry < Integer , Integer > x : freqCount . entrySet ( ) ) { int y = x . getValue ( ) ;", "nl": "Initialize number of pairs"}
{"code": "NoOfPairs = NoOfPairs + y * ( y - 1 ) / 2 ; }", "nl": "Add possible vaid pairs"}
{"code": "System . out . println ( NoOfPairs ) ; }", "nl": "Return Number of Pairs"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 1 , 4 , 20 , 3 , 10 , 5 } ; int brr [ ] = { 9 , 6 , 1 , 7 , 11 , 6 } ;", "nl": "Given array arr [ ] and brr [ ]"}
{"code": "int N = arr . length ;", "nl": "Size of given array"}
{"code": "CountPairs ( arr , brr , N ) ; } }", "nl": "Function calling"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static void medianChange ( List < Integer > arr1 , List < Integer > arr2 ) { int N = arr1 . size ( ) ;", "nl": "Function to find the median change after removing elements from arr2 [ ]"}
{"code": "List < Integer > median = new ArrayList < > ( ) ;", "nl": "To store the median"}
{"code": "if ( ( N & 1 ) != 0 ) median . add ( arr1 . get ( N / 2 ) * 1 ) ;", "nl": "If N is odd"}
{"code": "else median . add ( ( arr1 . get ( N / 2 ) + arr1 . get ( ( N - 1 ) / 2 ) ) / 2 ) ; for ( int x = 0 ; x < arr2 . size ( ) ; x ++ ) {", "nl": "If N is even"}
{"code": "int it = arr1 . indexOf ( arr2 . get ( x ) ) ;", "nl": "Find the current element in arr1"}
{"code": "arr1 . remove ( it ) ;", "nl": "Erase the element"}
{"code": "N -- ;", "nl": "Decrement N"}
{"code": "if ( ( N & 1 ) != 0 ) { median . add ( arr1 . get ( N / 2 ) * 1 ) ; }", "nl": "If N is odd"}
{"code": "else { median . add ( ( arr1 . get ( N / 2 ) + arr1 . get ( ( N - 1 ) / 2 ) ) / 2 ) ; } }", "nl": "If N is even"}
{"code": "for ( int i = 0 ; i < median . size ( ) - 1 ; i ++ ) { System . out . print ( median . get ( i + 1 ) - median . get ( i ) + \" \u2581 \" ) ; } }", "nl": "Print the corresponding difference of median"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "List < Integer > arr1 = new ArrayList < Integer > ( ) { { add ( 2 ) ; add ( 4 ) ; add ( 6 ) ; add ( 8 ) ; add ( 10 ) ; } } ; List < Integer > arr2 = new ArrayList < Integer > ( ) { { add ( 4 ) ; add ( 6 ) ; } } ;", "nl": "Given arrays"}
{"code": "medianChange ( arr1 , arr2 ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static int nfa = 1 ;", "nl": "NFA variable that keeps track of the state while transaction ."}
{"code": "static int flag = 0 ;", "nl": "This checks for invalid input ."}
{"code": "static void state1 ( char c ) {", "nl": "Function for the state Q2"}
{"code": "if ( c == ' a ' ) nfa = 2 ; else if ( c == ' b ' c == ' c ' ) nfa = 1 ; else flag = 1 ; }", "nl": "State transitions ' a ' takes to Q4 , and ' b ' and ' c ' remain at Q2"}
{"code": "static void state2 ( char c ) {", "nl": "Function for the state Q3"}
{"code": "if ( c == ' a ' ) nfa = 3 ; else if ( c == ' b ' c == ' c ' ) nfa = 2 ; else flag = 1 ; }", "nl": "State transitions ' a ' takes to Q3 , and ' b ' and ' c ' remain at Q4"}
{"code": "static void state3 ( char c ) {", "nl": "Function for the state Q4"}
{"code": "if ( c == ' a ' ) nfa = 1 ; else if ( c == ' b ' c == ' c ' ) nfa = 3 ; else flag = 1 ; }", "nl": "State transitions ' a ' takes to Q2 , and ' b ' and ' c ' remain at Q3"}
{"code": "static void state4 ( char c ) {", "nl": "Function for the state Q5"}
{"code": "if ( c == ' b ' ) nfa = 5 ; else if ( c == ' a ' c == ' c ' ) nfa = 4 ; else flag = 1 ; }", "nl": "State transitions ' b ' takes to Q6 , and ' a ' and ' c ' remain at Q5"}
{"code": "static void state5 ( char c ) {", "nl": "Function for the state Q6"}
{"code": "if ( c == ' b ' ) nfa = 6 ; else if ( c == ' a ' c == ' c ' ) nfa = 5 ; else flag = 1 ; }", "nl": "State transitions ' b ' takes to Q7 , and ' a ' and ' c ' remain at Q7"}
{"code": "static void state6 ( char c ) {", "nl": "Function for the state Q7"}
{"code": "if ( c == ' b ' ) nfa = 4 ; else if ( c == ' a ' c == ' c ' ) nfa = 6 ; else flag = 1 ; }", "nl": "State transitions ' b ' takes to Q5 , and ' a ' and ' c ' remain at Q7"}
{"code": "static void state7 ( char c ) {", "nl": "Function for the state Q8"}
{"code": "if ( c == ' c ' ) nfa = 8 ; else if ( c == ' b ' c == ' a ' ) nfa = 7 ; else flag = 1 ; }", "nl": "State transitions ' c ' takes to Q9 , and ' a ' and ' b ' remain at Q8"}
{"code": "static void state8 ( char c ) {", "nl": "Function for the state Q9"}
{"code": "if ( c == ' c ' ) nfa = 9 ; else if ( c == ' b ' c == ' a ' ) nfa = 8 ; else flag = 1 ; }", "nl": "State transitions ' c ' takes to Q10 , and ' a ' and ' b ' remain at Q9"}
{"code": "static void state9 ( char c ) {", "nl": "Function for the state Q10"}
{"code": "if ( c == ' c ' ) nfa = 7 ; else if ( c == ' b ' c == ' a ' ) nfa = 9 ; else flag = 1 ; }", "nl": "State transitions ' c ' takes to Q8 , and ' a ' and ' b ' remain at Q10"}
{"code": "static boolean checkA ( String s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 1 ) state1 ( s . charAt ( i ) ) ; else if ( nfa == 2 ) state2 ( s . charAt ( i ) ) ; else if ( nfa == 3 ) state3 ( s . charAt ( i ) ) ; } if ( nfa == 1 ) { return true ; } else { nfa = 4 ; } return false ; }", "nl": "Function to check for 3 a 's"}
{"code": "static boolean checkB ( String s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 4 ) state4 ( s . charAt ( i ) ) ; else if ( nfa == 5 ) state5 ( s . charAt ( i ) ) ; else if ( nfa == 6 ) state6 ( s . charAt ( i ) ) ; } if ( nfa == 4 ) { return true ; } else { nfa = 7 ; } return false ; }", "nl": "Function to check for 3 b 's"}
{"code": "static boolean checkC ( String s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 7 ) state7 ( s . charAt ( i ) ) ; else if ( nfa == 8 ) state8 ( s . charAt ( i ) ) ; else if ( nfa == 9 ) state9 ( s . charAt ( i ) ) ; } if ( nfa == 7 ) { return true ; } return false ; }", "nl": "Function to check for 3 c 's"}
{"code": "public static void main ( String [ ] args ) { String s = \" bbbca \" ; int x = 5 ;", "nl": "Driver Code"}
{"code": "if ( checkA ( s , x ) || checkB ( s , x ) || checkC ( s , x ) ) { System . out . println ( \" ACCEPTED \" ) ; } else { if ( flag == 0 ) { System . out . println ( \" NOT \u2581 ACCEPTED \" ) ; } else { System . out . println ( \" INPUT \u2581 OUT \u2581 OF \u2581 DICTIONARY . \" ) ; } } } }", "nl": "If any of the states is true , that is , if either the number of a ' s \u2581 or \u2581 number \u2581 of \u2581 b ' s or number of c 's  is a multiple of three, then the string is accepted"}
{"code": "class GFG {", "nl": "Java Program to count positions such that all elements before it are greater"}
{"code": "static int getPositionCount ( int a [ ] , int n ) {", "nl": "Function to count positions such that all elements before it are greater"}
{"code": "int count = 1 ;", "nl": "Count is initially 1 for the first element"}
{"code": "int min = a [ 0 ] ;", "nl": "Initial Minimum"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) {", "nl": "Traverse the array"}
{"code": "if ( a [ i ] <= min ) {", "nl": "If current element is new minimum"}
{"code": "min = a [ i ] ;", "nl": "Update minimum"}
{"code": "count ++ ; } } return count ; }", "nl": "Increment count"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 5 , 4 , 6 , 1 , 3 , 1 } ; int n = a . length ; System . out . print ( getPositionCount ( a , n ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int maxSum ( int arr [ ] , int n , int k ) {", "nl": "Function to return the maximum sum in a subarray of size k"}
{"code": "if ( n < k ) { return - 1 ; }", "nl": "k must be greater"}
{"code": "int res = 0 ; for ( int i = 0 ; i < k ; i ++ ) res += arr [ i ] ;", "nl": "Compute sum of first window of size k"}
{"code": "int curr_sum = res ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; res = Math . max ( res , curr_sum ) ; } return res ; }", "nl": "Compute sums of remaining windows by removing first element of previous window and adding last element of current window ."}
{"code": "static int solve ( int arr [ ] , int n , int k ) { int max_len = 0 , l = 0 , r = n , m ;", "nl": "Function to return the length of subarray Sum of all the subarray of this length is less than or equal to K"}
{"code": "while ( l <= r ) { m = ( l + r ) / 2 ;", "nl": "Binary search from l to r as all the array elements are positive so that the maximum subarray sum is monotonically increasing"}
{"code": "if ( maxSum ( arr , n , m ) > k ) r = m - 1 ; else { l = m + 1 ;", "nl": "Check if the subarray sum is greater than K or not"}
{"code": "max_len = m ; } } return max_len ; }", "nl": "Update the maximum length"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; int k = 10 ; System . out . println ( solve ( arr , n , k ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static int MAX = 100001 ; static int ROW = 10 ; static int COl = 3 ; static Vector < Integer > [ ] indices = new Vector [ MAX ] ;", "nl": "Java implementation of the approach"}
{"code": "static int test [ ] [ ] = { { 2 , 3 , 6 } , { 2 , 4 , 4 } , { 2 , 6 , 3 } , { 3 , 2 , 6 } , { 3 , 3 , 3 } , { 3 , 6 , 2 } , { 4 , 2 , 4 } , { 4 , 4 , 2 } , { 6 , 2 , 3 } , { 6 , 3 , 2 } } ;", "nl": "All possible solutions of the equation 1 / a + 1 / b + 1 / c = 1"}
{"code": "static int find_triplet ( int array [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { indices [ i ] = new Vector < > ( ) ; }", "nl": "Function to find the triplets"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { indices [ array [ i ] ] . add ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { int y = array [ i ] ; for ( int j = 0 ; j < ROW ; j ++ ) { int s = test [ j ] [ 1 ] * y ;", "nl": "Storing indices of the elements"}
{"code": "if ( s % test [ j ] [ 0 ] != 0 ) continue ; if ( s % test [ j ] [ 2 ] != 0 ) continue ; int x = s / test [ j ] [ 0 ] ; int z = s / test [ j ] [ 2 ] ; if ( x > MAX z > MAX ) continue ; int l = 0 ; int r = indices [ x ] . size ( ) - 1 ; int first = - 1 ;", "nl": "Check if y can act as the middle element of triplet with the given solution of 1 / a + 1 / b + 1 / c = 1"}
{"code": "while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ x ] . get ( m ) < i ) { first = m ; l = m + 1 ; } else { r = m - 1 ; } } l = 0 ; r = indices [ z ] . size ( ) - 1 ; int third = - 1 ;", "nl": "Binary search to find the number of possible values of the first element"}
{"code": "while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ z ] . get ( m ) > i ) { third = m ; r = m - 1 ; } else { l = m + 1 ; } } if ( first != - 1 && third != - 1 ) {", "nl": "Binary search to find the number of possible values of the third element"}
{"code": "answer += ( first + 1 ) * ( indices [ z ] . size ( ) - third ) ; } } } return answer ; }", "nl": "Contribution to the answer would be the multiplication of the possible values for the first and the third element"}
{"code": "public static void main ( String [ ] args ) { int array [ ] = { 2 , 4 , 5 , 6 , 7 } ; int n = array . length ; System . out . println ( find_triplet ( array , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int distinct ( int [ ] arr , int n ) { int count = 0 ;", "nl": "Java implementation of the above approach"}
{"code": "if ( n == 1 ) return 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) {", "nl": "if array has only one element , return 1"}
{"code": "if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; }", "nl": "For first element compare with only next element"}
{"code": "else { if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) count += 1 ; } }", "nl": "For remaining elements compare with both prev and next elements"}
{"code": "if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; }", "nl": "For last element compare with only prev element"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 0 , 0 , 0 , 0 , 0 , 1 , 0 } ; int n = arr . length ; System . out . println ( distinct ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG {", "nl": "java program for the above approach"}
{"code": "static boolean isSorted ( int [ ] [ ] arr , int N ) {", "nl": "Function to check if an array is sorted or not"}
{"code": "for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] [ 0 ] > arr [ i - 1 ] [ 0 ] ) { return false ; } }", "nl": "Traverse the array arr [ ]"}
{"code": "return true ; }", "nl": "Return true"}
{"code": "static String isPossibleToSort ( int [ ] [ ] arr , int N ) {", "nl": "Function to check if it is possible to sort the array w . r . t . first element"}
{"code": "int group = arr [ 0 ] [ 1 ] ;", "nl": "Stores the ID of the first element"}
{"code": "for ( int i = 1 ; i < N ; i ++ ) {", "nl": "Traverse the array arr [ ]"}
{"code": "if ( arr [ i ] [ 1 ] != group ) { return \" Yes \" ; } }", "nl": "If arr [ i ] . second is not equal to that of the group"}
{"code": "if ( isSorted ( arr , N ) ) { return \" Yes \" ; } else { return \" No \" ; } }", "nl": "If array is sorted"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 340000 , 2 } , { 45000 , 1 } , { 30000 , 2 } , { 50000 , 4 } } ; int N = arr . length ; System . out . print ( isPossibleToSort ( arr , N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . lang . * ; import java . util . * ;", "nl": "Java Program to implement the above approach"}
{"code": "class Node { Node left , right ; int data ; public Node ( int data ) { this . data = data ; left = null ; right = null ; } } class AlphaScore { Node root ; AlphaScore ( ) { root = null ; } static long sum = 0 , total_sum = 0 ; static long mod = 1000000007 ;", "nl": "Structure of a node"}
{"code": "public static long getAlphaScore ( Node node ) {", "nl": "Function to calculate and return the Alpha Score of the journey"}
{"code": "if ( node . left != null ) getAlphaScore ( node . left ) ;", "nl": "Traverse left subtree"}
{"code": "sum = ( sum + node . data ) % mod ;", "nl": "Calculate the alpha score of the current step"}
{"code": "total_sum = ( total_sum + sum ) % mod ;", "nl": "Update alpha score of the journey"}
{"code": "if ( node . right != null ) getAlphaScore ( node . right ) ;", "nl": "Traverse right subtree"}
{"code": "return total_sum ; }", "nl": "Return"}
{"code": "public static Node constructBST ( int [ ] arr , int start , int end , Node root ) { if ( start > end ) return null ; int mid = ( start + end ) / 2 ;", "nl": "Function to construct a BST from the sorted array arr [ ]"}
{"code": "if ( root == null ) root = new Node ( arr [ mid ] ) ;", "nl": "Insert root"}
{"code": "root . left = constructBST ( arr , start , mid - 1 , root . left ) ;", "nl": "Construct left subtree"}
{"code": "root . right = constructBST ( arr , mid + 1 , end , root . right ) ;", "nl": "Construct right subtree"}
{"code": "return root ; }", "nl": "Return root"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 10 , 11 , 12 } ; int length = arr . length ;", "nl": "Driver Code"}
{"code": "Arrays . sort ( arr ) ; Node root = null ;", "nl": "Sort the array"}
{"code": "root = constructBST ( arr , 0 , length - 1 , root ) ; System . out . println ( getAlphaScore ( root ) ) ; } }", "nl": "Construct BST from the sorted array"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to sort an array in decreasing order of their frequency"}
{"code": "static int sortByFreq ( Integer [ ] arr , int n ) {", "nl": "Function that return the index upto all the array elements are updated ."}
{"code": "int maxE = - 1 ;", "nl": "Initialise maxE = - 1"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { maxE = Math . max ( maxE , arr [ i ] ) ; }", "nl": "Find the maximum element of arr [ ]"}
{"code": "int freq [ ] = new int [ maxE + 1 ] ;", "nl": "Create frequency array freq [ ]"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; }", "nl": "Update the frequency array as per the occurrence of element in arr [ ]"}
{"code": "int cnt = 0 ;", "nl": "Initialise cnt to 0"}
{"code": "for ( int i = 0 ; i <= maxE ; i ++ ) {", "nl": "Traversing freq [ ]"}
{"code": "if ( freq [ i ] > 0 ) { int value = 100000 - i ; arr [ cnt ] = 100000 * freq [ i ] + value ; cnt ++ ; } }", "nl": "If freq of an element is greater than 0 update the value of arr [ ] at index cnt & increment cnt"}
{"code": "return cnt ; }", "nl": "Return cnt"}
{"code": "static void printSortedArray ( Integer [ ] arr , int cnt ) {", "nl": "Function that print array arr [ ] elements in sorted order"}
{"code": "for ( int i = 0 ; i < cnt ; i ++ ) {", "nl": "Traversing arr [ ] till index cnt"}
{"code": "int frequency = arr [ i ] / 100000 ;", "nl": "Find frequency of elements"}
{"code": "int value = 100000 - ( arr [ i ] % 100000 ) ;", "nl": "Find value at index i"}
{"code": "for ( int j = 0 ; j < frequency ; j ++ ) { System . out . print ( value + \" \u2581 \" ) ; } } }", "nl": "Traversing till frequency to print value at index i"}
{"code": "public static void main ( String [ ] args ) { Integer arr [ ] = { 4 , 4 , 5 , 6 , 4 , 2 , 2 , 8 , 5 } ;", "nl": "Driver code"}
{"code": "int n = arr . length ;", "nl": "Size of array arr [ ]"}
{"code": "int cnt = sortByFreq ( arr , n ) ;", "nl": "Function call to get cnt"}
{"code": "Arrays . sort ( arr , Collections . reverseOrder ( ) ) ;", "nl": "Sort the arr [ ] in decreasing order"}
{"code": "printSortedArray ( arr , cnt ) ; } }", "nl": "Function that prints elements in decreasing order"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static boolean checkRectangles ( int [ ] arr , int n ) { boolean ans = true ;", "nl": "Function to check whether we can make n rectangles of equal area"}
{"code": "Arrays . sort ( arr ) ;", "nl": "Sort the array"}
{"code": "int area = arr [ 0 ] * arr [ 4 * n - 1 ] ;", "nl": "Find the area of any one rectangle"}
{"code": "for ( int i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) {", "nl": "Check whether we have two equal sides for each rectangle and that area of each rectangle formed is the same"}
{"code": "ans = false ; break ; } }", "nl": "Update the answer to false if any condition fails"}
{"code": "if ( ans ) return true ; return false ; }", "nl": "If possible"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 8 , 2 , 1 , 2 , 4 , 4 , 8 } ; int n = 2 ; if ( checkRectangles ( arr , n ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int cntElements ( int arr [ ] , int n ) {", "nl": "Function to return the count of elements which are not in the correct position when sorted"}
{"code": "int copy_arr [ ] = new int [ n ] ;", "nl": "To store a copy of the original array"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ;", "nl": "Copy the elements of the given array to the new array"}
{"code": "int count = 0 ;", "nl": "To store the required count"}
{"code": "Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Sort the original array"}
{"code": "if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; }", "nl": "If current element was not at the right position"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 6 , 2 , 4 , 5 } ; int n = arr . length ; System . out . println ( cntElements ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } }", "nl": "Java implementation of the approach"}
{"code": "static void findPairs ( int arr [ ] , int n , int k , int d ) {", "nl": "Function to find the required pairs"}
{"code": "if ( n < 2 * k ) { System . out . print ( - 1 ) ; return ; }", "nl": "There has to be atleast 2 * k elements"}
{"code": "Vector < pair > pairs = new Vector < pair > ( ) ;", "nl": "To store the pairs"}
{"code": "Arrays . sort ( arr ) ;", "nl": "Sort the given array"}
{"code": "for ( int i = 0 ; i < k ; i ++ ) {", "nl": "For every possible pair"}
{"code": "if ( arr [ n - k + i ] - arr [ i ] >= d ) {", "nl": "If the current pair is valid"}
{"code": "pair p = new pair ( arr [ i ] , arr [ n - k + i ] ) ; pairs . add ( p ) ; } }", "nl": "Insert it into the pair vector"}
{"code": "if ( pairs . size ( ) < k ) { System . out . print ( - 1 ) ; return ; }", "nl": "If k pairs are not possible"}
{"code": "for ( pair v : pairs ) { System . out . println ( \" ( \" + v . first + \" , \u2581 \" + v . second + \" ) \" ) ; } }", "nl": "Print the pairs"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 4 , 6 , 10 , 23 , 14 , 7 , 2 , 20 , 9 } ; int n = arr . length ; int k = 4 , d = 3 ; findPairs ( arr , n , k , d ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Arrays ; import java . io . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int pairs_count ( int arr [ ] , int n , int sum ) {", "nl": "Function to return the count of pairs from arr [ ] with the given sum"}
{"code": "int ans = 0 ;", "nl": "To store the count of pairs"}
{"code": "Arrays . sort ( arr ) ;", "nl": "Sort the given array"}
{"code": "int i = 0 , j = n - 1 ; while ( i < j ) {", "nl": "Take two pointers"}
{"code": "if ( arr [ i ] + arr [ j ] < sum ) i ++ ;", "nl": "If sum is greater"}
{"code": "else if ( arr [ i ] + arr [ j ] > sum ) j -- ;", "nl": "If sum is lesser"}
{"code": "else {", "nl": "If sum is equal"}
{"code": "int x = arr [ i ] , xx = i ; while ( ( i < j ) && ( arr [ i ] == x ) ) i ++ ;", "nl": "Find the frequency of arr [ i ]"}
{"code": "int y = arr [ j ] , yy = j ; while ( ( j >= i ) && ( arr [ j ] == y ) ) j -- ;", "nl": "Find the frequency of arr [ j ]"}
{"code": "if ( x == y ) { int temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } }", "nl": "If arr [ i ] and arr [ j ] are same then remove the extra number counted"}
{"code": "return ans ; }", "nl": "Return the required answer"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 7 , 5 , - 1 } ; int n = arr . length ; int sum = 6 ; System . out . println ( pairs_count ( arr , n , sum ) ) ; } }", "nl": "Driver code"}
{"code": "public class GFG { public static boolean check ( String str ) { int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; int sum = 0 ;", "nl": "Java program to implement the above approach"}
{"code": "for ( int i = 0 ; i < str . length ( ) ; i ++ ) {", "nl": "for all the characters of the string"}
{"code": "int ascii = ( int ) str . charAt ( i ) ;", "nl": "find the ascii value of the character"}
{"code": "if ( ascii < 96 ascii > 122 ) return false ;", "nl": "check if if its a valid character , if not then return false"}
{"code": "sum += ascii ;", "nl": "calculate sum of all the characters ascii values"}
{"code": "if ( min > ascii ) min = ascii ;", "nl": "find minimum ascii value from the string"}
{"code": "if ( max < ascii ) max = ascii ; }", "nl": "find maximum ascii value from the string"}
{"code": "min -= 1 ;", "nl": "To get the previous element of the minimum ASCII value"}
{"code": "int eSum = ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ;", "nl": "take the expected sum from the above equation"}
{"code": "return sum == eSum ; }", "nl": "check if the expected sum is equals to the calculated sum or not"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "String str = \" dcef \" ; if ( check ( str ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ;", "nl": "1 st example"}
{"code": "String str1 = \" xyza \" ; if ( check ( str1 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "2 nd example"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static int findKth ( int arr [ ] , int n , int k ) { HashSet < Integer > missing = new HashSet < > ( ) ; int count = 0 ;", "nl": "Function to find the sum of minimum of all subarrays"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { missing . add ( arr [ i ] ) ; }", "nl": "Insert all the elements in a set"}
{"code": "int maxm = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int minm = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ;", "nl": "Find the maximum and minimum element"}
{"code": "for ( int i = minm + 1 ; i < maxm ; i ++ ) {", "nl": "Traverse from the minimum to maximum element"}
{"code": "if ( ! missing . contains ( i ) ) { count ++ ; }", "nl": "Check if \" i \" is missing"}
{"code": "if ( count == k ) { return i ; } }", "nl": "Check if it is kth missing"}
{"code": "return - 1 ; }", "nl": "If no kth element is missing"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 10 , 9 , 4 } ; int n = arr . length ; int k = 5 ; System . out . println ( findKth ( arr , n , k ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to sort linked list containing values from 1 to N"}
{"code": "static class Node { int data ; Node next ; } ; static Node start ;", "nl": "Link list node"}
{"code": "static void sortList ( Node head ) { int startVal = 1 ; while ( head != null ) { head . data = startVal ; startVal ++ ; head = head . next ; } }", "nl": "Function to sort linked list"}
{"code": "static void push ( Node head_ref , int new_data ) {", "nl": "Function to add a node at the beginning of Linked List"}
{"code": "Node new_node = new Node ( ) ;", "nl": "allocate node"}
{"code": "new_node . data = new_data ;", "nl": "put in the data"}
{"code": "new_node . next = head_ref ;", "nl": "link the old list off the new node"}
{"code": "head_ref = new_node ; start = head_ref ; }", "nl": "move the head to point to the new node"}
{"code": "static void printList ( Node node ) { while ( node != null ) { System . out . print ( node . data + \" \u2581 \" ) ; node = node . next ; } }", "nl": "This function prints contents of linked list starting from the given node"}
{"code": "public static void main ( String [ ] args ) { start = null ;", "nl": "Driver Code"}
{"code": "push ( start , 2 ) ; push ( start , 1 ) ; push ( start , 6 ) ; push ( start , 4 ) ; push ( start , 5 ) ; push ( start , 3 ) ; sortList ( start ) ; printList ( start ) ; } }", "nl": "The constructed linked list is : 3 -> 5 -> 4 -> 6 -> 1 -> 2"}
{"code": "class GfG {", "nl": "Java program to recursively check Linked List is sorted in descending order or not"}
{"code": "static class Node { int data ; Node next ; }", "nl": "Linked list node"}
{"code": "static boolean isSortedDesc ( Node head ) {", "nl": "function to Check Linked List is sorted in descending order or not"}
{"code": "if ( head == null head . next == null ) return true ;", "nl": "Base cases"}
{"code": "return ( head . data > head . next . data && isSortedDesc ( head . next ) ) ; } static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . next = null ; temp . data = data ; return temp ; }", "nl": "Check first two nodes and recursively check remaining ."}
{"code": "public static void main ( String [ ] args ) { Node head = newNode ( 7 ) ; head . next = newNode ( 5 ) ; head . next . next = newNode ( 4 ) ; head . next . next . next = newNode ( 3 ) ; if ( isSortedDesc ( head ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver program to test above"}
{"code": "import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . Vector ; class GFG { static int minSum ( int arr [ ] , int n ) {", "nl": "Java program to sort an array such that sum of product of alternate element is minimum ."}
{"code": "Vector < Integer > evenArr = new Vector < > ( ) ; Vector < Integer > oddArr = new Vector < > ( ) ;", "nl": "create evenArr [ ] and oddArr [ ]"}
{"code": "Arrays . sort ( arr ) ;", "nl": "sort main array in ascending order"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) { oddArr . add ( arr [ i ] ) ; } else { evenArr . add ( arr [ i ] ) ; } }", "nl": "Put elements in oddArr [ ] and evenArr [ ] as per desired value ."}
{"code": "Comparator comparator = Collections . reverseOrder ( ) ; Collections . sort ( evenArr , comparator ) ;", "nl": "sort evenArr [ ] in descending order"}
{"code": "int i = 0 , sum = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr . get ( j ) ; arr [ i ++ ] = oddArr . get ( j ) ; sum += evenArr . get ( j ) * oddArr . get ( j ) ; } return sum ; }", "nl": "merge both sub - array and calculate minimum sum of product of alternate elements"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = arr . length ; System . out . println ( \" Minimum \u2581 required \u2581 sum \u2581 = \u2581 \" + minSum ( arr , n ) ) ; System . out . println ( \" Sorted \u2581 array \u2581 in \u2581 required \u2581 format \u2581 : \u2581 \" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } } }", "nl": "Driver program"}
{"code": "class GFG {", "nl": "Java implementation for the above approach"}
{"code": "static void minTime ( String word ) { int ans = 0 ;", "nl": "Function to calculate minimum time to print all characters in the string"}
{"code": "int curr = 0 ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) {", "nl": "Current element where the pointer is pointing"}
{"code": "int k = ( int ) word . charAt ( i ) - 97 ;", "nl": "Find index of that element"}
{"code": "int a = Math . abs ( curr - k ) ;", "nl": "Calculate absolute difference between pointer index and character index as clockwise distance"}
{"code": "int b = 26 - Math . abs ( curr - k ) ;", "nl": "Subtract clockwise time from 26 to get anti - clockwise time"}
{"code": "ans += Math . min ( a , b ) ;", "nl": "Add minimum of both times to the answer"}
{"code": "ans ++ ; curr = ( int ) word . charAt ( i ) - 97 ; }", "nl": "Add one unit time to print the character"}
{"code": "System . out . print ( ans ) ; }", "nl": "Print the final answer"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "String str = \" zjpc \" ;", "nl": "Given string word"}
{"code": "minTime ( str ) ; } }", "nl": "Function call"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int reduceToOne ( long N ) {", "nl": "Function to find the minimum number of steps required to reduce N to 1"}
{"code": "int cnt = 0 ; while ( N != 1 ) {", "nl": "Stores the number of steps required"}
{"code": "if ( N == 2 || ( N % 2 == 1 ) ) {", "nl": "If the value of N is equal to 2 or N is odd"}
{"code": "N = N - 1 ;", "nl": "Decrement N by 1"}
{"code": "cnt ++ ; }", "nl": "Increment cnt by 1"}
{"code": "else if ( N % 2 == 0 ) {", "nl": "If N is even"}
{"code": "N = N / ( N / 2 ) ;", "nl": "Update N"}
{"code": "cnt ++ ; } }", "nl": "Increment cnt by 1"}
{"code": "return cnt ; }", "nl": "Return the number of steps obtained"}
{"code": "public static void main ( String [ ] args ) { long N = 35 ; System . out . println ( reduceToOne ( N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void maxDiamonds ( int A [ ] , int N , int K ) {", "nl": "Function to find the maximum number of diamonds that can be gained in exactly K minutes"}
{"code": "PriorityQueue < Integer > pq = new PriorityQueue < > ( ( a , b ) -> b - a ) ;", "nl": "Stores all the array elements"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { pq . add ( A [ i ] ) ; }", "nl": "Push all the elements to the priority queue"}
{"code": "int ans = 0 ;", "nl": "Stores the required result"}
{"code": "while ( ! pq . isEmpty ( ) && K -- > 0 ) {", "nl": "Loop while the queue is not empty and K is positive"}
{"code": "int top = pq . peek ( ) ;", "nl": "Store the top element from the pq"}
{"code": "pq . remove ( ) ;", "nl": "Pop it from the pq"}
{"code": "ans += top ;", "nl": "Add it to the answer"}
{"code": "top = top / 2 ; pq . add ( top ) ; }", "nl": "Divide it by 2 and push it back to the pq"}
{"code": "System . out . print ( ans ) ; }", "nl": "Print the answer"}
{"code": "public static void main ( String [ ] args ) { int A [ ] = { 2 , 1 , 7 , 4 , 2 } ; int K = 3 ; int N = A . length ; maxDiamonds ( A , N , K ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int MinimumCost ( int A [ ] , int B [ ] , int N ) {", "nl": "Function to find the minimum cost to make A [ i ] multiple of B [ i ] or vice - versa for every array element"}
{"code": "int totalCost = 0 ;", "nl": "Stores the minimum cost"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array"}
{"code": "int mod_A = B [ i ] % A [ i ] ; int totalCost_A = Math . min ( mod_A , A [ i ] - mod_A ) ;", "nl": "Case 1 : Update A [ i ]"}
{"code": "int mod_B = A [ i ] % B [ i ] ; int totalCost_B = Math . min ( mod_B , B [ i ] - mod_B ) ;", "nl": "Case 2 : Update B [ i ]"}
{"code": "totalCost += Math . min ( totalCost_A , totalCost_B ) ; }", "nl": "Add the minimum of the above two cases"}
{"code": "return totalCost ; }", "nl": "Return the resultant cost"}
{"code": "public static void main ( String [ ] args ) { int A [ ] = { 3 , 6 , 3 } ; int B [ ] = { 4 , 8 , 13 } ; int N = A . length ; System . out . print ( MinimumCost ( A , B , N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program of the above approach"}
{"code": "static void printLargestDivisible ( int arr [ ] , int N ) { int i , count0 = 0 , count7 = 0 ; for ( i = 0 ; i < N ; i ++ ) {", "nl": "Print the largest number divisible by 50"}
{"code": "if ( arr [ i ] == 0 ) count0 ++ ; else count7 ++ ; }", "nl": "Counting number of 0 s and 7 s"}
{"code": "if ( count7 % 50 == 0 ) { while ( count7 != 0 ) { System . out . print ( 7 ) ; count7 -= 1 ; } while ( count0 != 0 ) { System . out . print ( 0 ) ; count0 -= 1 ; } }", "nl": "If count of 7 is divisible by 50"}
{"code": "else if ( count7 < 5 ) { if ( count0 == 0 ) System . out . print ( \" No \" ) ; else System . out . print ( \"0\" ) ; }", "nl": "If count of 7 is less than 5"}
{"code": "else {", "nl": "If count of 7 is not divisible by 50"}
{"code": "count7 = count7 - count7 % 5 ; while ( count7 != 0 ) { System . out . print ( 7 ) ; count7 -= 1 ; } while ( count0 != 0 ) { System . out . print ( 0 ) ; count0 -= 1 ; } } }", "nl": "Count of groups of 5 in which count of 7 s can be grouped"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 0 , 7 , 0 , 7 , 7 , 7 , 7 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 7 , 7 } ;", "nl": "Given array"}
{"code": "int N = arr . length ; printLargestDivisible ( arr , N ) ; } }", "nl": "Size of the array"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int findMaxValByRearrArr ( int arr [ ] , int N ) {", "nl": "Function to find the maximum sum of GCD ( arr [ i ] , i ) by rearranging the array"}
{"code": "Arrays . sort ( arr ) ;", "nl": "Sort the array in ascending order"}
{"code": "int res = 0 ;", "nl": "Stores maximum sum of GCD ( arr [ i ] , i ) by rearranging the array elements"}
{"code": "do {", "nl": "Generate all possible permutations of the array"}
{"code": "int sum = 0 ;", "nl": "Stores sum of GCD ( arr [ i ] , i )"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array"}
{"code": "sum += __gcd ( i + 1 , arr [ i ] ) ; }", "nl": "Update sum"}
{"code": "res = Math . max ( res , sum ) ; } while ( next_permutation ( arr ) ) ; return res ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static boolean next_permutation ( int [ ] p ) { for ( int a = p . length - 2 ; a >= 0 ; -- a ) if ( p [ a ] < p [ a + 1 ] ) for ( int b = p . length - 1 ; ; -- b ) if ( p [ b ] > p [ a ] ) { int t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; for ( ++ a , b = p . length - 1 ; a < b ; ++ a , -- b ) { t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; } return true ; } return false ; }", "nl": "Update res"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 } ; int N = arr . length ; System . out . print ( findMaxValByRearrArr ( arr , N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "public static int min_elements ( int arr [ ] , int N ) {", "nl": "Function to find the minimum count of elements required to be removed such that frequency of arr [ i ] equal to arr [ i ]"}
{"code": "Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;", "nl": "Stores frequency of each element of the array"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array"}
{"code": "mp . put ( arr [ i ] , mp . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; }", "nl": "Update frequency of arr [ i ]"}
{"code": "int cntMinRem = 0 ;", "nl": "Stores minimum count of removals"}
{"code": "for ( int key : mp . keySet ( ) ) {", "nl": "Traverse the map"}
{"code": "int i = key ; int val = mp . get ( i ) ;", "nl": "Stores key value of the map"}
{"code": "if ( val < i ) {", "nl": "If frequency of i is less than i"}
{"code": "cntMinRem += val ; }", "nl": "Update cntMinRem"}
{"code": "else if ( val > i ) {", "nl": "If frequency of i is greater than i"}
{"code": "cntMinRem += ( val - i ) ; } } return cntMinRem ; }", "nl": "Update cntMinRem"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 1 , 4 , 2 } ; System . out . println ( min_elements ( arr , arr . length ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static boolean CheckAllarrayEqual ( int [ ] arr , int N ) {", "nl": "Function to check if an array of equal elements with sum equal to the given array can be obtained or not"}
{"code": "if ( N == 1 ) { return true ; }", "nl": "Base case"}
{"code": "int totalSum = arr [ 0 ] ;", "nl": "Stores sum of array elements"}
{"code": "int secMax = Integer . MIN_VALUE ;", "nl": "Stores second largest array element"}
{"code": "int Max = arr [ 0 ] ;", "nl": "Stores the largest array element"}
{"code": "for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] >= Max ) {", "nl": "Traverse the array"}
{"code": "secMax = Max ;", "nl": "Update secMax"}
{"code": "Max = arr [ i ] ; } else if ( arr [ i ] > secMax ) {", "nl": "Update Max"}
{"code": "secMax = arr [ i ] ; }", "nl": "Update secMax"}
{"code": "totalSum += arr [ i ] ; }", "nl": "Update totalSum"}
{"code": "if ( ( secMax * ( N - 1 ) ) > totalSum ) { return false ; }", "nl": "If totalSum is less than secMax * ( N - 1 ) )"}
{"code": "if ( totalSum % ( N - 1 ) != 0 ) { return false ; } return true ; }", "nl": "If totalSum is not divisible by ( N - 1 )"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 6 , 2 , 2 , 2 } ; int N = arr . length ; if ( CheckAllarrayEqual ( arr , N ) ) { System . out . print ( \" YES \" ) ; } else { System . out . print ( \" NO \" ) ; } } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static void Remove_one_element ( int arr [ ] , int n ) {", "nl": "Function to count ways to make Bitwise XOR of odd and even indexed elements equal by removing an array element"}
{"code": "int post_odd = 0 , post_even = 0 ;", "nl": "Stores xor of odd and even indexed elements from the end"}
{"code": "int curr_odd = 0 , curr_even = 0 ;", "nl": "Stores xor of odd and even indexed elements from the start"}
{"code": "int res = 0 ;", "nl": "Stores the required count"}
{"code": "for ( int i = n - 1 ; i >= 0 ; i -- ) {", "nl": "Traverse the array in reverse"}
{"code": "if ( i % 2 != 0 ) post_odd ^= arr [ i ] ;", "nl": "If i is odd"}
{"code": "else post_even ^= arr [ i ] ; }", "nl": "If i is even"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse the array"}
{"code": "if ( i % 2 != 0 ) post_odd ^= arr [ i ] ;", "nl": "If i is odd"}
{"code": "else post_even ^= arr [ i ] ;", "nl": "If i is even"}
{"code": "int X = curr_odd ^ post_even ;", "nl": "Removing arr [ i ] , post_even stores XOR of odd indexed elements"}
{"code": "int Y = curr_even ^ post_odd ;", "nl": "Removing arr [ i ] , post_odd stores XOR of even indexed elements"}
{"code": "if ( X == Y ) res ++ ;", "nl": "Check if they are equal"}
{"code": "if ( i % 2 != 0 ) curr_odd ^= arr [ i ] ;", "nl": "If i is odd , xor it with curr_odd"}
{"code": "else curr_even ^= arr [ i ] ; }", "nl": "If i is even , xor it with curr_even"}
{"code": "System . out . println ( res ) ; }", "nl": "Finally print res"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Drivers Code"}
{"code": "int arr [ ] = { 1 , 0 , 1 , 0 , 1 } ;", "nl": "Given array"}
{"code": "int N = arr . length ;", "nl": "Given size"}
{"code": "Remove_one_element ( arr , N ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int cntIndexesToMakeBalance ( int arr [ ] , int n ) {", "nl": "Function to count array indices whose removal makes sum of odd and even indexed elements equal"}
{"code": "if ( n == 1 ) { return 1 ; }", "nl": "If size of the array is 1"}
{"code": "if ( n == 2 ) return 0 ;", "nl": "If size of the array is 2"}
{"code": "int sumEven = 0 ;", "nl": "Stores sum of even - indexed elements of the given array"}
{"code": "int sumOdd = 0 ;", "nl": "Stores sum of odd - indexed elements of the given array"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse the array"}
{"code": "if ( i % 2 == 0 ) {", "nl": "If i is an even number"}
{"code": "sumEven += arr [ i ] ; }", "nl": "Update sumEven"}
{"code": "else {", "nl": "If i is an odd number"}
{"code": "sumOdd += arr [ i ] ; } }", "nl": "Update sumOdd"}
{"code": "int currOdd = 0 ;", "nl": "Stores sum of even - indexed array elements till i - th index"}
{"code": "int currEven = arr [ 0 ] ;", "nl": "Stores sum of odd - indexed array elements till i - th index"}
{"code": "int res = 0 ;", "nl": "Stores count of indices whose removal makes sum of odd and even indexed elements equal"}
{"code": "int newEvenSum = 0 ;", "nl": "Stores sum of even - indexed elements after removing the i - th element"}
{"code": "int newOddSum = 0 ;", "nl": "Stores sum of odd - indexed elements after removing the i - th element"}
{"code": "for ( int i = 1 ; i < n - 1 ; i ++ ) {", "nl": "Traverse the array"}
{"code": "if ( i % 2 != 0 ) {", "nl": "If i is an odd number"}
{"code": "currOdd += arr [ i ] ;", "nl": "Update currOdd"}
{"code": "newEvenSum = currEven + sumOdd - currOdd ;", "nl": "Update newEvenSum"}
{"code": "newOddSum = currOdd + sumEven - currEven - arr [ i ] ; }", "nl": "Update newOddSum"}
{"code": "else {", "nl": "If i is an even number"}
{"code": "currEven += arr [ i ] ;", "nl": "Update currEven"}
{"code": "newOddSum = currOdd + sumEven - currEven ;", "nl": "Update newOddSum"}
{"code": "newEvenSum = currEven + sumOdd - currOdd - arr [ i ] ; }", "nl": "Update newEvenSum"}
{"code": "if ( newEvenSum == newOddSum ) {", "nl": "If newEvenSum is equal to newOddSum"}
{"code": "res ++ ; } }", "nl": "Increase the count"}
{"code": "if ( sumOdd == sumEven - arr [ 0 ] ) {", "nl": "If sum of even - indexed and odd - indexed elements is equal by removing the first element"}
{"code": "res ++ ; }", "nl": "Increase the count"}
{"code": "if ( n % 2 == 1 ) {", "nl": "If length of the array is an odd number"}
{"code": "if ( sumOdd == sumEven - arr [ n - 1 ] ) {", "nl": "If sum of even - indexed and odd - indexed elements is equal by removing the last element"}
{"code": "res ++ ; } }", "nl": "Increase the count"}
{"code": "else {", "nl": "If length of the array is an even number"}
{"code": "if ( sumEven == sumOdd - arr [ n - 1 ] ) {", "nl": "If sum of even - indexed and odd - indexed elements is equal by removing the last element"}
{"code": "res ++ ; } } return res ; }", "nl": "Increase the count"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 } ; int n = arr . length ; System . out . println ( cntIndexesToMakeBalance ( arr , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void findNums ( int X , int Y ) {", "nl": "Function to find the value of A and B whose sum is X and xor is Y"}
{"code": "int A , B ;", "nl": "Initialize the two numbers"}
{"code": "if ( X < Y ) { A = - 1 ; B = - 1 ; }", "nl": "Case 1 : X < Y"}
{"code": "else if ( ( ( Math . abs ( X - Y ) ) & 1 ) != 0 ) { A = - 1 ; B = - 1 ; }", "nl": "Case 2 : X - Y is odd"}
{"code": "else if ( X == Y ) { A = 0 ; B = Y ; }", "nl": "Case 3 : If both Sum and XOR are equal"}
{"code": "else {", "nl": "Case 4 : If above cases fails"}
{"code": "A = ( X - Y ) / 2 ;", "nl": "Update the value of A"}
{"code": "if ( ( A & Y ) == 0 ) {", "nl": "Check if A & Y value is 0"}
{"code": "B = ( A + Y ) ; }", "nl": "If true , update B"}
{"code": "else { A = - 1 ; B = - 1 ; } }", "nl": "Otherwise assign - 1 to A , - 1 to B"}
{"code": "System . out . print ( A + \" \u2581 \" + B ) ; }", "nl": "Print the numbers A and B"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int X = 17 , Y = 13 ;", "nl": "Given Sum and XOR of 2 numbers"}
{"code": "findNums ( X , Y ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void checkCount ( int A [ ] , int Q [ ] [ ] , int q ) {", "nl": "Function to check if given range have equal number of increasing as well as decreasing subarrays"}
{"code": "for ( int i = 0 ; i < q ; i ++ ) { int L = Q [ i ] [ 0 ] ; int R = Q [ i ] [ 1 ] ;", "nl": "Traverse each query"}
{"code": "L -- ; R -- ;", "nl": "For 0 - based indexing"}
{"code": "if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } } }", "nl": "Condition for same count of increasing & decreasing subarray"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 11 , 13 , 12 , 14 } ; int Q [ ] [ ] = { { 1 , 4 } , { 2 , 4 } } ; int q = Q . length ; checkCount ( arr , Q , q ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static double pairProductMean ( int arr [ ] , int N ) {", "nl": "Function to find the mean of pair product array of arr [ ]"}
{"code": "Vector < Integer > pairArray = new Vector < > ( ) ;", "nl": "Store product of pairs"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int pairProduct = arr [ i ] * arr [ j ] ;", "nl": "Generate all unordered pairs"}
{"code": "pairArray . add ( pairProduct ) ; } }", "nl": "Store product of pairs"}
{"code": "int length = pairArray . size ( ) ;", "nl": "Size of pairArray"}
{"code": "float sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) sum += pairArray . get ( i ) ;", "nl": "Store sum of pairArray"}
{"code": "float mean ;", "nl": "Stores the mean of pairArray [ ]"}
{"code": "if ( length != 0 ) mean = sum / length ; else mean = 0 ;", "nl": "Find mean of pairArray [ ]"}
{"code": "return mean ; }", "nl": "Return the resultant mean"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = arr . length ;", "nl": "Given array arr [ ]"}
{"code": "System . out . format ( \" % .2f \" , pairProductMean ( arr , N ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void findPlayer ( String str [ ] , int n ) {", "nl": "Function to find the player who loses the game"}
{"code": "int move_first = 0 ;", "nl": "Moves for the first player"}
{"code": "int move_sec = 0 ;", "nl": "Moves for the second player"}
{"code": "for ( int i = 0 ; i < n - 1 ; i ++ ) {", "nl": "Iterate over array of Strings"}
{"code": "if ( str [ i ] . charAt ( 0 ) == str [ i ] . charAt ( str [ i ] . length ( ) - 1 ) ) {", "nl": "Check if the first and last character are the same"}
{"code": "if ( str [ i ] . charAt ( 0 ) == 48 ) move_first ++ ; else move_sec ++ ; } }", "nl": "Check if String start and end with character '0'"}
{"code": "if ( move_first <= move_sec ) { System . out . print ( \" Player \u2581 2 \u2581 wins \" ) ; } else { System . out . print ( \" Player \u2581 1 \u2581 wins \" ) ; } }", "nl": "If first player have less moves"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "String str [ ] = { \"010\" , \"101\" } ; int N = str [ 0 ] . length ( ) ;", "nl": "Given array of Strings"}
{"code": "findPlayer ( str , N ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int find_next ( int n , int k ) {", "nl": "Function to find the number greater than n whose Kth bit is set"}
{"code": "int M = n + 1 ; while ( true ) {", "nl": "Iterate from N + 1"}
{"code": "if ( ( M & ( 1L << k ) ) > 0 ) break ;", "nl": "Check if Kth bit is set or not"}
{"code": "M ++ ; }", "nl": "Increment M for next number"}
{"code": "return M ; }", "nl": "Return the minimum value"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 15 , K = 2 ;", "nl": "Given N and K"}
{"code": "System . out . print ( find_next ( N , K ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int find_next ( int n , int k ) {", "nl": "Function to find the number greater than n whose Kth bit is set"}
{"code": "int ans = 0 ;", "nl": "Stores the resultant number"}
{"code": "if ( ( n & ( 1L << k ) ) == 0 ) { int cur = 0 ;", "nl": "If Kth bit is not set"}
{"code": "for ( int i = 0 ; i < k ; i ++ ) {", "nl": "cur will be the sum of all powers of 2 < k"}
{"code": "if ( ( n & ( 1L << i ) ) > 0 ) cur += 1L << i ; }", "nl": "If the current bit is set"}
{"code": "ans = ( int ) ( n - cur + ( 1L << k ) ) ; }", "nl": "Add Kth power of 2 to n and subtract the all powers of 2 less than K that are set"}
{"code": "else { int first_unset_bit = - 1 , cur = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) {", "nl": "If the kth bit is set"}
{"code": "if ( ( n & ( 1L << i ) ) == 0 ) { first_unset_bit = i ; break ; }", "nl": "First unset bit position"}
{"code": "else cur += ( 1L << i ) ; }", "nl": "sum of bits that are set"}
{"code": "ans = ( int ) ( n - cur + ( 1L << first_unset_bit ) ) ;", "nl": "Add Kth power of 2 to n and subtract the all powers of 2 less than K that are set"}
{"code": "if ( ( ans & ( 1L << k ) ) == 0 ) ans += ( 1L << k ) ; }", "nl": "If Kth bit became unset then set it again"}
{"code": "return ans ; }", "nl": "Return the resultant number"}
{"code": "public static void main ( String [ ] args ) { int N = 15 , K = 2 ;", "nl": "Driver Code"}
{"code": "System . out . print ( find_next ( N , K ) ) ; } }", "nl": "Print ans"}
{"code": "class GFG { static String largestString ( String num , int k ) {", "nl": "Java program to implement the above approach"}
{"code": "String ans = \" \" ; for ( char i : num . toCharArray ( ) ) {", "nl": "Final result String"}
{"code": "while ( ans . length ( ) > 0 && ans . charAt ( ans . length ( ) - 1 ) < i && k > 0 ) {", "nl": "If the current char exceeds the character at the top of the stack"}
{"code": "ans = ans . substring ( 0 , ans . length ( ) - 1 ) ;", "nl": "Remove from the end of the String"}
{"code": "k -- ; }", "nl": "Decrease k for the removal"}
{"code": "ans += i ; }", "nl": "Insert current character"}
{"code": "while ( ans . length ( ) > 0 && k -- > 0 ) { ans = ans . substring ( 0 , ans . length ( ) - 1 ) ; }", "nl": "Perform remaining K deletions from the end of the String"}
{"code": "return ans ; }", "nl": "Return the String"}
{"code": "public static void main ( String [ ] args ) { String str = \" zyxedcba \" ; int k = 1 ; System . out . print ( largestString ( str , k ) + \"NEW_LINE\"); } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static void maxLengthSubArray ( int A [ ] , int N ) {", "nl": "Function that finds the maximum length of the sub - array that contains equal element on both halves of sub - array"}
{"code": "int forward [ ] = new int [ N ] ; int backward [ ] = new int [ N ] ;", "nl": "To store continuous occurence of the element"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 A [ i ] != A [ i - 1 ] ) { forward [ i ] = 1 ; } else forward [ i ] = forward [ i - 1 ] + 1 ; }", "nl": "To store continuous forkward occurence"}
{"code": "for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 A [ i ] != A [ i + 1 ] ) { backward [ i ] = 1 ; } else backward [ i ] = backward [ i + 1 ] + 1 ; }", "nl": "To store continuous backward occurence"}
{"code": "int ans = 0 ;", "nl": "To store the maximum length"}
{"code": "for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) ans = Math . max ( ans , Math . min ( forward [ i ] , backward [ i + 1 ] ) * 2 ) ; }", "nl": "Find maximum length"}
{"code": "System . out . println ( ans ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 6 , 6 , 6 , 9 } ;", "nl": "Given array"}
{"code": "int N = arr . length ;", "nl": "Size of the array"}
{"code": "maxLengthSubArray ( arr , N ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static void minNum ( int n ) { if ( n < 3 ) System . out . println ( - 1 ) ; else System . out . println ( 210 * ( ( int ) ( Math . pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ; }", "nl": "Function to find the minimum number of n digits divisible by all prime digits"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; minNum ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; @ SuppressWarnings ( \" unchecked \" ) class GFG {", "nl": "Java program for the above approach"}
{"code": "static String helper ( int d , int s ) {", "nl": "Function to return the minimum String of length d having the sum of digits s"}
{"code": "StringBuilder ans = new StringBuilder ( ) ; for ( int i = 0 ; i < d ; i ++ ) { ans . append ( \"0\" ) ; } for ( int i = d - 1 ; i >= 0 ; i -- ) {", "nl": "Return a String of length d"}
{"code": "if ( s >= 9 ) { ans . setCharAt ( i , '9' ) ; s -= 9 ; }", "nl": "Greedily put 9 's in the end"}
{"code": "else { char c = ( char ) ( s + ( int ) '0' ) ; ans . setCharAt ( i , c ) ; s = 0 ; } } return ans . toString ( ) ; }", "nl": "Put remaining sum"}
{"code": "static String findMin ( int x , int Y ) {", "nl": "Function to find the smallest number greater than Y whose sum of digits is X"}
{"code": "String y = Integer . toString ( Y ) ; int n = y . length ( ) ; ArrayList p = new ArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { p . add ( 0 ) ; }", "nl": "Convert number y to String"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { p . add ( i , ( int ) ( ( int ) y . charAt ( i ) - ( int ) '0' ) ) ; if ( i > 0 ) { p . add ( i , ( int ) p . get ( i ) + ( int ) p . get ( i - 1 ) ) ; } }", "nl": "Maintain prefix sum of digits"}
{"code": "for ( int i = n - 1 , k = 0 ; ; i -- , k ++ ) {", "nl": "Iterate over Y from the back where k is current length of suffix"}
{"code": "int d = 0 ; if ( i >= 0 ) { d = ( int ) y . charAt ( i ) - ( int ) '0' ; }", "nl": "Stores current digit"}
{"code": "for ( int j = d + 1 ; j <= 9 ; j ++ ) { int r = j ;", "nl": "Increase current digit"}
{"code": "if ( i > 0 ) { r += ( int ) p . get ( i - 1 ) ; }", "nl": "Sum upto current prefix"}
{"code": "if ( x - r >= 0 && x - r <= 9 * k ) {", "nl": "Return answer if remaining sum can be obtained in suffix"}
{"code": "String suf = helper ( k , x - r ) ; String pre = \" \" ; if ( i > 0 ) pre = y . substring ( 0 , i ) ;", "nl": "Find suffix of length k having sum of digits x - r"}
{"code": "char cur = ( char ) ( j + ( int ) '0' ) ; pre += cur ;", "nl": "Append current character"}
{"code": "return pre + suf ; } } } }", "nl": "Return the result"}
{"code": "public static void main ( String [ ] arg ) {", "nl": "Driver code"}
{"code": "int x = 18 ; int y = 99 ;", "nl": "Given number and sum"}
{"code": "System . out . print ( findMin ( x , y ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "public static void largestNumber ( int n , int X , int Y ) { int maxm = Math . max ( X , Y ) ;", "nl": "Function to generate and return the largest number"}
{"code": "Y = X + Y - maxm ;", "nl": "Store the smaller in Y"}
{"code": "X = maxm ;", "nl": "Store the larger in X"}
{"code": "int Xs = 0 ; int Ys = 0 ; while ( n > 0 ) {", "nl": "Stores respective counts"}
{"code": "if ( n % Y == 0 ) {", "nl": "If N is divisible by Y"}
{"code": "Xs += n ;", "nl": "Append X , N times to the answer"}
{"code": "n = 0 ; } else {", "nl": "Reduce N to zero"}
{"code": "n -= X ;", "nl": "Reduce N by X"}
{"code": "Ys += X ; } }", "nl": "Append Y , X times to the answer"}
{"code": "if ( n == 0 ) { while ( Xs -- > 0 ) System . out . print ( X ) ; while ( Ys -- > 0 ) System . out . print ( Y ) ; }", "nl": "If number can be formed"}
{"code": "else System . out . print ( \" - 1\" ) ; }", "nl": "Otherwise"}
{"code": "public static void main ( String [ ] args ) { int n = 19 , X = 7 , Y = 5 ; largestNumber ( n , X , Y ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static int minChanges ( String str , int N ) { int res ; int count0 = 0 , count1 = 0 ;", "nl": "Java implementation of the above approach"}
{"code": "for ( char x : str . toCharArray ( ) ) { if ( x == '0' ) count0 ++ ; } res = count0 ;", "nl": "Traverse input string and store the count of 0"}
{"code": "for ( char x : str . toCharArray ( ) ) { if ( x == '0' ) count0 -- ; if ( x == '1' ) count1 ++ ; res = Math . min ( res , count1 + count0 ) ; } return res ; }", "nl": "Traverse the input string again to find minimum number of flips"}
{"code": "public static void main ( String [ ] args ) { int N = 9 ; String str = \"000101001\" ; System . out . println ( minChanges ( str , N ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the missing number such that maximum absolute difference between adjacent element is minimum"}
{"code": "static int missingnumber ( int n , int arr [ ] ) { int mn = Integer . MAX_VALUE , mx = Integer . MIN_VALUE ;", "nl": "Function to find the missing number such that maximum absolute difference is minimum"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 && arr [ i ] == - 1 && arr [ i - 1 ] != - 1 ) { mn = Math . min ( mn , arr [ i - 1 ] ) ; mx = Math . max ( mx , arr [ i - 1 ] ) ; } if ( i < ( n - 1 ) && arr [ i ] == - 1 && arr [ i + 1 ] != - 1 ) { mn = Math . min ( mn , arr [ i + 1 ] ) ; mx = Math . max ( mx , arr [ i + 1 ] ) ; } } int res = ( mx + mn ) / 2 ; return res ; }", "nl": "Loop to find the maximum and minimum adjacent element to missing number"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; int arr [ ] = { - 1 , 10 , - 1 , 12 , - 1 } ;", "nl": "Driver Code"}
{"code": "int res = missingnumber ( n , arr ) ; System . out . print ( res ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static int lcsubtr ( char a [ ] , char b [ ] , int length1 , int length2 ) {", "nl": "Function to find the length of the longest common substring of the string X and Y"}
{"code": "int dp [ ] [ ] = new int [ length1 + 1 ] [ length2 + 1 ] ; int max = 0 ;", "nl": "LCSuff [ i ] [ j ] stores the lengths of the longest common suffixes of substrings"}
{"code": "for ( int i = 0 ; i <= length1 ; ++ i ) { for ( int j = 0 ; j <= length2 ; ++ j ) {", "nl": "Itearate over strings A and B"}
{"code": "if ( i == 0 j == 0 ) { dp [ i ] [ j ] = 0 ; }", "nl": "If first row or column"}
{"code": "else if ( a [ i - 1 ] == b [ j - 1 ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + 1 ; max = Math . max ( dp [ i ] [ j ] , max ) ; }", "nl": "If matching is found"}
{"code": "else { dp [ i ] [ j ] = 0 ; } } }", "nl": "Otherwise , if matching is not found"}
{"code": "return max ; }", "nl": "Finally , return the resultant maximum value LCS"}
{"code": "public static void main ( String [ ] args ) { String m = \"0110\" ; String n = \"1101\" ; char m1 [ ] = m . toCharArray ( ) ; char m2 [ ] = n . toCharArray ( ) ;", "nl": "Driver Code"}
{"code": "System . out . println ( lcsubtr ( m1 , m2 , m1 . length , m2 . length ) ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; import java . util . * ; class GFG { static int maxN = 20 ; static int maxSum = 50 ; static int minSum = 50 ; static int Base = 50 ;", "nl": "Java program for the above approach"}
{"code": "static int [ ] [ ] dp = new int [ maxN ] [ maxSum + minSum ] ; static boolean [ ] [ ] v = new boolean [ maxN ] [ maxSum + minSum ] ;", "nl": "To store the states of DP"}
{"code": "static int findCnt ( int [ ] arr , int i , int required_sum , int n ) {", "nl": "Function to find count of subsets with a given sum"}
{"code": "if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; }", "nl": "Base case"}
{"code": "if ( v [ i ] [ required_sum + Base ] ) return dp [ i ] [ required_sum + Base ] ;", "nl": "If an already computed subproblem occurs"}
{"code": "v [ i ] [ required_sum + Base ] = true ;", "nl": "Set the state as solved"}
{"code": "dp [ i ] [ required_sum + Base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + Base ] ; }", "nl": "Recurrence relation"}
{"code": "static void countSubsets ( int [ ] arr , int K , int n ) {", "nl": "Function to count ways to split array into pair of subsets with difference K"}
{"code": "int sum = 0 ;", "nl": "Store the total sum of element of the array"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse the array"}
{"code": "sum += arr [ i ] ; }", "nl": "Calculate sum of array elements"}
{"code": "int S1 = ( sum + K ) / 2 ;", "nl": "Store the required sum"}
{"code": "System . out . print ( findCnt ( arr , 0 , S1 , n ) ) ; }", "nl": "Print the number of subsets with sum equal to S1"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 1 , 1 , 2 , 3 } ; int N = arr . length ; int K = 1 ;", "nl": "Driver Code"}
{"code": "countSubsets ( arr , K , N ) ; } }", "nl": "Function Call"}
{"code": "class GFG { static float [ ] [ ] dp = new float [ 105 ] [ 605 ] ;", "nl": "Java program for above approach"}
{"code": "static float find ( int N , int sum ) { if ( N < 0 sum < 0 ) return 0 ; if ( dp [ N ] [ sum ] > 0 ) return dp [ N ] [ sum ] ;", "nl": "Function to calculate the probability for the given sum to be equal to sum in N throws of dice"}
{"code": "if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return ( float ) ( 1.0 / 6 ) ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N ] [ sum ] ; }", "nl": "Base cases"}
{"code": "public static void main ( String [ ] args ) { int N = 4 , a = 13 , b = 17 ; float probability = 0.0f ;", "nl": "Driver Code"}
{"code": "for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ;", "nl": "Calculate probability of all sums from a to b"}
{"code": "System . out . printf ( \" % .6f \" , probability ) ; } }", "nl": "Print the answer"}
{"code": "import java . util . HashMap ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int count ( int n ) {", "nl": "Function to find the minimum number to steps to reduce N to 0"}
{"code": "HashMap < Integer , Integer > dp = new HashMap < Integer , Integer > ( ) ;", "nl": "Dictionary for storing the precomputed sum"}
{"code": "dp . put ( 0 , 0 ) ; dp . put ( 1 , 1 ) ;", "nl": "Bases Cases"}
{"code": "if ( ! dp . containsKey ( n ) ) dp . put ( n , 1 + Math . min ( n % 2 + count ( n / 2 ) , n % 3 + count ( n / 3 ) ) ) ;", "nl": "Check if n is not in dp then only call the function so as to reduce no of recursive calls"}
{"code": "return dp . get ( n ) ; }", "nl": "Return the answer"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 6 ;", "nl": "Given number N"}
{"code": "System . out . println ( String . valueOf ( ( count ( N ) ) ) ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java implementation to find the minimum number of operations required to change an array of all zeros such that every element is greater than the given array"}
{"code": "static void find_minimum_operations ( int n , int b [ ] , int k ) {", "nl": "Function to find the minimum number of operations required to change all the array of zeros such that every element is greater than the given array"}
{"code": "int d [ ] = new int [ n + 1 ] ;", "nl": "Declaring the difference array of size N"}
{"code": "int i , operations = 0 , need ; for ( i = 0 ; i < n ; i ++ ) {", "nl": "Number of operations"}
{"code": "if ( i > 0 ) { d [ i ] += d [ i - 1 ] ; }", "nl": "First update the D [ i ] value with the previous value"}
{"code": "if ( b [ i ] > d [ i ] ) {", "nl": "The index i has to be incremented"}
{"code": "operations += b [ i ] - d [ i ] ; need = b [ i ] - d [ i ] ;", "nl": "We have to perform ( b [ i ] - d [ i ] ) operations more"}
{"code": "d [ i ] += need ;", "nl": "Increment the range i to i + k by need"}
{"code": "if ( i + k <= n ) { d [ i + k ] -= need ; } } } System . out . println ( operations ) ; }", "nl": "Check if i + k is valid index"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; int b [ ] = { 1 , 2 , 3 , 4 , 5 } ; int k = 2 ;", "nl": "Driver Code"}
{"code": "find_minimum_operations ( n , b , k ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {", "nl": "Java implementation to find the number of ways to cut the matrix into the K parts such that each part have atleast one filled cell"}
{"code": "static int ways ( int [ ] [ ] arr , int K ) { int R = arr . length ; int C = arr [ 0 ] . length ; int [ ] [ ] preSum = new int [ R ] [ C ] ;", "nl": "Function to find the number of ways to cut the matrix into the K parts such that each part have atleast one filled cell"}
{"code": "for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { preSum [ r ] = arr [ r ] ; if ( r + 1 < R ) preSum [ r ] += preSum [ r + 1 ] ; if ( c + 1 < C ) preSum [ r ] += preSum [ r ] ; if ( r + 1 < R && c + 1 < C ) preSum [ r ] -= preSum [ r + 1 ] ; } }", "nl": "Loop to find prefix sum of the given matrix"}
{"code": "int [ ] [ ] [ ] dp = new int [ K + 1 ] [ R ] [ C ] ;", "nl": "dp ( r , c , 1 ) = 1 if preSum [ r ] else 0"}
{"code": "for ( int k = 1 ; k <= K ; k ++ ) { for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { if ( k == 1 ) { dp [ k ] [ r ] = ( preSum [ r ] > 0 ) ? 1 : 0 ; } else { dp [ k ] [ r ] = 0 ; for ( int r1 = r + 1 ; r1 < R ; r1 ++ ) {", "nl": "Loop to iterate over the dp table of the given matrix"}
{"code": "if ( preSum [ r ] - preSum [ r1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r1 ] ; } for ( int c1 = c + 1 ; c1 < C ; c1 ++ ) {", "nl": "Check if can cut horizontally at r1 , at least one apple in matrix ( r , c ) -> r1 , C - 1"}
{"code": "if ( preSum [ r ] - preSum [ r ] [ c1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r ] [ c1 ] ; } } } } } return dp [ K ] [ 0 ] [ 0 ] ; }", "nl": "Check if we can cut vertically at c1 , at least one apple in matrix ( r , c ) -> R - 1 , c1"}
{"code": "public static void main ( String [ ] args ) { int [ ] [ ] arr = { { 1 , 0 , 0 } , { 1 , 1 , 1 } , { 0 , 0 , 0 } } ; int k = 3 ;", "nl": "Driver code"}
{"code": "System . out . println ( ways ( arr , k ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG { static int p = 1000000007 ;", "nl": "Java implementation of the above approach"}
{"code": "static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) {", "nl": "Iterative Function to calculate ( x ^ y ) % p in O ( log y )"}
{"code": "if ( y % 2 == 1 ) res = ( res * x ) % p ;", "nl": "If y is odd , multiply x with result"}
{"code": "y = y >> 1 ; x = ( x * x ) % p ; } return res ; }", "nl": "y must be even now"}
{"code": "static void nCr ( int n , int p , int f [ ] [ ] , int m ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) {", "nl": "Iterative Function to calculate ( nCr ) % p and save in f [ n ] [ r ]"}
{"code": "if ( j > i ) { f [ i ] [ j ] = 0 ; }", "nl": "If j > i then C ( i , j ) = 0"}
{"code": "else if ( j == 0 j == i ) { f [ i ] [ j ] = 1 ; } else { f [ i ] [ j ] = ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % p ; } } } }", "nl": "If iis equal to j then C ( i , j ) = 1"}
{"code": "static void ProductOfSubsets ( int arr [ ] , int n , int m ) { int [ ] [ ] f = new int [ n + 1 ] [ 100 ] ; nCr ( n , p - 1 , f , m ) ; Arrays . sort ( arr ) ;", "nl": "Function calculate the Final answer"}
{"code": "long ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Initialize ans"}
{"code": "int x = 0 ; for ( int j = 1 ; j <= m ; j ++ ) {", "nl": "x is count of occurence of arr [ i ] in different set such that index of arr [ i ] in those sets divides K completely ."}
{"code": "if ( m % j == 0 ) {", "nl": "Finding the count of arr [ i ] by placing it at index which divides K completely"}
{"code": "x = ( x + ( f [ n - i - 1 ] [ m - j ] * f [ i ] [ j - 1 ] ) % ( p - 1 ) ) % ( p - 1 ) ; } } ans = ( ( ans * power ( arr [ i ] , x , p ) ) % p ) ; } System . out . print ( ans + \"NEW_LINE\"); }", "nl": "By Fermat 's theorem"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 4 , 5 , 7 , 9 , 3 } ; int K = 4 ; int N = arr . length ; ProductOfSubsets ( arr , N , K ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int countWays ( int n , int m ) {", "nl": "Function to count the number of ways to write N as sum of k non - negative integers"}
{"code": "int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;", "nl": "Initialise dp [ ] [ ] array"}
{"code": "for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; }", "nl": "Only 1 way to choose the value with sum K"}
{"code": "int sum ; for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { sum = 0 ;", "nl": "Initialise sum"}
{"code": "for ( int k = 0 ; k <= j ; k ++ ) { sum += dp [ i - 1 ] [ k ] ; }", "nl": "Count the ways from previous states"}
{"code": "dp [ i ] [ j ] = sum ; } }", "nl": "Update the sum"}
{"code": "return dp [ m ] [ n ] ; }", "nl": "Return the final count of ways"}
{"code": "public static void main ( String [ ] args ) { int N = 2 , K = 3 ;", "nl": "Driver Code"}
{"code": "System . out . print ( countWays ( N , K ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int countWays ( int n , int m ) {", "nl": "Function to count the number of ways to write N as sum of k non - negative integers"}
{"code": "int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;", "nl": "Initialise dp [ ] [ ] array"}
{"code": "for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; if ( i != 0 ) { dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] ; } }", "nl": "Fill the dp [ ] [ ] with sum = m"}
{"code": "for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) {", "nl": "Iterate the dp [ ] [ ] to fill the dp [ ] [ ] array"}
{"code": "if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; }", "nl": "Condition for first column"}
{"code": "else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;", "nl": "Else fill the dp [ ] [ ] with sum till ( i , j )"}
{"code": "if ( i == m && j == n ) { return dp [ i ] [ j ] ; }", "nl": "If reach the end , then return the value"}
{"code": "dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } } } return Integer . MIN_VALUE ; }", "nl": "Update at current index"}
{"code": "public static void main ( String [ ] args ) { int N = 2 , K = 3 ;", "nl": "Driver Code"}
{"code": "System . out . print ( countWays ( N , K ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . HashMap ; import java . util . Vector ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "public static void SieveOfEratosthenes ( int MAX , Vector < Integer > primes ) { boolean [ ] prime = new boolean [ MAX + 1 ] ; for ( int i = 0 ; i < MAX + 1 ; i ++ ) prime [ i ] = true ;", "nl": "Function to pre - store primes"}
{"code": "for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) {", "nl": "Sieve method to check if prime or not"}
{"code": "for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } }", "nl": "Multiples"}
{"code": "for ( int i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] ) primes . add ( i ) ; } }", "nl": "Pre - store all the primes"}
{"code": "public static int findLongest ( int [ ] A , int n ) {", "nl": "Function to find the intest subsequence"}
{"code": "HashMap < Integer , Integer > mpp = new HashMap < > ( ) ; Vector < Integer > primes = new Vector < > ( ) ;", "nl": "Hash map"}
{"code": "SieveOfEratosthenes ( A [ n - 1 ] , primes ) ; int [ ] dp = new int [ n ] ;", "nl": "Call the function to pre - store the primes"}
{"code": "dp [ n - 1 ] = 1 ; mpp . put ( A [ n - 1 ] , n - 1 ) ;", "nl": "Initialize last element with 1 as that is the intest possible"}
{"code": "for ( int i = n - 2 ; i >= 0 ; i -- ) {", "nl": "Iterate from the back and find the intest"}
{"code": "int num = A [ i ] ;", "nl": "Get the number"}
{"code": "dp [ i ] = 1 ; int maxi = 0 ;", "nl": "Initialize dp [ i ] as 1 as the element will only me in the subsequence ."}
{"code": "for ( int it : primes ) {", "nl": "Iterate in all the primes and multiply to get the next element"}
{"code": "int xx = num * it ;", "nl": "Next element if multiplied with it"}
{"code": "if ( xx > A [ n - 1 ] ) break ;", "nl": "If exceeds the last element then break"}
{"code": "else if ( mpp . get ( xx ) != null && mpp . get ( xx ) != 0 ) {", "nl": "If the number is there in the array"}
{"code": "dp [ i ] = Math . max ( dp [ i ] , 1 + dp [ mpp . get ( xx ) ] ) ; } }", "nl": "Get the maximum most element"}
{"code": "mpp . put ( A [ i ] , i ) ; } int ans = 1 ;", "nl": "Hash the element"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , dp [ i ] ) ; return ans ; }", "nl": "Find the intest"}
{"code": "public static void main ( String [ ] args ) { int [ ] a = { 1 , 2 , 5 , 6 , 12 , 35 , 60 , 385 } ; int n = a . length ; System . out . println ( findLongest ( a , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class solution {", "nl": "Java program to find the number of Bit Strings of length N with K adjacent set bits"}
{"code": "static int waysToKAdjacentSetBits ( int n , int k , int currentIndex , int adjacentSetBits , int lastBit ) {", "nl": "Function to find the number of Bit Strings of length N with K adjacent set bits"}
{"code": "if ( currentIndex == n ) {", "nl": "Base Case when we form bit string of length n"}
{"code": "if ( adjacentSetBits == k ) return 1 ; return 0 ; } int noOfWays = 0 ;", "nl": "if f ( bit string ) = k , count this way"}
{"code": "if ( lastBit == 1 ) {", "nl": "Check if the last bit was set , if it was set then call for next index by incrementing the adjacent bit count else just call the next index with same value of adjacent bit count and either set the bit at current index or let it remain unset"}
{"code": "noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ;", "nl": "set the bit at currentIndex"}
{"code": "noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } else if ( lastBit == 0 ) { noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } return noOfWays ; }", "nl": "unset the bit at currentIndex"}
{"code": "public static void main ( String args [ ] ) { int n = 5 , k = 2 ;", "nl": "Driver Code"}
{"code": "int totalWays = waysToKAdjacentSetBits ( n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( n , k , 1 , 0 , 0 ) ; System . out . println ( \" Number \u2581 of \u2581 ways \u2581 = \u2581 \" + totalWays ) ; } }", "nl": "total ways = ( ways by placing 1 st bit as 1 + ways by placing 1 st bit as 0 )"}
{"code": "import java . util . * ; class GFG {", "nl": "Java Program to find sum of all combination takne ( 1 to N ) at a time using dynamic programming"}
{"code": "static void postfix ( int a [ ] , int n ) { for ( int i = n - 1 ; i > 0 ; i -- ) { a [ i - 1 ] = a [ i - 1 ] + a [ i ] ; } }", "nl": "find the postfix sum array"}
{"code": "static void modify ( int a [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i - 1 ] = i * a [ i ] ; } }", "nl": "modify the array such that we don 't  have to compute the products which  are obtained before"}
{"code": "static void allCombination ( int a [ ] , int n ) { int sum = 0 ;", "nl": "finding sum of all combination taken 1 to N at a time"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) { sum += i ; } System . out . println ( \" f ( 1 ) \u2581 - - > \u2581 \" + sum ) ;", "nl": "sum taken 1 at time is simply sum of 1 - N"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) {", "nl": "for sum of products for all combination"}
{"code": "postfix ( a , n - i + 1 ) ;", "nl": "finding postfix array"}
{"code": "sum = 0 ; for ( int j = 1 ; j <= n - i ; j ++ ) { sum += ( j * a [ j ] ) ; } System . out . println ( \" f ( \" + ( i + 1 ) + \" ) \u2581 - - > \u2581 \" + sum ) ;", "nl": "sum of products taken i + 1 at a time"}
{"code": "modify ( a , n ) ; } }", "nl": "modify the array for overlapping problem"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; int [ ] a = new int [ n ] ;", "nl": "Driver 's Code"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = i + 1 ; }", "nl": "storing numbers from 1 to N"}
{"code": "allCombination ( a , n ) ; } }", "nl": "calling allCombination"}
{"code": "import java . lang . * ; import java . util . * ; public class GfG {", "nl": "Program to find n - th stair using step size 1 or 2 or 3."}
{"code": "public static int findStep ( int n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; }", "nl": "Returns count of ways to reach n - th stair using 1 or 2 or 3 steps ."}
{"code": "public static void main ( String argc [ ] ) { int n = 4 ; System . out . println ( findStep ( n ) ) ; } }", "nl": "Driver function"}
{"code": "import java . io . * ; class Partition {", "nl": "A recursive Java solution for partition problem"}
{"code": "static boolean isSubsetSum ( int arr [ ] , int n , int sum ) {", "nl": "A utility function that returns true if there is a subset of arr [ ] with sun equal to given sum"}
{"code": "if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ;", "nl": "Base Cases"}
{"code": "if ( arr [ n - 1 ] > sum ) return isSubsetSum ( arr , n - 1 , sum ) ;", "nl": "If last element is greater than sum , then ignore it"}
{"code": "return isSubsetSum ( arr , n - 1 , sum ) || isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) ; }", "nl": "else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element"}
{"code": "static boolean findPartition ( int arr [ ] , int n ) {", "nl": "Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false"}
{"code": "int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ;", "nl": "Calculate sum of the elements in array"}
{"code": "if ( sum % 2 != 0 ) return false ;", "nl": "If sum is odd , there cannot be two subsets with equal sum"}
{"code": "return isSubsetSum ( arr , n , sum / 2 ) ; }", "nl": "Find if there is subset with sum equal to half of total sum"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 3 , 1 , 5 , 9 , 12 } ; int n = arr . length ;", "nl": "Driver code"}
{"code": "if ( findPartition ( arr , n ) == true ) System . out . println ( \" Can \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 \" + \" subsets \u2581 of \u2581 equal \u2581 sum \" ) ; else System . out . println ( \" Can \u2581 not \u2581 be \u2581 divided \u2581 into \u2581 \" + \" two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ) ; } }", "nl": "Function call"}
{"code": "import java . io . * ; class GFG {", "nl": "A Dynamic Programming based Java program to partition problem"}
{"code": "public static boolean findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ;", "nl": "Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false"}
{"code": "for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; boolean [ ] part = new boolean [ sum / 2 + 1 ] ;", "nl": "Calculate sum of all elements"}
{"code": "for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = false ; }", "nl": "Initialize the part array as 0"}
{"code": "for ( i = 0 ; i < n ; i ++ ) {", "nl": "Fill the partition table in bottom up manner"}
{"code": "for ( j = sum / 2 ; j >= arr [ i ] ; j -- ) {", "nl": "The element to be included in the sum cannot be greater than the sum"}
{"code": "if ( part [ j - arr [ i ] ] == true j == arr [ i ] ) part [ j ] = true ; } } return part [ sum / 2 ] ; }", "nl": "Check if sum - arr [ i ] could be formed from a subset using elements before index i"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 3 , 2 , 3 , 2 } ; int n = 6 ;", "nl": "Driver code"}
{"code": "if ( findPartiion ( arr , n ) == true ) System . out . println ( \" Can \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 \" + \" subsets \u2581 of \u2581 equal \u2581 sum \" ) ; else System . out . println ( \" Can \u2581 not \u2581 be \u2581 divided \u2581 into \u2581 \" + \" two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "JAVA program for the above approach"}
{"code": "static int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long m = 1000000007 ; long inv [ ] = new long [ r + 1 ] ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ;", "nl": "Function to find binomial coefficient"}
{"code": "for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m / i ) * inv [ ( int ) ( m % i ) ] % m ; } int ans = 1 ;", "nl": "Getting the modular inversion for all the numbers from 2 to r with respect to m here m = 1000000007"}
{"code": "for ( int i = 2 ; i <= r ; i ++ ) { ans = ( int ) ( ( ( ans % m ) * ( inv [ i ] % m ) ) % m ) ; }", "nl": "for 1 / ( r ! ) part"}
{"code": "for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( int ) ( ( ( ans % m ) * ( i % m ) ) % m ) ; } return ans ; }", "nl": "for ( n ) * ( n - 1 ) * ( n - 2 ) * ... * ( n - r + 1 ) part"}
{"code": "public static void main ( String [ ] args ) { int n = 5 , r = 2 ; System . out . print ( \" Value \u2581 of \u2581 C ( \" + n + \" , \u2581 \" + r + \" ) \u2581 is \u2581 \" + binomialCoeff ( n , r ) + \"NEW_LINE\"); } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static int gcd ( int a , int b ) {", "nl": "Function to find the gcd of two numbers"}
{"code": "if ( a < b ) { int t = a ; a = b ; b = t ; } if ( a % b == 0 ) return b ;", "nl": "Base case"}
{"code": "return gcd ( b , a % b ) ; }", "nl": "Recurse"}
{"code": "static void printAnswer ( int x , int y ) {", "nl": "Function to print the answer"}
{"code": "int val = gcd ( x , y ) ;", "nl": "GCD of X and Y"}
{"code": "if ( ( val & ( val - 1 ) ) == 0 ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; }", "nl": "If GCD is power of 2"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int x = 4 ; int y = 7 ;", "nl": "Given X and Y"}
{"code": "printAnswer ( x , y ) ; } }", "nl": "Function call"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static int getElement ( int N , int r , int c ) {", "nl": "Function to return the element in the rth row and cth column from the required matrix"}
{"code": "if ( r > c ) return 0 ;", "nl": "Condition for lower half of matrix"}
{"code": "if ( r == 1 ) { return c ; }", "nl": "Condition if element is in first row"}
{"code": "int a = ( r + 1 ) * ( int ) ( Math . pow ( 2 , ( r - 2 ) ) ) ;", "nl": "Starting element of AP in row r"}
{"code": "int d = ( int ) ( Math . pow ( 2 , ( r - 1 ) ) ) ;", "nl": "Common difference of AP in row r"}
{"code": "c = c - r ; int element = a + d * c ; return element ; }", "nl": "Position of element to find in AP in row r"}
{"code": "public static void main ( String [ ] args ) { int N = 4 , R = 3 , C = 4 ; System . out . println ( getElement ( N , R , C ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG {", "nl": "Java implementation of above approach"}
{"code": "static String MinValue ( String number , int x ) {", "nl": "Function to insert X in N and return the minimum value string"}
{"code": "int length = number . length ( ) ;", "nl": "Variable to store length of string N"}
{"code": "int position = length + 1 ;", "nl": "Variable to denote the position where X must be added"}
{"code": "if ( number . charAt ( 0 ) == ' - ' ) {", "nl": "If the given string N represent a negative value"}
{"code": "for ( int i = number . length ( ) - 1 ; i >= 1 ; -- i ) { if ( ( number . charAt ( i ) - 48 ) < x ) { position = i ; } } } else {", "nl": "X must be place at the last index where is greater than N [ i ]"}
{"code": "for ( int i = number . length ( ) - 1 ; i >= 0 ; -- i ) { if ( ( number . charAt ( i ) - 48 ) > x ) { position = i ; } } }", "nl": "For positive numbers , X must be placed at the last index where it is smaller than N [ i ]"}
{"code": "number = number . substring ( 0 , position ) + x + number . substring ( position , number . length ( ) ) ;", "nl": "Insert X at that position"}
{"code": "return number . toString ( ) ; }", "nl": "return string"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver call"}
{"code": "String number = \"89\" ; int x = 1 ;", "nl": "given input"}
{"code": "System . out . print ( MinValue ( number , x ) ) ; } }", "nl": "function call"}
{"code": "class GFG {", "nl": "Java program for above approach"}
{"code": "public static String divisibleByk ( String s , int n , int k ) {", "nl": "Function to check the binary number is divisible by K"}
{"code": "int [ ] poweroftwo = new int [ n ] ;", "nl": "Array poweroftwo will store pow ( 2 , i ) % k"}
{"code": "poweroftwo [ 0 ] = 1 % k ; for ( int i = 1 ; i < n ; i ++ ) {", "nl": "Initializing the first element in Array"}
{"code": "poweroftwo [ i ] = ( poweroftwo [ i - 1 ] * ( 2 % k ) ) % k ; }", "nl": "Storing every pow ( 2 , i ) % k value in the array"}
{"code": "int rem = 0 ;", "nl": "To store the remaining"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Iterating till N"}
{"code": "if ( s . charAt ( n - i - 1 ) == '1' ) {", "nl": "If current bit is 1"}
{"code": "rem += ( poweroftwo [ i ] ) ; rem %= k ; } }", "nl": "Updating rem"}
{"code": "if ( rem == 0 ) { return \" Yes \" ; }", "nl": "If completely divisible"}
{"code": "else return \" No \" ; }", "nl": "If not Completely divisible"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "String s = \"1010001\" ; int k = 9 ;", "nl": "Given Input"}
{"code": "int n = s . length ( ) ;", "nl": "length of string s"}
{"code": "System . out . println ( divisibleByk ( s , n , k ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int maxSumbySplittingString ( String str , int N ) {", "nl": "Function to find the maximum sum of count of 0 s in the left subString and count of 1 s in the right subString by splitting the String"}
{"code": "int cntOne = 0 ;", "nl": "Stores count of 1 s the in binary String"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the binary String"}
{"code": "if ( str . charAt ( i ) == '1' ) {", "nl": "If current character is '1'"}
{"code": "cntOne ++ ; } }", "nl": "Update cntOne"}
{"code": "int zero = 0 ;", "nl": "Stores count of 0 s"}
{"code": "int one = 0 ;", "nl": "Stores count of 1 s"}
{"code": "int res = 0 ;", "nl": "Stores maximum sum of count of 0 s and 1 s by splitting the String"}
{"code": "for ( int i = 0 ; i < N - 1 ; i ++ ) {", "nl": "Traverse the binary String"}
{"code": "if ( str . charAt ( i ) == '0' ) {", "nl": "If current character is '0'"}
{"code": "zero ++ ; }", "nl": "Update zero"}
{"code": "else {", "nl": "If current character is '1'"}
{"code": "one ++ ; }", "nl": "Update one"}
{"code": "res = Math . max ( res , zero + cntOne - one ) ; } return res ; }", "nl": "Update res"}
{"code": "public static void main ( String [ ] args ) { String str = \"00111\" ; int N = str . length ( ) ; System . out . print ( maxSumbySplittingString ( str , N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void cntBalancedParenthesis ( String s , int N ) {", "nl": "Function to find the maximum count of pairs required to be removed such that subsequence of string does not contain any valid parenthesis"}
{"code": "int cntPairs = 0 ;", "nl": "Stores count of pairs of balanced parenthesis"}
{"code": "int cntCurly = 0 ;", "nl": "Stores count of curly balanced parenthesis"}
{"code": "int cntSml = 0 ;", "nl": "Stores count of small balanced parenthesis"}
{"code": "int cntSqr = 0 ;", "nl": "Stores count of square balanced parenthesis"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == ' { ' ) {", "nl": "Iterate over characters of the string"}
{"code": "cntCurly ++ ; } else if ( s . charAt ( i ) == ' ( ' ) {", "nl": "Update cntCurly"}
{"code": "cntSml ++ ; } else if ( s . charAt ( i ) == ' [ ' ) {", "nl": "Update cntSml"}
{"code": "cntSqr ++ ; } else if ( s . charAt ( i ) == ' } ' && cntCurly > 0 ) {", "nl": "Update cntSqr"}
{"code": "cntCurly -- ;", "nl": "Update cntCurly"}
{"code": "cntPairs ++ ; } else if ( s . charAt ( i ) == ' ) ' && cntSml > 0 ) {", "nl": "Update cntPairs"}
{"code": "cntSml -- ;", "nl": "Update cntSml"}
{"code": "cntPairs ++ ; } else if ( s . charAt ( i ) == ' ] ' && cntSqr > 0 ) {", "nl": "Update cntPairs"}
{"code": "cntSqr -- ;", "nl": "Update cntSml"}
{"code": "cntPairs ++ ; } } System . out . println ( cntPairs ) ; }", "nl": "Update cntPairs"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "String s = \" { ( } ) \" ; int N = s . length ( ) ;", "nl": "Given String"}
{"code": "cntBalancedParenthesis ( s , N ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int arcIntersection ( String S , int len ) { Stack < Character > stk = new Stack < > ( ) ;", "nl": "Function to check if there is arc intersection or not"}
{"code": "for ( int i = 0 ; i < len ; i ++ ) {", "nl": "Traverse the String S"}
{"code": "stk . push ( S . charAt ( i ) ) ; if ( stk . size ( ) >= 2 ) {", "nl": "Insert all the elements in the stack one by one"}
{"code": "char temp = stk . peek ( ) ;", "nl": "Extract the top element"}
{"code": "stk . pop ( ) ;", "nl": "Pop out the top element"}
{"code": "if ( stk . peek ( ) == temp ) { stk . pop ( ) ; }", "nl": "Check if the top element is same as the popped element"}
{"code": "else { stk . add ( temp ) ; } } }", "nl": "Otherwise"}
{"code": "if ( stk . isEmpty ( ) ) return 1 ; return 0 ; }", "nl": "If the stack is empty"}
{"code": "static void countString ( String arr [ ] , int N ) {", "nl": "Function to check if there is arc intersection or not for the given array of Strings"}
{"code": "int count = 0 ;", "nl": "Stores count of String not having arc intersection"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Iterate through array"}
{"code": "int len = arr [ i ] . length ( ) ;", "nl": "Length of every String"}
{"code": "count += arcIntersection ( arr [ i ] , len ) ; }", "nl": "Function Call"}
{"code": "System . out . print ( count + \"NEW_LINE\"); }", "nl": "Print the desired count"}
{"code": "public static void main ( String [ ] args ) { String arr [ ] = { \"0101\" , \"0011\" , \"0110\" } ; int N = arr . length ;", "nl": "Driver Code"}
{"code": "countString ( arr , N ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static String ConvertequivalentBase8 ( String S ) {", "nl": "Function to convert the binary string into octal representation"}
{"code": "HashMap < String , Character > mp = new HashMap < String , Character > ( ) ;", "nl": "Stores binary representation of the decimal value [ 0 - 7 ]"}
{"code": "mp . put ( \"000\" , '0' ) ; mp . put ( \"001\" , '1' ) ; mp . put ( \"010\" , '2' ) ; mp . put ( \"011\" , '3' ) ; mp . put ( \"100\" , '4' ) ; mp . put ( \"101\" , '5' ) ; mp . put ( \"110\" , '6' ) ; mp . put ( \"111\" , '7' ) ;", "nl": "Stores the decimal values of binary Strings [ 0 - 7 ]"}
{"code": "int N = S . length ( ) ; if ( N % 3 == 2 ) {", "nl": "Stores length of S"}
{"code": "S = \"0\" + S ; } else if ( N % 3 == 1 ) {", "nl": "Update S"}
{"code": "S = \"00\" + S ; }", "nl": "Update S"}
{"code": "N = S . length ( ) ;", "nl": "Update N"}
{"code": "String oct = \" \" ;", "nl": "Stores octal representation of the binary String"}
{"code": "for ( int i = 0 ; i < N ; i += 3 ) {", "nl": "Traverse the binary String"}
{"code": "String temp = S . substring ( i , i + 3 ) ;", "nl": "Stores 3 consecutive characters of the binary String"}
{"code": "oct += mp . get ( temp ) ; } return oct ; }", "nl": "Append octal representation of temp"}
{"code": "static String binString_div_9 ( String S , int N ) {", "nl": "Function to check if binary String is divisible by 9 or not"}
{"code": "String oct = \" \" ; oct = ConvertequivalentBase8 ( S ) ;", "nl": "Stores octal representation of S"}
{"code": "int oddSum = 0 ;", "nl": "Stores sum of elements present at odd positions of oct"}
{"code": "int evenSum = 0 ;", "nl": "Stores sum of elements present at odd positions of oct"}
{"code": "int M = oct . length ( ) ;", "nl": "Stores length of oct"}
{"code": "for ( int i = 0 ; i < M ; i += 2 )", "nl": "Traverse the String oct"}
{"code": "oddSum += ( oct . charAt ( i ) - '0' ) ;", "nl": "Update oddSum"}
{"code": "for ( int i = 1 ; i < M ; i += 2 ) {", "nl": "Traverse the String oct"}
{"code": "evenSum += ( oct . charAt ( i ) - '0' ) ; }", "nl": "Update evenSum"}
{"code": "int Oct_9 = 11 ;", "nl": "Stores octal representation of 9"}
{"code": "if ( Math . abs ( oddSum - evenSum ) % Oct_9 == 0 ) { return \" Yes \" ; } return \" No \" ; }", "nl": "If absolute value of ( oddSum - evenSum ) is divisible by Oct_9"}
{"code": "public static void main ( String [ ] args ) { String S = \"1010001\" ; int N = S . length ( ) ; System . out . println ( binString_div_9 ( S , N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; import java . lang . * ; class GFG {", "nl": "Java program to gather characters of a string in minimum cost"}
{"code": "static int min_cost ( String S ) {", "nl": "Function to calculate the minimum cost"}
{"code": "int cost = 0 ;", "nl": "Stores the minimum cost"}
{"code": "int F = 0 ;", "nl": "Stores the count of characters found"}
{"code": "int B = 0 ; int count = 0 ; for ( char c : S . toCharArray ( ) ) if ( c == ' \u2581 ' ) count ++ ;", "nl": "Stores the count of blank spaces found"}
{"code": "int n = S . length ( ) - count ;", "nl": "Stores the count of total characters"}
{"code": "if ( n == 1 ) return cost ;", "nl": "If the count of characters is equal to 1"}
{"code": "for ( char in : S . toCharArray ( ) ) {", "nl": "Iterate over the string"}
{"code": "if ( in != ' \u2581 ' ) {", "nl": "Consider the previous character together with current character"}
{"code": "if ( B != 0 ) {", "nl": "If not together already"}
{"code": "cost += Math . min ( n - F , F ) * B ; B = 0 ; }", "nl": "Add the cost to group them together"}
{"code": "F += 1 ; }", "nl": "Increase count of characters found"}
{"code": "else {", "nl": "Otherwise"}
{"code": "B += 1 ; } }", "nl": "Increase count of spaces found"}
{"code": "return cost ; }", "nl": "Return the total cost obtained"}
{"code": "public static void main ( String [ ] args ) { String S = \" \u2581 @ $ \" ; System . out . println ( min_cost ( S ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static boolean isVowel ( char ch ) { if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) return true ; else return false ; }", "nl": "Function that return true if the given character is a vowel"}
{"code": "static int minCost ( String S ) {", "nl": "Function to return the minimum cost to convert all the vowels of a string to a single one"}
{"code": "int cA = 0 ; int cE = 0 ; int cI = 0 ; int cO = 0 ; int cU = 0 ;", "nl": "Stores count of respective vowels"}
{"code": "for ( int i = 0 ; i < S . length ( ) ; i ++ ) {", "nl": "Iterate through the string"}
{"code": "if ( isVowel ( S . charAt ( i ) ) ) {", "nl": "If a vowel is encountered"}
{"code": "cA += Math . abs ( S . charAt ( i ) - ' a ' ) ; cE += Math . abs ( S . charAt ( i ) - ' e ' ) ; cI += Math . abs ( S . charAt ( i ) - ' i ' ) ; cO += Math . abs ( S . charAt ( i ) - ' o ' ) ; cU += Math . abs ( S . charAt ( i ) - ' u ' ) ; } }", "nl": "Calculate the cost"}
{"code": "return Math . min ( Math . min ( Math . min ( Math . min ( cA , cE ) , cI ) , cO ) , cU ) ; }", "nl": "Return the minimum cost"}
{"code": "public static void main ( String [ ] args ) { String S = \" geeksforgeeks \" ; System . out . println ( minCost ( S ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to generate a string whose substrings of length K concatenates to form given strings"}
{"code": "public static void decode_String ( String str , int K ) { String ans = \" \" ;", "nl": "Function to return the required required string"}
{"code": "for ( int i = 0 ; i < str . length ( ) ; i += K )", "nl": "Iterate the given string"}
{"code": "ans += str . charAt ( i ) ;", "nl": "Append the first character of every substring of length K"}
{"code": "for ( int i = str . length ( ) - ( K - 1 ) ; i < str . length ( ) ; i ++ ) ans += str . charAt ( i ) ; System . out . println ( ans ) ; }", "nl": "Consider all characters from the last substring"}
{"code": "public static void main ( String [ ] args ) { int K = 3 ; String str = \" abcbcscsesesesd \" ; decode_String ( str , K ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find lexicographically smallest K - length substring containing maximum number of vowels"}
{"code": "static String maxVowelSubString ( String str , int K ) {", "nl": "Function that prints the lexicographically smallest K - length substring containing maximum number of vowels"}
{"code": "int N = str . length ( ) ;", "nl": "Store the length of the string"}
{"code": "int [ ] pref = new int [ N ] ;", "nl": "Initialize a prefix sum array"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Loop through the string to create the prefix sum array"}
{"code": "if ( str . charAt ( i ) == ' a ' || str . charAt ( i ) == ' e ' || str . charAt ( i ) == ' i ' || str . charAt ( i ) == ' o ' || str . charAt ( i ) == ' u ' ) pref [ i ] = 1 ;", "nl": "Store 1 at the index if it is a vowel"}
{"code": "else pref [ i ] = 0 ;", "nl": "Otherwise , store 0"}
{"code": "if ( i != 0 ) pref [ i ] += pref [ i - 1 ] ; }", "nl": "Process the prefix array"}
{"code": "int maxCount = pref [ K - 1 ] ;", "nl": "Initialize the variable to store maximum count of vowels"}
{"code": "String res = str . substring ( 0 , K ) ;", "nl": "Initialize the variable to store substring with maximum count of vowels"}
{"code": "for ( int i = K ; i < N ; i ++ ) {", "nl": "Loop through the prefix array"}
{"code": "int currCount = pref [ i ] - pref [ i - K ] ;", "nl": "Store the current count of vowels"}
{"code": "if ( currCount > maxCount ) { maxCount = currCount ; res = str . substring ( i - K + 1 , i + 1 ) ; }", "nl": "Update the result if current count is greater than maximum count"}
{"code": "else if ( currCount == maxCount ) { String temp = str . substring ( i - K + 1 , i + 1 ) ; if ( temp . compareTo ( res ) < 0 ) res = temp ; } }", "nl": "Update lexicographically smallest substring if the current count is equal to the maximum count"}
{"code": "return res ; }", "nl": "Return the result"}
{"code": "public static void main ( String [ ] args ) { String str = \" ceebbaceeffo \" ; int K = 3 ; System . out . print ( maxVowelSubString ( str , K ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void decodeStr ( String str , int len ) {", "nl": "Function to decode and print the original String"}
{"code": "char [ ] c = new char [ len ] ; int med , pos = 1 , k ;", "nl": "To store the decoded String"}
{"code": "if ( len % 2 == 1 ) med = len / 2 ; else med = len / 2 - 1 ;", "nl": "Getting the mid element"}
{"code": "c [ med ] = str . charAt ( 0 ) ;", "nl": "Storing the first element of the String at the median position"}
{"code": "if ( len % 2 == 0 ) c [ med + 1 ] = str . charAt ( 1 ) ;", "nl": "If the length is even then store the second element also"}
{"code": "if ( len % 2 == 1 ) k = 1 ; else k = 2 ; for ( int i = k ; i < len ; i += 2 ) { c [ med - pos ] = str . charAt ( i ) ;", "nl": "k represents the number of characters that are already stored in the c [ ]"}
{"code": "if ( len % 2 == 1 ) c [ med + pos ] = str . charAt ( i + 1 ) ;", "nl": "If String length is odd"}
{"code": "else c [ med + pos + 1 ] = str . charAt ( i + 1 ) ; pos ++ ; }", "nl": "If it is even"}
{"code": "for ( int i = 0 ; i < len ; i ++ ) System . out . print ( c [ i ] ) ; }", "nl": "Print the decoded String"}
{"code": "public static void main ( String [ ] args ) { String str = \" ofrsgkeeeekgs \" ; int len = str . length ( ) ; decodeStr ( str , len ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static void findCount ( String s , int L , int R ) {", "nl": "Java program for the naive approach"}
{"code": "int distinct = 0 ;", "nl": "Counter to count distinct char"}
{"code": "int [ ] frequency = new int [ 26 ] ;", "nl": "Initializing frequency array to count characters as the appear in subString S [ L : R ]"}
{"code": "for ( int i = L ; i <= R ; i ++ ) {", "nl": "Iterating over S [ L ] to S [ R ]"}
{"code": "frequency [ s . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) {", "nl": "Incrementing the count of s [ i ] character in frequency array"}
{"code": "if ( frequency [ i ] > 0 ) distinct ++ ; } System . out . print ( distinct + \"NEW_LINE\"); }", "nl": "If frequency of any character is > 0 then increment the counter"}
{"code": "public static void main ( String [ ] args ) { String s = \" geeksforgeeksisa \" + \" computerscienceportal \" ; int queries = 3 ; int Q [ ] [ ] = { { 0 , 10 } , { 15 , 18 } , { 12 , 20 } } ; for ( int i = 0 ; i < queries ; i ++ ) findCount ( s , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to perform K operations upon the String and find the modified String"}
{"code": "static String ReverseComplement ( char [ ] s , int n , int k ) {", "nl": "Function to perform K operations upon the String and find modified String"}
{"code": "int rev = ( k + 1 ) / 2 ;", "nl": "Number of reverse operations"}
{"code": "int complement = k - rev ;", "nl": "Number of complement operations"}
{"code": "if ( rev % 2 == 1 ) s = reverse ( s ) ;", "nl": "If rev is odd parity"}
{"code": "if ( complement % 2 == 1 ) { for ( int i = 0 ; i < n ; i ++ ) {", "nl": "If complement is odd parity"}
{"code": "if ( s [ i ] == '0' ) s [ i ] = '1' ; else s [ i ] = '0' ; } }", "nl": "Complementing each position"}
{"code": "return String . valueOf ( s ) ; } static char [ ] reverse ( char a [ ] ) { int i , n = a . length ; char t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } return a ; }", "nl": "Return the modified String"}
{"code": "public static void main ( String [ ] args ) { String str = \"10011\" ; int k = 5 ; int n = str . length ( ) ;", "nl": "Driver Code"}
{"code": "System . out . print ( ReverseComplement ( str . toCharArray ( ) , n , k ) ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java implementation to check that the permutation of the given String is K times repeated String"}
{"code": "static boolean repeatingString ( String s , int n , int k ) {", "nl": "Function to check that permutation of the given String is a K times repeating String"}
{"code": "if ( n % k != 0 ) { return false ; }", "nl": "if length of String is not divisible by K"}
{"code": "int [ ] frequency = new int [ 123 ] ;", "nl": "Frequency Array"}
{"code": "for ( int i = 0 ; i < 123 ; i ++ ) { frequency [ i ] = 0 ; }", "nl": "Initially frequency of each character is 0"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { frequency [ s . charAt ( i ) ] ++ ; } int repeat = n / k ;", "nl": "Computing the frequency of each character in the String"}
{"code": "for ( int i = 0 ; i < 123 ; i ++ ) { if ( frequency [ i ] % repeat != 0 ) { return false ; } } return true ; }", "nl": "Loop to check that frequency of every character of the String is divisible by K"}
{"code": "public static void main ( String [ ] args ) { String s = \" abcdcba \" ; int n = s . length ( ) ; int k = 3 ; if ( repeatingString ( s , n , k ) ) { System . out . print ( \" Yes \" + \"NEW_LINE\"); } else { System . out . print ( \" No \" + \"NEW_LINE\"); } } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void findPhoneNumber ( int n ) { int temp = n ; int sum = 0 ;", "nl": "Function to find the last two digits of the number and print the complete number"}
{"code": "while ( temp != 0 ) { sum += temp % 10 ; temp = temp / 10 ; }", "nl": "Sum of the first eight digits of the number"}
{"code": "if ( sum < 10 ) System . out . print ( n + \"0\" + sum ) ;", "nl": "if sum < 10 , then the two digits are '0' and the value of sum"}
{"code": "else System . out . print ( n + \" \" + sum ) ; }", "nl": "if sum > 10 , then the two digits are the value of sum"}
{"code": "public static void main ( String [ ] args ) { int n = 98765432 ; findPhoneNumber ( n ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int maxN = 20 ; static int maxM = 64 ;", "nl": "Java implementation of the approach"}
{"code": "static int cntSplits ( String s ) {", "nl": "Function to return the required count"}
{"code": "if ( s . charAt ( s . length ( ) - 1 ) == '1' ) return 0 ;", "nl": "If the splitting is not possible"}
{"code": "int c_zero = 0 ;", "nl": "To store the count of zeroes"}
{"code": "for ( int i = 0 ; i < s . length ( ) ; i ++ ) c_zero += ( s . charAt ( i ) == '0' ) ? 1 : 0 ;", "nl": "Counting the number of zeroes"}
{"code": "return ( int ) Math . pow ( 2 , c_zero - 1 ) ; }", "nl": "Return the final answer"}
{"code": "public static void main ( String [ ] args ) { String s = \"10010\" ; System . out . println ( cntSplits ( s ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void findNumbers ( String s ) {", "nl": "Function to return the number of substrings of same characters"}
{"code": "int n = s . length ( ) ;", "nl": "Size of the string"}
{"code": "int count = 1 ; int result = 0 ;", "nl": "Initialize count to 1"}
{"code": "int left = 0 ; int right = 1 ; while ( right < n ) {", "nl": "Initialize left to 0 and right to 1 to traverse the string"}
{"code": "if ( s . charAt ( left ) == s . charAt ( right ) ) { count ++ ; }", "nl": "Checking if consecutive characters are same and increment the count"}
{"code": "else {", "nl": "When we encounter a different characters"}
{"code": "result += count * ( count + 1 ) / 2 ;", "nl": "Increment the result"}
{"code": "left = right ; count = 1 ; } right ++ ; }", "nl": "To repeat the whole process set left equals right and count variable to 1"}
{"code": "result += count * ( count + 1 ) / 2 ; System . out . println ( result ) ; }", "nl": "Store the final value of result"}
{"code": "public static void main ( String [ ] args ) { String s = \" bbbcbb \" ; findNumbers ( s ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for printing string with duplicate vowels"}
{"code": "static boolean isVowel ( char ch ) { ch = Character . toUpperCase ( ch ) ; return ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) ; }", "nl": "Function to check for the Vowel"}
{"code": "static String duplicateVowels ( String str ) { int t = str . length ( ) ;", "nl": "Function to get the resultant string with vowels duplicated"}
{"code": "String res = \" \" ;", "nl": "Another string to store the resultant string"}
{"code": "for ( int i = 0 ; i < t ; i ++ ) { if ( isVowel ( str . charAt ( i ) ) ) res += str . charAt ( i ) ; res += str . charAt ( i ) ; } return res ; }", "nl": "Loop to check for each character"}
{"code": "public static void main ( String [ ] args ) { String str = \" helloworld \" ;", "nl": "Driver Code"}
{"code": "System . out . println ( \" Original \u2581 String : \u2581 \" + str ) ; String res = duplicateVowels ( str ) ;", "nl": "Print the original string"}
{"code": "System . out . println ( \" String \u2581 with \u2581 Vowels \u2581 duplicated : \u2581 \" + res ) ; } }", "nl": "Print the resultant string"}
{"code": "public class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int stringToInt ( String str ) {", "nl": "Recursive function to convert string to integer"}
{"code": "if ( str . length ( ) == 1 ) return ( str . charAt ( 0 ) - '0' ) ;", "nl": "If the number represented as a string contains only a single digit then returns its value"}
{"code": "double y = stringToInt ( str . substring ( 1 ) ) ;", "nl": "Recursive call for the sub - string starting at the second character"}
{"code": "double x = str . charAt ( 0 ) - '0' ;", "nl": "First digit of the number"}
{"code": "x = x * Math . pow ( 10 , str . length ( ) - 1 ) + y ; return ( int ) ( x ) ; }", "nl": "First digit multiplied by the appropriate power of 10 and then add the recursive result For example , xy = ( ( x * 10 ) + y )"}
{"code": "public static void main ( String [ ] args ) { String str = \"1235\" ; System . out . print ( stringToInt ( str ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int MAX = 26 ;", "nl": "Java implementation of the approach"}
{"code": "static int largestSubSeq ( String arr [ ] , int n ) {", "nl": "Function to return the length of the longest sub - sequence with at least one common character in every string"}
{"code": "int [ ] count = new int [ MAX ] ;", "nl": "count [ 0 ] will store the number of strings which contain ' a ' , count [ 1 ] will store the number of strings which contain ' b ' and so on . ."}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { String str = arr [ i ] ;", "nl": "For every string"}
{"code": "boolean [ ] hash = new boolean [ MAX ] ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { hash [ str . charAt ( j ) - ' a ' ] = true ; } for ( int j = 0 ; j < MAX ; j ++ ) {", "nl": "Hash array to set which character is present in the current string"}
{"code": "if ( hash [ j ] ) count [ j ] ++ ; } } int max = - 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( max < count [ i ] ) max = count [ i ] ; } return max ; }", "nl": "If current character appears in the string then update its count"}
{"code": "public static void main ( String [ ] args ) { String arr [ ] = { \" ab \" , \" bc \" , \" de \" } ; int n = arr . length ; System . out . println ( largestSubSeq ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static boolean isPalindrome ( String str ) { int len = str . length ( ) ; for ( int i = 0 ; i < len / 2 ; i ++ ) { if ( str . charAt ( i ) != str . charAt ( len - 1 - i ) ) return false ; } return true ; }", "nl": "Function that returns true if str is a palindrome"}
{"code": "static boolean createStringAndCheckPalindrome ( int N ) {", "nl": "Function that returns true if the generated string is a palindrome"}
{"code": "String sub = \" \" + N , res_str = \" \" ; int sum = 0 ;", "nl": "sub contains N as a string"}
{"code": "while ( N > 0 ) { int digit = N % 10 ; sum += digit ; N = N / 10 ; }", "nl": "Calculate the sum of the digits"}
{"code": "while ( res_str . length ( ) < sum ) res_str += sub ;", "nl": "Repeat the substring until the length of the resultant string < sum"}
{"code": "if ( res_str . length ( ) > sum ) res_str = res_str . substring ( 0 , sum ) ;", "nl": "If length of the resultant string exceeded sum then take substring from 0 to sum - 1"}
{"code": "if ( isPalindrome ( res_str ) ) return true ; return false ; }", "nl": "If the generated string is a palindrome"}
{"code": "public static void main ( String args [ ] ) { int N = 10101 ; if ( createStringAndCheckPalindrome ( N ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to minimize the length of string by removing occurrence of only one character"}
{"code": "static int minimumLength ( String s ) { int maxOcc = 0 , n = s . length ( ) ; int arr [ ] = new int [ 26 ] ;", "nl": "Function to find the minimum length"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) arr [ s . charAt ( i ) - ' a ' ] ++ ;", "nl": "Count the frequency of each alphabet"}
{"code": "for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ;", "nl": "Find the alphabets with maximum frequency"}
{"code": "return ( n - maxOcc ) ; }", "nl": "Subtract the frequency of character from length of string"}
{"code": "public static void main ( String [ ] args ) { String str = \" afddewqd \" ; System . out . println ( minimumLength ( str ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to remove all the characters other then alphabets"}
{"code": "static void removeSpecialCharacter ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) {", "nl": "function to remove characters and print new string"}
{"code": "if ( s . charAt ( i ) < ' A ' || s . charAt ( i ) > ' Z ' && s . charAt ( i ) < ' a ' || s . charAt ( i ) > ' z ' ) {", "nl": "Finding the character whose ASCII value fall under this range"}
{"code": "s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; i -- ; } } System . out . print ( s ) ; }", "nl": "erase function to erase the character"}
{"code": "public static void main ( String [ ] args ) { String s = \" $ Gee * k ; s . . fo , \u2581 r ' Ge ^ eks ? \" ; removeSpecialCharacter ( s ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to remove all the characters other then alphabets"}
{"code": "static void removeSpecialCharacter ( String str ) { char [ ] s = str . toCharArray ( ) ; int j = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) {", "nl": "function to remove characters and print new string"}
{"code": "if ( ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) || ( s [ i ] >= ' a ' && s [ i ] <= ' z ' ) ) { s [ j ] = s [ i ] ; j ++ ; } } System . out . println ( String . valueOf ( s ) . substring ( 0 , j ) ) ; }", "nl": "Store only valid characters"}
{"code": "public static void main ( String [ ] args ) { String s = \" $ Gee * k ; s . . fo , \u2581 r ' Ge ^ eks ? \" ; removeSpecialCharacter ( s ) ; } }", "nl": "driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG { static int findRepeatFirstN2 ( String s ) {", "nl": "Java program to find the first character that is repeated"}
{"code": "int p = - 1 , i , j ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { for ( j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }", "nl": "this is O ( N ^ 2 ) method"}
{"code": "static public void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; int pos = findRepeatFirstN2 ( str ) ; if ( pos == - 1 ) System . out . println ( \" Not \u2581 found \" ) ; else System . out . println ( str . charAt ( pos ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class Gfg { public static void prCharWithFreq ( String s ) {", "nl": "Java implementation to print the characters and frequencies in order of its occurrence"}
{"code": "Map < Character , Integer > d = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( d . containsKey ( s . charAt ( i ) ) ) { d . put ( s . charAt ( i ) , d . get ( s . charAt ( i ) ) + 1 ) ; } else { d . put ( s . charAt ( i ) , 1 ) ; } }", "nl": "Store all characters and their frequencies in dictionary"}
{"code": "for ( int i = 0 ; i < s . length ( ) ; i ++ ) {", "nl": "Print characters and their frequencies in same order of their appearance"}
{"code": "if ( d . get ( s . charAt ( i ) ) != 0 ) { System . out . print ( s . charAt ( i ) ) ; System . out . print ( d . get ( s . charAt ( i ) ) + \" \u2581 \" ) ; d . put ( s . charAt ( i ) , 0 ) ; } } }", "nl": "Print only if this character is not printed before"}
{"code": "public static void main ( String [ ] args ) { String S = \" geeksforgeeks \" ; prCharWithFreq ( S ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to count number of possible strings with n characters ."}
{"code": "static int possibleStrings ( int n , int r , int b , int g ) {", "nl": "Function to calculate number of strings"}
{"code": "int fact [ ] = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ;", "nl": "Store factorial of numbers up to n for further computation"}
{"code": "int left = n - ( r + g + b ) ; int sum = 0 ;", "nl": "Find the remaining values to be added"}
{"code": "for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ;", "nl": "Make all possible combinations of R , B and G for the remaining value"}
{"code": "sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } }", "nl": "Compute permutation of each combination one by one and add them ."}
{"code": "return sum ; }", "nl": "Return total no . of strings / permutation"}
{"code": "public static void main ( String [ ] args ) { int n = 4 , r = 2 ; int b = 0 , g = 1 ; System . out . println ( possibleStrings ( n , r , b , g ) ) ; } }", "nl": "Drivers code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find minimum number of characters to be removed to make two strings anagram ."}
{"code": "static int remAnagram ( String str1 , String str2 ) {", "nl": "function to calculate minimum numbers of characters to be removed to make two strings anagram"}
{"code": "int count1 [ ] = new int [ 26 ] ; int count2 [ ] = new int [ 26 ] ;", "nl": "make hash array for both string and calculate frequency of each character"}
{"code": "for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count1 [ str1 . charAt ( i ) - ' a ' ] ++ ;", "nl": "count frequency of each character in first string"}
{"code": "for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) count2 [ str2 . charAt ( i ) - ' a ' ] ++ ;", "nl": "count frequency of each character in second string"}
{"code": "int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }", "nl": "traverse count arrays to find number of characters to be removed"}
{"code": "public static void main ( String [ ] args ) { String str1 = \" bcadeh \" , str2 = \" hea \" ; System . out . println ( remAnagram ( str1 , str2 ) ) ; } }", "nl": "Driver program to run the case"}
{"code": "public class GFG {", "nl": "Java program to check if a string can be made valid by removing at most 1 character ."}
{"code": "static int CHARS = 26 ;", "nl": "Assuming only lower case characters"}
{"code": "static boolean isValidString ( String str ) { int freq [ ] = new int [ CHARS ] ;", "nl": "To check a string S can be converted to a valid string by removing less than or equal to one character ."}
{"code": "for ( int i = 0 ; i < str . length ( ) ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; }", "nl": "freq [ ] : stores the frequency of each character of a string"}
{"code": "int i , freq1 = 0 , count_freq1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } }", "nl": "Find first character with non - zero frequency"}
{"code": "int j , freq2 = 0 , count_freq2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) { count_freq1 ++ ; } else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } }", "nl": "Find a character with frequency different from freq1 ."}
{"code": "for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) { count_freq1 ++ ; } if ( freq [ k ] == freq2 ) { count_freq2 ++ ;", "nl": "If we find a third non - zero frequency or count of both frequencies become more than 1 , then return false"}
{"code": "{ return false ; } }", "nl": "} else If we find a third non - zero freq"}
{"code": "if ( count_freq1 > 1 && count_freq2 > 1 ) { return false ; } }", "nl": "If counts of both frequencies is more than 1"}
{"code": "return true ; }", "nl": "Return true if we reach here"}
{"code": "public static void main ( String [ ] args ) { String str = \" abcbc \" ; if ( isValidString ( str ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }", "nl": "Driver code"}
{"code": "import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class AllCharsWithSameFrequencyWithOneVarAllowed {", "nl": "Java program to check if a string can be made valid by removing at most 1 character using hashmap ."}
{"code": "public static boolean checkForVariation ( String str ) { if ( str == null || str . isEmpty ( ) ) { return true ; } Map < Character , Integer > map = new HashMap < > ( ) ;", "nl": "To check a string S can be converted to a variation string"}
{"code": "for ( int i = 0 ; i < str . length ( ) ; i ++ ) { map . put ( str . charAt ( i ) , map . getOrDefault ( str . charAt ( i ) , 0 ) + 1 ) ; } Iterator < Integer > itr = map . values ( ) . iterator ( ) ;", "nl": "Run loop form 0 to length of string"}
{"code": "boolean first = true , second = true ; int val1 = 0 , val2 = 0 ; int countOfVal1 = 0 , countOfVal2 = 0 ; while ( itr . hasNext ( ) ) { int i = itr . next ( ) ;", "nl": "declaration of variables"}
{"code": "if ( first ) { val1 = i ; first = false ; countOfVal1 ++ ; continue ; } if ( i == val1 ) { countOfVal1 ++ ; continue ; }", "nl": "if first is true than countOfVal1 increase"}
{"code": "if ( second ) { val2 = i ; countOfVal2 ++ ; second = false ; continue ; } if ( i == val2 ) { countOfVal2 ++ ; continue ; } return false ; } if ( countOfVal1 > 1 && countOfVal2 > 1 ) { return false ; } else { return true ; } }", "nl": "if second is true than countOfVal2 increase"}
{"code": "public static void main ( String [ ] args ) { System . out . println ( checkForVariation ( \" abcbc \" ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation for find pairs of complete strings ."}
{"code": "static int countCompletePairs ( String set1 [ ] , String set2 [ ] , int n , int m ) { int result = 0 ;", "nl": "Returns count of complete pairs from set [ 0. . n - 1 ] and set2 [ 0. . m - 1 ]"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) {", "nl": "Consider all pairs of both strings"}
{"code": "String concat = set1 [ i ] + set2 [ j ] ;", "nl": "Create a concatenation of current pair"}
{"code": "int frequency [ ] = new int [ 26 ] ; for ( int k = 0 ; k < concat . length ( ) ; k ++ ) { frequency [ concat . charAt ( k ) - ' a ' ] ++ ; }", "nl": "Compute frequencies of all characters in the concatenated String ."}
{"code": "int k ; for ( k = 0 ; k < 26 ; k ++ ) { if ( frequency [ k ] < 1 ) { break ; } } if ( k == 26 ) { result ++ ; } } } return result ; }", "nl": "If frequency of any character is not greater than 0 , then this pair is not complete ."}
{"code": "static public void main ( String [ ] args ) { String set1 [ ] = { \" abcdefgh \" , \" geeksforgeeks \" , \" lmnopqrst \" , \" abc \" } ; String set2 [ ] = { \" ijklmnopqrstuvwxyz \" , \" abcdefghijklmnopqrstuvwxyz \" , \" defghijklmnopqrstuvwxyz \" } ; int n = set1 . length ; int m = set2 . length ; System . out . println ( countCompletePairs ( set1 , set2 , n , m ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find count of complete pairs"}
{"code": "static int countCompletePairs ( String set1 [ ] , String set2 [ ] , int n , int m ) { int result = 0 ;", "nl": "Returns count of complete pairs from set [ 0. . n - 1 ] and set2 [ 0. . m - 1 ]"}
{"code": "int [ ] con_s1 = new int [ n ] ; int [ ] con_s2 = new int [ m ] ;", "nl": "con_s1 [ i ] is going to store an integer whose set bits represent presence / absence of characters in string set1 [ i ] . Similarly con_s2 [ i ] is going to store an integer whose set bits represent presence / absence of characters in string set2 [ i ]"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Process all strings in set1 [ ]"}
{"code": "con_s1 [ i ] = 0 ; for ( int j = 0 ; j < set1 [ i ] . length ( ) ; j ++ ) {", "nl": "initializing all bits to 0"}
{"code": "con_s1 [ i ] = con_s1 [ i ] | ( 1 << ( set1 [ i ] . charAt ( j ) - ' a ' ) ) ; } }", "nl": "Setting the ascii code of char s [ i ] [ j ] to 1 in the compressed integer ."}
{"code": "for ( int i = 0 ; i < m ; i ++ ) {", "nl": "Process all strings in set2 [ ]"}
{"code": "con_s2 [ i ] = 0 ; for ( int j = 0 ; j < set2 [ i ] . length ( ) ; j ++ ) {", "nl": "initializing all bits to 0"}
{"code": "con_s2 [ i ] = con_s2 [ i ] | ( 1 << ( set2 [ i ] . charAt ( j ) - ' a ' ) ) ; } }", "nl": "setting the ascii code of char s [ i ] [ j ] to 1 in the compressed integer ."}
{"code": "long complete = ( 1 << 26 ) - 1 ;", "nl": "assigning a variable whose all 26 ( 0. . 25 ) bits are set to 1"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) {", "nl": "Now consider every pair of integer in con_s1 [ ] and con_s2 [ ] and check if the pair is complete ."}
{"code": "if ( ( con_s1 [ i ] con_s2 [ j ] ) == complete ) { result ++ ; } } } return result ; }", "nl": "if all bits are set , the strings are complete !"}
{"code": "public static void main ( String args [ ] ) { String set1 [ ] = { \" abcdefgh \" , \" geeksforgeeks \" , \" lmnopqrst \" , \" abc \" } ; String set2 [ ] = { \" ijklmnopqrstuvwxyz \" , \" abcdefghijklmnopqrstuvwxyz \" , \" defghijklmnopqrstuvwxyz \" } ; int n = set1 . length ; int m = set2 . length ; System . out . println ( countCompletePairs ( set1 , set2 , n , m ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary"}
{"code": "static String encodeString ( String str ) { HashMap < Character , Integer > map = new HashMap < > ( ) ; String res = \" \" ; int i = 0 ;", "nl": "Function to encode given string"}
{"code": "char ch ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { ch = str . charAt ( j ) ;", "nl": "for each character in given string"}
{"code": "if ( ! map . containsKey ( ch ) ) map . put ( ch , i ++ ) ;", "nl": "If the character is occurring for the first time , assign next unique number to that char"}
{"code": "res += map . get ( ch ) ; } return res ; }", "nl": "append the number associated with current character into the output string"}
{"code": "static void findMatchedWords ( String [ ] dict , String pattern ) {", "nl": "Function to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary"}
{"code": "int len = pattern . length ( ) ;", "nl": "len is length of the pattern"}
{"code": "String hash = encodeString ( pattern ) ;", "nl": "encode the string"}
{"code": "for ( String word : dict ) {", "nl": "for each word in the dictionary array"}
{"code": "if ( word . length ( ) == len && encodeString ( word ) . equals ( hash ) ) System . out . print ( word + \" \u2581 \" ) ; } }", "nl": "If size of pattern is same as size of current dictionary word and both pattern and the word has same hash , print the word"}
{"code": "public static void main ( String args [ ] ) { String [ ] dict = { \" abb \" , \" abc \" , \" xyz \" , \" xyy \" } ; String pattern = \" foo \" ; findMatchedWords ( dict , pattern ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static boolean check ( String pattern , String word ) { if ( pattern . length ( ) != word . length ( ) ) return false ; int [ ] ch = new int [ 128 ] ; int Len = word . length ( ) ; for ( int i = 0 ; i < Len ; i ++ ) { if ( ch [ ( int ) pattern . charAt ( i ) ] == 0 ) { ch [ ( int ) pattern . charAt ( i ) ] = word . charAt ( i ) ; } else if ( ch [ ( int ) pattern . charAt ( i ) ] != word . charAt ( i ) ) { return false ; } } return true ; }", "nl": "Java program to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary"}
{"code": "static void findMatchedWords ( HashSet < String > dict , String pattern ) {", "nl": "Function to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary"}
{"code": "int Len = pattern . length ( ) ;", "nl": "len is length of the pattern"}
{"code": "String result = \" \u2581 \" ; for ( String word : dict ) { if ( check ( pattern , word ) ) { result = word + \" \u2581 \" + result ; } } System . out . print ( result ) ; }", "nl": "For each word in the dictionary"}
{"code": "public static void main ( String [ ] args ) { HashSet < String > dict = new HashSet < String > ( ) ; dict . add ( \" abb \" ) ; dict . add ( \" abc \" ) ; dict . add ( \" xyz \" ) ; dict . add ( \" xyy \" ) ; String pattern = \" foo \" ; findMatchedWords ( dict , pattern ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to count total number of words in the string"}
{"code": "public static int countWords ( String str ) {", "nl": "Function to count total number of words in the string"}
{"code": "if ( str == null || str . isEmpty ( ) ) return 0 ; int wordCount = 0 ; boolean isWord = false ; int endOfLine = str . length ( ) - 1 ;", "nl": "Check if the string is null or empty then return zero"}
{"code": "char [ ] ch = str . toCharArray ( ) ; for ( int i = 0 ; i < ch . length ; i ++ ) {", "nl": "Converting the given string into a character array"}
{"code": "if ( Character . isLetter ( ch [ i ] ) && i != endOfLine ) isWord = true ;", "nl": "Check if the character is a letter and index of character array doesn 't  equal to end of line that means, it is  a word and set isWord by true"}
{"code": "else if ( ! Character . isLetter ( ch [ i ] ) && isWord ) { wordCount ++ ; isWord = false ; }", "nl": "Check if the character is not a letter that means there is a space , then we increment the wordCount by one and set the isWord by false"}
{"code": "else if ( Character . isLetter ( ch [ i ] ) && i == endOfLine ) wordCount ++ ; }", "nl": "Check for the last word of the sentence and increment the wordCount by one"}
{"code": "return wordCount ; }", "nl": "Return the total number of words in the string"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "String str = \"One twothree four five \";", "nl": "Given String str"}
{"code": "System . out . println ( \" No \u2581 of \u2581 words \u2581 : \u2581 \" + countWords ( str ) ) ; } }", "nl": "Print the result"}
{"code": "class GFG {", "nl": "Java code to reverse a string"}
{"code": "public static String [ ] RevString ( String [ ] s , int l ) {", "nl": "Reverse the string"}
{"code": "if ( l % 2 == 0 ) {", "nl": "Check if number of words is even"}
{"code": "int j = l / 2 ;", "nl": "Find the middle word"}
{"code": "while ( j <= l - 1 ) { String temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } }", "nl": "Starting from the middle start swapping words at jth position and l - 1 - j position"}
{"code": "else {", "nl": "Check if number of words is odd"}
{"code": "int j = ( l / 2 ) + 1 ;", "nl": "Find the middle word"}
{"code": "while ( j <= l - 1 ) { String temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } }", "nl": "Starting from the middle start swapping the words at jth position and l - 1 - j position"}
{"code": "return s ; }", "nl": "Return the reversed sentence"}
{"code": "public static void main ( String [ ] args ) { String s = \" getting \u2581 good \u2581 at \u2581 coding \u2581 \" + \" needs \u2581 a \u2581 lot \u2581 of \u2581 practice \" ; String [ ] words = s . split ( \" \\\\ s \" ) ; words = RevString ( words , words . length ) ; s = String . join ( \" \u2581 \" , words ) ; System . out . println ( s ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to print path from root to all nodes in a complete binary tree ."}
{"code": "static void printPath ( Vector < Integer > res , int nThNode , int kThNode ) {", "nl": "Function to print path of all the nodes nth node represent as given node kth node represents as left and right node"}
{"code": "if ( kThNode > nThNode ) return ;", "nl": "base condition if kth node value is greater then nth node then its means kth node is not valid so we not store it into the res simply we just return"}
{"code": "res . add ( kThNode ) ;", "nl": "Storing node into res"}
{"code": "for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + \" \u2581 \" ) ; System . out . print ( \"NEW_LINE\");", "nl": "Print the path from root to node"}
{"code": "printPath ( res , nThNode , kThNode * 2 ) ;", "nl": "store left path of a tree So for left we will go node ( kThNode * 2 )"}
{"code": "printPath ( res , nThNode , kThNode * 2 + 1 ) ; res . remove ( res . size ( ) - 1 ) ; }", "nl": "right path of a tree and for right we will go node ( kThNode * 2 + 1 )"}
{"code": "static void printPathToCoverAllNodeUtil ( int nThNode ) {", "nl": "Function to print path from root to all of the nodes"}
{"code": "Vector < Integer > res = new Vector < Integer > ( ) ;", "nl": "res is for store the path from root to particulate node"}
{"code": "printPath ( res , nThNode , 1 ) ; }", "nl": "Print path from root to all node . third argument 1 because of we have to consider root node is 1"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "int nThNode = 7 ;", "nl": "Given Node"}
{"code": "printPathToCoverAllNodeUtil ( nThNode ) ; } }", "nl": "Print path from root to all node ."}
{"code": "import java . util . * ; class GFG {", "nl": "Java code to implement the above approach"}
{"code": "static int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; }", "nl": "A utility function to get the middle index of given range ."}
{"code": "static boolean isArmstrong ( int x ) { int n = String . valueOf ( x ) . length ( ) ; int sum1 = 0 ; int temp = x ; while ( temp > 0 ) { int digit = temp % 10 ; sum1 += Math . pow ( digit , n ) ; temp /= 10 ; } if ( sum1 == x ) return true ; return false ; }", "nl": "Function that return true if num is armstrong else return false"}
{"code": "static int MaxUtil ( int [ ] st , int ss , int se , int l , int r , int node ) {", "nl": "A recursive function to get the sum of values in the given range of the array . The following are parameters for this function . st . Pointer to segment tree node . Index of current node in the segment tree . ss & se . Starting and ending indexes of the segment represented by current node , i . e . , st [ node ] l & r . Starting and ending indexes of range query"}
{"code": "if ( l <= ss && r >= se ) return st [ node ] ;", "nl": "If segment of this node is completely part of given range , then return the max of segment ."}
{"code": "if ( se < l ss > r ) return - 1 ;", "nl": "If segment of this node does not belong to given range"}
{"code": "int mid = getMid ( ss , se ) ; return Math . max ( MaxUtil ( st , ss , mid , l , r , 2 * node ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 1 ) ) ; }", "nl": "If segment of this node is partially the part of given range"}
{"code": "static void updateValue ( int arr [ ] , int [ ] st , int ss , int se , int index , int value , int node ) { if ( index < ss index > se ) { System . out . print ( \" Invalid \u2581 Input \" + \"NEW_LINE\"); return ; } if ( ss == se ) {", "nl": "A recursive function to update the nodes which have the given the index in their range . The following are parameters st , ss and se are same as defined above index . index of the element to be updated ."}
{"code": "arr [ index ] = value ; if ( isArmstrong ( value ) ) st [ node ] = value ; else st [ node ] = - 1 ; } else { int mid = getMid ( ss , se ) ; if ( index >= ss && index <= mid ) updateValue ( arr , st , ss , mid , index , value , 2 * node ) ; else updateValue ( arr , st , mid + 1 , se , index , value , 2 * node + 1 ) ; st [ node ] = Math . max ( st [ 2 * node + 1 ] , st [ 2 * node + 2 ] ) ; } return ; }", "nl": "update value in array and in segment tree"}
{"code": "static int getMax ( int [ ] st , int n , int l , int r ) {", "nl": "Return max of elements in range from index l ( query start ) to r ( query end ) ."}
{"code": "if ( l < 0 r > n - 1 l > r ) { System . out . printf ( \" Invalid \u2581 Input \" ) ; return - 1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; }", "nl": "Check for erroneous input values"}
{"code": "static int constructSTUtil ( int arr [ ] , int ss , int se , int [ ] st , int si ) {", "nl": "A recursive function that constructs Segment Tree for array [ ss . . se ] . si is index of current node in segment tree st"}
{"code": "if ( ss == se ) { if ( isArmstrong ( arr [ ss ] ) ) st [ si ] = arr [ ss ] ; else st [ si ] = - 1 ; return st [ si ] ; }", "nl": "If there is one element in array , store it in current node of segment tree and return"}
{"code": "int mid = getMid ( ss , se ) ; st [ si ] = Math . max ( constructSTUtil ( arr , ss , mid , st , si * 2 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 1 ) ) ; return st [ si ] ; }", "nl": "If there are more than one elements , then recur for left and right subtrees and store the max of values in this node"}
{"code": "static int [ ] constructST ( int arr [ ] , int n ) {", "nl": "Function to cona segment tree from given array . This function allocates memory for segment tree ."}
{"code": "int x = ( int ) ( Math . ceil ( Math . log ( n ) ) ) ;", "nl": "Height of segment tree"}
{"code": "int max_size = 2 * ( int ) Math . pow ( 2 , x ) - 1 ;", "nl": "Maximum size of segment tree"}
{"code": "int [ ] st = new int [ max_size ] ;", "nl": "Allocate memory"}
{"code": "constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ;", "nl": "Fill the allocated memory st"}
{"code": "return st ; }", "nl": "Return the constructed segment tree"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 192 , 113 , 535 , 7 , 19 , 111 } ; int n = arr . length ;", "nl": "Driver code"}
{"code": "int [ ] st = constructST ( arr , n ) ;", "nl": "Build segment tree from given array"}
{"code": "System . out . print ( \" Maximum \u2581 armstrong \u2581 \" + \" number \u2581 in \u2581 given \u2581 range \u2581 = \u2581 \" + getMax ( st , n , 1 , 3 ) + \"NEW_LINE\");", "nl": "Print max of values in array from index 1 to 3"}
{"code": "updateValue ( arr , st , 0 , n - 1 , 1 , 153 , 0 ) ;", "nl": "Update : set arr [ 1 ] = 153 and update corresponding segment tree nodes ."}
{"code": "System . out . print ( \" Updated \u2581 Maximum \u2581 armstrong \u2581 \" + \" number \u2581 in \u2581 given \u2581 range \u2581 = \u2581 \" + getMax ( st , n , 1 , 3 ) + \"NEW_LINE\"); } }", "nl": "Find max after the value is updated"}
{"code": "class GFG {", "nl": "Java program to implement the above problem"}
{"code": "static void maxRegions ( int n ) { int num ; num = n * ( n + 1 ) / 2 + 1 ;", "nl": "Function to find the maximum number of regions on a plane"}
{"code": "System . out . println ( num ) ; ; }", "nl": "print the maximum number of regions"}
{"code": "public static void main ( String [ ] args ) { int n = 10 ; maxRegions ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void checkSolveable ( int n , int m ) {", "nl": "Function to check if the jigsaw Puzzle is solveable or not"}
{"code": "if ( n == 1 m == 1 ) System . out . print ( \" YES \" ) ;", "nl": "Base Case"}
{"code": "else if ( m == 2 && n == 2 ) System . out . print ( \" YES \" ) ; else System . out . print ( \" NO \" ) ; }", "nl": "By placing the blank tabs as a chain"}
{"code": "public static void main ( String [ ] args ) { int n = 1 , m = 3 ; checkSolveable ( n , m ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int GCD ( int a , int b ) {", "nl": "Function to find the GCD of two numbers a and b"}
{"code": "if ( b == 0 ) return a ;", "nl": "Base Case"}
{"code": "else return GCD ( b , a % b ) ; }", "nl": "Recursively find the GCD"}
{"code": "static void check ( int x , int y ) {", "nl": "Function to check if ( x , y ) can be reached from ( 1 , 0 ) from given moves"}
{"code": "if ( GCD ( x , y ) == 1 ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } }", "nl": "If GCD is 1 , then print \" Yes \""}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int X = 2 , Y = 7 ;", "nl": "Given X and Y"}
{"code": "check ( X , Y ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG { static final int size = 1000001 ;", "nl": "Java Program to implement the above approach"}
{"code": "static void seiveOfEratosthenes ( int [ ] prime ) { prime [ 0 ] = 1 ; prime [ 1 ] = 0 ; for ( int i = 2 ; i * i < 1000001 ; i ++ ) {", "nl": "Seieve of Erotosthenes to compute all primes"}
{"code": "if ( prime [ i ] == 0 ) { for ( int j = i * i ; j < 1000001 ; j += i ) {", "nl": "If prime"}
{"code": "prime [ j ] = 1 ; } } } }", "nl": "Mark all its multiples as non - prime"}
{"code": "static float probabiltyEuler ( int [ ] prime , int L , int R , int M ) { int [ ] arr = new int [ size ] ; int [ ] eulerTotient = new int [ size ] ; int count = 0 ;", "nl": "Function to find the probability of Euler 's Totient Function in a given range"}
{"code": "for ( int i = L ; i <= R ; i ++ ) {", "nl": "Initializing two arrays with values from L to R for Euler 's totient"}
{"code": "eulerTotient [ i - L ] = i ; arr [ i - L ] = i ; } for ( int i = 2 ; i < 1000001 ; i ++ ) {", "nl": "Indexing from 0"}
{"code": "if ( prime [ i ] == 0 ) {", "nl": "If the current number is prime"}
{"code": "for ( int j = ( L / i ) * i ; j <= R ; j += i ) { if ( j - L >= 0 ) {", "nl": "Checking if i is prime factor of numbers in range L to R"}
{"code": "eulerTotient [ j - L ] = eulerTotient [ j - L ] / i * ( i - 1 ) ; while ( arr [ j - L ] % i == 0 ) { arr [ j - L ] /= i ; } } } } }", "nl": "Update all the numbers which has prime factor i"}
{"code": "for ( int i = L ; i <= R ; i ++ ) { if ( arr [ i - L ] > 1 ) { eulerTotient [ i - L ] = ( eulerTotient [ i - L ] / arr [ i - L ] ) * ( arr [ i - L ] - 1 ) ; } } for ( int i = L ; i <= R ; i ++ ) {", "nl": "If number in range has a prime factor > Math . sqrt ( number )"}
{"code": "if ( ( eulerTotient [ i - L ] % M ) == 0 ) { count ++ ; } }", "nl": "Count those which are divisible by M"}
{"code": "return ( float ) ( 1.0 * count / ( R + 1 - L ) ) ; }", "nl": "Return the result"}
{"code": "public static void main ( String [ ] args ) { int [ ] prime = new int [ size ] ; seiveOfEratosthenes ( prime ) ; int L = 1 , R = 7 , M = 3 ; System . out . print ( probabiltyEuler ( prime , L , R , M ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to find the Largest Odd Divisior Game to check which player wins"}
{"code": "public static void findWinner ( int n , int k ) { int cnt = 0 ;", "nl": "Function to find the Largest Odd Divisior Game to check which player wins"}
{"code": "if ( n == 1 ) System . out . println ( \" No \" ) ;", "nl": "Check if n == 1 then player 2 will win"}
{"code": "else if ( ( n & 1 ) != 0 n == 2 ) System . out . println ( \" Yes \" ) ; else { int tmp = n ; int val = 1 ;", "nl": "Check if n == 2 or n is odd"}
{"code": "while ( tmp > k && tmp % 2 == 0 ) { tmp /= 2 ; val *= 2 ; }", "nl": "While n is greater than k and divisible by 2 keep incrementing tha val"}
{"code": "for ( int i = 3 ; i <= Math . sqrt ( tmp ) ; i ++ ) { while ( tmp % i == 0 ) { cnt ++ ; tmp /= i ; } } if ( tmp > 1 ) cnt ++ ;", "nl": "Loop to find greatest odd divisor"}
{"code": "if ( val == n ) System . out . println ( \" No \" ) ; else if ( n / tmp == 2 && cnt == 1 ) System . out . println ( \" No \" ) ;", "nl": "Check if n is a power of 2"}
{"code": "else System . out . println ( \" Yes \" ) ; } }", "nl": "Check if cnt is not one then player 1 wins"}
{"code": "public static void main ( String [ ] args ) { int n = 1 , k = 1 ; findWinner ( n , k ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program of the above approach"}
{"code": "static void pen_hex ( long n ) { long pn = 1 ; for ( long i = 1 ; i < n ; i ++ ) {", "nl": "Function to print numbers upto N which are both pentagonal as well as hexagonal numbers"}
{"code": "pn = i * ( 3 * i - 1 ) / 2 ; if ( pn > n ) break ;", "nl": "Calculate i - th pentagonal number"}
{"code": "double seqNum = ( 1 + Math . sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == ( long ) seqNum ) System . out . print ( pn + \" , \u2581 \" ) ; } }", "nl": "Check if the pentagonal number pn is hexagonal or not"}
{"code": "public static void main ( String [ ] args ) { long N = 1000000 ; pen_hex ( N ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to check if row - major order traversal of matrix is palindrome or not"}
{"code": "static boolean isPal ( int a [ ] [ ] , int n , int m ) {", "nl": "Function to check if row - major order traversal of the matrix is is palindrome"}
{"code": "for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; }", "nl": "Loop to check if the matrix is matrix is palindrome or not"}
{"code": "public static void main ( String [ ] args ) { int n = 3 , m = 3 ; int a [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 4 } , { 3 , 2 , 1 } } ; if ( isPal ( a , n , m ) ) { System . out . print ( \" YES \" + \"NEW_LINE\"); } else { System . out . print ( \" NO \" + \"NEW_LINE\"); } } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to find the smallest number whose sum of digits is also N"}
{"code": "static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }", "nl": "Function to get sum of digits"}
{"code": "static void smallestNumber ( int N ) { int i = 1 ; while ( 1 != 0 ) {", "nl": "Function to find the smallest number whose sum of digits is also N"}
{"code": "if ( getSum ( i ) == N ) { System . out . print ( i ) ; break ; } i ++ ; } }", "nl": "Checking if number has sum of digits = N"}
{"code": "public static void main ( String [ ] args ) { int N = 10 ; smallestNumber ( N ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation to check if N is a Rare number"}
{"code": "static int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }", "nl": "Iterative function to reverse digits of num"}
{"code": "static boolean isPerfectSquare ( double x ) {", "nl": "Function to check if N is perfect square"}
{"code": "double sr = Math . sqrt ( x ) ;", "nl": "Find floating point value of square root of x ."}
{"code": "return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }", "nl": "If square root is an integer"}
{"code": "static boolean isRare ( int N ) {", "nl": "Function to check if N is an Rare number"}
{"code": "int reverseN = reversDigits ( N ) ;", "nl": "Find reverse of N"}
{"code": "if ( reverseN == N ) return false ; return isPerfectSquare ( N + reverseN ) && isPerfectSquare ( N - reverseN ) ; }", "nl": "Number should be non - palindromic"}
{"code": "public static void main ( String [ ] args ) { int n = 65 ; if ( isRare ( n ) ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to count the elements in the range [ L , R ] whose prime factors are only 2 and 3."}
{"code": "static void calc_ans ( int l , int r ) { Vector < Integer > power2 = new Vector < Integer > ( ) , power3 = new Vector < Integer > ( ) ;", "nl": "Function which will calculate the elements in the given range"}
{"code": "int mul2 = 1 ; while ( mul2 <= r ) { power2 . add ( mul2 ) ; mul2 *= 2 ; }", "nl": "Store the current power of 2"}
{"code": "int mul3 = 1 ; while ( mul3 <= r ) { power3 . add ( mul3 ) ; mul3 *= 3 ; }", "nl": "Store the current power of 3"}
{"code": "Vector < Integer > power23 = new Vector < Integer > ( ) ; for ( int x = 0 ; x < power2 . size ( ) ; x ++ ) { for ( int y = 0 ; y < power3 . size ( ) ; y ++ ) { int mul = power2 . get ( x ) * power3 . get ( y ) ; if ( mul == 1 ) continue ;", "nl": "power23 [ ] will store pairwise product of elements of power2 and power3 that are <= r"}
{"code": "if ( mul <= r ) power23 . add ( mul ) ; } }", "nl": "Insert in power23 ] [ ] only if mul <= r"}
{"code": "int ans = 0 ; for ( int x : power23 ) { if ( x >= l && x <= r ) ans ++ ; }", "nl": "Store the required answer"}
{"code": "System . out . print ( ans + \"NEW_LINE\"); }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { int l = 1 , r = 10 ; calc_ans ( l , r ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to count of K length subsequence whose product is even"}
{"code": "static int nCr ( int n , int r ) { if ( r > n ) return 0 ; return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }", "nl": "Function to calculate nCr"}
{"code": "static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }", "nl": "Returns factorial of n"}
{"code": "static int countSubsequences ( int arr [ ] , int n , int k ) { int countOdd = 0 ;", "nl": "Function for finding number of K length subsequences whose product is even number"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) countOdd ++ ; } int ans = nCr ( n , k ) - nCr ( countOdd , k ) ; return ans ; }", "nl": "Counting odd numbers in the array"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 2 , 4 } ; int K = 1 ; int N = arr . length ; System . out . println ( countSubsequences ( arr , N , K ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java Program to find the first digit of X in base Y"}
{"code": "static void first_digit ( int x , int y ) {", "nl": "Function to find the first digit of X in base Y"}
{"code": "int length = ( int ) ( Math . log ( x ) / Math . log ( y ) + 1 ) ;", "nl": "calculating number of digits of x in base y"}
{"code": "int first_digit = ( int ) ( x / Math . pow ( y , length - 1 ) ) ; System . out . println ( first_digit ) ; }", "nl": "finding first digit of x in base y"}
{"code": "public static void main ( String args [ ] ) { int X = 55 , Y = 3 ; first_digit ( X , Y ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void checkIfCurzonNumber ( long N ) { double powerTerm , productTerm ;", "nl": "Function to check if a number is a Curzon number or not"}
{"code": "powerTerm = Math . pow ( 2 , N ) + 1 ;", "nl": "Find 2 ^ N + 1"}
{"code": "productTerm = 2 * N + 1 ;", "nl": "Find 2 * N + 1"}
{"code": "if ( powerTerm % productTerm == 0 ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; }", "nl": "Check for divisibility"}
{"code": "public static void main ( String [ ] args ) { long N = 5 ; checkIfCurzonNumber ( N ) ; N = 10 ; checkIfCurzonNumber ( N ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static int minCount ( int n ) {", "nl": "Function to return the count of minimum numbers ending with 7 required such that the sum of these numbers is n"}
{"code": "int [ ] hasharr = { 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 } ;", "nl": "hasharr [ i ] will store the minimum numbers ending with 7 so that it sums to number ending with digit i"}
{"code": "if ( n > 69 ) return hasharr [ n % 10 ] ; else {", "nl": "Its always possible to write numbers > 69 to write as numbers ending with 7"}
{"code": "if ( n >= hasharr [ n % 10 ] * 7 ) return ( hasharr [ n % 10 ] ) ; else return - 1 ; } }", "nl": "If the number is atleast equal to the sum of minimum numbers ending with 7"}
{"code": "public static void main ( String [ ] args ) { int n = 38 ; System . out . println ( minCount ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java implementation to print the modified binary triangle pattern"}
{"code": "static void modifiedBinaryPattern ( int n ) {", "nl": "Function to print the modified binary pattern"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) {", "nl": "Loop to traverse the rows"}
{"code": "for ( int j = 1 ; j <= i ; j ++ ) {", "nl": "Loop to traverse the numbers in each row"}
{"code": "if ( j == 1 j == i ) System . out . print ( 1 ) ;", "nl": "Check if j is 1 or i In either case print 1"}
{"code": "else System . out . print ( 0 ) ; }", "nl": "Else print 0"}
{"code": "System . out . println ( ) ; } }", "nl": "Change the cursor to next line after each row"}
{"code": "public static void main ( String [ ] args ) { int n = 7 ;", "nl": "Driver Code"}
{"code": "modifiedBinaryPattern ( n ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java program to find the real and imaginary parts of a Complex Number"}
{"code": "static void findRealAndImag ( String s ) {", "nl": "Function to find real and imaginary parts of a complex number"}
{"code": "int l = s . length ( ) ;", "nl": "string length stored in variable l"}
{"code": "int i ;", "nl": "variable for the index of the separator"}
{"code": "if ( s . indexOf ( ' + ' ) != - 1 ) { i = s . indexOf ( ' + ' ) ; }", "nl": "Storing the index of ' + '"}
{"code": "else { i = s . indexOf ( ' - ' ) ; }", "nl": "else storing the index of ' - '"}
{"code": "String real = s . substring ( 0 , i ) ;", "nl": "Finding the real part of the complex number"}
{"code": "String imaginary = s . substring ( i + 1 , l - 1 ) ; System . out . println ( \" Real \u2581 part : \u2581 \" + real ) ; System . out . println ( \" Imaginary \u2581 part : \u2581 \" + imaginary ) ; }", "nl": "Finding the imaginary part of the complex number"}
{"code": "public static void main ( String [ ] args ) { String s = \"3 + 4i \" ; findRealAndImag ( s ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation to find distinct powers of N that add upto K"}
{"code": "static int highestPower ( int n , int k ) { int i = 0 ; int a = ( int ) Math . pow ( n , i ) ;", "nl": "Function to return the highest power of N not exceeding K"}
{"code": "while ( a <= k ) { i += 1 ; a = ( int ) Math . pow ( n , i ) ; } return i - 1 ; }", "nl": "Loop to find the highest power less than K"}
{"code": "static int b [ ] = new int [ 50 ] ;", "nl": "Initializing the PowerArray with all 0 's."}
{"code": "static int PowerArray ( int n , int k ) { while ( k > 0 ) {", "nl": "Function to print the distinct powers of N that add upto K"}
{"code": "int t = highestPower ( n , k ) ;", "nl": "Getting the highest power of n before k"}
{"code": "if ( b [ t ] > 0 ) {", "nl": "To check if the power is being used twice or not"}
{"code": "System . out . print ( - 1 ) ; return 0 ; } else", "nl": "Print - 1 if power is being used twice"}
{"code": "b [ t ] = 1 ;", "nl": "If the power is not visited , then mark the power as visited"}
{"code": "k -= Math . pow ( n , t ) ; }", "nl": "Decrementing the value of K"}
{"code": "for ( int i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] > 0 ) { System . out . print ( i + \" , \u2581 \" ) ; } } return 0 ; }", "nl": "Printing the powers of N that sum up to K"}
{"code": "public static void main ( String [ ] args ) { int N = 3 ; int K = 40 ; PowerArray ( N , K ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static final int N = 10005 ;", "nl": "Java program to find sum of elements in an array having composite frequency"}
{"code": "static void SieveOfEratosthenes ( Vector < Boolean > composite ) { for ( int i = 0 ; i < N ; i ++ ) { composite . add ( i , false ) ; } for ( int p = 2 ; p * p < N ; p ++ ) {", "nl": "Function to create Sieve to check primes"}
{"code": "if ( ! composite . get ( p ) ) {", "nl": "If composite [ p ] is not changed , then it is a prime"}
{"code": "for ( int i = p * 2 ; i < N ; i += p ) { composite . add ( i , true ) ; } } } }", "nl": "Update all multiples of p , set them to composite"}
{"code": "static int sumOfElements ( int arr [ ] , int n ) { Vector < Boolean > composite = new Vector < Boolean > ( ) ; for ( int i = 0 ; i < N ; i ++ ) composite . add ( false ) ; SieveOfEratosthenes ( composite ) ;", "nl": "Function to return the sum of elements in an array having composite frequency"}
{"code": "HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; }", "nl": "Map is used to store element frequencies"}
{"code": "int sum = 0 ;", "nl": "To store sum"}
{"code": "for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) {", "nl": "Traverse the map using iterators"}
{"code": "if ( composite . get ( it . getValue ( ) ) ) { sum += ( it . getKey ( ) ) ; } } return sum ; }", "nl": "Count the number of elements having composite frequencies"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 1 , 1 , 1 , 3 , 3 , 2 , 4 } ; int n = arr . length ;", "nl": "Driver code"}
{"code": "System . out . print ( sumOfElements ( arr , n ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to removes all odd frequency elements from an Array"}
{"code": "static void remove ( int arr [ ] , int n ) {", "nl": "Function that removes the elements which have odd frequencies in the array"}
{"code": "HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } }", "nl": "Create a map to store the frequency of each element"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Remove the elements which have odd frequencies"}
{"code": "if ( ( mp . containsKey ( arr [ i ] ) && mp . get ( arr [ i ] ) % 2 == 1 ) ) continue ; System . out . print ( arr [ i ] + \" , \u2581 \" ) ; } }", "nl": "If the element has odd frequency then skip"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 3 , 3 , 3 , 2 , 2 , 4 , 7 , 7 } ; int n = arr . length ;", "nl": "Driver code"}
{"code": "remove ( arr , n ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of to maximize the first element of the array such that average of the array remains constant"}
{"code": "static void getmax ( int arr [ ] , int n , int x ) {", "nl": "Maximum value of the first array element that can be attained"}
{"code": "int s = 0 ;", "nl": "Variable to store the sum"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; }", "nl": "Loop to find the sum of array"}
{"code": "System . out . print ( Math . min ( s , x ) ) ; }", "nl": "Desired maximum value"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int x = 5 ; int arr_size = arr . length ; getmax ( arr , arr_size , x ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to illustrate the above problem"}
{"code": "static void shortestLength ( int n , int x [ ] , int y [ ] ) { int answer = 0 ;", "nl": "function to get the minimum length of the shorter side of the triangle"}
{"code": "int i = 0 ; while ( n != 0 && i < x . length ) {", "nl": "traversing through each points on the plane"}
{"code": "if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; }", "nl": "if sum of a points is greater than the previous one , the maximum gets replaced"}
{"code": "System . out . println ( \" Length \u2581 - > \u2581 \" + answer ) ; System . out . println ( \" Path \u2581 - > \u2581 \" + \" ( \u2581 1 , \u2581 \" + answer + \" \u2581 ) \" + \" and \u2581 ( \u2581 \" + answer + \" , \u2581 1 \u2581 ) \" ) ; }", "nl": "print the length"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int n = 4 ;", "nl": "initialize the number of points"}
{"code": "int x [ ] = new int [ ] { 1 , 4 , 2 , 1 } ; int y [ ] = new int [ ] { 4 , 1 , 1 , 2 } ; shortestLength ( n , x , y ) ; } }", "nl": "points on the plane"}
{"code": "class GFG {", "nl": "Java program to find intersection rectangle of given two rectangles ."}
{"code": "static void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) {", "nl": "function to find intersection rectangle of given two rectangles ."}
{"code": "int x5 = Math . max ( x1 , x3 ) ; int y5 = Math . max ( y1 , y3 ) ;", "nl": "gives bottom - left point of intersection rectangle"}
{"code": "int x6 = Math . min ( x2 , x4 ) ; int y6 = Math . min ( y2 , y4 ) ;", "nl": "gives top - right point of intersection rectangle"}
{"code": "if ( x5 > x6 y5 > y6 ) { System . out . println ( \" No \u2581 intersection \" ) ; return ; } System . out . print ( \" ( \" + x5 + \" , \u2581 \" + y5 + \" ) \u2581 \" ) ; System . out . print ( \" ( \" + x6 + \" , \u2581 \" + y6 + \" ) \u2581 \" ) ;", "nl": "no intersection"}
{"code": "int x7 = x5 ; int y7 = y6 ; System . out . print ( \" ( \" + x7 + \" , \u2581 \" + y7 + \" ) \u2581 \" ) ;", "nl": "gives top - left point of intersection rectangle"}
{"code": "int x8 = x6 ; int y8 = y5 ; System . out . print ( \" ( \" + x8 + \" , \u2581 \" + y8 + \" ) \u2581 \" ) ; }", "nl": "gives bottom - right point of intersection rectangle"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver code"}
{"code": "int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ;", "nl": "bottom - left and top - right corners of first rectangle"}
{"code": "int x3 = 2 , y3 = 3 , x4 = 7 , y4 = 9 ;", "nl": "bottom - left and top - right corners of first rectangle"}
{"code": "FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; } }", "nl": "function call"}
{"code": "class GFG {", "nl": "Java program to find corner points of a rectangle using given length and middle points ."}
{"code": "static class Point { float x , y ; Point ( ) { x = y = 0 ; } Point ( float a , float b ) { x = a ; y = b ; } } ;", "nl": "Structure to represent a co - ordinate point"}
{"code": "static void printCorners ( Point p , Point q , float l ) { Point a = new Point ( ) , b = new Point ( ) , c = new Point ( ) , d = new Point ( ) ;", "nl": "This function receives two points and length of the side of rectangle and prints the 4 corner points of the rectangle"}
{"code": "if ( p . x == q . x ) { a . x = ( float ) ( p . x - ( l / 2.0 ) ) ; a . y = p . y ; d . x = ( float ) ( p . x + ( l / 2.0 ) ) ; d . y = p . y ; b . x = ( float ) ( q . x - ( l / 2.0 ) ) ; b . y = q . y ; c . x = ( float ) ( q . x + ( l / 2.0 ) ) ; c . y = q . y ; }", "nl": "horizontal rectangle"}
{"code": "else if ( p . y == q . y ) { a . y = ( float ) ( p . y - ( l / 2.0 ) ) ; a . x = p . x ; d . y = ( float ) ( p . y + ( l / 2.0 ) ) ; d . x = p . x ; b . y = ( float ) ( q . y - ( l / 2.0 ) ) ; b . x = q . x ; c . y = ( float ) ( q . y + ( l / 2.0 ) ) ; c . x = q . x ; }", "nl": "vertical rectangle"}
{"code": "else {", "nl": "slanted rectangle"}
{"code": "float m = ( p . x - q . x ) / ( q . y - p . y ) ;", "nl": "calculate slope of the side"}
{"code": "float dx = ( float ) ( ( l / Math . sqrt ( 1 + ( m * m ) ) ) * 0.5 ) ; float dy = m * dx ; a . x = p . x - dx ; a . y = p . y - dy ; d . x = p . x + dx ; d . y = p . y + dy ; b . x = q . x - dx ; b . y = q . y - dy ; c . x = q . x + dx ; c . y = q . y + dy ; } System . out . print ( ( int ) a . x + \" , \u2581 \" + ( int ) a . y + \" NEW_LINE\" + ( int ) b . x + \" , \u2581 \" + ( int ) b . y + \"NEW_LINE\" + ( int ) c . x + \" , \u2581 \" + ( int ) c . y + \" NEW_LINE\" + ( int ) d . x + \" , \u2581 \" + ( int ) d . y + \"NEW_LINE\"); }", "nl": "calculate displacements along axes"}
{"code": "public static void main ( String [ ] args ) { Point p1 = new Point ( 1 , 0 ) , q1 = new Point ( 1 , 2 ) ; printCorners ( p1 , q1 , 2 ) ; Point p = new Point ( 1 , 1 ) , q = new Point ( - 1 , - 1 ) ; printCorners ( p , q , ( float ) ( 2 * Math . sqrt ( 2 ) ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "public static int minimumCost ( int arr [ ] , int N , int X , int Y ) {", "nl": "Function to find the minimum cost to modify the array according to the given criteria"}
{"code": "int even_count = 0 , odd_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Count of wrong positioned odd and even elements"}
{"code": "if ( ( arr [ i ] & 1 ) > 0 && ( i % 2 == 0 ) ) { odd_count ++ ; }", "nl": "Odd Count"}
{"code": "if ( ( arr [ i ] % 2 ) == 0 && ( i & 1 ) > 0 ) { even_count ++ ; } }", "nl": "Even Count"}
{"code": "int cost1 = X * Math . min ( odd_count , even_count ) ;", "nl": "Swapping Cost"}
{"code": "int cost2 = Y * ( Math . max ( odd_count , even_count ) - Math . min ( odd_count , even_count ) ) ;", "nl": "Decrementing cost after swapping"}
{"code": "int cost3 = ( odd_count + even_count ) * Y ;", "nl": "Only decrementing cost"}
{"code": "return Math . min ( cost1 + cost2 , cost3 ) ; }", "nl": "Return the minimum cost of the two cases"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 5 , 3 , 7 , 2 , 1 } , X = 10 , Y = 2 ; int N = arr . length ; System . out . println ( minimumCost ( arr , N , X , Y ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "package whatever do not write package name here"}
{"code": "static int findMinMax ( int [ ] a ) {", "nl": "Function to find the minimum product of the minimum and maximum among all the possible subarrays"}
{"code": "int min_val = 1000000000 ;", "nl": "Stores resultant minimum product"}
{"code": "for ( int i = 1 ; i < a . length ; ++ i ) {", "nl": "Traverse the given array arr [ ]"}
{"code": "min_val = Math . min ( min_val , a [ i ] * a [ i - 1 ] ) ; }", "nl": "Min of product of all two pair of consecutive elements"}
{"code": "return min_val ; }", "nl": "Return the resultant value"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 6 , 4 , 5 , 6 , 2 , 4 , 1 } ; System . out . println ( findMinMax ( arr ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; public class GFG { static int sum ;", "nl": "Java program for the above approach"}
{"code": "static class TreeNode { int data ; TreeNode left ; TreeNode right ;", "nl": "Structure of Tree"}
{"code": "TreeNode ( int data ) { this . data = data ; this . left = null ; this . right = null ; } } ;", "nl": "Constructor"}
{"code": "static void kDistanceDownSum ( TreeNode root , int k ) {", "nl": "Function to add the node to the sum below the target node"}
{"code": "if ( root == null k < 0 ) return ;", "nl": "Base Case"}
{"code": "if ( k == 0 ) { sum += root . data ; return ; }", "nl": "If Kth distant node is reached"}
{"code": "kDistanceDownSum ( root . left , k - 1 ) ; kDistanceDownSum ( root . right , k - 1 ) ; }", "nl": "Recur for the left and the right subtrees"}
{"code": "static int kDistanceSum ( TreeNode root , int target , int k ) {", "nl": "Function to find the K distant nodes from target node , it returns - 1 if target node is not present in tree"}
{"code": "if ( root == null ) return - 1 ;", "nl": "Base Case 1"}
{"code": "if ( root . data == target ) { kDistanceDownSum ( root . left , k - 1 ) ; return 0 ; }", "nl": "If target is same as root ."}
{"code": "int dl = - 1 ;", "nl": "Recurr for the left subtree"}
{"code": "if ( target < root . data ) { dl = kDistanceSum ( root . left , target , k ) ; }", "nl": "Tree is BST so reduce the search space"}
{"code": "if ( dl != - 1 ) {", "nl": "Check if target node was found in left subtree"}
{"code": "if ( dl + 1 == k ) sum += root . data ;", "nl": "If root is at distance k from the target"}
{"code": "return - 1 ; }", "nl": "Node less than target will be present in left"}
{"code": "int dr = - 1 ; if ( target > root . data ) { dr = kDistanceSum ( root . right , target , k ) ; } if ( dr != - 1 ) {", "nl": "When node is not present in the left subtree"}
{"code": "if ( dr + 1 == k ) sum += root . data ;", "nl": "If Kth distant node is reached"}
{"code": "else kDistanceDownSum ( root . left , k - dr - 2 ) ; return 1 + dr ; }", "nl": "Node less than target at k distance maybe present in the left tree"}
{"code": "return - 1 ; }", "nl": "If target was not present in the left nor in right subtree"}
{"code": "static TreeNode insertNode ( int data , TreeNode root ) {", "nl": "Function to insert a node in BST"}
{"code": "if ( root == null ) { TreeNode node = new TreeNode ( data ) ; return node ; }", "nl": "If root is null"}
{"code": "else if ( data > root . data ) { root . right = insertNode ( data , root . right ) ; }", "nl": "Insert the data in right half"}
{"code": "else if ( data <= root . data ) { root . left = insertNode ( data , root . left ) ; }", "nl": "Insert the data in left half"}
{"code": "return root ; }", "nl": "Return the root node"}
{"code": "static void findSum ( TreeNode root , int target , int K ) {", "nl": "Function to find the sum of K distant nodes from the target node having value less than target node"}
{"code": "sum = 0 ; kDistanceSum ( root , target , K ) ;", "nl": "Stores the sum of nodes having values < target at K distance"}
{"code": "System . out . print ( sum ) ; }", "nl": "Print the resultant sum"}
{"code": "public static void main ( String [ ] args ) { TreeNode root = null ; int N = 11 ; int tree [ ] = { 3 , 1 , 7 , 0 , 2 , 5 , 10 , 4 , 6 , 9 , 8 } ;", "nl": "Driver Code"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { root = insertNode ( tree [ i ] , root ) ; } int target = 7 ; int K = 2 ; findSum ( root , target , K ) ; } }", "nl": "Create the Tree"}
{"code": "import java . io . * ; class GFG {", "nl": "Java Program for the above approach"}
{"code": "static int itemType ( int n ) {", "nl": "Function to find the type of the item given out according to the given rules"}
{"code": "int count = 0 ;", "nl": "Stores the count of item given out at each step"}
{"code": "for ( int day = 1 ; ; day ++ ) {", "nl": "Iterate over the days from 1"}
{"code": "for ( int type = day ; type > 0 ; type -- ) { count += type ;", "nl": "Iterate over type of item on that day"}
{"code": "if ( count >= n ) return type ; } } }", "nl": "Count of items given out should exceed n"}
{"code": "public static void main ( String [ ] args ) { int N = 10 ; System . out . println ( itemType ( N ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static int FindSum ( int [ ] arr , int N ) {", "nl": "Function to print the sum of array elements that are equidistant from two consecutive powers of 2"}
{"code": "int res = 0 ;", "nl": "Stores the resultant sum of the array elements"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array arr [ ]"}
{"code": "int power = ( int ) ( Math . log ( arr [ i ] ) / Math . log ( 2 ) ) ;", "nl": "Stores the power of 2 of the number arr [ i ]"}
{"code": "int LesserValue = ( int ) Math . pow ( 2 , power ) ;", "nl": "Stores the number which is power of 2 and lesser than or equal to arr [ i ]"}
{"code": "int LargerValue = ( int ) Math . pow ( 2 , power + 1 ) ;", "nl": "Stores the number which is power of 2 and greater than or equal to arr [ i ]"}
{"code": "if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) {", "nl": "If arr [ i ] - LesserValue is the same as LargerValue - arr [ i ]"}
{"code": "res += arr [ i ] ; } }", "nl": "Increment res by arr [ i ]"}
{"code": "return res ; }", "nl": "Return the resultant sum res"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 10 , 24 , 17 , 3 , 8 } ; int N = arr . length ; System . out . println ( FindSum ( arr , N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; import java . lang . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void findLast ( int mat [ ] [ ] ) { int m = 3 ; int n = 3 ;", "nl": "Function to find the person who will finish last"}
{"code": "Set < Integer > rows = new HashSet < Integer > ( ) ; Set < Integer > cols = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( mat [ i ] [ j ] > 0 ) ) { rows . add ( i ) ; cols . add ( j ) ; } } }", "nl": "To keep track of rows and columns having 1"}
{"code": "int avRows = m - rows . size ( ) ; int avCols = n - cols . size ( ) ;", "nl": "Available rows and columns"}
{"code": "int choices = Math . min ( avRows , avCols ) ;", "nl": "Minimum number of choices we have"}
{"code": "if ( ( choices & 1 ) != 0 )", "nl": "If number of choices are odd"}
{"code": "System . out . println ( \" P1\" ) ;", "nl": "P1 will finish last"}
{"code": "else System . out . println ( \" P2\" ) ; }", "nl": "Otherwise , P2 will finish last"}
{"code": "public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 0 , 0 } , { 0 , 0 , 0 } , { 0 , 0 , 1 } } ; findLast ( mat ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . lang . * ; class GFG { static final int MOD = 1000000007 ;", "nl": "/ Java program for the above approach"}
{"code": "static void sumOfBinaryNumbers ( int n ) {", "nl": "Function to find the sum of first N natural numbers represented in binary representation"}
{"code": "int ans = 0 ; int one = 1 ;", "nl": "Stores the resultant sum"}
{"code": "while ( true ) {", "nl": "Iterate until the value of N is greater than 0"}
{"code": "if ( n <= 1 ) { ans = ( ans + n ) % MOD ; break ; }", "nl": "If N is less than 2"}
{"code": "int x = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; int cur = 0 ; int add = ( int ) ( Math . pow ( 2 , ( x - 1 ) ) ) ;", "nl": "Store the MSB position of N"}
{"code": "for ( int i = 1 ; i <= x ; i ++ ) {", "nl": "Iterate in the range [ 1 , x ] and add the contribution of the numbers from 1 to ( 2 ^ x - 1 )"}
{"code": "cur = ( cur + add ) % MOD ; add = ( add * 10 % MOD ) ; }", "nl": "Update the value of the cur and add"}
{"code": "ans = ( ans + cur ) % MOD ;", "nl": "Add the cur to ans"}
{"code": "int rem = n - ( int ) ( Math . pow ( 2 , x ) ) + 1 ;", "nl": "Store the remaining numbers"}
{"code": "int p = ( int ) Math . pow ( 10 , x ) ; p = ( p * ( rem % MOD ) ) % MOD ; ans = ( ans + p ) % MOD ;", "nl": "Add the contribution by MSB by the remaining numbers"}
{"code": "n = rem - 1 ; }", "nl": "The next iteration will be repeated for 2 ^ x - 1"}
{"code": "System . out . println ( ans ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { int N = 3 ; sumOfBinaryNumbers ( N ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static void nearestFibonacci ( int num ) {", "nl": "Function to find the Fibonacci number which is nearest to N"}
{"code": "if ( num == 0 ) { System . out . print ( 0 ) ; return ; }", "nl": "Base Case"}
{"code": "int first = 0 , second = 1 ;", "nl": "Initialize the first & second terms of the Fibonacci series"}
{"code": "int third = first + second ;", "nl": "Store the third term"}
{"code": "while ( third <= num ) {", "nl": "Iterate until the third term is less than or equal to num"}
{"code": "first = second ;", "nl": "Update the first"}
{"code": "second = third ;", "nl": "Update the second"}
{"code": "third = first + second ; }", "nl": "Update the third"}
{"code": "int ans = ( Math . abs ( third - num ) >= Math . abs ( second - num ) ) ? second : third ;", "nl": "Store the Fibonacci number having smaller difference with N"}
{"code": "System . out . print ( ans ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { int N = 17 ; nearestFibonacci ( N ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; import java . lang . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static boolean checkPermutation ( int ans [ ] , int a [ ] , int n ) {", "nl": "Function to check if the maximum prefix array of ans [ ] is equal to array arr [ ]"}
{"code": "int Max = Integer . MIN_VALUE ;", "nl": "Initialize a variable , Max"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse the array , ans [ ]"}
{"code": "Max = Math . max ( Max , ans [ i ] ) ;", "nl": "Store the maximum value upto index i"}
{"code": "if ( Max != a [ i ] ) return false ; }", "nl": "If it is not equal to a [ i ] , then return false"}
{"code": "return true ; }", "nl": "Otherwise return false"}
{"code": "static void findPermutation ( int a [ ] , int n ) {", "nl": "Function to find the permutation of the array whose prefix maximum array is same as the given array a [ ]"}
{"code": "int ans [ ] = new int [ n ] ;", "nl": "Stores the required permutation"}
{"code": "HashMap < Integer , Integer > um = new HashMap < > ( ) ;", "nl": "Stores the index of first occurrence of elements"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse the array a [ ]"}
{"code": "if ( ! um . containsKey ( a [ i ] ) ) {", "nl": "If a [ i ] is not present in um , then store it in um"}
{"code": "ans [ i ] = a [ i ] ; um . put ( a [ i ] , i ) ; } }", "nl": "Update the ans [ i ] to a [ i ]"}
{"code": "ArrayList < Integer > v = new ArrayList < > ( ) ; int j = 0 ;", "nl": "Stores the unvisited numbers"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) {", "nl": "Fill the array , v [ ]"}
{"code": "if ( ! um . containsKey ( i ) ) { v . add ( i ) ; } }", "nl": "Store the index"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse the array , ans [ ]"}
{"code": "if ( ans [ i ] == 0 ) { ans [ i ] = v . get ( j ) ; j ++ ; } }", "nl": "Fill v [ j ] at places where ans [ i ] is 0"}
{"code": "if ( checkPermutation ( ans , a , n ) ) {", "nl": "Check if the current permutation maximum prefix array is same as the given array a [ ]"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + \" \u2581 \" ) ; } }", "nl": "If true , the print the permutation"}
{"code": "else System . out . println ( \" - 1\" ) ; }", "nl": "Otherwise , print - 1"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 } ; int N = arr . length ;", "nl": "Driver Code"}
{"code": "findPermutation ( arr , N ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; import java . util . Map ; import java . util . HashMap ; class GFG {", "nl": "package whatever do not write package name here"}
{"code": "public static void countEqualElementPairs ( int arr [ ] , int N ) {", "nl": "Function to count the number of required pairs for every array element"}
{"code": "HashMap < Integer , Integer > map = new HashMap < > ( ) ;", "nl": "Initialize a map"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { Integer k = map . get ( arr [ i ] ) ; map . put ( arr [ i ] , ( k == null ) ? 1 : k + 1 ) ; }", "nl": "Update the frequency of every element"}
{"code": "int total = 0 ;", "nl": "Stores the count of pairs"}
{"code": "for ( Map . Entry < Integer , Integer > e : map . entrySet ( ) ) {", "nl": "Traverse the map"}
{"code": "total += ( e . getValue ( ) * ( e . getValue ( ) - 1 ) ) / 2 ; }", "nl": "Count the number of ways to select pairs consisting of equal elements only"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array"}
{"code": "System . out . print ( total - ( map . get ( arr [ i ] ) - 1 ) + \" \u2581 \" ) ; } }", "nl": "Print the count for every array element"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int arr [ ] = { 1 , 1 , 2 , 1 , 2 } ;", "nl": "Given array"}
{"code": "int N = 5 ; countEqualElementPairs ( arr , N ) ; } }", "nl": "Size of the array"}
{"code": "public class GFG {", "nl": "Java program to find the count of natural octal numbers upto N digits"}
{"code": "static int count ( int N ) { int sum = 0 ;", "nl": "Function to return the count of natural octal numbers upto N digits"}
{"code": "for ( int i = 1 ; i <= N ; i ++ ) { sum += 7 * Math . pow ( 8 , i - 1 ) ; } return sum ; }", "nl": "Loop to iterate from 1 to N and calculating number of octal numbers for every ' i ' th digit ."}
{"code": "public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( count ( N ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find all the palindromic divisors of a number"}
{"code": "static boolean isPalindrome ( int n ) {", "nl": "Function to check is num is palindromic or not"}
{"code": "String str = String . valueOf ( n ) ;", "nl": "Convert n to String str"}
{"code": "int s = 0 , e = str . length ( ) - 1 ; while ( s < e ) {", "nl": "Starting and ending index of String str"}
{"code": "if ( str . charAt ( s ) != str . charAt ( e ) ) { return false ; } s ++ ; e -- ; } return true ; }", "nl": "If char at s and e are not equals then return false"}
{"code": "static void palindromicDivisors ( int n ) {", "nl": "Function to find palindromic divisors"}
{"code": "Vector < Integer > PalindromDivisors = new Vector < Integer > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) {", "nl": "To sore the palindromic divisors of number n"}
{"code": "if ( n % i == 0 ) {", "nl": "If n is divisible by i"}
{"code": "if ( n / i == i ) {", "nl": "Check if number is a perfect square"}
{"code": "if ( isPalindrome ( i ) ) { PalindromDivisors . add ( i ) ; } } else {", "nl": "Check divisor is palindromic , then store it"}
{"code": "if ( isPalindrome ( i ) ) { PalindromDivisors . add ( i ) ; }", "nl": "Check if divisors are palindrome"}
{"code": "if ( isPalindrome ( n / i ) ) { PalindromDivisors . add ( n / i ) ; } } } }", "nl": "Check if n / divisors is palindromic or not"}
{"code": "Collections . sort ( PalindromDivisors ) ; for ( int i = 0 ; i < PalindromDivisors . size ( ) ; i ++ ) { System . out . print ( PalindromDivisors . get ( i ) + \" \u2581 \" ) ; } }", "nl": "Print all palindromic divisors in sorted order"}
{"code": "public static void main ( String [ ] args ) { int n = 66 ;", "nl": "Driver code"}
{"code": "palindromicDivisors ( n ) ; } }", "nl": "Function call to find all palindromic divisors"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int findMinDel ( int [ ] arr , int n ) {", "nl": "Function to return the minimum deletions to get minimum OR"}
{"code": "int min_num = Integer . MAX_VALUE ;", "nl": "To store the minimum element"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) min_num = Math . min ( arr [ i ] , min_num ) ;", "nl": "Find the minimum element from the array"}
{"code": "int cnt = 0 ;", "nl": "To store the frequency of the minimum element"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ;", "nl": "Find the frequency of the minimum element"}
{"code": "return n - cnt ; }", "nl": "Return the final answer"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 3 , 3 , 2 } ; int n = arr . length ; System . out . print ( findMinDel ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int cntSubArr ( int [ ] arr , int n ) {", "nl": "Function to return the required count"}
{"code": "int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "To store the final answer"}
{"code": "int curr_gcd = 0 ;", "nl": "To store the GCD starting from index ' i '"}
{"code": "for ( int j = i ; j < n ; j ++ ) { curr_gcd = __gcd ( curr_gcd , arr [ j ] ) ;", "nl": "Loop to find the gcd of each subarray from arr [ i ] to arr [ i ... n - 1 ]"}
{"code": "ans += ( curr_gcd == 1 ) ? 1 : 0 ; } }", "nl": "Increment the count if curr_gcd = 1"}
{"code": "return ans ; } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; }", "nl": "Return the final answer"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 } ; int n = arr . length ; System . out . println ( cntSubArr ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to display first N Prime numbers"}
{"code": "static void print_primes_till_N ( int N ) {", "nl": "Function to print first N prime numbers"}
{"code": "int i , j , flag ;", "nl": "Declare the variables"}
{"code": "System . out . println ( \" Prime \u2581 numbers \u2581 between \u2581 1 \u2581 and \u2581 \" + N + \" \u2581 are : \" ) ;", "nl": "Print display message"}
{"code": "for ( i = 1 ; i <= N ; i ++ ) {", "nl": "Traverse each number from 1 to N with the help of for loop"}
{"code": "if ( i == 1 i == 0 ) continue ;", "nl": "Skip 0 and 1 as they are neither prime nor composite"}
{"code": "flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } }", "nl": "flag variable to tell if i is prime or not"}
{"code": "if ( flag == 1 ) System . out . print ( i + \" \u2581 \" ) ; } }", "nl": "flag = 1 means i is prime and flag = 0 means i is not prime"}
{"code": "public static void main ( String [ ] args ) { int N = 100 ; print_primes_till_N ( N ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int MAX = 32 ;", "nl": "Java implementation of the approach"}
{"code": "static int findX ( int A , int B ) { int X = 0 ;", "nl": "Function to find X according to the given conditions"}
{"code": "for ( int bit = 0 ; bit < MAX ; bit ++ ) {", "nl": "int can have 32 bits"}
{"code": "int tempBit = 1 << bit ;", "nl": "Temporary ith bit"}
{"code": "int bitOfX = A & B & tempBit ;", "nl": "Compute ith bit of X according to given conditions Expression below is the direct conclusion from the illustration we had taken earlier"}
{"code": "X += bitOfX ; } return X ; }", "nl": "Add the ith bit of X to X"}
{"code": "public static void main ( String [ ] args ) { int A = 11 , B = 13 ; System . out . println ( findX ( A , B ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int cntSubSets ( int arr [ ] , int n ) {", "nl": "Function to return the count of subsets with the maximum mean"}
{"code": "int maxVal = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ;", "nl": "Maximum value from the array"}
{"code": "int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; }", "nl": "To store the number of times maximum element appears in the array"}
{"code": "return ( int ) ( Math . pow ( 2 , cnt ) - 1 ) ; }", "nl": "Return the count of valid subsets"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 1 , 2 } ; int n = arr . length ; System . out . println ( cntSubSets ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static float findProb ( int arr [ ] , int n ) {", "nl": "Function to return the probability of getting the maximum pair sum when a random pair is chosen from the given array"}
{"code": "long maxSum = Integer . MIN_VALUE , maxCount = 0 , totalPairs = 0 ;", "nl": "Initialize the maximum sum , its count and the count of total pairs"}
{"code": "for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) {", "nl": "For every single pair"}
{"code": "int sum = arr [ i ] + arr [ j ] ;", "nl": "Get the sum of the current pair"}
{"code": "if ( sum == maxSum ) {", "nl": "If the sum is equal to the current maximum sum so far"}
{"code": "maxCount ++ ; }", "nl": "Increment its count"}
{"code": "else if ( sum > maxSum ) {", "nl": "If the sum is greater than the current maximum"}
{"code": "maxSum = sum ; maxCount = 1 ; } totalPairs ++ ; } }", "nl": "Update the current maximum and re - initialize the count to 1"}
{"code": "float prob = ( float ) maxCount / ( float ) totalPairs ; return prob ; }", "nl": "Find the required probability"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 1 , 1 , 1 , 2 , 2 , 2 } ; int n = arr . length ; System . out . println ( findProb ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }", "nl": "Java implementation of the approach"}
{"code": "static int maxCommonFactors ( int a , int b ) {", "nl": "Function to return the count of common factors of a and b such that all the elements are co - prime to one another"}
{"code": "int __gcd = gcd ( a , b ) ;", "nl": "GCD of a and b"}
{"code": "int ans = 1 ;", "nl": "Include 1 initially"}
{"code": "for ( int i = 2 ; i * i <= __gcd ; i ++ ) { if ( __gcd % i == 0 ) { ans ++ ; while ( __gcd % i == 0 ) __gcd /= i ; } }", "nl": "Find all the prime factors of the gcd"}
{"code": "if ( __gcd != 1 ) ans ++ ;", "nl": "If gcd is prime"}
{"code": "return ans ; }", "nl": "Return the required answer"}
{"code": "public static void main ( String [ ] args ) { int a = 12 , b = 18 ; System . out . println ( maxCommonFactors ( a , b ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int days [ ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ;", "nl": "Java implementation of the approach"}
{"code": "static int dayOfYear ( String date ) {", "nl": "Function to return the day number of the year for the given date"}
{"code": "int year = Integer . parseInt ( date . substring ( 0 , 4 ) ) ; int month = Integer . parseInt ( date . substring ( 5 , 7 ) ) ; int day = Integer . parseInt ( date . substring ( 8 ) ) ;", "nl": "Extract the year , month and the day from the date string"}
{"code": "if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 year % 400 == 0 ) ) { ++ day ; }", "nl": "If current year is a leap year and the date given is after the 28 th of February then it must include the 29 th February"}
{"code": "while ( -- month > 0 ) { day = day + days [ month - 1 ] ; } return day ; }", "nl": "Add the days in the previous months"}
{"code": "public static void main ( String [ ] args ) { String date = \"2019-01-09\" ; System . out . println ( dayOfYear ( date ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find number of cells in the table contains X"}
{"code": "public static int Cells ( int n , int x ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && x / i <= n ) ans ++ ; return ans ; }", "nl": "Function to find number of cells in the table contains X"}
{"code": "public static void main ( String [ ] args ) { int n = 6 , x = 12 ;", "nl": "Driver code"}
{"code": "System . out . println ( Cells ( n , x ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; import java . lang . Math ; import java . io . * ; class GFG {", "nl": "Java implementation of above approach"}
{"code": "static int nextPowerOfFour ( int n ) { int x = ( int ) Math . floor ( Math . sqrt ( Math . sqrt ( n ) ) ) ;", "nl": "Function to return the smallest power of 4 greater than or equal to n"}
{"code": "if ( Math . pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return ( int ) Math . pow ( x , 4 ) ; } }", "nl": "If n is itself is a power of 4 then return n"}
{"code": "public static void main ( String [ ] args ) throws java . lang . Exception { int n = 122 ; System . out . println ( nextPowerOfFour ( n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int minOperations ( int x , int y , int p , int q ) {", "nl": "Function to return the minimum operations required"}
{"code": "if ( y % x != 0 ) return - 1 ; int d = y / x ;", "nl": "Not possible"}
{"code": "int a = 0 ;", "nl": "To store the greatest power of p that divides d"}
{"code": "while ( d % p == 0 ) { d /= p ; a ++ ; }", "nl": "While divible by p"}
{"code": "int b = 0 ;", "nl": "To store the greatest power of q that divides d"}
{"code": "while ( d % q == 0 ) { d /= q ; b ++ ; }", "nl": "While divible by q"}
{"code": "if ( d != 1 ) return - 1 ;", "nl": "If d > 1"}
{"code": "return ( a + b ) ; }", "nl": "Since , d = p ^ a * q ^ b"}
{"code": "public static void main ( String [ ] args ) { int x = 12 , y = 2592 , p = 2 , q = 3 ; System . out . println ( minOperations ( x , y , p , q ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int nCr ( int n ) {", "nl": "Function to calculate NC4"}
{"code": "if ( n < 4 ) return 0 ; int answer = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; answer /= 24 ; return answer ; }", "nl": "Base case to calculate NC4"}
{"code": "static int countQuadruples ( int N , int K ) {", "nl": "Function to return the count of required quadruples using Inclusion Exclusion"}
{"code": "int M = N / K ; int answer = nCr ( M ) ;", "nl": "Effective N"}
{"code": "for ( int i = 2 ; i < M ; i ++ ) { int j = i ;", "nl": "Iterate over 2 to M"}
{"code": "int temp2 = M / i ;", "nl": "Number of divisors of i till M"}
{"code": "int count = 0 ;", "nl": "Count stores the number of prime divisors occurring exactly once"}
{"code": "int check = 0 ; int temp = j ; while ( j % 2 == 0 ) { count ++ ; j /= 2 ; if ( count >= 2 ) break ; } if ( count >= 2 ) { check = 1 ; } for ( int k = 3 ; k <= Math . sqrt ( temp ) ; k += 2 ) { int cnt = 0 ; while ( j % k == 0 ) { cnt ++ ; j /= k ; if ( cnt >= 2 ) break ; } if ( cnt >= 2 ) { check = 1 ; break ; } else if ( cnt == 1 ) count ++ ; } if ( j > 2 ) { count ++ ; }", "nl": "To prevent repetition of prime divisors"}
{"code": "if ( check == 1 ) continue ; else {", "nl": "If repetition of prime divisors present ignore this number"}
{"code": "if ( count % 2 == 1 ) { answer -= nCr ( temp2 ) ; } else { answer += nCr ( temp2 ) ; } } } return answer ; }", "nl": "If prime divisor count is odd subtract it from answer else add"}
{"code": "public static void main ( String [ ] args ) { int N = 10 , K = 2 ; System . out . println ( countQuadruples ( N , K ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int getX ( int a , int b , int c , int d ) { int X = ( b * c - a * d ) / ( d - c ) ; return X ; }", "nl": "Function to return the required number X"}
{"code": "public static void main ( String [ ] args ) { int a = 2 , b = 3 , c = 4 , d = 5 ; System . out . println ( getX ( a , b , c , d ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; import java . lang . * ; class GFG {", "nl": "Java code for above approach"}
{"code": "static boolean isVowel ( char ch ) { if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) return true ; else return false ; }", "nl": "Function to check if a character is vowel or consonent"}
{"code": "static long fact ( long n ) { if ( n < 2 ) { return 1 ; } return n * fact ( n - 1 ) ; }", "nl": "Function to calculate factorial of a number"}
{"code": "static long only_vowels ( HashMap < Character , Integer > freq ) { long denom = 1 ; long cnt_vwl = 0 ;", "nl": "Calculating no of ways for arranging vowels"}
{"code": "for ( Map . Entry < Character , Integer > itr : freq . entrySet ( ) ) { if ( isVowel ( itr . getKey ( ) ) ) { denom *= fact ( itr . getValue ( ) ) ; cnt_vwl += itr . getValue ( ) ; } } return fact ( cnt_vwl ) / denom ; }", "nl": "Iterate the map and count the number of vowels and calculate no of ways to arrange vowels"}
{"code": "static long all_vowels_together ( HashMap < Character , Integer > freq ) {", "nl": "Calculating no of ways to arrange the given word such that all vowels come together"}
{"code": "long vow = only_vowels ( freq ) ;", "nl": "Calculate no of ways to arrange vowels"}
{"code": "long denom = 1 ;", "nl": "To store denominator of fraction"}
{"code": "long cnt_cnst = 0 ; for ( Map . Entry < Character , Integer > itr : freq . entrySet ( ) ) { if ( ! isVowel ( itr . getKey ( ) ) ) { denom *= fact ( itr . getValue ( ) ) ; cnt_cnst += itr . getValue ( ) ; } }", "nl": "Count of consonents"}
{"code": "long ans = fact ( cnt_cnst + 1 ) / denom ; return ( ans * vow ) ; }", "nl": "Calculate the number of ways to arrange the word such that all vowels come together"}
{"code": "static long total_permutations ( HashMap < Character , Integer > freq ) {", "nl": "To calculate total number of permutations"}
{"code": "long cnt = 0 ;", "nl": "To store length of the given word"}
{"code": "long denom = 1 ; for ( Map . Entry < Character , Integer > itr : freq . entrySet ( ) ) { denom *= fact ( itr . getValue ( ) ) ; cnt += itr . getValue ( ) ; }", "nl": "Denominator of fraction"}
{"code": "return fact ( cnt ) / denom ; }", "nl": "Return total number of permutations of the given word"}
{"code": "static long no_vowels_together ( String word ) {", "nl": "Function to calculate number of permutations such that no vowels come together"}
{"code": "HashMap < Character , Integer > freq = new HashMap < > ( ) ;", "nl": "To store frequency of character"}
{"code": "for ( int i = 0 ; i < word . length ( ) ; i ++ ) { char ch = Character . toLowerCase ( word . charAt ( i ) ) ; if ( freq . containsKey ( ch ) ) { freq . put ( ch , freq . get ( ch ) + 1 ) ; } else { freq . put ( ch , 1 ) ; } }", "nl": "Count frequency of all characters"}
{"code": "long total = total_permutations ( freq ) ;", "nl": "Calculate total number of permutations"}
{"code": "long vwl_tgthr = all_vowels_together ( freq ) ;", "nl": "Calculate total number of permutations such that all vowels come together"}
{"code": "long res = total - vwl_tgthr ;", "nl": "Subtract vwl_tgthr from total to get the result"}
{"code": "return res ; }", "nl": "Return the result"}
{"code": "public static void main ( String [ ] args ) { String word = \" allahabad \" ; long ans = no_vowels_together ( word ) ; System . out . println ( ans ) ; word = \" geeksforgeeks \" ; ans = no_vowels_together ( word ) ; System . out . println ( ans ) ; word = \" abcd \" ; ans = no_vowels_together ( word ) ; System . out . println ( ans ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int numberOfMen ( int D , int m , int d ) { int Men = ( m * ( D - d ) ) / d ; return Men ; }", "nl": "Function to return the number of men initially"}
{"code": "public static void main ( String args [ ] ) { int D = 5 , m = 4 , d = 4 ; System . out . println ( numberOfMen ( D , m , d ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program area of triangle formed by the axes of co - ordinates and a given straight line"}
{"code": "static double area ( double a , double b , double c ) { double d = Math . abs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; }", "nl": "Function to find area"}
{"code": "public static void main ( String [ ] args ) { double a = - 2 , b = 4 , c = 3 ; System . out . println ( area ( a , b , c ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static ArrayList < Integer > addToArrayForm ( ArrayList < Integer > A , int K ) {", "nl": "Function to return the vector containing the answer"}
{"code": "ArrayList < Integer > v = new ArrayList < Integer > ( ) ; ArrayList < Integer > ans = new ArrayList < Integer > ( ) ;", "nl": "ArrayList v is to store each digits sum and ArrayList ans is to store the answer"}
{"code": "int rem = 0 ; int i = 0 ;", "nl": "No carry in the beginning"}
{"code": "for ( i = A . size ( ) - 1 ; i >= 0 ; i -- ) {", "nl": "Start loop from the end and take element one by one"}
{"code": "int my = A . get ( i ) + K % 10 + rem ; if ( my > 9 ) {", "nl": "Array index and last digit of number"}
{"code": "rem = 1 ;", "nl": "Maintain carry of summation"}
{"code": "v . add ( my % 10 ) ; } else { v . add ( my ) ; rem = 0 ; } K = K / 10 ; }", "nl": "Push the digit value into the array"}
{"code": "while ( K > 0 ) {", "nl": "K value is greater then 0"}
{"code": "int my = K % 10 + rem ; v . add ( my % 10 ) ;", "nl": "Push digits of K one by one in the array"}
{"code": "if ( my / 10 > 0 ) rem = 1 ; else rem = 0 ; K = K / 10 ; } if ( rem > 0 ) v . add ( rem ) ;", "nl": "Also maintain carry with summation"}
{"code": "for ( int j = v . size ( ) - 1 ; j >= 0 ; j -- ) ans . add ( v . get ( j ) ) ; return ans ; }", "nl": "Reverse the elements of vector v and store it in vector ans"}
{"code": "public static void main ( String [ ] args ) { ArrayList < Integer > A = new ArrayList < Integer > ( ) ; A . add ( 2 ) ; A . add ( 7 ) ; A . add ( 4 ) ; int K = 181 ; ArrayList < Integer > ans = addToArrayForm ( A , K ) ;", "nl": "Driver code"}
{"code": "for ( int i = 0 ; i < ans . size ( ) ; i ++ ) System . out . print ( ans . get ( i ) ) ; } }", "nl": "Print the answer"}
{"code": "import java . util . * ; class GFG { static int MAX = 100005 ;", "nl": "Java implementation of the approach"}
{"code": "static int kadaneAlgorithm ( int [ ] ar , int n ) { int sum = 0 , maxSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ar [ i ] ; if ( sum < 0 ) sum = 0 ; maxSum = Math . max ( maxSum , sum ) ; } return maxSum ; }", "nl": "Function to return maximum sum of a sub - array"}
{"code": "static int maxFunction ( int [ ] arr , int n ) { int [ ] b = new int [ MAX ] ; int [ ] c = new int [ MAX ] ;", "nl": "Function to return maximum value of function F"}
{"code": "for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 1 ) { b [ i ] = Math . abs ( arr [ i + 1 ] - arr [ i ] ) ; c [ i ] = - b [ i ] ; } else { c [ i ] = Math . abs ( arr [ i + 1 ] - arr [ i ] ) ; b [ i ] = - c [ i ] ; } }", "nl": "Compute arrays B [ ] and C [ ]"}
{"code": "int ans = kadaneAlgorithm ( b , n - 1 ) ; ans = Math . max ( ans , kadaneAlgorithm ( c , n - 1 ) ) ; return ans ; }", "nl": "Find maximum sum sub - array of both of the arrays and take maximum among them"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 4 , 7 } ; int n = arr . length ; System . out . println ( maxFunction ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static int findThirdDigit ( int n ) {", "nl": "Function to find the element"}
{"code": "if ( n < 3 ) return 0 ;", "nl": "if n < 3"}
{"code": "return ( n & 1 ) > 0 ? 1 : 6 ; }", "nl": "If n is even return 6 If n is odd return 1"}
{"code": "public static void main ( String args [ ] ) { int n = 7 ; System . out . println ( findThirdDigit ( n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static double getProbability ( int a , int b , int c , int d ) {", "nl": "Function to return the probability of A winning"}
{"code": "double p = ( double ) a / ( double ) b ; double q = ( double ) c / ( double ) d ;", "nl": "p and q store the values of fractions a / b and c / d"}
{"code": "double ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; }", "nl": "To store the winning probability of A"}
{"code": "public static void main ( String [ ] args ) { int a = 1 , b = 2 , c = 10 , d = 11 ; System . out . printf ( \" % .5f \" , getProbability ( a , b , c , d ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of above approach"}
{"code": "static boolean isPalindrome ( int n ) {", "nl": "Function to check if n is palindrome"}
{"code": "int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ;", "nl": "Find the appropriate divisor to extract the leading digit"}
{"code": "if ( leading != trailing ) return false ;", "nl": "If first and last digits are not same then return false"}
{"code": "n = ( n % divisor ) / 10 ;", "nl": "Removing the leading and trailing digits from the number"}
{"code": "divisor = divisor / 100 ; } return true ; }", "nl": "Reducing divisor by a factor of 2 as 2 digits are dropped"}
{"code": "static int largestPalindrome ( int [ ] A , int n ) { int currentMax = - 1 ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Function to find the largest palindromic number"}
{"code": "if ( A [ i ] > currentMax && isPalindrome ( A [ i ] ) ) currentMax = A [ i ] ; }", "nl": "If a palindrome larger than the currentMax is found"}
{"code": "return currentMax ; }", "nl": "Return the largest palindromic number from the array"}
{"code": "public static void main ( String [ ] args ) { int [ ] A = { 1 , 232 , 54545 , 999991 } ; int n = A . length ;", "nl": "Driver program"}
{"code": "System . out . println ( largestPalindrome ( A , n ) ) ; } }", "nl": "print required answer"}
{"code": "class OddPosition {", "nl": "Java implementation of the approach"}
{"code": "public static long getFinalElement ( long n ) { long finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }", "nl": "Function to return the final element"}
{"code": "public static void main ( String [ ] args ) { int N = 12 ; System . out . println ( getFinalElement ( N ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find sum of elements in an array having prime frequency"}
{"code": "static void SieveOfEratosthenes ( boolean prime [ ] , int p_size ) {", "nl": "Function to create Sieve to check primes"}
{"code": "prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) {", "nl": "False here indicates that it is not prime"}
{"code": "if ( prime [ p ] ) {", "nl": "If prime [ p ] is not changed , then it is a prime"}
{"code": "for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }", "nl": "Update all multiples of p , set them to non - prime"}
{"code": "static int sumOfElements ( int arr [ ] , int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; SieveOfEratosthenes ( prime , n + 1 ) ; int i , j ;", "nl": "Function to return the sum of elements in an array having prime frequency"}
{"code": "HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; else m . put ( arr [ i ] , 1 ) ; } int sum = 0 ;", "nl": "Map is used to store element frequencies"}
{"code": "for ( Map . Entry < Integer , Integer > entry : m . entrySet ( ) ) { int key = entry . getKey ( ) ; int value = entry . getValue ( ) ;", "nl": "Traverse the map"}
{"code": "if ( prime [ value ] ) { sum += ( key ) ; } } return sum ; }", "nl": "Count the number of elements having prime frequencies"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 5 , 4 , 6 , 5 , 4 , 6 } ; int n = arr . length ; System . out . println ( sumOfElements ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find the sum of all odd length palindromic numbers within the given range"}
{"code": "static boolean isPalindrome ( int num ) { int reverse_num = 0 , remainder , temp ;", "nl": "Function that returns true if the given number is a palindrome"}
{"code": "temp = num ; while ( temp != 0 ) { remainder = temp % 10 ; reverse_num = reverse_num * 10 + remainder ; temp /= 10 ; }", "nl": "Here we are generating a new number ( reverse_num ) * by reversing the digits of original input number"}
{"code": "if ( reverse_num == num ) { return true ; } return false ; }", "nl": "If the original input number ( num ) is equal to * to its reverse ( reverse_num ) then its palindrome * else it is not ."}
{"code": "static boolean isOddLength ( int num ) { int count = 0 ; while ( num > 0 ) { num /= 10 ; count ++ ; } if ( count % 2 != 0 ) { return true ; } return false ; }", "nl": "Function that returns true if the given number is of odd length"}
{"code": "static long sumOfAllPalindrome ( int L , int R ) { long sum = 0 ; if ( L <= R ) for ( int i = L ; i <= R ; i ++ ) {", "nl": "Function to return the sum of all odd length palindromic numbers within the given range"}
{"code": "if ( isPalindrome ( i ) && isOddLength ( i ) ) { sum += i ; } } return sum ; }", "nl": "if number is palindrome and of odd length"}
{"code": "public static void main ( String [ ] args ) { int L = 110 , R = 1130 ; System . out . println ( sumOfAllPalindrome ( L , R ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to calculate the no . of ways to arrange the word having vowels together"}
{"code": "static int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f = f * i ; return f ; }", "nl": "Factorial of a number"}
{"code": "static int waysOfConsonants ( int size1 , int [ ] freq ) { int ans = fact ( size1 ) ; for ( int i = 0 ; i < 26 ; i ++ ) {", "nl": "Calculating ways for arranging consonants"}
{"code": "if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) continue ; else ans = ans / fact ( freq [ i ] ) ; } return ans ; }", "nl": "Ignore vowels"}
{"code": "static int waysOfVowels ( int size2 , int [ ] freq ) { return fact ( size2 ) / ( fact ( freq [ 0 ] ) * fact ( freq [ 4 ] ) * fact ( freq [ 8 ] ) * fact ( freq [ 14 ] ) * fact ( freq [ 20 ] ) ) ; }", "nl": "Calculating ways for arranging vowels"}
{"code": "static int countWays ( String str ) { int [ ] freq = new int [ 200 ] ; for ( int i = 0 ; i < 200 ; i ++ ) freq [ i ] = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) freq [ str . charAt ( i ) - ' a ' ] ++ ;", "nl": "Function to count total no . of ways"}
{"code": "int vowel = 0 , consonant = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) != ' a ' && str . charAt ( i ) != ' e ' && str . charAt ( i ) != ' i ' && str . charAt ( i ) != ' o ' && str . charAt ( i ) != ' u ' ) consonant ++ ; else vowel ++ ; }", "nl": "Count vowels and consonant"}
{"code": "return waysOfConsonants ( consonant + 1 , freq ) * waysOfVowels ( vowel , freq ) ; }", "nl": "Total no . of ways"}
{"code": "public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; System . out . println ( countWays ( str ) ) ; } }", "nl": "Driver code"}
{"code": "public class GFG {", "nl": "Java Program to find alternate sum of Fibonacci numbers"}
{"code": "static double calculateAlternateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ;", "nl": "Computes value of first fibonacci numbers and stores their alternate sum"}
{"code": "double sum = Math . pow ( fibo [ 0 ] , 2 ) + Math . pow ( fibo [ 1 ] , 2 ) ;", "nl": "Initialize result"}
{"code": "for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ;", "nl": "Add remaining terms"}
{"code": "if ( i % 2 == 0 ) sum -= fibo [ i ] ;", "nl": "For even terms"}
{"code": "else sum += fibo [ i ] ; }", "nl": "For odd terms"}
{"code": "return sum ; }", "nl": "Return the alternating sum"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver code"}
{"code": "int n = 8 ;", "nl": "Get n"}
{"code": "System . out . println ( \" Alternating \u2581 Fibonacci \u2581 Sum \u2581 upto \u2581 \" + n + \" \u2581 terms : \u2581 \" + calculateAlternateSum ( n ) ) ; } }", "nl": "Find the alternating sum"}
{"code": "class GFG {", "nl": "Java Program to find Nth term"}
{"code": "static int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; }", "nl": "Function that will return nth term"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int n = 9 ;", "nl": "Get n"}
{"code": "System . out . println ( getValue ( n ) ) ;", "nl": "Get the value"}
{"code": "n = 1025 ;", "nl": "Get n"}
{"code": "System . out . println ( getValue ( n ) ) ; } }", "nl": "Get the value"}
{"code": "import java . io . * ; import java . util . * ; public class GFG {", "nl": "Java implementation of above approach"}
{"code": "static void countDigits ( double val , long [ ] arr ) { while ( ( long ) val > 0 ) { long digit = ( long ) val % 10 ; arr [ ( int ) digit ] ++ ; val = ( long ) val / 10 ; } return ; } static void countFrequency ( int x , int n ) {", "nl": "Function that traverses digits in a number and modifies frequency count array"}
{"code": "long [ ] freq_count = new long [ 10 ] ;", "nl": "Array to keep count of digits"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) {", "nl": "Traversing through x ^ 1 to x ^ n"}
{"code": "double val = Math . pow ( ( double ) x , ( double ) i ) ;", "nl": "For power function , both its parameters are to be in double"}
{"code": "countDigits ( val , freq_count ) ; }", "nl": "calling countDigits function on x ^ i"}
{"code": "for ( int i = 0 ; i <= 9 ; i ++ ) { System . out . print ( freq_count [ i ] + \" \u2581 \" ) ; } }", "nl": "Printing count of digits 0 - 9"}
{"code": "public static void main ( String args [ ] ) { int x = 15 , n = 3 ; countFrequency ( x , n ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find the number of values of b such that a = b + ( a ^ b )"}
{"code": "static int countSolutions ( int a ) { int count = 0 ;", "nl": "function to return the number of solutions"}
{"code": "for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }", "nl": "check for every possible value"}
{"code": "public static void main ( String [ ] args ) { int a = 3 ; System . out . println ( countSolutions ( a ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find the number of values of b such that a = b + ( a ^ b )"}
{"code": "static int countSolutions ( int a ) { int count = Integer . bitCount ( a ) ; count = ( int ) Math . pow ( 2 , count ) ; return count ; }", "nl": "function to return the number of solutions"}
{"code": "public static void main ( String [ ] args ) { int a = 3 ; System . out . println ( countSolutions ( a ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to calculate the sum of area of all possible squares that comes inside the rectangle"}
{"code": "static int calculateAreaSum ( int l , int b ) { int size = 1 ;", "nl": "Function to calculate the sum of area of all possible squares that comes inside the rectangle"}
{"code": "int maxSize = Math . min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) {", "nl": "Square with max size possible"}
{"code": "int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ;", "nl": "calculate total square of a given size"}
{"code": "int area = totalSquares * size * size ;", "nl": "calculate area of squares of a particular size"}
{"code": "totalArea += area ;", "nl": "total area"}
{"code": "size ++ ; } return totalArea ; }", "nl": "increment size"}
{"code": "public static void main ( String [ ] args ) { int l = 4 , b = 3 ; System . out . println ( calculateAreaSum ( l , b ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG { static long boost_hyperfactorial ( long num ) {", "nl": "function to calculate the value of hyperfactorial"}
{"code": "long val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { val = val * ( long ) Math . pow ( i , i ) ; }", "nl": "initialise the val to 1"}
{"code": "return val ; }", "nl": "returns the hyperfactorial of a number"}
{"code": "public static void main ( String args [ ] ) { int num = 5 ; System . out . println ( boost_hyperfactorial ( num ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find the hyperfactorial of a number using boost libraries"}
{"code": "static int boost_hyperfactorial ( int num ) {", "nl": "function to calculate the value of hyperfactorial"}
{"code": "int val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) {", "nl": "initialise the val to 1"}
{"code": "val *= i ; } }", "nl": "1 ^ 1 * 2 ^ 2 * 3 ^ 3. . . ."}
{"code": "return val ; }", "nl": "returns the hyperfactorial of a number"}
{"code": "public static void main ( String [ ] args ) { int num = 5 ; System . out . println ( boost_hyperfactorial ( num ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static int subtractOne ( int x ) { int m = 1 ;", "nl": "Java code to subtract one from a given number"}
{"code": "while ( ! ( ( x & m ) > 0 ) ) { x = x ^ m ; m <<= 1 ; }", "nl": "Flip all the set bits until we find a 1"}
{"code": "x = x ^ m ; return x ; }", "nl": "flip the rightmost 1 bit"}
{"code": "public static void main ( String [ ] args ) { System . out . println ( subtractOne ( 13 ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG { static int rows = 3 ; static int cols = 3 ;", "nl": "Java program to find mean vector of given matrix"}
{"code": "static void meanVector ( int mat [ ] [ ] ) { System . out . print ( \" [ \u2581 \" ) ;", "nl": "Function to find mean vector"}
{"code": "for ( int i = 0 ; i < rows ; i ++ ) {", "nl": "loop to traverse each column"}
{"code": "double mean = 0.00 ;", "nl": "to calculate mean of each row"}
{"code": "int sum = 0 ; for ( int j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum / rows ; System . out . print ( ( int ) mean + \" \u2581 \" ) ; } System . out . print ( \" ] \" ) ; }", "nl": "to store sum of elements of a column"}
{"code": "public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; meanVector ( mat ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; public class GFG {", "nl": "Java code to check if a number is a hoax number or not ."}
{"code": "static List < Integer > primeFactors ( int n ) { List < Integer > res = new ArrayList < Integer > ( ) ; if ( n % 2 == 0 ) { while ( n % 2 == 0 ) n = n / 2 ; res . add ( 2 ) ; }", "nl": "Function to find distinct prime factors of given number n"}
{"code": "for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) {", "nl": "n is odd at this point , since it is no longer divisible by 2. So we can test only for the odd numbers , whether they are factors of n"}
{"code": "if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; res . add ( i ) ; } }", "nl": "Check if i is prime factor"}
{"code": "if ( n > 2 ) res . add ( n ) ; return res ; }", "nl": "This condition is to handle the case when n is a prime number greater than 2"}
{"code": "static boolean isHoax ( int n ) {", "nl": "Function to calculate sum of digits of distinct prime factors of given number n and sum of digits of number n and compare the sums obtained"}
{"code": "List < Integer > pf = primeFactors ( n ) ;", "nl": "Distinct prime factors of n are being stored in vector pf"}
{"code": "if ( pf . get ( 0 ) == n ) return false ;", "nl": "If n is a prime number , it cannot be a hoax number"}
{"code": "int all_pf_sum = 0 ; for ( int i = 0 ; i < pf . size ( ) ; i ++ ) {", "nl": "Finding sum of digits of distinct prime factors of the number n"}
{"code": "int pf_sum ; for ( pf_sum = 0 ; pf . get ( i ) > 0 ; pf_sum += pf . get ( i ) % 10 , pf . set ( i , pf . get ( i ) / 10 ) ) ; all_pf_sum += pf_sum ; }", "nl": "Finding sum of digits in current prime factor pf [ i ] ."}
{"code": "int sum_n ; for ( sum_n = 0 ; n > 0 ; sum_n += n % 10 , n /= 10 ) ;", "nl": "Finding sum of digits of number n"}
{"code": "return sum_n == all_pf_sum ; }", "nl": "Comparing the two calculated sums"}
{"code": "public static void main ( String args [ ] ) { int n = 84 ; if ( isHoax ( n ) ) System . out . print ( \"A Hoax NumberNEW_LINE\"); else System . out . print ( \"Not a Hoax NumberNEW_LINE\"); } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find out Lucas - Lehmer series ."}
{"code": "static void LucasLehmer ( int n ) {", "nl": "Function to find out first n terms ( considering 4 as 0 th term ) of Lucas - Lehmer series ."}
{"code": "long current_val = 4 ;", "nl": "the 0 th term of the series is 4."}
{"code": "ArrayList < Long > series = new ArrayList < > ( ) ;", "nl": "create an array to store the terms ."}
{"code": "series . add ( current_val ) ; for ( int i = 0 ; i < n ; i ++ ) { current_val = current_val * current_val - 2 ; series . add ( current_val ) ; }", "nl": "compute each term and add it to the array ."}
{"code": "for ( int i = 0 ; i <= n ; i ++ ) { System . out . println ( \" Term \u2581 \" + i + \" : \u2581 \" + series . get ( i ) ) ; } }", "nl": "print out the terms one by one ."}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; LucasLehmer ( n ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find modular inverse of all numbers from 1 to n using naive method"}
{"code": "static int modInverse ( int a , int prime ) { a = a % prime ; for ( int x = 1 ; x < prime ; x ++ ) if ( ( a * x ) % prime == 1 ) return x ; return - 1 ; } static void printModIverses ( int n , int prime ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( modInverse ( i , prime ) + \" \u2581 \" ) ; }", "nl": "A naive method to find modular multiplicative inverse of ' a ' under modulo ' prime '"}
{"code": "public static void main ( String args [ ] ) { int n = 10 , prime = 17 ; printModIverses ( n , prime ) ; } }", "nl": "Driver Program"}
{"code": "class GFG {", "nl": "Java to find min operations required to convert into charming number"}
{"code": "static int minOp ( int num ) {", "nl": "function for minimum operation"}
{"code": "int rem ; int count = 0 ;", "nl": "remainder and operations count"}
{"code": "while ( num > 0 ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num /= 10 ; } return count ; }", "nl": "count digits not equal to 3 or 8"}
{"code": "public static void main ( String [ ] args ) { int num = 234198 ; System . out . print ( \" Minimum \u2581 Operations \u2581 = \" + minOp ( num ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find the number with maximum digit sum ."}
{"code": "static int sumOfDigits ( int a ) { int sum = 0 ; while ( a != 0 ) { sum += a % 10 ; a /= 10 ; } return sum ; }", "nl": "function to calculate the sum of digits of a number ."}
{"code": "static int findMax ( int x ) {", "nl": "Returns the maximum number with maximum sum of digits ."}
{"code": "int b = 1 , ans = x ;", "nl": "initializing b as 1 and initial max sum to be of n"}
{"code": "while ( x != 0 ) {", "nl": "iterates from right to left in a digit"}
{"code": "int cur = ( x - 1 ) * b + ( b - 1 ) ;", "nl": "while iterating this is the number from from right to left"}
{"code": "if ( sumOfDigits ( cur ) > sumOfDigits ( ans ) || ( sumOfDigits ( cur ) == sumOfDigits ( ans ) && cur > ans ) ) ans = cur ;", "nl": "calls the function to check if sum of cur is more then of ans"}
{"code": "x /= 10 ; b *= 10 ; } return ans ; }", "nl": "reduces the number to one unit less"}
{"code": "public static void main ( String [ ] args ) { int n = 521 ; System . out . println ( findMax ( n ) ) ; } }", "nl": "driver program"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program to find IQR of a data set"}
{"code": "static int median ( int a [ ] , int l , int r ) { int n = r - l + 1 ; n = ( n + 1 ) / 2 - 1 ; return n + l ; }", "nl": "Function to give index of the median"}
{"code": "static int IQR ( int [ ] a , int n ) { Arrays . sort ( a ) ;", "nl": "Function to calculate IQR"}
{"code": "int mid_index = median ( a , 0 , n ) ;", "nl": "Index of median of entire data"}
{"code": "int Q1 = a [ median ( a , 0 , mid_index ) ] ;", "nl": "Median of first half"}
{"code": "int Q3 = a [ mid_index + median ( a , mid_index + 1 , n ) ] ;", "nl": "Median of second half"}
{"code": "return ( Q3 - Q1 ) ; }", "nl": "IQR calculation"}
{"code": "public static void main ( String [ ] args ) { int [ ] a = { 1 , 19 , 7 , 6 , 5 , 9 , 12 , 27 , 18 , 2 , 15 } ; int n = a . length ; System . out . println ( IQR ( a , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of above approach"}
{"code": "static boolean isPalindrome ( int n ) {", "nl": "Function to check if n is palindrome"}
{"code": "int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ;", "nl": "Find the appropriate divisor to extract the leading digit"}
{"code": "if ( leading != trailing ) return false ;", "nl": "If first and last digits are not same then return false"}
{"code": "n = ( n % divisor ) / 10 ;", "nl": "Removing the leading and trailing digits from the number"}
{"code": "divisor = divisor / 100 ; } return true ; }", "nl": "Reducing divisor by a factor of 2 as 2 digits are dropped"}
{"code": "static int largestPalindrome ( int [ ] A , int n ) {", "nl": "Function to find the largest palindromic number"}
{"code": "Arrays . sort ( A ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) {", "nl": "Sort the array"}
{"code": "if ( isPalindrome ( A [ i ] ) ) return A [ i ] ; }", "nl": "If number is palindrome"}
{"code": "return - 1 ; }", "nl": "If no palindromic number found"}
{"code": "public static void main ( String [ ] args ) { int [ ] A = { 1 , 232 , 54545 , 999991 } ; int n = A . length ;", "nl": "Driver program"}
{"code": "System . out . println ( largestPalindrome ( A , n ) ) ; } }", "nl": "print required answer"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find the sum of all the integers below N which are multiples of either A or B"}
{"code": "static int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ )", "nl": "Function to return the sum of all the integers below N which are multiples of either A or B"}
{"code": "if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; }", "nl": "If i is a multiple of a or b"}
{"code": "public static void main ( String [ ] args ) { int n = 10 , a = 3 , b = 5 ; System . out . println ( findSum ( n , a , b ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int subtractOne ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; } public static void main ( String [ ] args ) { System . out . printf ( \" % d \" , subtractOne ( 13 ) ) ; } }", "nl": "Driver code"}
{"code": "class PellNumber {", "nl": "Pell Number Series using Recursion in JAVA"}
{"code": "public static int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }", "nl": "calculate n - th Pell number"}
{"code": "public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( pell ( n ) ) ; } }", "nl": "driver function"}
{"code": "import java . util . Vector ; class GFG {", "nl": "Java program to find LCM of array without using GCD ."}
{"code": "static long LCM ( int arr [ ] , int n ) {", "nl": "Returns LCM of arr [ 0. . n - 1 ]"}
{"code": "int max_num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_num < arr [ i ] ) { max_num = arr [ i ] ; } }", "nl": "Find the maximum value in arr [ ]"}
{"code": "long res = 1 ;", "nl": "Initialize result"}
{"code": "while ( x <= max_num ) {", "nl": "Find all factors that are present in two or more array elements . int x = 2 ; Current factor ."}
{"code": "Vector < Integer > indexes = new Vector < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] % x == 0 ) { indexes . add ( indexes . size ( ) , j ) ; } }", "nl": "To store indexes of all array elements that are divisible by x ."}
{"code": "if ( indexes . size ( ) >= 2 ) {", "nl": "If there are 2 or more array elements that are divisible by x ."}
{"code": "for ( int j = 0 ; j < indexes . size ( ) ; j ++ ) { arr [ indexes . get ( j ) ] = arr [ indexes . get ( j ) ] / x ; } res = res * x ; } else { x ++ ; } }", "nl": "Reduce all array elements divisible by x ."}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { res = res * arr [ i ] ; } return res ; }", "nl": "Then multiply all reduced array elements"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 } ; int n = arr . length ; System . out . println ( LCM ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . lang . Math ; public class Main {", "nl": "Java program for the above approach"}
{"code": "static int politness ( int n ) { int count = 0 ;", "nl": "Function to find politeness"}
{"code": "for ( int i = 2 ; i <= Math . sqrt ( 2 * n ) ; i ++ ) { int a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a /= i ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a /= 2 ; if ( a > 0 ) { count ++ ; } } return count ; }", "nl": "sqrt ( 2 * n ) as max length will be when the sum starts from 1 which follows the equation n ^ 2 - n - ( 2 * sum ) = 0"}
{"code": "public static void main ( String [ ] args ) { int n = 90 ; System . out . println ( \" Politness \u2581 of \u2581 \" + n + \" \u2581 = \u2581 \" + politness ( n ) ) ; n = 15 ; System . out . println ( \" Politness \u2581 of \u2581 \" + n + \" \u2581 = \u2581 \" + politness ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static int MAX = 10000 ;", "nl": "Java program to implement Goldbach 's conjecture"}
{"code": "static ArrayList < Integer > primes = new ArrayList < Integer > ( ) ;", "nl": "Array to store all prime less than and equal to 10 ^ 6"}
{"code": "static void sieveSundaram ( ) {", "nl": "Utility function for Sieve of Sundaram"}
{"code": "boolean [ ] marked = new boolean [ MAX / 2 + 100 ] ;", "nl": "In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x . Since we want primes smaller than MAX , we reduce MAX to half This array is used to separate numbers of the form i + j + 2 * i * j from others where 1 <= i <= j"}
{"code": "for ( int i = 1 ; i <= ( Math . sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ;", "nl": "Main logic of Sundaram . Mark all numbers which do not generate prime number by doing 2 * i + 1"}
{"code": "primes . add ( 2 ) ;", "nl": "Since 2 is a prime number"}
{"code": "for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . add ( 2 * i + 1 ) ; }", "nl": "Print other primes . Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false ."}
{"code": "static void findPrimes ( int n ) {", "nl": "Function to perform Goldbach 's conjecture"}
{"code": "if ( n <= 2 n % 2 != 0 ) { System . out . println ( \" Invalid \u2581 Input \u2581 \" ) ; return ; }", "nl": "Return if number is not even or less than 3"}
{"code": "for ( int i = 0 ; primes . get ( i ) <= n / 2 ; i ++ ) {", "nl": "Check only upto half of number"}
{"code": "int diff = n - primes . get ( i ) ;", "nl": "find difference by subtracting current prime from n"}
{"code": "if ( primes . contains ( diff ) ) {", "nl": "Search if the difference is also a prime number"}
{"code": "System . out . println ( primes . get ( i ) + \" \u2581 + \u2581 \" + diff + \" \u2581 = \u2581 \" + n ) ; return ; } } }", "nl": "Express as a sum of primes"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "sieveSundaram ( ) ;", "nl": "Finding all prime numbers before limit"}
{"code": "findPrimes ( 4 ) ; findPrimes ( 38 ) ; findPrimes ( 100 ) ; } }", "nl": "Express number as a sum of two primes"}
{"code": "import java . io . * ; import java . math . * ; class GFG {", "nl": "JAVA Program to print kth prime factor"}
{"code": "static int kPrimeFactor ( int n , int k ) {", "nl": "A function to generate prime factors of a given number n and return k - th prime factor"}
{"code": "while ( n % 2 == 0 ) { k -- ; n = n / 2 ; if ( k == 0 ) return 2 ; }", "nl": "Find the number of 2 's that  divide k"}
{"code": "for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) {", "nl": "n must be odd at this point . So we can skip one element ( Note i = i + 2 )"}
{"code": "while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n / i ; } }", "nl": "While i divides n , store i and divide n"}
{"code": "if ( n > 2 && k == 1 ) return n ; return - 1 ; }", "nl": "This condition is to handle the case where n is a prime number greater than 2"}
{"code": "public static void main ( String args [ ] ) { int n = 12 , k = 3 ; System . out . println ( kPrimeFactor ( n , k ) ) ; n = 14 ; k = 3 ; System . out . println ( kPrimeFactor ( n , k ) ) ; } }", "nl": "Driver Program"}
{"code": "class GFG { static int MAX = 10001 ;", "nl": "Java program to find k - th prime factor using Sieve Of Eratosthenes . This program is efficient when we have a range of numbers ."}
{"code": "static void sieveOfEratosthenes ( int [ ] s ) {", "nl": "Using SieveOfEratosthenes to find smallest prime factor of all the numbers . For example , if MAX is 10 , s [ 2 ] = s [ 4 ] = s [ 6 ] = s [ 10 ] = 2 s [ 3 ] = s [ 9 ] = 3 s [ 5 ] = 5 s [ 7 ] = 7"}
{"code": "boolean [ ] prime = new boolean [ MAX + 1 ] ;", "nl": "Create a boolean array \" prime [ 0 . . MAX ] \" and initialize all entries in it as false ."}
{"code": "for ( int i = 2 ; i <= MAX ; i += 2 ) s [ i ] = 2 ;", "nl": "Initializing smallest factor equal to 2 for all the even numbers"}
{"code": "for ( int i = 3 ; i <= MAX ; i += 2 ) { if ( prime [ i ] == false ) {", "nl": "For odd numbers less then equal to n"}
{"code": "s [ i ] = i ;", "nl": "s ( i ) for a prime is the number itself"}
{"code": "for ( int j = i ; j * i <= MAX ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ;", "nl": "For all multiples of current prime number"}
{"code": "s [ i * j ] = i ; } } } } }", "nl": "i is the smallest prime factor for number \" i * j \" ."}
{"code": "static int kPrimeFactor ( int n , int k , int [ ] s ) {", "nl": "Function to generate prime factors and return its k - th prime factor . s [ i ] stores least prime factor of i ."}
{"code": "while ( n > 1 ) { if ( k == 1 ) return s [ n ] ;", "nl": "Keep dividing n by least prime factor while either n is not 1 or count of prime factors is not k ."}
{"code": "k -- ;", "nl": "To keep track of count of prime factors"}
{"code": "n /= s [ n ] ; } return - 1 ; }", "nl": "Divide n to find next prime factor"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int [ ] s = new int [ MAX + 1 ] ; sieveOfEratosthenes ( s ) ; int n = 12 , k = 3 ; System . out . println ( kPrimeFactor ( n , k , s ) ) ; n = 14 ; k = 3 ; System . out . println ( kPrimeFactor ( n , k , s ) ) ; } }", "nl": "s [ i ] is going to store prime factor of i ."}
{"code": "import java . util . HashMap ; class GFG {", "nl": "Java program to find sum of divisors of all the divisors of a natural number ."}
{"code": "public static int sumDivisorsOfDivisors ( int n ) {", "nl": "Returns sum of divisors of all the divisors of n"}
{"code": "HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int j = 2 ; j <= Math . sqrt ( n ) ; j ++ ) { int count = 0 ; while ( n % j == 0 ) { n /= j ; count ++ ; } if ( count != 0 ) mp . put ( j , count ) ; }", "nl": "Calculating powers of prime factors and storing them in a map mp [ ] ."}
{"code": "if ( n != 1 ) mp . put ( n , 1 ) ;", "nl": "If n is a prime number"}
{"code": "int ans = 1 ; for ( HashMap . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { int pw = 1 ; int sum = 0 ; for ( int i = entry . getValue ( ) + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw = entry . getKey ( ) ; } ans *= sum ; } return ans ; }", "nl": "For each prime factor , calculating ( p ^ ( a + 1 ) - 1 ) / ( p - 1 ) and adding it to answer ."}
{"code": "public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( sumDivisorsOfDivisors ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int prime ( int n ) {", "nl": "Function to return nearest prime number"}
{"code": "if ( n % 2 != 0 ) n -= 2 ; else n -- ; int i , j ; for ( i = n ; i >= 2 ; i -= 2 ) { if ( i % 2 == 0 ) continue ; for ( j = 3 ; j <= Math . sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) break ; } if ( j > Math . sqrt ( i ) ) return i ; }", "nl": "All prime numbers are odd except two"}
{"code": "return 2 ; }", "nl": "It will only be executed when n is 3"}
{"code": "public static void main ( String [ ] args ) { int n = 17 ; System . out . print ( prime ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find repeating sequence in a fraction"}
{"code": "static String fractionToDecimal ( int numr , int denr ) {", "nl": "This function returns repeating sequence of a fraction . If repeating sequence doesn 't  exits, then returns empty String"}
{"code": "String res = \" \" ;", "nl": "Initialize result"}
{"code": "HashMap < Integer , Integer > mp = new HashMap < > ( ) ; mp . clear ( ) ;", "nl": "Create a map to store already seen remainders . Remainder is used as key and its position in result is stored as value . Note that we need position for cases like 1 / 6. In this case , the recurring sequence doesn 't  start from first remainder."}
{"code": "int rem = numr % denr ;", "nl": "Find first remainder"}
{"code": "while ( ( rem != 0 ) && ( ! mp . containsKey ( rem ) ) ) {", "nl": "Keep finding remainder until either remainder becomes 0 or repeats"}
{"code": "mp . put ( rem , res . length ( ) ) ;", "nl": "Store this remainder"}
{"code": "rem = rem * 10 ;", "nl": "Multiply remainder with 10"}
{"code": "int res_part = rem / denr ; res += String . valueOf ( res_part ) ;", "nl": "Append rem / denr to result"}
{"code": "rem = rem % denr ; } if ( rem == 0 ) return \" \" ; else if ( mp . containsKey ( rem ) ) return res . substring ( mp . get ( rem ) ) ; return \" \" ; }", "nl": "Update remainder"}
{"code": "public static void main ( String [ ] args ) { int numr = 50 , denr = 22 ; String res = fractionToDecimal ( numr , denr ) ; if ( res == \" \" ) System . out . print ( \" No \u2581 recurring \u2581 sequence \" ) ; else System . out . print ( \" Recurring \u2581 sequence \u2581 is \u2581 \" + res ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to count numbers from 1 to n with 0 as a digit"}
{"code": "static int has0 ( int x ) {", "nl": "Returns 1 if x has 0 , else 0"}
{"code": "while ( x != 0 ) {", "nl": "Traverse through all digits of x to check if it has 0."}
{"code": "if ( x % 10 == 0 ) return 1 ; x /= 10 ; } return 0 ; }", "nl": "If current digit is 0 , return true"}
{"code": "static int getCount ( int n ) {", "nl": "Returns count of numbers from 1 to n with 0 as digit"}
{"code": "int count = 0 ;", "nl": "Initialize count of numbers having 0 as digit"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) count += has0 ( i ) ; return count ; }", "nl": "Traverse through all numbers and for every number check if it has 0."}
{"code": "public static void main ( String args [ ] ) { int n = 107 ; System . out . println ( \" Count \u2581 of \u2581 numbers \u2581 from \u2581 1\" + \" \u2581 to \u2581 \" + n + \" \u2581 is \u2581 \" + getCount ( n ) ) ; } }", "nl": "Driver program"}
{"code": "class GFG {", "nl": "A Simple Java program to check if square root of a number under modulo p exists or not"}
{"code": "static boolean squareRootExists ( int n , int p ) { n = n % p ;", "nl": "Returns true if square root of n under modulo p exists"}
{"code": "for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; }", "nl": "One by one check all numbers from 2 to p - 1"}
{"code": "public static void main ( String [ ] args ) { int p = 7 ; int n = 2 ; if ( squareRootExists ( n , p ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }", "nl": "Driver program to test"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find largest x such that p * x divides n !"}
{"code": "static int Largestpower ( int n , int p ) {", "nl": "Function that returns largest power of p that divides n !"}
{"code": "int ans = 0 ;", "nl": "Initialize result"}
{"code": "while ( n > 0 ) { n /= p ; ans += n ; } return ans ; }", "nl": "Calculate x = n / p + n / ( p ^ 2 ) + n / ( p ^ 3 ) + ... ."}
{"code": "public static void main ( String [ ] args ) { int n = 10 ; int p = 3 ; System . out . println ( \" \u2581 The \u2581 largest \u2581 power \u2581 of \u2581 \" + p + \" \u2581 that \u2581 divides \u2581 \" + n + \" ! \u2581 is \u2581 \" + Largestpower ( n , p ) ) ; } }", "nl": "Driver program"}
{"code": "class Factorial { int factorial ( int n ) {", "nl": "Java program to find factorial of given number"}
{"code": "return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }", "nl": "single line to find factorial"}
{"code": "public static void main ( String args [ ] ) { Factorial obj = new Factorial ( ) ; int num = 5 ; System . out . println ( \" Factorial \u2581 of \u2581 \" + num + \" \u2581 is \u2581 \" + obj . factorial ( num ) ) ; } }", "nl": "Driver Code"}
{"code": "static boolean getBit ( int num , int i ) {", "nl": "Function to get the bit at the ith position"}
{"code": "return ( ( num & ( 1 << i ) ) != 0 ) ; }", "nl": "Return true if the bit is set . Otherwise return false"}
{"code": "static int clearBit ( int num , int i ) {", "nl": "Function to clear the ith bit of the given number N"}
{"code": "int mask = ~ ( 1 << i ) ;", "nl": "Create the mask for the ith bit unset"}
{"code": "return num & mask ; }", "nl": "Return the update value"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int [ ] arr1 = { 1 , 2 , 3 } ;", "nl": "Given arr1 [ ]"}
{"code": "int [ ] arr2 = { 1 , 2 , 3 } ;", "nl": "Given arr2 [ ]"}
{"code": "int N = arr1 . length ;", "nl": "Size of arr1 [ ]"}
{"code": "int M = arr2 . length ;", "nl": "Size of arr2 [ ]"}
{"code": "Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) ; }", "nl": "Function Call"}
{"code": "static void Bitwise_AND_sum_i ( int arr1 [ ] , int arr2 [ ] , int M , int N ) {", "nl": "Function to compute the AND sum for each element of an array"}
{"code": "int [ ] frequency = new int [ 32 ] ;", "nl": "Declaring an array of size 32 for storing the count of each bit"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array arr2 [ ] and store the count of a bit in frequency array"}
{"code": "int bit_position = 0 ; int num = arr1 [ i ] ;", "nl": "Current bit position"}
{"code": "while ( num != 0 ) {", "nl": "While num is greater than 0"}
{"code": "if ( ( num & 1 ) != 0 ) {", "nl": "Checks if ith bit is set or not"}
{"code": "frequency [ bit_position ] += 1 ; }", "nl": "Increment the count of bit by one"}
{"code": "bit_position += 1 ;", "nl": "Increment the bit position by one"}
{"code": "num >>= 1 ; } }", "nl": "Right shift the num by one"}
{"code": "for ( int i = 0 ; i < M ; i ++ ) { int num = arr2 [ i ] ;", "nl": "Traverse in the arr2 [ ]"}
{"code": "int value_at_that_bit = 1 ;", "nl": "Store the ith bit value"}
{"code": "int bitwise_AND_sum = 0 ;", "nl": "Total required sum"}
{"code": "for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) {", "nl": "Traverse in the range [ 0 , 31 ]"}
{"code": "if ( ( num & 1 ) != 0 ) {", "nl": "Checks if current bit is set"}
{"code": "bitwise_AND_sum += frequency [ bit_position ] * value_at_that_bit ; }", "nl": "Increment the bitwise sum by frequency [ bit_position ] * value_at_that_bit ;"}
{"code": "num >>= 1 ;", "nl": "Right shift num by one"}
{"code": "value_at_that_bit <<= 1 ; }", "nl": "Left shift vale_at_that_bit by one"}
{"code": "System . out . print ( bitwise_AND_sum + \" \u2581 \" ) ; } } }", "nl": "Print the sum obtained for ith number in arr1 [ ]"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to unset the rightmost set bit"}
{"code": "static void FlipBits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) {", "nl": "Unsets the rightmost set bit of n and returns the result"}
{"code": "if ( ( n >> bit ) % 2 > 0 ) {", "nl": "Checking whether bit position is set or not"}
{"code": "n = n ^ ( 1 << bit ) ; break ; } } System . out . print ( \" The \u2581 number \u2581 after \u2581 unsetting \u2581 the \" ) ; System . out . print ( \" \u2581 rightmost \u2581 set \u2581 bit \u2581 \" + n ) ; }", "nl": "If bit position is found set , we flip this bit by xoring given number and number with bit position set"}
{"code": "public static void main ( String [ ] args ) { int N = 12 ; FlipBits ( N ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int bitwiseAndOdd ( int n ) {", "nl": "Function to return the bitwise AND of all the odd integers from the range [ 1 , n ]"}
{"code": "int result = 1 ;", "nl": "Initialize result to 1"}
{"code": "for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; }", "nl": "Starting from 3 , bitwise AND all the odd integers less than or equal to n"}
{"code": "public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( bitwiseAndOdd ( n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int bitwiseAndOdd ( int n ) { return 1 ; }", "nl": "Function to return the bitwise AND of all the odd integers from the range [ 1 , n ]"}
{"code": "public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( bitwiseAndOdd ( n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation to reverse bits of a number"}
{"code": "public static int reverseBits ( int n ) { int rev = 0 ;", "nl": "function to reverse bits of a number"}
{"code": "while ( n > 0 ) {", "nl": "traversing bits of ' n ' from the right"}
{"code": "rev <<= 1 ;", "nl": "bitwise left shift ' rev ' by 1"}
{"code": "if ( ( int ) ( n & 1 ) == 1 ) rev ^= 1 ;", "nl": "if current bit is '1'"}
{"code": "n >>= 1 ; }", "nl": "bitwise right shift ' n ' by 1"}
{"code": "return rev ; }", "nl": "required number"}
{"code": "public static void main ( String [ ] args ) { int n = 11 ; System . out . println ( reverseBits ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java Program to count number of ways to split array into two groups such that each group has equal XOR value"}
{"code": "static int countgroup ( int a [ ] , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ;", "nl": "Return the count number of ways to split array into two groups such that each group has equal XOR value ."}
{"code": "if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; }", "nl": "We can split only if XOR is 0. Since XOR of all is 0 , we can consider all subsets as one group ."}
{"code": "public static void main ( String args [ ] ) { int a [ ] = { 1 , 2 , 3 } ; int n = a . length ; System . out . println ( countgroup ( a , n ) ) ; } }", "nl": "Driver program"}
{"code": "class GFG {", "nl": "Java program to extract k bits from a given position ."}
{"code": "static int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; }", "nl": "Function to extract k bits from p position and returns the extracted value as integer"}
{"code": "public static void main ( String [ ] args ) { int number = 171 , k = 5 , p = 2 ; System . out . println ( \" The \u2581 extracted \u2581 number \u2581 is \u2581 \" + bitExtracted ( number , k , p ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int findMax ( int num ) { byte size_of_int = 4 ; int num_copy = num ;", "nl": "Java program to find maximum number by swapping extreme bits ."}
{"code": "int j = size_of_int * 8 - 1 ; int i = 0 ; while ( i < j ) {", "nl": "Traverse bits from both extremes"}
{"code": "int m = ( num_copy >> i ) & 1 ; int n = ( num_copy >> j ) & 1 ;", "nl": "Obtaining i - th and j - th bits"}
{"code": "if ( m > n ) { int x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; }", "nl": "Swapping the bits if lesser significant is greater than higher significant bit and accordingly modifying the number"}
{"code": "static public void main ( String [ ] args ) { int num = 4 ; System . out . println ( findMax ( num ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation to efficiently check whether n is a multiple of 4 or not"}
{"code": "static boolean isAMultipleOf4 ( int n ) {", "nl": "method to check whether ' n ' is a multiple of 4 or not"}
{"code": "if ( ( n & 3 ) == 0 ) return true ;", "nl": "if true , then ' n ' is a multiple of 4"}
{"code": "return false ; }", "nl": "else ' n ' is not a multiple of 4"}
{"code": "public static void main ( String [ ] args ) { int n = 16 ; System . out . println ( isAMultipleOf4 ( n ) ? \" Yes \" : \" No \" ) ; } }", "nl": "Driver method"}
{"code": "import java . io . * ; class GFG { public static int square ( int n ) {", "nl": "Java Simple solution to calculate square without using * and pow ( )"}
{"code": "if ( n < 0 ) n = - n ;", "nl": "handle negative input"}
{"code": "int res = n ;", "nl": "Initialize result"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; }", "nl": "Add n to res n - 1 times"}
{"code": "public static void main ( String [ ] args ) { for ( int n = 1 ; n <= 5 ; n ++ ) System . out . println ( \" n \u2581 = \u2581 \" + n + \" , \u2581 n ^ 2 \u2581 = \u2581 \" + square ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG { static int PointInKSquares ( int n , int a [ ] , int k ) { Arrays . sort ( a ) ; return a [ n - k ] ; }", "nl": "Java implementation of the approach"}
{"code": "public static void main ( String [ ] args ) { int k = 2 ; int [ ] a = { 1 , 2 , 3 , 4 } ; int n = a . length ; int x = PointInKSquares ( n , a , k ) ; System . out . println ( \" ( \" + x + \" , \u2581 \" + x + \" ) \" ) ; } }", "nl": "Driver Program to test above function"}
{"code": "class GFG {", "nl": "Java program to calculate the number of n digit stepping numbers ."}
{"code": "static long answer ( int n ) {", "nl": "function that calculates the answer"}
{"code": "int [ ] dp = new int [ 10 ] ;", "nl": "dp [ j ] stores count of i digit stepping numbers ending with digit j ."}
{"code": "int [ ] prev = new int [ 10 ] ;", "nl": "To store result of length i - 1 before updating dp [ j ] for length i ."}
{"code": "if ( n == 1 ) return 10 ;", "nl": "if n is 1 then answer will be 10."}
{"code": "for ( int j = 0 ; j <= 9 ; j ++ ) dp [ j ] = 1 ;", "nl": "Initialize values for count of digits equal to 1."}
{"code": "for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { prev [ j ] = dp [ j ] ; } for ( int j = 0 ; j <= 9 ; j ++ ) {", "nl": "Compute values for count of digits more than 1."}
{"code": "if ( j == 0 ) dp [ j ] = prev [ j + 1 ] ;", "nl": "If ending digit is 0"}
{"code": "else if ( j == 9 ) dp [ j ] = prev [ j - 1 ] ;", "nl": "If ending digit is 9"}
{"code": "else dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] ; } }", "nl": "For other digits ."}
{"code": "long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ j ] ; return sum ; }", "nl": "stores the final answer"}
{"code": "public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( answer ( n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG1 { static int MAX = 100000 ;", "nl": "Java implementation of the approach"}
{"code": "static long catalan [ ] = new long [ MAX ] ;", "nl": "To store first N Catalan numbers"}
{"code": "static void catalanDP ( long n ) {", "nl": "Function to find first n Catalan numbers"}
{"code": "catalan [ 0 ] = catalan [ 1 ] = 1 ;", "nl": "Initialize first two values in table"}
{"code": "for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) { catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } } }", "nl": "Filong entries in catalan [ ] using recursive formula"}
{"code": "static int CatalanSequence ( int arr [ ] , int n ) {", "nl": "Function to return the minimum changes required"}
{"code": "catalanDP ( n ) ; HashSet < Integer > s = new HashSet < Integer > ( ) ;", "nl": "Find first n Catalan Numbers"}
{"code": "int a = 1 , b = 1 ; int c ;", "nl": "a and b are first two Catalan Sequence numbers"}
{"code": "s . add ( a ) ; if ( n >= 2 ) { s . add ( b ) ; } for ( int i = 2 ; i < n ; i ++ ) { s . add ( ( int ) catalan [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Insert first n catalan elements to set"}
{"code": "if ( s . contains ( arr [ i ] ) ) { s . remove ( arr [ i ] ) ; } }", "nl": "If catalan element is present in the array then remove it from set"}
{"code": "return s . size ( ) ; }", "nl": "Return the remaining number of elements in the set"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 5 , 41 } ; int n = arr . length ; System . out . print ( CatalanSequence ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation to find the sum of all the composite numbers from odd indices of the given array"}
{"code": "static int composite ( int n ) { int flag = 0 ; int c = 0 ;", "nl": "Function to check for composite numbers"}
{"code": "for ( int j = 1 ; j <= n ; j ++ ) { if ( n % j == 0 ) { c += 1 ; } }", "nl": "Check if the factors are greater than 2"}
{"code": "if ( c >= 3 ) flag = 1 ; return flag ; }", "nl": "Check if the number is composite or not"}
{"code": "static void odd_indices ( int arr [ ] , int n ) { int sum = 0 ;", "nl": "Function to print the sum of all composite numbers in the array"}
{"code": "for ( int k = 0 ; k < n ; k += 2 ) { int check = composite ( arr [ k ] ) ;", "nl": "Iterate for odd indices in the array"}
{"code": "if ( check == 1 ) sum += arr [ k ] ; }", "nl": "Check if the number is composite then add it to sum"}
{"code": "System . out . print ( sum + \"NEW_LINE\"); }", "nl": "return the sum"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 13 , 5 , 8 , 16 , 25 } ; int n = arr . length ; odd_indices ( arr , n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "JAVA Code for Queries on count of points lie inside a circle"}
{"code": "public static void preprocess ( int p [ ] , int x [ ] , int y [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) p [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Arrays . sort ( p ) ; }", "nl": "Computing the x ^ 2 + y ^ 2 for each given points and sorting them ."}
{"code": "public static int query ( int p [ ] , int n , int rad ) { int start = 0 , end = n - 1 ; while ( ( end - start ) > 1 ) { int mid = ( start + end ) / 2 ; double tp = Math . sqrt ( p [ mid ] ) ; if ( tp > ( rad * 1.0 ) ) end = mid - 1 ; else start = mid ; } double tp1 = Math . sqrt ( p [ start ] ) ; double tp2 = Math . sqrt ( p [ end ] ) ; if ( tp1 > ( rad * 1.0 ) ) return 0 ; else if ( tp2 <= ( rad * 1.0 ) ) return end + 1 ; else return start + 1 ; }", "nl": "Return count of points lie inside or on circumference of circle using binary search on p [ 0. . n - 1 ]"}
{"code": "public static void main ( String [ ] args ) { int x [ ] = { 1 , 2 , 3 , - 1 , 4 } ; int y [ ] = { 1 , 2 , 3 , - 1 , 4 } ; int n = x . length ;", "nl": "Driver program to test above function"}
{"code": "int p [ ] = new int [ n ] ; preprocess ( p , x , y , n ) ;", "nl": "Compute distances of all points and keep the distances sorted so that query can work in O ( logn ) using Binary Search ."}
{"code": "System . out . println ( query ( p , n , 3 ) ) ;", "nl": "Print number of points in a circle of radius 3."}
{"code": "System . out . println ( query ( p , n , 32 ) ) ; } }", "nl": "Print number of points in a circle of radius 32."}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to Count of numbers of length N having prime numbers at odd indices and odd numbers at even indices"}
{"code": "static int find_Numb_ways ( int n ) {", "nl": "function to find total number of ways"}
{"code": "int odd_indices = n / 2 ;", "nl": "No of odd indices in n - digit number"}
{"code": "int even_indices = ( n / 2 ) + ( n % 2 ) ;", "nl": "No of even indices in n - digit number"}
{"code": "int arr_odd = ( int ) Math . pow ( 4 , odd_indices ) ;", "nl": "No of ways of arranging prime number digits in odd indices"}
{"code": "int arr_even = ( int ) Math . pow ( 5 , even_indices ) ;", "nl": "No of ways of arranging odd number digits in even indices"}
{"code": "return arr_odd * arr_even ; }", "nl": "returning the total number of ways"}
{"code": "public static void main ( String [ ] args ) { int n = 4 ; System . out . print ( find_Numb_ways ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static boolean isSpiralSorted ( int [ ] arr , int n ) {", "nl": "Function to check if the array is spirally sorted or not"}
{"code": "int start = 0 ;", "nl": "Stores start index of the array"}
{"code": "int end = n - 1 ; while ( start < end ) {", "nl": "Stores end index of an array"}
{"code": "if ( arr [ start ] > arr [ end ] ) { return false ; }", "nl": "If arr [ start ] greater than arr [ end ]"}
{"code": "start ++ ;", "nl": "Update start"}
{"code": "if ( arr [ end ] > arr [ start ] ) { return false ; }", "nl": "If arr [ end ] greater than arr [ start ]"}
{"code": "end -- ; } return true ; }", "nl": "Update end"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 1 , 10 , 14 , 20 , 18 , 12 , 5 } ; int N = arr . length ;", "nl": "Driver code"}
{"code": "if ( isSpiralSorted ( arr , N ) != false ) System . out . print ( \" YES \" ) ; else System . out . print ( \" NO \" ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void findWordsSameRow ( List < String > arr ) {", "nl": "Function to print all strings that can be typed using keys of a single row in a QWERTY Keyboard"}
{"code": "Map < Character , Integer > mp = new HashMap < Character , Integer > ( ) ; mp . put ( ' q ' , 1 ) ; mp . put ( ' w ' , 1 ) ; mp . put ( ' e ' , 1 ) ; mp . put ( ' r ' , 1 ) ; mp . put ( ' t ' , 1 ) ; mp . put ( ' y ' , 1 ) ; mp . put ( ' u ' , 1 ) ; mp . put ( ' i ' , 1 ) ; mp . put ( ' o ' , 1 ) ; mp . put ( ' p ' , 1 ) ; mp . put ( ' a ' , 2 ) ; mp . put ( ' s ' , 2 ) ; mp . put ( ' d ' , 2 ) ; mp . put ( ' f ' , 2 ) ; mp . put ( ' g ' , 2 ) ; mp . put ( ' h ' , 2 ) ; mp . put ( ' j ' , 2 ) ; mp . put ( ' k ' , 2 ) ; mp . put ( ' l ' , 2 ) ; mp . put ( ' z ' , 3 ) ; mp . put ( ' x ' , 3 ) ; mp . put ( ' c ' , 3 ) ; mp . put ( ' v ' , 3 ) ; mp . put ( ' b ' , 3 ) ; mp . put ( ' n ' , 3 ) ; mp . put ( ' m ' , 3 ) ;", "nl": "Stores row number of all possible character of the strings"}
{"code": "for ( String word : arr ) {", "nl": "Traverse the array"}
{"code": "if ( word . length ( ) != 0 ) {", "nl": "If current string is not an empty string"}
{"code": "boolean flag = true ;", "nl": "Sets true / false if a string can be typed using keys of a single row or not"}
{"code": "int rowNum = mp . get ( Character . toLowerCase ( word . charAt ( 0 ) ) ) ;", "nl": "Stores row number of the first character of current string"}
{"code": "int M = word . length ( ) ;", "nl": "Stores length of word"}
{"code": "for ( int i = 1 ; i < M ; i ++ ) {", "nl": "Traverse current string"}
{"code": "if ( mp . get ( Character . toLowerCase ( word . charAt ( i ) ) ) != rowNum ) {", "nl": "If current character can 't be  typed using keys of rowNum only"}
{"code": "flag = false ; break ; } }", "nl": "Update flag"}
{"code": "if ( flag ) {", "nl": "If current string can be typed using keys from rowNum only"}
{"code": "System . out . print ( word + \" \u2581 \" ) ; } } } }", "nl": "Print the string"}
{"code": "public static void main ( String [ ] args ) { List < String > words = Arrays . asList ( \" Yeti \" , \" Had \" , \" GFG \" , \" comment \" ) ; findWordsSameRow ( words ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program of the above approach"}
{"code": "static int countSubsequece ( int a [ ] , int n ) { int i , j , k , l ;", "nl": "Function to find the count of the subsequence of given type"}
{"code": "int answer = 0 ;", "nl": "Stores the count of quadruples"}
{"code": "for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) {", "nl": "Generate all possible combinations of quadruples"}
{"code": "if ( a [ j ] == a [ l ] &&", "nl": "Check if 1 st element is equal to 3 rd element"}
{"code": "a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; }", "nl": "Check if 2 nd element is equal to 4 th element"}
{"code": "public static void main ( String [ ] args ) { int [ ] a = { 1 , 2 , 3 , 2 , 1 , 3 , 2 } ; System . out . print ( countSubsequece ( a , 7 ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static char minDistChar ( char [ ] s ) { int n = s . length ;", "nl": "Function to find the character repeats with minimum distance"}
{"code": "int [ ] first = new int [ 26 ] ; int [ ] last = new int [ 26 ] ;", "nl": "Stores the first and last index"}
{"code": "for ( int i = 0 ; i < 26 ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; }", "nl": "Initialize with - 1"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Get the values of last and first occurence"}
{"code": "if ( first [ s [ i ] - ' a ' ] == - 1 ) { first [ s [ i ] - ' a ' ] = i ; }", "nl": "Update the first index"}
{"code": "last [ s [ i ] - ' a ' ] = i ; }", "nl": "Update the last index"}
{"code": "int min = Integer . MAX_VALUE ; char ans = '1' ;", "nl": "Initialize min"}
{"code": "for ( int i = 0 ; i < 26 ; i ++ ) {", "nl": "Get the minimum"}
{"code": "if ( last [ i ] == first [ i ] ) continue ;", "nl": "Values must not be same"}
{"code": "if ( min > last [ i ] - first [ i ] ) { min = last [ i ] - first [ i ] ; ans = ( char ) ( i + ' a ' ) ; } }", "nl": "Update the minimum distance"}
{"code": "return ans ; }", "nl": "return ans"}
{"code": "public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ;", "nl": "Driver Code"}
{"code": "System . out . print ( minDistChar ( str . toCharArray ( ) ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG { static int n = 3 ; static class Pair { int first , second ; Pair ( int a , int b ) { first = a ; second = b ; } }", "nl": "Java implementation of the approach"}
{"code": "static int minSteps ( int arr [ ] [ ] ) {", "nl": "Function to return the minimum steps required to reach the end of the matrix"}
{"code": "boolean v [ ] [ ] = new boolean [ n ] [ n ] ;", "nl": "Array to determine whether a cell has been visited before"}
{"code": "Queue < Pair > q = new LinkedList < Pair > ( ) ;", "nl": "Queue for bfs"}
{"code": "q . add ( new Pair ( 0 , 0 ) ) ;", "nl": "Initializing queue"}
{"code": "int depth = 0 ;", "nl": "To store the depth of search"}
{"code": "while ( q . size ( ) != 0 ) {", "nl": "BFS algorithm"}
{"code": "int x = q . size ( ) ; while ( x -- > 0 ) {", "nl": "Current queue size"}
{"code": "Pair y = q . peek ( ) ;", "nl": "Top - most element of queue"}
{"code": "int i = y . first , j = y . second ; q . remove ( ) ;", "nl": "To store index of cell for simplicity"}
{"code": "if ( v [ i ] [ j ] ) continue ;", "nl": "Base case"}
{"code": "if ( i == n - 1 && j == n - 1 ) return depth ;", "nl": "If we reach ( n - 1 , n - 1 )"}
{"code": "v [ i ] [ j ] = true ;", "nl": "Marking the cell visited"}
{"code": "if ( i + arr [ i ] [ j ] < n ) q . add ( new Pair ( i + arr [ i ] [ j ] , j ) ) ; if ( j + arr [ i ] [ j ] < n ) q . add ( new Pair ( i , j + arr [ i ] [ j ] ) ) ; } depth ++ ; } return - 1 ; }", "nl": "Pushing the adjacent cells in the queue that can be visited from the current cell"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; System . out . println ( minSteps ( arr ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "A Java program to find largest gap between two elements in an array ."}
{"code": "static int solve ( int [ ] a , int n ) { int max1 = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( Math . abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = Math . abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; }", "nl": "function to solve the given problem"}
{"code": "static public void main ( String [ ] args ) { int [ ] arr = { - 1 , 2 , 3 , - 4 , - 10 , 22 } ; int size = arr . length ; System . out . println ( \" Largest \u2581 gap \u2581 is \u2581 : \u2581 \" + solve ( arr , size ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "A Java program to find largest gap between two elements in an array ."}
{"code": "static int solve ( int a [ ] , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ;", "nl": "function to solve the given problem"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return Math . abs ( min1 - max1 ) ; }", "nl": "finding maximum and minimum of an array"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { - 1 , 2 , 3 , 4 , - 10 } ; int size = arr . length ; System . out . println ( \" Largest \u2581 gap \u2581 is \u2581 : \u2581 \" + solve ( arr , size ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java Program for removing characters from reversed string where vowels are present in original string"}
{"code": "static void replaceOriginal ( String s , int n ) {", "nl": "Function for replacing the string"}
{"code": "char r [ ] = new char [ n ] ;", "nl": "initialize a string of length n"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse through all characters of string"}
{"code": "r [ i ] = s . charAt ( n - 1 - i ) ;", "nl": "assign the value to string r from last index of string s"}
{"code": "if ( s . charAt ( i ) != ' a ' && s . charAt ( i ) != ' e ' && s . charAt ( i ) != ' i ' && s . charAt ( i ) != ' o ' && s . charAt ( i ) != ' u ' ) { System . out . print ( r [ i ] ) ; } } System . out . println ( \" \" ) ; }", "nl": "if s [ i ] is a consonant then print r [ i ]"}
{"code": "public static void main ( String [ ] args ) { String s = \" geeksforgeeks \" ; int n = s . length ( ) ; replaceOriginal ( s , n ) ; } }", "nl": "Driver function"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static boolean sameStrings ( String str1 , String str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ;", "nl": "Function to find if given Strings are same or not"}
{"code": "if ( N != M ) { return false ; }", "nl": "Base Condition"}
{"code": "int [ ] a = new int [ 256 ] ; int [ ] b = new int [ 256 ] ;", "nl": "Stores frequency of characters of the String str1 and str2"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { a [ str1 . charAt ( i ) - ' a ' ] ++ ; b [ str2 . charAt ( i ) - ' a ' ] ++ ; }", "nl": "Traverse Strings str1 & str2 and store frequencies in a [ ] and b [ ]"}
{"code": "int i = 0 ; while ( i < 256 ) { if ( ( a [ i ] == 0 && b [ i ] == 0 ) || ( a [ i ] != 0 && b [ i ] != 0 ) ) { i ++ ; }", "nl": "Check if both Strings have same characters or not"}
{"code": "else { return false ; } }", "nl": "If a character is present in one String and is not in another String , return false"}
{"code": "Arrays . sort ( a ) ; Arrays . sort ( b ) ;", "nl": "Sort the array a [ ] and b [ ]"}
{"code": "for ( i = 0 ; i < 256 ; i ++ ) {", "nl": "Check arrays a and b contain the same frequency or not"}
{"code": "if ( a [ i ] != b [ i ] ) return false ; }", "nl": "If the frequencies are not the same after sorting"}
{"code": "return true ; }", "nl": "At this point , str1 can be converted to str2"}
{"code": "public static void main ( String [ ] args ) { String S1 = \" cabbba \" , S2 = \" abbccc \" ; if ( sameStrings ( S1 , S2 ) ) System . out . print ( \" YES \" + \"NEW_LINE\"); else System . out . print ( \" \u2581 NO \" + \"NEW_LINE\"); } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static int solution ( int A , int B , int C ) { int arr [ ] = new int [ 3 ] ;", "nl": "Function to find the minimum number operations"}
{"code": "arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ;", "nl": "Insert the three numbers in array"}
{"code": "Arrays . sort ( arr ) ;", "nl": "Sort the array"}
{"code": "if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ;", "nl": "Case 2"}
{"code": "else return ( arr [ 0 ] + arr [ 1 ] ) ; }", "nl": "Case 1"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int A = 8 , B = 1 , C = 5 ;", "nl": "Given A , B , C"}
{"code": "System . out . println ( solution ( A , B , C ) ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ;", "nl": "Function to return the index of the key in arr [ l . . h ] if the key is present otherwise return - 1"}
{"code": "if ( ( arr [ l ] == arr [ mid ] ) && ( arr [ h ] == arr [ mid ] ) ) { l ++ ; h -- ; return search ( arr , l , h , key ) ; }", "nl": "The tricky case , just update left and right"}
{"code": "else if ( arr [ l ] <= arr [ mid ] ) {", "nl": "If arr [ l ... mid ] is sorted"}
{"code": "if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ;", "nl": "As this subarray is sorted , we can quickly check if key lies in any of the halves"}
{"code": "else return search ( arr , mid + 1 , h , key ) ; }", "nl": "If key does not lie in the first half subarray then divide the other half into two subarrays such that we can quickly check if key lies in the other half"}
{"code": "else if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }", "nl": "If arr [ l . . mid ] first subarray is not sorted then arr [ mid ... h ] must be sorted subarray"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 3 , 3 , 1 , 2 , 3 , 3 } ; int n = arr . length ; int key = 3 ; System . out . println ( search ( arr , 0 , n - 1 , key ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Collections ; import java . util . Vector ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "public static String getSortedString ( StringBuilder s , int n ) {", "nl": "Function to return the sorted string"}
{"code": "Vector < Character > v1 = new Vector < > ( ) ; Vector < Character > v2 = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) >= ' a ' && s . charAt ( i ) <= ' z ' ) v1 . add ( s . charAt ( i ) ) ; if ( s . charAt ( i ) >= ' A ' && s . charAt ( i ) <= ' z ' ) v2 . add ( s . charAt ( i ) ) ; }", "nl": "Vectors to store the lowercase and uppercase characters"}
{"code": "Collections . sort ( v1 ) ; Collections . sort ( v2 ) ; int i = 0 , j = 0 ; for ( int k = 0 ; k < n ; k ++ ) {", "nl": "Sort both the vectors"}
{"code": "if ( s . charAt ( k ) > = ' a ' && s . charAt ( k ) <= ' z ' ) { s . setCharAt ( k , v1 . elementAt ( i ) ) ; ++ i ; }", "nl": "If current character is lowercase then pick the lowercase character from the sorted list"}
{"code": "else if ( s . charAt ( k ) > = ' A ' && s . charAt ( k ) <= ' Z ' ) { s . setCharAt ( k , v2 . elementAt ( j ) ) ; ++ j ; } }", "nl": "Else pick the uppercase character"}
{"code": "return s . toString ( ) ; }", "nl": "Return the sorted string"}
{"code": "public static void main ( String [ ] args ) { StringBuilder s = new StringBuilder ( \" gEeksfOrgEEkS \" ) ; int n = s . length ( ) ; System . out . println ( getSortedString ( s , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GfG {", "nl": "Java program to implement the above approach"}
{"code": "static boolean check ( char s [ ] ) {", "nl": "Function to check if the condition holds"}
{"code": "int l = s . length ;", "nl": "Get the length of the string"}
{"code": "Arrays . sort ( s ) ;", "nl": "sort the given string"}
{"code": "for ( int i = 1 ; i < l ; i ++ ) {", "nl": "Iterate for every index and check for the condition"}
{"code": "if ( s [ i ] - s [ i - 1 ] != 1 ) return false ; } return true ; }", "nl": "If are not consecutive"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "String str = \" dcef \" ; if ( check ( str . toCharArray ( ) ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ;", "nl": "1 st example"}
{"code": "String str1 = \" xyza \" ; if ( check ( str1 . toCharArray ( ) ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "2 nd example"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java code to find minimum number of elements such that their sum is greater than sum of remaining elements of the array ."}
{"code": "static int minElements ( int arr [ ] , int n ) {", "nl": "Function to find minimum elements needed"}
{"code": "int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ;", "nl": "Calculating HALF of array sum"}
{"code": "Arrays . sort ( arr ) ; int res = 0 , curr_sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_sum += arr [ i ] ; res ++ ;", "nl": "Sort the array in ascending order and start traversing array from the ascending sort in descending order ."}
{"code": "if ( curr_sum > halfSum ) return res ; } return res ; }", "nl": "Current sum greater than sum"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 3 , 1 , 7 , 1 } ; int n = arr . length ; System . out . println ( minElements ( arr , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void arrayElementEqual ( int arr [ ] , int N ) {", "nl": "Function to check if its possible to make all array elements equal or not"}
{"code": "int sum = 0 ;", "nl": "Stores the sum of the array"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; }", "nl": "Traverse the array"}
{"code": "if ( sum % N == 0 ) { System . out . print ( \" Yes \" ) ; }", "nl": "If sum is divisible by N"}
{"code": "else { System . out . print ( \" No \" + \"NEW_LINE\"); } }", "nl": "Otherwise , not possible to make all array elements equal"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 1 , 5 , 6 , 4 } ;", "nl": "Given array"}
{"code": "int N = arr . length ; arrayElementEqual ( arr , N ) ; } }", "nl": "Size of the array"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int findMaxValByRearrArr ( int arr [ ] , int N ) {", "nl": "Function to find the maximum sum of GCD ( arr [ i ] , i ) by rearranging the array"}
{"code": "int res = 0 ;", "nl": "Stores maximum sum of GCD ( arr [ i ] , i ) by rearranging the array elements"}
{"code": "res = ( N * ( N + 1 ) ) / 2 ; return res ; }", "nl": "Update res"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 } ; int N = arr . length ; System . out . print ( findMaxValByRearrArr ( arr , N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int MaximumSides ( int n ) {", "nl": "Function to find the maximum sided polygon that can be inscribed"}
{"code": "if ( n < 4 ) return - 1 ;", "nl": "Base Case"}
{"code": "return n % 2 == 0 ? n / 2 : - 1 ; }", "nl": "Return n / 2 if n is even Otherwise , return - 1"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 8 ;", "nl": "Given N"}
{"code": "System . out . print ( MaximumSides ( N ) ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static float pairProductMean ( int arr [ ] , int N ) {", "nl": "Function to find the mean of pair product array of arr [ ]"}
{"code": "int suffixSumArray [ ] = new int [ N ] ; suffixSumArray [ N - 1 ] = arr [ N - 1 ] ;", "nl": "Initializing suffix sum array"}
{"code": "for ( int i = N - 2 ; i >= 0 ; i -- ) { suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] ; }", "nl": "Build suffix sum array"}
{"code": "int length = ( N * ( N - 1 ) ) / 2 ;", "nl": "Size of pairProductArray"}
{"code": "float res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { res += arr [ i ] * suffixSumArray [ i + 1 ] ; }", "nl": "Stores sum of pairProductArray"}
{"code": "float mean ;", "nl": "Store the mean"}
{"code": "if ( length != 0 ) mean = res / length ; else mean = 0 ;", "nl": "Find mean of pairProductArray"}
{"code": "return mean ; }", "nl": "Return the resultant mean"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = arr . length ;", "nl": "Given array arr [ ]"}
{"code": "System . out . format ( \" % .2f \" , pairProductMean ( arr , N ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java Program to implement the above approach"}
{"code": "static int ncr ( int n , int k ) { int res = 1 ;", "nl": "Function to return the value of Binomial Coefficient C ( n , k )"}
{"code": "if ( k > n - k ) k = n - k ;", "nl": "Since C ( n , k ) = C ( n , n - k )"}
{"code": "for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }", "nl": "Calculate the value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- -- * 1 ]"}
{"code": "static int countPath ( int N , int M , int K ) { int answer ; if ( K >= 2 ) answer = 0 ; else if ( K == 0 ) answer = ncr ( N + M - 2 , N - 1 ) ; else {", "nl": "Function to find the minimum count of paths from top left to bottom right by placing K 1 s in the matrix"}
{"code": "answer = ncr ( N + M - 2 , N - 1 ) ;", "nl": "Count of ways without 1 s"}
{"code": "int X = ( N - 1 ) / 2 + ( M - 1 ) / 2 ; int Y = ( N - 1 ) / 2 ; int midCount = ncr ( X , Y ) ;", "nl": "Count of paths from starting point to mid point"}
{"code": "X = ( ( N - 1 ) - ( N - 1 ) / 2 ) + ( ( M - 1 ) - ( M - 1 ) / 2 ) ; Y = ( ( N - 1 ) - ( N - 1 ) / 2 ) ; midCount *= ncr ( X , Y ) ; answer -= midCount ; } return answer ; }", "nl": "Count of paths from mid point to end point"}
{"code": "public static void main ( String [ ] args ) { int N = 3 ; int M = 3 ; int K = 1 ; System . out . print ( countPath ( N , M , K ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } }", "nl": "Java program to implement the above approach"}
{"code": "static int find_max ( Vector < pair > v , int n ) {", "nl": "Function to find maximum count of operations"}
{"code": "int count = 0 ; if ( n >= 2 ) count = 2 ; else count = 1 ;", "nl": "Initialize count by 0"}
{"code": "for ( int i = 1 ; i < n - 1 ; i ++ ) {", "nl": "Iterate over remaining pairs"}
{"code": "if ( v . get ( i - 1 ) . first < ( v . get ( i ) . first - v . get ( i ) . second ) ) count ++ ;", "nl": "Check if first operation is applicable"}
{"code": "else if ( v . get ( i + 1 ) . first > ( v . get ( i ) . first + v . get ( i ) . second ) ) { count ++ ; v . get ( i ) . first = v . get ( i ) . first + v . get ( i ) . second ; }", "nl": "Check if 2 nd operation is applicable"}
{"code": "else continue ; }", "nl": "Otherwise"}
{"code": "return count ; }", "nl": "Return the count of operations"}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; Vector < pair > v = new Vector < > ( ) ; v . add ( new pair ( 10 , 20 ) ) ; v . add ( new pair ( 15 , 10 ) ) ; v . add ( new pair ( 20 , 16 ) ) ; System . out . print ( find_max ( v , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . Arrays ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static void numberofsubstrings ( String str , int k , char charArray [ ] ) { int N = str . length ( ) ;", "nl": "Function to find the number of substrings that can be formed using given characters"}
{"code": "int available [ ] = new int [ 26 ] ; Arrays . fill ( available , 0 ) ;", "nl": "Boolean array for storing the available characters"}
{"code": "for ( int i = 0 ; i < k ; i ++ ) { available [ charArray [ i ] - ' a ' ] = 1 ; }", "nl": "Mark indices of all available characters as 1"}
{"code": "int lastPos = - 1 ;", "nl": "Initialize lastPos as - 1"}
{"code": "int ans = ( N * ( N + 1 ) ) / 2 ;", "nl": "Initialize ans with the total no of possible substrings"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the string from left to right"}
{"code": "if ( available [ str . charAt ( i ) - ' a ' ] == 0 ) {", "nl": "If the current character is not present in B"}
{"code": "ans -= ( ( i - lastPos ) * ( N - i ) ) ;", "nl": "Subtract the total possible substrings"}
{"code": "lastPos = i ; } }", "nl": "Update the value of lastpos to current index"}
{"code": "System . out . println ( ans ) ; }", "nl": "Print the final answer"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "String str = \" abcb \" ; int k = 2 ;", "nl": "Given String"}
{"code": "char [ ] charArray = { ' a ' , ' b ' } ;", "nl": "Given character array"}
{"code": "numberofsubstrings ( str , k , charArray ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java implementation of above approach"}
{"code": "static int minCost ( int N , int P , int Q ) {", "nl": "Function to return minimum cost to reach destination"}
{"code": "int cost = 0 ;", "nl": "Initialize cost to 0"}
{"code": "while ( N > 0 ) { if ( ( N & 1 ) > 0 ) { cost += P ; N -- ; } else { int temp = N / 2 ;", "nl": "going backwards until we reach initial position"}
{"code": "if ( temp * P > Q ) cost += Q ;", "nl": "if 2 * X jump is better than X + 1"}
{"code": "else cost += P * temp ; N /= 2 ; } }", "nl": "if X + 1 jump is better"}
{"code": "return cost ; }", "nl": "return cost"}
{"code": "public static void main ( String [ ] args ) { int N = 9 , P = 5 , Q = 1 ; System . out . println ( minCost ( N , P , Q ) ) ; } }", "nl": "Driver program"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static void numberOfWays ( int n , int k ) {", "nl": "Function to find number of ways to reach from node 1 to 1 again , after moving exactly K edges"}
{"code": "int [ ] dp = new int [ 1000 ] ;", "nl": "Initialize a dp [ ] array , where dp [ i ] stores number of ways to reach at a i node"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 0 ; }", "nl": "Initialize the dp array with 0"}
{"code": "dp [ 0 ] = 1 ;", "nl": "Base Case"}
{"code": "for ( int i = 1 ; i <= k ; i ++ ) {", "nl": "Iterate for the number of edges moved"}
{"code": "int numWays = 0 ;", "nl": "Sum will store number of ways to reach all the nodes"}
{"code": "for ( int j = 0 ; j < n ; j ++ ) { numWays += dp [ j ] ; }", "nl": "Iterate for every possible state for the current step"}
{"code": "for ( int j = 0 ; j < n ; j ++ ) { dp [ j ] = numWays - dp [ j ] ; } }", "nl": "Update the value of the dp array after travelling each edge"}
{"code": "System . out . println ( dp [ 0 ] + \"NEW_LINE\"); }", "nl": "Print dp [ 0 ] as the answer"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "int N = 5 , K = 3 ;", "nl": "Given Input"}
{"code": "numberOfWays ( N , K ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; class GFG { static int M = 1000000007 ; static int waysOfDecoding ( String s ) { long first = 1 , second = s . charAt ( 0 ) == ' * ' ? 9 : s . charAt ( 0 ) == '0' ? 0 : 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { long temp = second ;", "nl": "Java program for the above approach"}
{"code": "if ( s . charAt ( i ) == ' * ' ) { second = 9 * second ;", "nl": "If s [ i ] = = ' * ' there can be 9 possible values of *"}
{"code": "if ( s . charAt ( i - 1 ) == '1' ) second = ( second + 9 * first ) % M ;", "nl": "If previous character is 1 then words that can be formed are K ( 11 ) , L ( 12 ) , M ( 13 ) , N ( 14 ) O ( 15 ) , P ( 16 ) , Q ( 17 ) , R ( 18 ) , S ( 19 )"}
{"code": "else if ( s . charAt ( i - 1 ) == '2' ) second = ( second + 6 * first ) % M ;", "nl": "If previous character is 2 then the words that can be formed are U ( 21 ) , V ( 22 ) , W ( 23 ) , X ( 24 ) Y ( 25 ) , Z ( 26 )"}
{"code": "else if ( s . charAt ( i - 1 ) == ' * ' ) second = ( second + 15 * first ) % M ; }", "nl": "If the previous digit is * then all 15 2 - digit characters can be formed"}
{"code": "else { second = s . charAt ( i ) != '0' ? second : 0 ;", "nl": "If s [ i ] != ' * '"}
{"code": "if ( s . charAt ( i - 1 ) == '1' ) second = ( second + first ) % M ;", "nl": "Adding first in second if s [ i - 1 ] = 1"}
{"code": "else if ( s . charAt ( i - 1 ) == '2' && s . charAt ( i ) <= '6' ) second = ( second + first ) % M ;", "nl": "Adding first in second if s [ i - 1 ] = = 2 and s [ i ] <= '6'"}
{"code": "else if ( s . charAt ( i - 1 ) == ' * ' ) second = ( second + ( s . charAt ( i ) <= '6' ? 2 : 1 ) * first ) % M ; } first = temp ; } return ( int ) second ; }", "nl": "if s [ i - 1 ] == ' * ' the union of above 2 cases has to be done"}
{"code": "public static void main ( String [ ] args ) { String s = \" * \" ; System . out . println ( waysOfDecoding ( s ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program for above approach"}
{"code": "static int findMinCost ( int [ ] [ ] arr , int X , int n , int i ) {", "nl": "Function to calculate minimum cost of buying least X chocolates"}
{"code": "if ( X <= 0 ) return 0 ; if ( i >= n ) return Integer . MAX_VALUE ;", "nl": "Base Case"}
{"code": "int inc = findMinCost ( arr , X - arr [ i ] [ 0 ] , n , i + 1 ) ; if ( inc != Integer . MAX_VALUE ) inc += arr [ i ] [ 1 ] ;", "nl": "Include the i - th box"}
{"code": "int exc = findMinCost ( arr , X , n , i + 1 ) ;", "nl": "Exclude the i - th box"}
{"code": "return Math . min ( inc , exc ) ; }", "nl": "Return the minimum of the above two cases"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int [ ] [ ] arr = { { 4 , 3 } , { 3 , 2 } , { 2 , 4 } , { 1 , 3 } , { 4 , 2 } } ; int X = 7 ;", "nl": "Given array and value of X"}
{"code": "int n = arr . length ; int ans = findMinCost ( arr , X , n , 0 ) ;", "nl": "Store the size of the array"}
{"code": "if ( ans != Integer . MAX_VALUE ) System . out . println ( ans ) ; else System . out . println ( - 1 ) ; } }", "nl": "Print the answer"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static double find ( int N , int sum ) {", "nl": "Function to calculate the probability for the given sum to be equal to sum in N throws of dice"}
{"code": "if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } double s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; }", "nl": "Base cases"}
{"code": "public static void main ( String [ ] args ) { int N = 4 , a = 13 , b = 17 ; double probability = 0.0 ; for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ;", "nl": "Driver code"}
{"code": "System . out . format ( \" % .6f \" , probability ) ; } }", "nl": "Print the answer"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static int minDays ( int n ) {", "nl": "Function to find the minimum number to steps to reduce N to 0"}
{"code": "if ( n < 1 ) return n ;", "nl": "Base case"}
{"code": "int cnt = 1 + Math . min ( n % 2 + minDays ( n / 2 ) , n % 3 + minDays ( n / 3 ) ) ;", "nl": "Recursive Call to count the minimum steps needed"}
{"code": "return cnt ; }", "nl": "Return the answer"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 6 ;", "nl": "Given Number N"}
{"code": "System . out . print ( minDays ( N ) ) ; } }", "nl": "Function Call"}
