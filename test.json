{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int minSum ( int A [ ] , int N ) {", "nl": "Function to find minimum sum after deletion"}
{"code": "HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int sum = 0 ;", "nl": "Stores frequency of array elements"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array"}
{"code": "sum += A [ i ] ;", "nl": "Calculate sum"}
{"code": "if ( mp . containsKey ( A [ i ] ) ) { mp . put ( A [ i ] , mp . get ( A [ i ] ) + 1 ) ; } else { mp . put ( A [ i ] , 1 ) ; } }", "nl": "Update frequency of the current element"}
{"code": "int minSum = Integer . MAX_VALUE ;", "nl": "Stores the minimum sum required"}
{"code": "for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) {", "nl": "Traverse map"}
{"code": "minSum = Math . min ( minSum , sum - ( it . getKey ( ) * it . getValue ( ) ) ) ; }", "nl": "Find the minimum sum obtained"}
{"code": "return minSum ; }", "nl": "Return minimum sum"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int arr [ ] = { 4 , 5 , 6 , 6 } ;", "nl": "Input array"}
{"code": "int N = arr . length ; System . out . print ( minSum ( arr , N ) + \"NEW_LINE\"); } }", "nl": "Size of array"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of above approach"}
{"code": "static void maxAdjacent ( int [ ] arr , int N ) { ArrayList < Integer > res = new ArrayList < Integer > ( ) ;", "nl": "Function to calculate maximum difference between adjacent elements excluding every array element once"}
{"code": "for ( int i = 1 ; i < N - 1 ; i ++ ) { int prev = arr [ 0 ] ;", "nl": "Traverse the array"}
{"code": "int maxi = Integer . MIN_VALUE ;", "nl": "Stores the maximum diff"}
{"code": "for ( int j = 1 ; j < N ; j ++ ) {", "nl": "Check for maximum adjacent element"}
{"code": "if ( i == j ) continue ;", "nl": "Exclude current element"}
{"code": "maxi = Math . max ( maxi , Math . abs ( arr [ j ] - prev ) ) ;", "nl": "Update maximum difference"}
{"code": "prev = arr [ j ] ; }", "nl": "Update previous value"}
{"code": "res . add ( maxi ) ; }", "nl": "Append the result into a vector"}
{"code": "for ( int x : res ) { System . out . print ( x + \" \u2581 \" ) ; } System . out . println ( ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 4 , 7 , 8 } ; int N = arr . length ; maxAdjacent ( arr , N ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int findSize ( int N ) {", "nl": "Function to find the size of the array if the array initially contains a single element"}
{"code": "if ( N == 0 ) return 1 ; if ( N == 1 ) return 1 ; int Size = 2 * findSize ( N / 2 ) + 1 ;", "nl": "Base case"}
{"code": "return Size ; }", "nl": "P / 2 -> findSize ( N / 2 ) P % 2 -> 1 P / 2 -> findSize ( N / 2 )"}
{"code": "static int CountOnes ( int N , int L , int R ) { if ( L > R ) { return 0 ; }", "nl": "Function to return the count of 1 s in the range [ L , R ]"}
{"code": "if ( N <= 1 ) { return N ; } int ret = 0 ; int M = N / 2 ; int Siz_M = findSize ( M ) ;", "nl": "Base Case"}
{"code": "if ( L <= Siz_M ) {", "nl": "PART 1 -> N / 2 [ 1 , Siz_M ]"}
{"code": "ret += CountOnes ( N / 2 , L , Math . min ( Siz_M , R ) ) ; }", "nl": "Update the right end point of the range to min ( Siz_M , R )"}
{"code": "if ( L <= Siz_M + 1 && Siz_M + 1 <= R ) { ret += N % 2 ; }", "nl": "PART 2 -> N % 2 [ SizM + 1 , Siz_M + 1 ]"}
{"code": "if ( Siz_M + 1 < R ) { ret += CountOnes ( N / 2 , Math . max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) ; } return ret ; }", "nl": "PART 3 -> N / 2 [ SizM + 2 , 2 * Siz_M - 1 ] Same as PART 1 Property of Symmetricity Shift the coordinates according to PART 1 Subtract ( Siz_M + 1 ) from both L , R"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 7 , L = 2 , R = 5 ;", "nl": "Input"}
{"code": "System . out . println ( CountOnes ( N , L , R ) ) ; } }", "nl": "Counts the number of 1 's in  the range [L, R]"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static boolean prime ( int n ) {", "nl": "Function to check if number is prime or not"}
{"code": "if ( n == 1 ) return false ;", "nl": "As 1 is neither prime nor composite return false"}
{"code": "for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; }", "nl": "Check if it is divided by any number then it is not prime , return false"}
{"code": "return true ; }", "nl": "Check if n is not divided by any number then it is prime and hence return true"}
{"code": "static void minDivisior ( int n ) {", "nl": "Function to find the pair ( a , b ) such that sum is N & LCM is minimum"}
{"code": "if ( prime ( n ) ) { System . out . print ( 1 + \" \u2581 \" + ( n - 1 ) ) ; }", "nl": "Check if the number is prime"}
{"code": "else { for ( int i = 2 ; i * i <= n ; i ++ ) {", "nl": "Now , if it is not prime then find the least divisior"}
{"code": "if ( n % i == 0 ) {", "nl": "Check if divides n then it is a factor"}
{"code": "System . out . print ( n / i + \" \u2581 \" + ( n / i * ( i - 1 ) ) ) ; break ; } } } }", "nl": "Required output is a = n / i & b = n / i * ( n - 1 )"}
{"code": "public static void main ( String [ ] args ) { int N = 4 ;", "nl": "Driver Code"}
{"code": "minDivisior ( N ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int Landau = Integer . MIN_VALUE ;", "nl": "To store Landau 's function of the number"}
{"code": "static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }", "nl": "Function to return gcd of 2 numbers"}
{"code": "static int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; }", "nl": "Function to return LCM of two numbers"}
{"code": "static void findLCM ( Vector < Integer > arr ) { int nth_lcm = arr . get ( 0 ) ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) nth_lcm = lcm ( nth_lcm , arr . get ( i ) ) ;", "nl": "Function to find max lcm value among all representations of n"}
{"code": "Landau = Math . max ( Landau , nth_lcm ) ; }", "nl": "Calculate Landau 's value"}
{"code": "static void findWays ( Vector < Integer > arr , int i , int n ) {", "nl": "Recursive function to find different ways in which n can be written as sum of atleast one positive integers"}
{"code": "if ( n == 0 ) findLCM ( arr ) ;", "nl": "Check if sum becomes n , consider this representation"}
{"code": "for ( int j = i ; j <= n ; j ++ ) {", "nl": "Start from previous element in the representation till n"}
{"code": "arr . add ( j ) ;", "nl": "Include current element from representation"}
{"code": "findWays ( arr , j , n - j ) ;", "nl": "Call function again with reduced sum"}
{"code": "arr . remove ( arr . size ( ) - 1 ) ; } }", "nl": "Backtrack - remove current element from representation"}
{"code": "static void Landau_function ( int n ) { Vector < Integer > arr = new Vector < > ( ) ;", "nl": "Function to find the Landau 's function"}
{"code": "findWays ( arr , 1 , n ) ;", "nl": "Using recurrence find different ways in which n can be written as a sum of atleast one + ve integers"}
{"code": "System . out . print ( Landau ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 4 ;", "nl": "Given N"}
{"code": "Landau_function ( N ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java implementation to check the following expression for an integer N is valid or not"}
{"code": "static boolean isPrime ( int n ) {", "nl": "Function to check if a number holds the condition ( N - 1 ) ! % N = N - 1"}
{"code": "if ( n == 1 ) return true ; if ( n <= 3 ) return true ;", "nl": "Corner cases"}
{"code": "if ( n % 2 == 0 n % 3 == 0 ) return false ;", "nl": "Number divisible by 2 or 3 are not prime"}
{"code": "for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }", "nl": "Iterate from 5 and keep checking for prime"}
{"code": "static void checkExpression ( int n ) { if ( isPrime ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; }", "nl": "Function to check the expression for the value N"}
{"code": "public static void main ( String [ ] args ) { int N = 3 ; checkExpression ( N ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation to check if it is possible to split array into K subsets with odd sum"}
{"code": "static boolean checkArray ( int n , int k , int arr [ ] ) {", "nl": "Function to check if array can be split in required K subsets"}
{"code": "int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Store count of odd numbers"}
{"code": "if ( ( arr [ i ] & 1 ) != 0 ) cnt += 1 ; }", "nl": "Check if element is odd"}
{"code": "if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; }", "nl": "Check if split is possible"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 7 , 5 , 3 , 1 } ; int n = arr . length ; int k = 4 ; if ( checkArray ( n , k , arr ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation to compute the sum of division of all the possible pairs for the given array"}
{"code": "static long func ( int arr [ ] , int n ) { double ans = 0 ; int maxx = 0 ; double freq [ ] = new double [ 100005 ] ; int temp ;", "nl": "Function to compute the sum"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = Math . max ( maxx , temp ) ; }", "nl": "Counting frequency of each term and finding maximum among it"}
{"code": "for ( int i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( int i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] != 0 ) { double j ;", "nl": "Making cumulative frequency"}
{"code": "double cur = Math . ceil ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { int val = Math . min ( maxx , ( int ) ( Math . ceil ( i * j ) - 1.0 ) ) ; int times = ( int ) ( freq [ i ] - freq [ i - 1 ] ) , con = ( int ) ( j - 0.5 ) ;", "nl": "Taking the ceil value"}
{"code": "ans += times * con * ( freq [ ( int ) val ] - freq [ ( int ) cur ] ) ; cur = val ; if ( val == maxx ) break ; } } }", "nl": "nos . in [ ( n - 0.5 ) X , ( n + 0.5 ) X ) range will add n to the ans"}
{"code": "return ( long ) ans ; }", "nl": "Return the final result"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . print ( func ( arr , n ) + \"NEW_LINE\"); } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find the count of elements to be inserted to make Array sum twice the XOR of Array"}
{"code": "static void insert_element ( int a [ ] , int n ) {", "nl": "Function to find the minimum number of elements that need to be inserted such that the sum of the elements of the array is twice the XOR of the array"}
{"code": "int Xor = 0 ;", "nl": "Variable to store the Xor of all the elements"}
{"code": "int Sum = 0 ;", "nl": "Variable to store the sum of all elements"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { Xor ^= a [ i ] ; Sum += a [ i ] ; }", "nl": "Loop to find the Xor and the sum of the array"}
{"code": "if ( Sum == 2 * Xor ) {", "nl": "If sum = 2 * Xor"}
{"code": "System . out . println ( \"0\" ) ; return ; }", "nl": "No need to insert more elements"}
{"code": "if ( Xor == 0 ) { System . out . println ( \"1\" ) ; System . out . println ( Sum ) ; return ; }", "nl": "We insert one more element which is Sum"}
{"code": "int num1 = Sum + Xor ; int num2 = Xor ;", "nl": "We insert two more elements Sum + Xor and Xor ."}
{"code": "System . out . print ( \"2\" ) ;", "nl": "Print the number of elements inserted in the array"}
{"code": "System . out . println ( num1 + \" \u2581 \" + num2 ) ; }", "nl": "Print the elements that are inserted in the array"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 } ; int n = a . length ; insert_element ( a , n ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to check if roots of a quadratic equation are reciprocal of each other or not"}
{"code": "static void checkSolution ( int a , int b , int c ) { if ( a == c ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; }", "nl": "Function to check if the roots of a quadratic equation are reciprocal of each other or not"}
{"code": "public static void main ( String [ ] args ) { int a = 2 , b = 0 , c = 2 ; checkSolution ( a , b , c ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static boolean isPerfectSquare ( double x ) {", "nl": "Function check whether x is a perfect square or not"}
{"code": "double sr = Math . sqrt ( x ) ;", "nl": "Find floating point value of square root of x ."}
{"code": "return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }", "nl": "If square root is an integer"}
{"code": "static void checkSunnyNumber ( int N ) {", "nl": "Function to check Sunny Number"}
{"code": "if ( isPerfectSquare ( N + 1 ) ) { System . out . println ( \" Yes \" ) ; }", "nl": "Check if ( N + 1 ) is a perfect square or not"}
{"code": "else { System . out . println ( \" No \" ) ; } }", "nl": "If ( N + 1 ) is not a perfect square"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int N = 8 ;", "nl": "Given Number"}
{"code": "checkSunnyNumber ( N ) ; } }", "nl": "Function call"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program to count the numbers which can convert N to 1 using the given operation"}
{"code": "static int countValues ( int n ) { int answer = 0 ;", "nl": "Function to count the numbers which can convert N to 1 using the given operation"}
{"code": "for ( int i = 2 ; i <= n ; i ++ ) { int k = n ;", "nl": "Iterate through all the integers"}
{"code": "while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; }", "nl": "Check if N can be converted to 1"}
{"code": "if ( k == 1 ) answer ++ ; } return answer ; }", "nl": "Incrementing the count if it can be converted"}
{"code": "public static void main ( String args [ ] ) { int N = 6 ; System . out . print ( countValues ( N ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find K numbers with sum equal to N and the sum of their squares maximized"}
{"code": "static void printKNumbers ( int N , int K ) {", "nl": "Function that prints the required K numbers"}
{"code": "for ( int i = 0 ; i < K - 1 ; i ++ ) System . out . print ( 1 + \" \u2581 \" ) ;", "nl": "Print 1 , K - 1 times"}
{"code": "System . out . print ( N - K + 1 ) ; }", "nl": "Print ( N - K + 1 )"}
{"code": "public static void main ( String [ ] args ) { int N = 10 , K = 3 ; printKNumbers ( N , K ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to find N 'th stepping natural Number"}
{"code": "static int NthSmallest ( int K ) {", "nl": "Function to find the Nth stepping natural number"}
{"code": "Queue < Integer > Q = new LinkedList < > ( ) ; int x = 0 ;", "nl": "Declare the queue"}
{"code": "for ( int i = 1 ; i < 10 ; i ++ ) Q . add ( i ) ;", "nl": "Enqueue 1 , 2 , ... , 9 in this order"}
{"code": "for ( int i = 1 ; i <= K ; i ++ ) {", "nl": "Perform K operation on queue"}
{"code": "x = Q . peek ( ) ;", "nl": "Get the ith Stepping number"}
{"code": "Q . remove ( ) ;", "nl": "Perform Dequeue from the Queue"}
{"code": "if ( x % 10 != 0 ) {", "nl": "If x mod 10 is not equal to 0"}
{"code": "Q . add ( x * 10 + x % 10 - 1 ) ; }", "nl": "then Enqueue 10 x + ( x mod 10 ) - 1"}
{"code": "Q . add ( x * 10 + x % 10 ) ;", "nl": "Enqueue 10 x + ( x mod 10 )"}
{"code": "if ( x % 10 != 9 ) {", "nl": "If x mod 10 is not equal to 9"}
{"code": "Q . add ( x * 10 + x % 10 + 1 ) ; } }", "nl": "then Enqueue 10 x + ( x mod 10 ) + 1"}
{"code": "return x ; }", "nl": "Return the dequeued number of the K - th operation as the Nth stepping number"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 16 ; System . out . print ( NthSmallest ( N ) ) ; } }", "nl": "initialise K"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int nearest ( int n ) {", "nl": "Function to return the Least number"}
{"code": "int prevSquare = ( int ) Math . sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ;", "nl": "Get the perfect square before and after N"}
{"code": "int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ;", "nl": "Check which is nearest to N"}
{"code": "return ans ; }", "nl": "return the result"}
{"code": "public static void main ( String [ ] args ) { int n = 14 ; System . out . println ( nearest ( n ) ) ; n = 16 ; System . out . println ( nearest ( n ) ) ; n = 18 ; System . out . println ( nearest ( n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to calculate the value of pi up to n decimal places"}
{"code": "static void printValueOfPi ( int N ) {", "nl": "Function that prints the value of pi upto N decimal places"}
{"code": "double pi = 2 * Math . acos ( 0.0 ) ;", "nl": "Find value of pi upto using acos ( ) function"}
{"code": "System . out . println ( pi ) ; }", "nl": "Print value of pi upto N decimal places"}
{"code": "public static void main ( String [ ] args ) { int N = 4 ;", "nl": "Driver Code"}
{"code": "printValueOfPi ( N ) ; } }", "nl": "Function that prints the value of pi"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void decBinary ( int arr [ ] , int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } }", "nl": "Function to convert decimal number n to its binary representation stored as an array arr [ ]"}
{"code": "static int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; }", "nl": "Function to convert the number represented as a binary array arr [ ] into its decimal equivalent"}
{"code": "static int getNum ( int n , int k ) {", "nl": "Function to return the updated integer after flipping the kth bit"}
{"code": "int l = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ;", "nl": "Number of bits in n"}
{"code": "int a [ ] = new int [ l ] ; decBinary ( a , n ) ;", "nl": "Find the binary representation of n"}
{"code": "if ( k > l ) return n ;", "nl": "The number of bits in n are less than k"}
{"code": "a [ k - 1 ] = ( a [ k - 1 ] == 0 ) ? 1 : 0 ;", "nl": "Flip the kth bit"}
{"code": "return binaryDec ( a , l ) ; }", "nl": "Return the decimal equivalent of the number"}
{"code": "public static void main ( String [ ] args ) { int n = 56 ; int k = 2 ; System . out . println ( getNum ( n , k ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static int MAX = 1000000 ; static int MOD = 10000007 ;", "nl": "Java implementation of the approach"}
{"code": "static int [ ] result = new int [ MAX + 1 ] ; static int [ ] fact = new int [ MAX + 1 ] ;", "nl": "Declare result array globally"}
{"code": "static void preCompute ( ) {", "nl": "Function to precompute the product of factorials upto MAX"}
{"code": "fact [ 0 ] = 1 ; result [ 0 ] = 1 ;", "nl": "Initialize base condition if n = 0 then factorial of 0 is equal to 1 and answer for n = 0 is 1"}
{"code": "for ( int i = 1 ; i <= MAX ; i ++ ) {", "nl": "Iterate loop from 1 to MAX"}
{"code": "fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ;", "nl": "factorial ( i ) = factorial ( i - 1 ) * i"}
{"code": "result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } }", "nl": "Result for current n is equal to result [ i - 1 ] multiplied by the factorial of i"}
{"code": "static void performQueries ( int q [ ] , int n ) {", "nl": "Function to perform the queries"}
{"code": "preCompute ( ) ;", "nl": "Precomputing the result till MAX"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) System . out . println ( result [ q [ i ] ] ) ; }", "nl": "Perform queries"}
{"code": "public static void main ( String [ ] args ) { int q [ ] = { 4 , 5 } ; int n = q . length ; performQueries ( q , n ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find nth term divisible by a , b or c"}
{"code": "static long gcd ( long a , long b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; }", "nl": "Function to return gcd of a and b"}
{"code": "static long divTermCount ( long a , long b , long c , long num ) {", "nl": "Function to return the count of integers from the range [ 1 , num ] which are divisible by either a , b or c"}
{"code": "return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; }", "nl": "Calculate the number of terms divisible by a , b and c then remove the terms which are divisible by both ( a , b ) or ( b , c ) or ( c , a ) and then add the numbers which are divisible by a , b and c"}
{"code": "static long findNthTerm ( int a , int b , int c , long n ) {", "nl": "Function for binary search to find the nth term divisible by a , b or c"}
{"code": "long low = 1 , high = Long . MAX_VALUE , mid ; while ( low < high ) { mid = low + ( high - low ) / 2 ;", "nl": "Set low to 1 and high to LONG_MAX"}
{"code": "if ( divTermCount ( a , b , c , mid ) < n ) { low = mid + 1 ; }", "nl": "If the current term is less than n then we need to increase low to mid + 1"}
{"code": "else { high = mid ; } } return low ; }", "nl": "If current term is greater than equal to n then high = mid"}
{"code": "public static void main ( String args [ ] ) { int a = 2 , b = 3 , c = 5 , n = 100 ; System . out . println ( findNthTerm ( a , b , c , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static double calculate_angle ( int n , int i , int j , int k ) {", "nl": "Function that checks whether given angle can be created using any 3 sides"}
{"code": "int x , y ;", "nl": "Initialize x and y"}
{"code": "if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ;", "nl": "Calculate the number of vertices between i and j , j and k"}
{"code": "double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ;", "nl": "Calculate the angle subtended at the circumference"}
{"code": "double ans = 180 - ang1 - ang2 ; return ans ; }", "nl": "Angle subtended at j can be found using the fact that the sum of angles of a triangle is equal to 180 degrees"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; int a1 = 1 ; int a2 = 2 ; int a3 = 5 ; System . out . println ( ( int ) calculate_angle ( n , a1 , a2 , a3 ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of above approach ."}
{"code": "static void Loss ( int SP , int P ) { float loss = 0 ; loss = ( float ) ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; System . out . println ( \" Loss \u2581 = \u2581 \" + loss ) ; }", "nl": "Function that will find loss"}
{"code": "public static void main ( String [ ] args ) { int SP = 2400 , P = 30 ;", "nl": "Driver Code"}
{"code": "Loss ( SP , P ) ; } }", "nl": "Calling Function"}
{"code": "class GFG { static int MAXN = 1000001 ;", "nl": "Java implementation of the approach"}
{"code": "static int [ ] spf = new int [ MAXN ] ;", "nl": "Stores smallest prime factor for every number"}
{"code": "static int [ ] hash1 = new int [ MAXN ] ;", "nl": "Hash to store prime factors count"}
{"code": "static void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ )", "nl": "Function to calculate SPF ( Smallest Prime Factor ) for every number till MAXN"}
{"code": "spf [ i ] = i ;", "nl": "Marking smallest prime factor for every number to be itself"}
{"code": "for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ;", "nl": "Separately marking spf for every even number as 2"}
{"code": "for ( int i = 3 ; i * i < MAXN ; i ++ ) {", "nl": "Checking if i is prime"}
{"code": "if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i )", "nl": "Marking SPF for all numbers divisible by i"}
{"code": "if ( spf [ j ] == j ) spf [ j ] = i ; } } }", "nl": "Marking spf [ j ] if it is not previously marked"}
{"code": "static void getFactorization ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 ) {", "nl": "Function to store the prime factors after dividing by the smallest prime factor at every step"}
{"code": "hash1 [ spf [ x ] ] ++ ; x = x / spf [ x ] ; } while ( x % temp == 0 ) x = x / temp ; } }", "nl": "Storing the count of prime factors in hash"}
{"code": "static boolean check ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ;", "nl": "Function that returns true if there are no common prime factors between x and other numbers of the array"}
{"code": "if ( x % temp == 0 && hash1 [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x / temp ; } return true ; }", "nl": "Checking whether it common prime factor with other numbers"}
{"code": "static boolean hasValidNum ( int [ ] arr , int n ) {", "nl": "Function that returns true if there is an element in the array which is coprime with all the other elements of the array"}
{"code": "sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ;", "nl": "Using sieve for generating prime factors"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; }", "nl": "Checking the common prime factors with other numbers"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 2 , 8 , 4 , 10 , 6 , 7 } ; int n = arr . length ; if ( hasValidNum ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "class GfG {", "nl": "Java implementation of the approach"}
{"code": "static int countWays ( int N ) {", "nl": "Function to return the number of ways to remove edges from the graph so that odd number of edges are left in the graph"}
{"code": "int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return ( int ) Math . pow ( 2 , E - 1 ) ; }", "nl": "Total number of edges"}
{"code": "public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( countWays ( N ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int l [ ] [ ] = new int [ 1001 ] [ 1001 ] ; static void initialize ( ) {", "nl": "Initialize the matrix with 0"}
{"code": "l [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 1001 ; i ++ ) {", "nl": "0 C0 = 1"}
{"code": "l [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i + 1 ; j ++ ) {", "nl": "Set every nCr = 1 where r = 0"}
{"code": "l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) ; } } }", "nl": "Value for the current cell of Pascal 's triangle"}
{"code": "static int nCr ( int n , int r ) {", "nl": "Function to return the value of nCr"}
{"code": "return l [ n ] [ r ] ; }", "nl": "Return nCr"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "initialize ( ) ; int n = 8 ; int r = 3 ; System . out . println ( nCr ( n , r ) ) ; } }", "nl": "Build the Pascal 's triangle"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; }", "nl": "Function to return the minimum required absolute difference"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( minAbsDiff ( n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static boolean check ( int s ) {", "nl": "Java implementation of the above approach"}
{"code": "int [ ] freq = new int [ 10 ] ; int r , i ; for ( i = 0 ; i < 10 ; i ++ ) { freq [ i ] = 0 ; } while ( s != 0 ) {", "nl": "creating a frequency array"}
{"code": "r = s % 10 ;", "nl": "Finding the last digit of the number"}
{"code": "s = ( int ) ( s / 10 ) ;", "nl": "Dividing the number by 10 to eliminate last digit"}
{"code": "freq [ r ] += 1 ; } int xor__ = 0 ;", "nl": "counting frequency of each digit"}
{"code": "for ( i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } return true ; }", "nl": "checking if the xor of all frequency is zero or not"}
{"code": "public static void main ( String [ ] args ) { int s = 122233 ; if ( check ( s ) ) System . out . println ( \"YesNEW_LINE\"); else System . out . println ( \"NoNEW_LINE\"); } }", "nl": "Driver function"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static void printLines ( int n , int k ) {", "nl": "Function to print N lines"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( k * ( 6 * i + 1 ) + \" \u2581 \" + k * ( 6 * i + 2 ) + \" \u2581 \" + k * ( 6 * i + 3 ) + \" \u2581 \" + k * ( 6 * i + 5 ) ) ; } }", "nl": "Iterate N times to print N lines"}
{"code": "public static void main ( String args [ ] ) { int n = 2 , k = 2 ; printLines ( n , k ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static int calculateSum ( int n ) {", "nl": "Java program to find sum of first n terms"}
{"code": "return ( ( int ) Math . pow ( 2 , n + 1 ) + n - 2 ) ; }", "nl": "Sn = n * ( 4 * n * n + 6 * n - 1 ) / 3"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "int n = 4 ;", "nl": "number of terms to be included in sum"}
{"code": "System . out . println ( \" Sum \u2581 = \u2581 \" + calculateSum ( n ) ) ; } }", "nl": "find the Sn"}
{"code": "import java . util . * ; class GFG { static final int mod = 1000000007 ;", "nl": "Java program to count the number of special strings of a given length N"}
{"code": "static int count_special ( int n ) {", "nl": "Function to return count of special Strings"}
{"code": "int [ ] fib = new int [ n + 1 ] ;", "nl": "Stores the answer for a particular value of n"}
{"code": "fib [ 0 ] = 1 ;", "nl": "For n = 0 we have empty String"}
{"code": "fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) {", "nl": "For n = 1 we have 2 special Strings"}
{"code": "fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; }", "nl": "Calculate count of special String of length i"}
{"code": "return fib [ n ] ; }", "nl": "fib [ n ] stores the count of special Strings of length n"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int n = 3 ; System . out . print ( count_special ( n ) + \"NEW_LINE\"); } }", "nl": "Initialise n"}
{"code": "import java . io . * ; class GFG { static int mod = 1000000000 ;", "nl": "Java implementation of the above approach"}
{"code": "static int ways ( int i , int arr [ ] , int n ) {", "nl": "Find the number of ways to reach the end"}
{"code": "if ( i == n - 1 ) return 1 ; int sum = 0 ;", "nl": "Base case"}
{"code": "for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; }", "nl": "Recursive structure"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = arr . length ; System . out . println ( ways ( 0 , arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static final int mod = ( int ) ( 1e9 + 7 ) ;", "nl": "Java implementation of above approach"}
{"code": "static int ways ( int arr [ ] , int n ) {", "nl": "find the number of ways to reach the end"}
{"code": "int dp [ ] = new int [ n + 1 ] ;", "nl": "dp to store value"}
{"code": "dp [ n - 1 ] = 1 ;", "nl": "base case"}
{"code": "for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ;", "nl": "Bottom up dp structure"}
{"code": "for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } }", "nl": "F [ i ] is dependent of F [ i + 1 ] to F [ i + k ]"}
{"code": "return dp [ 0 ] % mod ; }", "nl": "Return value of dp [ 0 ]"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = arr . length ; System . out . println ( ways ( arr , n ) % mod ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } }", "nl": "Java program to get minimum cost to sort strings by reversal operation"}
{"code": "static pair countSum ( int arr [ ] , int n ) { int result = 0 ;", "nl": "Returns the count of odd and even subsequences"}
{"code": "int count_odd , count_even ;", "nl": "Variables to store the count of even subsequences and odd subsequences"}
{"code": "count_odd = 0 ; count_even = 0 ;", "nl": "Initialising count_even and count_odd to 0 since as there is no subsequence before the iteration with even or odd count ."}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) {", "nl": "Find sum of all subsequences with even count and odd count and storing them as we iterate ."}
{"code": "if ( arr [ i - 1 ] % 2 == 0 ) { count_even = count_even + count_even + 1 ; count_odd = count_odd + count_odd ; }", "nl": "if the number is even"}
{"code": "else { int temp = count_even ; count_even = count_even + count_odd ; count_odd = count_odd + temp + 1 ; } } return new pair ( count_even , count_odd ) ; }", "nl": "if the number is odd"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = arr . length ;", "nl": "Driver code"}
{"code": "pair ans = countSum ( arr , n ) ; System . out . print ( \" EvenSum \u2581 = \u2581 \" + ans . first ) ; System . out . print ( \" \u2581 OddSum \u2581 = \u2581 \" + ans . second ) ; } }", "nl": "Calling the function"}
{"code": "import java . util . * ; class GFG { static int MAX = 10 ;", "nl": "Java implementation of the approach"}
{"code": "static Vector < Integer > numToVec ( int N ) { Vector < Integer > digit = new Vector < Integer > ( ) ;", "nl": "Function to convert a number into vector"}
{"code": "while ( N != 0 ) { digit . add ( N % 10 ) ; N = N / 10 ; }", "nl": "Push all the digits of N from the end one by one to the vector"}
{"code": "if ( digit . size ( ) == 0 ) digit . add ( 0 ) ;", "nl": "If the original number was 0"}
{"code": "Collections . reverse ( digit ) ;", "nl": "Reverse the vector elements"}
{"code": "return digit ; }", "nl": "Return the required vector"}
{"code": "static int solve ( Vector < Integer > A , int B , int C ) { Vector < Integer > digit = new Vector < Integer > ( ) ; int d , d2 ;", "nl": "Function to return the count of B length integers which are less than C and they contain digits from set A [ ] only"}
{"code": "digit = numToVec ( C ) ; d = A . size ( ) ;", "nl": "Convert number to digit array"}
{"code": "if ( B > digit . size ( ) d == 0 ) return 0 ;", "nl": "Case 1 : No such number possible as the generated numbers will always be greater than C"}
{"code": "else if ( B < digit . size ( ) ) {", "nl": "Case 2 : All integers of length B are valid as they all are less than C"}
{"code": "if ( A . get ( 0 ) == 0 && B != 1 ) return ( int ) ( ( d - 1 ) * Math . pow ( d , B - 1 ) ) ; else return ( int ) Math . pow ( d , B ) ; }", "nl": "contain 0"}
{"code": "else { int [ ] dp = new int [ B + 1 ] ; int [ ] lower = new int [ MAX + 1 ] ;", "nl": "Case 3"}
{"code": "for ( int i = 0 ; i < d ; i ++ ) lower [ A . get ( i ) + 1 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) lower [ i ] = lower [ i - 1 ] + lower [ i ] ; boolean flag = true ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { d2 = lower [ digit . get ( i - 1 ) ] ; dp [ i ] = dp [ i - 1 ] * d ;", "nl": "Update the lower [ ] array such that lower [ i ] stores the count of elements in A [ ] which are less than i"}
{"code": "if ( i == 1 && A . get ( 0 ) == 0 && B != 1 ) d2 = d2 - 1 ;", "nl": "For first index we can 't use 0"}
{"code": "if ( flag ) dp [ i ] += d2 ;", "nl": "Whether ( i - 1 ) digit of generated number can be equal to ( i - 1 ) digit of C"}
{"code": "flag = ( flag & ( lower [ digit . get ( i - 1 ) + 1 ] == lower [ digit . get ( i - 1 ) ] + 1 ) ) ; } return dp [ B ] ; } }", "nl": "Is digit [ i - 1 ] present in A ?"}
{"code": "public static void main ( String [ ] args ) { Integer arr [ ] = { 0 , 1 , 2 , 5 } ; Vector < Integer > A = new Vector < > ( Arrays . asList ( arr ) ) ; int N = 2 ; int k = 21 ; System . out . println ( solve ( A , N , k ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to count the number of paths with weight W in a K - ary tree"}
{"code": "public static int solve ( int [ ] [ ] dp , int wt , int K , int M , int used ) {", "nl": "Function to return the number of ways having weight as wt in K - ary tree"}
{"code": "if ( wt < 0 ) { return 0 ; } if ( wt == 0 ) {", "nl": "Return 0 if weight becomes less than zero"}
{"code": "if ( used == 1 ) { return 1 ; } return 0 ; } if ( dp [ wt ] [ used ] != - 1 ) { return dp [ wt ] [ used ] ; } int ans = 0 ; for ( int i = 1 ; i <= K ; i ++ ) {", "nl": "Return one only if the current path has included edge weight of atleast M"}
{"code": "if ( i >= M ) { ans += solve ( dp , wt - i , K , M , used 1 ) ; } else { ans += solve ( dp , wt - i , K , M , used ) ; } } return dp [ wt ] [ used ] = ans ; }", "nl": "If the current edge weight is greater than or equal to M , set used as true"}
{"code": "public static void main ( String [ ] args ) { int W = 3 , K = 3 , M = 2 ; int [ ] [ ] dp = new int [ W + 1 ] [ 2 ] ; for ( int i = 0 ; i < W + 1 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } System . out . print ( solve ( dp , W , K , M , 0 ) + \"NEW_LINE\"); } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation of above approach"}
{"code": "static long partitions ( int n ) { long p [ ] = new long [ n + 1 ] ;", "nl": "Function to find the number of partitions of N"}
{"code": "p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; }", "nl": "Base case"}
{"code": "public static void main ( String [ ] args ) { int N = 20 ; System . out . println ( partitions ( N ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find longest increasing path in a matrix ."}
{"code": "static int LIP ( int dp [ ] [ ] , int mat [ ] [ ] , int n , int m , int x , int y ) {", "nl": "Return the length of LIP in 2D matrix"}
{"code": "if ( dp [ x ] [ y ] < 0 ) { int result = 0 ;", "nl": "If value not calculated yet ."}
{"code": "if ( x == n - 1 && y == m - 1 ) return dp [ x ] [ y ] = 1 ;", "nl": "If reach bottom left cell , return 1."}
{"code": "if ( x == n - 1 y == m - 1 ) result = 1 ;", "nl": "If reach the corner of the matrix ."}
{"code": "if ( x + 1 < n && mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) ;", "nl": "If value greater than below cell ."}
{"code": "if ( y + 1 < m && mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) result = Math . max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) ; dp [ x ] [ y ] = result ; } return dp [ x ] [ y ] ; }", "nl": "If value greater than left cell ."}
{"code": "static int wrapper ( int mat [ ] [ ] , int n , int m ) { int dp [ ] [ ] = new int [ 10 ] [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) Arrays . fill ( dp [ i ] , - 1 ) ; return LIP ( dp , mat , n , m , 0 , 0 ) ; }", "nl": "Wrapper function"}
{"code": "public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 2 , 2 , 3 , 4 } , { 3 , 2 , 3 , 4 } , { 4 , 5 , 6 , 7 } , } ; int n = 4 , m = 4 ; System . out . println ( wrapper ( mat , n , m ) ) ; } }", "nl": "Driver program to test above function"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to count total number of paths from a point to origin"}
{"code": "static int countPaths ( int n , int m ) {", "nl": "Recursive function to count number of paths"}
{"code": "if ( n == 0 m == 0 ) return 1 ;", "nl": "If we reach bottom or top left , we are have only one way to reach ( 0 , 0 )"}
{"code": "return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }", "nl": "Else count sum of both ways"}
{"code": "public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( \" \u2581 Number \u2581 of \u2581 Paths \u2581 \" + countPaths ( n , m ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . Arrays ; class GFG { static final int MAX = 100 ;", "nl": "Java program to solve Gold Mine problem"}
{"code": "static int getMaxGold ( int gold [ ] [ ] , int m , int n ) {", "nl": "Returns maximum amount of gold that can be collected when journey started from first column and moves allowed are right , right - up and right - down"}
{"code": "int goldTable [ ] [ ] = new int [ m ] [ n ] ; for ( int [ ] rows : goldTable ) Arrays . fill ( rows , 0 ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) {", "nl": "Create a table for storing intermediate results and initialize all cells to 0. The first row of goldMineTable gives the maximum gold that the miner can collect when starts that row"}
{"code": "int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ;", "nl": "Gold collected on going to the cell on the right ( -> )"}
{"code": "int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ;", "nl": "Gold collected on going to the cell to right up ( / )"}
{"code": "int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ;", "nl": "Gold collected on going to the cell to right down ( \\ )"}
{"code": "goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; } }", "nl": "Max gold collected from taking either of the above 3 paths"}
{"code": "int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }", "nl": "The max amount of gold collected will be the max value in first column of all rows"}
{"code": "public static void main ( String arg [ ] ) { int gold [ ] [ ] = { { 1 , 3 , 1 , 5 } , { 2 , 2 , 4 , 1 } , { 5 , 0 , 2 , 3 } , { 0 , 6 , 1 , 2 } } ; int m = 4 , n = 4 ; System . out . print ( getMaxGold ( gold , m , n ) ) ; } }", "nl": "driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG { public static int M = 100 ;", "nl": "Java program to find minimum adjustment cost of an array"}
{"code": "static int minAdjustmentCost ( int A [ ] , int n , int target ) {", "nl": "Function to find minimum adjustment cost of an array"}
{"code": "int [ ] [ ] dp = new int [ n ] [ M + 1 ] ;", "nl": "dp [ i ] [ j ] stores minimal adjustment cost on changing A [ i ] to j"}
{"code": "for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ;", "nl": "handle first element of array separately"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) {", "nl": "do for rest elements of the array"}
{"code": "for ( int j = 0 ; j <= M ; j ++ ) {", "nl": "replace A [ i ] to j and calculate minimal adjustment cost dp [ i ] [ j ]"}
{"code": "dp [ i ] [ j ] = Integer . MAX_VALUE ;", "nl": "initialize minimal adjustment cost to INT_MAX"}
{"code": "int k = Math . max ( j - target , 0 ) ; for ( ; k <= Math . min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + Math . abs ( A [ i ] - j ) ) ; } }", "nl": "consider all k such that k >= max ( j - target , 0 ) and k <= min ( M , j + target ) and take minimum"}
{"code": "int res = Integer . MAX_VALUE ; for ( int j = 0 ; j <= M ; j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ; return res ; }", "nl": "return minimum value from last row of dp table"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 } ; int n = arr . length ; int target = 10 ; System . out . println ( \" Minimum \u2581 adjustment \u2581 cost \u2581 is \u2581 \" + minAdjustmentCost ( arr , n , target ) ) ; } }", "nl": "Driver program"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int totalCombination ( int L , int R ) {", "nl": "Function to find the number of triplets from the range [ L , R ] having sum of two numbers from the triplet equal to the third number"}
{"code": "int count = 0 ;", "nl": "Stores the total number of triplets"}
{"code": "int K = R - L ;", "nl": "Find the difference of the range"}
{"code": "if ( K < L ) return 0 ;", "nl": "Case 1 : If triplets can 't  be formed, then return 0"}
{"code": "int ans = K - L ;", "nl": "Otherwise"}
{"code": "count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ;", "nl": "Update the total number of triplets"}
{"code": "return count ; }", "nl": "Return the count"}
{"code": "public static void main ( String [ ] args ) { int L = 2 , R = 6 ; System . out . print ( totalCombination ( L , R ) ) ; } }", "nl": "Driven Code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void printArrays ( int n ) {", "nl": "Satisfying the given conditions"}
{"code": "ArrayList < Integer > A = new ArrayList < Integer > ( ) ; ArrayList < Integer > B = new ArrayList < Integer > ( ) ;", "nl": "Declare the two arrays A and B"}
{"code": "for ( int i = 1 ; i <= 2 * n ; i ++ ) {", "nl": "Iterate from range [ 1 , 2 * n ]"}
{"code": "if ( i % 2 == 0 ) A . add ( i ) ; else B . add ( i ) ; }", "nl": "Assign consecutive numbers to same indices of the two arrays"}
{"code": "System . out . print ( \" { \u2581 \" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( A . get ( i ) ) ; if ( i != n - 1 ) System . out . print ( \" , \u2581 \" ) ; } System . out . print ( \" }NEW_LINE\");", "nl": "Print the first array"}
{"code": "System . out . print ( \" { \u2581 \" ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( B . get ( i ) ) ; if ( i != n - 1 ) System . out . print ( \" , \u2581 \" ) ; } System . out . print ( \" \u2581 } \" ) ; }", "nl": "Print the second array , B"}
{"code": "public static void main ( String [ ] args ) { int N = 5 ;", "nl": "Driver code"}
{"code": "printArrays ( N ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void flipBitsOfAandB ( int A , int B ) {", "nl": "Function to flip bits of A and B which are set bits in A and B"}
{"code": "for ( int i = 0 ; i < 32 ; i ++ ) {", "nl": "Iterater all possible bits of A and B"}
{"code": "if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) {", "nl": "If ith bit is set in both A and B"}
{"code": "A = A ^ ( 1 << i ) ;", "nl": "Clear i - th bit of A"}
{"code": "B = B ^ ( 1 << i ) ; } }", "nl": "Clear i - th bit of B"}
{"code": "System . out . print ( A + \" \u2581 \" + B ) ; }", "nl": "Print A and B"}
{"code": "public static void main ( String [ ] args ) { int A = 7 , B = 4 ; flipBitsOfAandB ( A , B ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to find count of distinct pair sum between two 1 to N value Arrays"}
{"code": "static int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; }", "nl": "Function to find the distinct sums"}
{"code": "public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( findDistinctSums ( N ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static int countSubstrings ( String str ) {", "nl": "Function to count the number of substrings consists of 0 , 1 , and 2"}
{"code": "int [ ] freq = new int [ 3 ] ;", "nl": "Initialize frequency array of size 3"}
{"code": "int count = 0 ; int i = 0 ;", "nl": "Stores the resultant count"}
{"code": "for ( int j = 0 ; j < str . length ( ) ; j ++ ) {", "nl": "Traversing string str"}
{"code": "freq [ str . charAt ( j ) - '0' ] ++ ;", "nl": "Update frequency array"}
{"code": "while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str . charAt ( i ++ ) - '0' ] -- ; }", "nl": "If all the characters are present counting number of substrings possible"}
{"code": "count += i ; }", "nl": "Update number of substrings"}
{"code": "return count ; }", "nl": "Return the number of substrings"}
{"code": "public static void main ( String [ ] args ) { String str = \"00021\" ; System . out . println ( countSubstrings ( str ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int minFlips ( String str ) {", "nl": "Function to find the minimum number of flips to make all three pairs of consecutive characters different"}
{"code": "int count = 0 ;", "nl": "Stores resultant count of pairs"}
{"code": "if ( str . length ( ) <= 2 ) { return 0 ; }", "nl": "Base Case"}
{"code": "for ( int i = 0 ; i < str . length ( ) - 2 {", "nl": "Iterate over the range [ 0 , N - 2 ]"}
{"code": "if ( str . charAt ( i ) == str . charAt ( i + 1 ) && str . charAt ( i + 2 ) == str . charAt ( i + 1 ) ) { i = i + 3 ; count ++ ; } else { i ++ ; } }", "nl": "If the consecutive 3 numbers are the same then increment the count and the counter"}
{"code": "return count ; }", "nl": "Return the answer"}
{"code": "public static void main ( String [ ] args ) { String S = \"0011101\" ; System . out . println ( minFlips ( S ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . awt . * ; import java . util . * ; class GFG {", "nl": "Java program for above approach"}
{"code": "static String convertToHex ( int num ) { StringBuilder temp = new StringBuilder ( ) ; while ( num != 0 ) { int rem = num % 16 ; char c ; if ( rem < 10 ) { c = ( char ) ( rem + 48 ) ; } else { c = ( char ) ( rem + 87 ) ; } temp . append ( c ) ; num = num / 16 ; } return temp . toString ( ) ; }", "nl": "Function to convert Decimal to Hex"}
{"code": "static String encryptString ( String S , int N ) { StringBuilder ans = new StringBuilder ( ) ;", "nl": "Function to encrypt the string"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { char ch = S . charAt ( i ) ; int count = 0 ; String hex ;", "nl": "Iterate the characters of the string"}
{"code": "while ( i < N && S . charAt ( i ) == ch ) {", "nl": "Iterate until S [ i ] is equal to ch"}
{"code": "count ++ ; i ++ ; }", "nl": "Update count and i"}
{"code": "i -- ;", "nl": "Decrement i by 1"}
{"code": "hex = convertToHex ( count ) ;", "nl": "Convert count to hexadecimal representation"}
{"code": "ans . append ( ch ) ;", "nl": "Append the character"}
{"code": "ans . append ( hex ) ; }", "nl": "Append the characters frequency in hexadecimal representation"}
{"code": "ans . reverse ( ) ;", "nl": "Reverse the obtained answer"}
{"code": "return ans . toString ( ) ; }", "nl": "Return required answer"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "String S = \" abc \" ; int N = S . length ( ) ;", "nl": "Given Input"}
{"code": "System . out . println ( encryptString ( S , N ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int binomialCoeff ( int n , int k ) { int res = 1 ;", "nl": "Function to calculate and return the value of Binomial Coefficient C ( n , k )"}
{"code": "if ( k > n - k ) k = n - k ;", "nl": "Since C ( n , k ) = C ( n , n - k )"}
{"code": "for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }", "nl": "Calculate the value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- - * 1 ]"}
{"code": "static int countOfString ( int N ) {", "nl": "Function to return the count of binary Strings of length N such that frequency of 1 ' s \u2581 exceed \u2581 that \u2581 of \u2581 0' s"}
{"code": "int Stotal = ( int ) Math . pow ( 2 , N ) ;", "nl": "Count of N - length binary Strings"}
{"code": "int Sequal = 0 ;", "nl": "Count of N - length binary Strings having equal count of 0 ' s \u2581 and \u2581 1' s"}
{"code": "if ( N % 2 == 0 ) Sequal = binomialCoeff ( N , N / 2 ) ; int S1 = ( Stotal - Sequal ) / 2 ; return S1 ; }", "nl": "For even length Strings"}
{"code": "public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( countOfString ( N ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static String removeCharRecursive ( String str , char X ) {", "nl": "Function to remove all occurrences of a character in the string"}
{"code": "if ( str . length ( ) == 0 ) { return \" \" ; }", "nl": "Base Case"}
{"code": "if ( str . charAt ( 0 ) == X ) {", "nl": "Check the first character of the given string"}
{"code": "return removeCharRecursive ( str . substring ( 1 ) , X ) ; }", "nl": "Pass the rest of the string to recursion Function call"}
{"code": "return str . charAt ( 0 ) + removeCharRecursive ( str . substring ( 1 ) , X ) ; }", "nl": "Add the first character of str and string from recursion"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "String str = \" geeksforgeeks \" ;", "nl": "Given String"}
{"code": "char X = ' e ' ;", "nl": "Given character"}
{"code": "str = removeCharRecursive ( str , X ) ; System . out . println ( str ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static boolean isValid ( char a1 , char a2 , String str , int flag ) { char v1 , v2 ;", "nl": "Function checks whether given time is correct"}
{"code": "if ( flag == 0 ) { v1 = str . charAt ( 4 ) ; v2 = str . charAt ( 3 ) ; } else {", "nl": "To check minute value of time"}
{"code": "v1 = str . charAt ( 1 ) ; v2 = str . charAt ( 0 ) ; }", "nl": "To check hour value of time"}
{"code": "if ( v1 != a1 && v1 != ' ? ' ) return false ; if ( v2 != a2 && v2 != ' ? ' ) return false ; return true ; }", "nl": "Changes in value is not allowed at position where ' ? ' is not present"}
{"code": "static boolean inRange ( int hh , int mm , int L , int R ) { int a = Math . abs ( hh - mm ) ;", "nl": "Function checks whether the absolute difference between hour and minute value is within [ L , R ]"}
{"code": "if ( a < L a > R ) return false ; return true ; }", "nl": "Checks if the difference is outside the give range"}
{"code": "static void displayTime ( int hh , int mm ) { if ( hh > 10 ) System . out . print ( hh + \" : \" ) ; else if ( hh < 10 ) System . out . print ( \"0\" + hh + \" : \" ) ; if ( mm > 10 ) System . out . println ( mm ) ; else if ( mm < 10 ) System . out . println ( \"0\" + mm ) ; }", "nl": "Displays time in proper 24 - hour format"}
{"code": "static void maximumTimeWithDifferenceInRange ( String str , int L , int R ) { int i = 0 , j = 0 ; int h1 , h2 , m1 , m2 ;", "nl": "Function find the desired value of time whose difference lies in the range [ L , R ]"}
{"code": "for ( i = 23 ; i >= 0 ; i -- ) { h1 = i % 10 ; h2 = i / 10 ;", "nl": "Decrease hour value from 23 to 0"}
{"code": "if ( ! isValid ( ( char ) h1 , ( char ) h2 , str , 1 ) ) { continue ; }", "nl": "Check if the hour value is valid if not valid then no need to change minute value , since time will still remain in valid , to check hour value flag is set to 1."}
{"code": "for ( j = 59 ; j >= 0 ; j -- ) { m1 = j % 10 ; m2 = j / 10 ;", "nl": "Decrease minute value from 59 to 0"}
{"code": "if ( ! isValid ( ( char ) m1 , ( char ) m2 , str , 0 ) ) { continue ; } if ( inRange ( i , j , L , R ) ) { displayTime ( i , j ) ; return ; } } } if ( inRange ( i , j , L , R ) ) displayTime ( i , j ) ; else System . out . println ( \" - 1\" ) ; }", "nl": "Check if the minute value is valid , if not valid then skip the current iteration , to check ' minute ' value flag is set to 0."}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "String timeValue = \" ? ? : ? ? \" ;", "nl": "Input time"}
{"code": "int L = 20 , R = 39 ; maximumTimeWithDifferenceInRange ( timeValue , L , R ) ; } }", "nl": "Difference range"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static boolean check ( String s , int n ) {", "nl": "Function to check String str can be split a String into even length palindromic subStrings"}
{"code": "Stack < Character > st = new Stack < Character > ( ) ;", "nl": "Initialize a stack"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Iterate the String"}
{"code": "if ( ! st . isEmpty ( ) && st . peek ( ) == s . charAt ( i ) ) st . pop ( ) ;", "nl": "If the i - th character is same as that at the top of the stack then pop the top element"}
{"code": "else st . add ( s . charAt ( i ) ) ; }", "nl": "Else push the current charactor into the stack"}
{"code": "if ( st . isEmpty ( ) ) { return true ; }", "nl": "If the stack is empty , then even palindromic subStrings are possible"}
{"code": "else { return false ; } }", "nl": "Else not - possible"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "String str = \" aanncddc \" ; int n = str . length ( ) ;", "nl": "Given String"}
{"code": "if ( check ( str , n ) ) { System . out . print ( \" Yes \" + \"NEW_LINE\"); } else { System . out . print ( \" No \" + \"NEW_LINE\"); } } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG { static void findNumOfValidWords ( Vector < String > w , Vector < String > p ) {", "nl": "Java program for the above approach"}
{"code": "HashMap < Integer , Integer > m = new HashMap < > ( ) ;", "nl": "To store the frequency of String after bitmasking"}
{"code": "Vector < Integer > res = new Vector < > ( ) ;", "nl": "To store result for each string in arr2 [ ]"}
{"code": "for ( String s : w ) { int val = 0 ;", "nl": "Traverse the arr1 [ ] and bitmask each string in it"}
{"code": "for ( char c : s . toCharArray ( ) ) { val = val | ( 1 << ( c - ' a ' ) ) ; }", "nl": "Bitmasking for each String s"}
{"code": "if ( m . containsKey ( val ) ) m . put ( val , m . get ( val ) + 1 ) ; else m . put ( val , 1 ) ; }", "nl": "Update the frequency of String with it 's bitmasking value"}
{"code": "for ( String s : p ) { int val = 0 ;", "nl": "Traverse the arr2 [ ]"}
{"code": "for ( char c : s . toCharArray ( ) ) { val = val | ( 1 << ( c - ' a ' ) ) ; } int temp = val ; int first = s . charAt ( 0 ) - ' a ' ; int count = 0 ; while ( temp != 0 ) {", "nl": "Bitmasking for each String s"}
{"code": "if ( ( ( temp >> first ) & 1 ) == 1 ) { if ( m . containsKey ( temp ) ) { count += m . get ( temp ) ; } }", "nl": "Check if temp is present in an unordered_map or not"}
{"code": "temp = ( temp - 1 ) & val ; }", "nl": "Check for next set bit"}
{"code": "res . add ( count ) ; }", "nl": "Push the count for current String in resultant array"}
{"code": "for ( int it : res ) { System . out . println ( it ) ; } }", "nl": "Print the count for each String"}
{"code": "public static void main ( String [ ] args ) { Vector < String > arr1 = new Vector < > ( ) ; arr1 . add ( \" aaaa \" ) ; arr1 . add ( \" asas \" ) ; arr1 . add ( \" able \" ) ; arr1 . add ( \" ability \" ) ; arr1 . add ( \" actt \" ) ; arr1 . add ( \" actor \" ) ; arr1 . add ( \" access \" ) ; Vector < String > arr2 = new Vector < > ( ) ; arr2 . add ( \" aboveyz \" ) ; arr2 . add ( \" abrodyz \" ) ; arr2 . add ( \" absolute \" ) ; arr2 . add ( \" absoryz \" ) ; arr2 . add ( \" actresz \" ) ; arr2 . add ( \" gaswxyz \" ) ;", "nl": "Driver Code"}
{"code": "findNumOfValidWords ( arr1 , arr2 ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to maximize the value of the decimal equivalent given in the binary form"}
{"code": "static void flip ( String s ) { StringBuilder sb = new StringBuilder ( s ) ; for ( int i = 0 ; i < sb . length ( ) ; i ++ ) {", "nl": "Function to print the binary number"}
{"code": "if ( sb . charAt ( i ) == '0' ) {", "nl": "Check if the current number is 0"}
{"code": "while ( sb . charAt ( i ) == '0' ) {", "nl": "Find the continuous 0 s"}
{"code": "sb . setCharAt ( i , '1' ) ; i ++ ; }", "nl": "Replace initially occurring 0 with 1"}
{"code": "break ; } } System . out . println ( sb . toString ( ) ) ; }", "nl": "Break out of loop if 1 occurs"}
{"code": "public static void main ( String [ ] args ) { String s = \"100010001\" ; flip ( s ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void getOrgString ( String s ) {", "nl": "Function to return the original string after converting it back from camelCase"}
{"code": "System . out . print ( s . charAt ( 0 ) ) ;", "nl": "Print the first character as it is"}
{"code": "int i = 1 ; while ( i < s . length ( ) ) {", "nl": "Traverse the rest of the characters one by one"}
{"code": "if ( s . charAt ( i ) >= ' A ' && s . charAt ( i ) <= ' Z ' ) System . out . print ( \" \u2581 \" + Character . toLowerCase ( s . charAt ( i ) ) ) ;", "nl": "If current character is uppercase print space followed by the current character in lowercase"}
{"code": "else System . out . print ( s . charAt ( i ) ) ; i ++ ; } }", "nl": "Else print the current character"}
{"code": "public static void main ( String [ ] args ) { String s = \" ILoveGeeksForGeeks \" ; getOrgString ( s ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; import java . lang . * ; class GFG {", "nl": "Java program to find the occurrences of character x in the infinite repeated string upto length n"}
{"code": "static int countChar ( String str , char x ) { int count = 0 ; int n = 10 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) count ++ ;", "nl": "Function to count the character ' a '"}
{"code": "int repetitions = n / str . length ( ) ; count = count * repetitions ;", "nl": "atleast k repetition are required"}
{"code": "for ( int i = 0 ; i < n % str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == x ) count ++ ; } return count ; }", "nl": "if n is not the multiple of the string size check for the remaining repeating character ."}
{"code": "public static void main ( String args [ ] ) { String str = \" abcac \" ; System . out . println ( countChar ( str , ' a ' ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static void countFreq ( int arr [ ] , int n , int limit ) {", "nl": "Java program to count frequencies of array items having small values ."}
{"code": "int [ ] count = new int [ limit + 1 ] ;", "nl": "Create an array to store counts . The size of array is limit + 1 and all values are initially 0"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) System . out . println ( i + \" \u2581 \" + count [ i ] ) ; }", "nl": "Traverse through array elements and count frequencies ( assuming that elements are limited by limit )"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 } ; int n = arr . length ; int limit = 10 ; countFreq ( arr , n , limit ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Program to check if the binary string contains m consecutive 1 ' s \u2581 or \u2581 0' s"}
{"code": "static boolean check ( String s , int m ) {", "nl": "Function that checks if the binary string contains m consecutive 1 ' s \u2581 or \u2581 0' s"}
{"code": "int l = s . length ( ) ;", "nl": "length of binary string"}
{"code": "int c1 = 0 ;", "nl": "counts zeros"}
{"code": "int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '0' ) { c2 = 0 ;", "nl": "counts 1 's"}
{"code": "c1 ++ ; } else { c1 = 0 ;", "nl": "count consecutive 0 's"}
{"code": "c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; }", "nl": "count consecutive 1 's"}
{"code": "public static void main ( String [ ] args ) { String s = \"001001\" ; int m = 2 ;", "nl": "Drivers Code"}
{"code": "if ( check ( s , m ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }", "nl": "function call"}
{"code": "class GFG {", "nl": "Java implementation to find product of digits of elements at k - th level"}
{"code": "static int productAtKthLevel ( String tree , int k ) { int level = - 1 ;", "nl": "Function to find product of digits of elements at k - th level"}
{"code": "int product = 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Initialize result"}
{"code": "if ( tree . charAt ( i ) == ' ( ' ) level ++ ;", "nl": "increasing level number"}
{"code": "else if ( tree . charAt ( i ) == ' ) ' ) level -- ; else {", "nl": "decreasing level number"}
{"code": "if ( level == k ) product *= ( tree . charAt ( i ) - '0' ) ; } }", "nl": "check if current level is the desired level or not"}
{"code": "return product ; }", "nl": "required product"}
{"code": "public static void main ( String [ ] args ) { String tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" ; int k = 2 ; System . out . println ( productAtKthLevel ( tree , k ) ) ; } }", "nl": "Driver program"}
{"code": "class GFG {", "nl": "Java code to form string after removing duplicates from rows and columns ."}
{"code": "static void findDuplciates ( String [ ] a , int n , int m ) {", "nl": "Function to check duplicates in row and column"}
{"code": "boolean [ ] [ ] isPresent = new boolean [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { isPresent [ i ] [ j ] = false ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) {", "nl": "Create an array isPresent and initialize all entries of it as false . The value of isPresent [ i , j ] is going to be true if s [ i , j ] is present in its row or column ."}
{"code": "for ( int k = 0 ; k < n ; k ++ ) { if ( a [ i ] . charAt ( j ) == a [ k ] . charAt ( j ) && i != k ) { isPresent [ i ] [ j ] = true ; isPresent [ k ] [ j ] = true ; } }", "nl": "Checking every row for duplicates of a [ i , j ]"}
{"code": "for ( int k = 0 ; k < m ; k ++ ) { if ( a [ i ] . charAt ( j ) == a [ i ] . charAt ( k ) && j != k ) { isPresent [ i ] [ j ] = true ; isPresent [ i ] [ k ] = true ; } } } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ )", "nl": "Checking every column for duplicate characters"}
{"code": "if ( isPresent [ i ] [ j ] == false ) System . out . print ( a [ i ] . charAt ( j ) ) ; }", "nl": "If the character is unique in its row and column"}
{"code": "public static void main ( String [ ] args ) { int n = 2 , m = 2 ;", "nl": "Driver code"}
{"code": "String [ ] a = new String [ ] { \" zx \" , \" xz \" } ;", "nl": "character array"}
{"code": "findDuplciates ( a , n , m ) ; } }", "nl": "Calling function"}
{"code": "class GFG { static boolean isValidISBN ( String isbn ) {", "nl": "Java program to check if a given ISBN isvalid or not"}
{"code": "int n = isbn . length ( ) ; if ( n != 10 ) return false ;", "nl": "length must be 10"}
{"code": "int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn . charAt ( i ) - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; }", "nl": "Computing weighted sum of first 9 digits"}
{"code": "char last = isbn . charAt ( 9 ) ; if ( last != ' X ' && ( last < '0' last > '9' ) ) return false ;", "nl": "Checking last digit ."}
{"code": "sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ;", "nl": "If last digit is ' X ' , add 10 to sum , else add its value"}
{"code": "return ( sum % 11 == 0 ) ; }", "nl": "Return true if weighted sum of digits is divisible by 11."}
{"code": "public static void main ( String [ ] args ) { String isbn = \"007462542X \" ; if ( isValidISBN ( isbn ) ) System . out . print ( \" Valid \" ) ; else System . out . print ( \" Invalid \" ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to reverse order of vowels"}
{"code": "static boolean isVowel ( char c ) { return ( c == ' a ' c == ' A ' c == ' e ' c == ' E ' c == ' i ' c == ' I ' c == ' o ' c == ' O ' c == ' u ' c == ' U ' ) ; }", "nl": "utility function to check for vowel"}
{"code": "static String reverseVowel ( String str1 ) { int j = 0 ;", "nl": "Function to reverse order of vowels"}
{"code": "char [ ] str = str1 . toCharArray ( ) ; String vowel = \" \" ; for ( int i = 0 ; i < str . length ; i ++ ) { if ( isVowel ( str [ i ] ) ) { j ++ ; vowel += str [ i ] ; } }", "nl": "Storing the vowels separately"}
{"code": "for ( int i = 0 ; i < str . length ; i ++ ) { if ( isVowel ( str [ i ] ) ) { str [ i ] = vowel . charAt ( -- j ) ; } } return String . valueOf ( str ) ; }", "nl": "Placing the vowels in the reverse order in the string"}
{"code": "public static void main ( String [ ] args ) { String str = \" hello \u2581 world \" ; System . out . println ( reverseVowel ( str ) ) ; } }", "nl": "Driver function"}
{"code": "class GFG {", "nl": "Java program to find the string which contain the first character of each word of another string ."}
{"code": "static String firstLetterWord ( String str ) { String result = \" \" ;", "nl": "Function to find string which has first character of each word ."}
{"code": "boolean v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) {", "nl": "Traverse the string ."}
{"code": "if ( str . charAt ( i ) == ' \u2581 ' ) { v = true ; }", "nl": "If it is space , set v as true ."}
{"code": "else if ( str . charAt ( i ) != ' \u2581 ' && v == true ) { result += ( str . charAt ( i ) ) ; v = false ; } } return result ; }", "nl": "Else check if v is true or not . If true , copy character in output string and set v as false ."}
{"code": "public static void main ( String [ ] args ) { String str = \" geeks \u2581 for \u2581 geeks \" ; System . out . println ( firstLetterWord ( str ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Arrays ; class GFG { static int ans = 0 ;", "nl": "Java implementation of the approach"}
{"code": "static void dfs ( int i , int j , int [ ] [ ] grid , boolean [ ] [ ] vis , int z , int z_count ) { int n = grid . length , m = grid [ 0 ] . length ;", "nl": "Function for dfs . i , j == > Current cell indexes vis == > To mark visited cells ans == > Result z == > Current count 0 s visited z_count == > Total 0 s present"}
{"code": "vis [ i ] [ j ] = true ; if ( grid [ i ] [ j ] == 0 )", "nl": "Mark the block as visited"}
{"code": "z ++ ;", "nl": "update the count"}
{"code": "if ( grid [ i ] [ j ] == 2 ) {", "nl": "If end block reached"}
{"code": "if ( z == z_count ) ans ++ ; vis [ i ] [ j ] = false ; return ; }", "nl": "If path covered all the non - obstacle blocks"}
{"code": "if ( i >= 1 && ! vis [ i - 1 ] [ j ] && grid [ i - 1 ] [ j ] != - 1 ) dfs ( i - 1 , j , grid , vis , z , z_count ) ;", "nl": "Up"}
{"code": "if ( i < n - 1 && ! vis [ i + 1 ] [ j ] && grid [ i + 1 ] [ j ] != - 1 ) dfs ( i + 1 , j , grid , vis , z , z_count ) ;", "nl": "Down"}
{"code": "if ( j >= 1 && ! vis [ i ] [ j - 1 ] && grid [ i ] [ j - 1 ] != - 1 ) dfs ( i , j - 1 , grid , vis , z , z_count ) ;", "nl": "Left"}
{"code": "if ( j < m - 1 && ! vis [ i ] [ j + 1 ] && grid [ i ] [ j + 1 ] != - 1 ) dfs ( i , j + 1 , grid , vis , z , z_count ) ;", "nl": "Right"}
{"code": "vis [ i ] [ j ] = false ; }", "nl": "Unmark the block ( unvisited )"}
{"code": "static int uniquePaths ( int [ ] [ ] grid ) {", "nl": "Function to return the count of the unique paths"}
{"code": "int n = grid . length , m = grid [ 0 ] . length ; boolean [ ] [ ] vis = new boolean [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { Arrays . fill ( vis [ i ] , false ) ; } int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) {", "nl": "int z_count = 0 ; Total 0 s present"}
{"code": "if ( grid [ i ] [ j ] == 0 ) z_count ++ ; else if ( grid [ i ] [ j ] == 1 ) {", "nl": "Count non - obstacle blocks"}
{"code": "x = i ; y = j ; } } } dfs ( x , y , grid , vis , 0 , z_count ) ; return ans ; }", "nl": "Starting position"}
{"code": "public static void main ( String [ ] args ) { int [ ] [ ] grid = { { 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 2 , - 1 } } ; System . out . println ( uniquePaths ( grid ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Arrays ; class GFG {", "nl": "Java Program to find the number of unordered pairs ( x , y ) which satisfy the given equation for the array"}
{"code": "static int numPairs ( int a [ ] , int n ) { int ans , i , index ;", "nl": "Return the number of unordered pairs satisfying the conditions"}
{"code": "ans = 0 ;", "nl": "ans stores the number of unordered pairs"}
{"code": "for ( i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ;", "nl": "Making each value of array to positive"}
{"code": "Arrays . sort ( a ) ;", "nl": "Sort the array"}
{"code": "for ( i = 0 ; i < n ; i ++ ) { index = 2 ; ans += index - i - 1 ; }", "nl": "For each index calculating the right boundary for the unordered pairs"}
{"code": "return ans ; }", "nl": "Return the final result"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = new int [ ] { 3 , 6 } ; int n = a . length ; System . out . println ( numPairs ( a , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static int areaOfSquare ( int S ) {", "nl": "Function to find the area of a square"}
{"code": "int area = S * S ; return area ; }", "nl": "Use above formula"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int S = 5 ;", "nl": "Given Side of square"}
{"code": "System . out . println ( areaOfSquare ( S ) ) ; } }", "nl": "Function call"}
{"code": "class GFG { static int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }", "nl": "Java program to implement the above approach"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int x = 3 ;", "nl": "Number of circles"}
{"code": "int y = 4 ;", "nl": "Number of straight lines"}
{"code": "System . out . print ( maxPointOfIntersection ( x , y ) ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java program to find nth Icosihenagonal number"}
{"code": "static int Icosihenagonal_num ( int n ) {", "nl": "Function to find Icosihenagonal number"}
{"code": "return ( 19 * n * n - 17 * n ) / 2 ; }", "nl": "Formula to calculate nth Icosihenagonal number"}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( Icosihenagonal_num ( n ) + \"NEW_LINE\"); n = 10 ; System . out . print ( Icosihenagonal_num ( n ) + \"NEW_LINE\"); } }", "nl": "Driver Code"}
{"code": "class GFG { static double [ ] find_Centroid ( double v [ ] [ ] ) { double [ ] ans = new double [ 2 ] ; int n = v . length ; double signedArea = 0 ;", "nl": "Java implementation of the approach"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { double x0 = v [ i ] [ 0 ] , y0 = v [ i ] [ 1 ] ; double x1 = v [ ( i + 1 ) % n ] [ 0 ] , y1 = v [ ( i + 1 ) % n ] [ 1 ] ;", "nl": "For all vertices"}
{"code": "double A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ;", "nl": "Calculate value of A using shoelace formula"}
{"code": "ans [ 0 ] += ( x0 + x1 ) * A ; ans [ 1 ] += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) ; ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) ; return ans ; }", "nl": "Calculating coordinates of centroid of polygon"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "double vp [ ] [ ] = { { 1 , 2 } , { 3 , - 4 } , { 6 , - 7 } } ; double [ ] ans = find_Centroid ( vp ) ; System . out . println ( ans [ 0 ] + \" \u2581 \" + ans [ 1 ] ) ; } }", "nl": "Coordinate of the vertices"}
{"code": "import java . io . * ; class GFG {", "nl": "java implementation of the approach"}
{"code": "public static void main ( String [ ] args ) { int d = 10 ; double a ;", "nl": "Driver code"}
{"code": "a = ( double ) ( 360 - ( 6 * d ) ) / 4 ;", "nl": "according to formula derived above"}
{"code": "System . out . print ( a + \" , \u2581 \" + ( a + d ) + \" , \u2581 \" + ( a + ( 2 * d ) ) + \" , \u2581 \" + ( a + ( 3 * d ) ) ) ; } }", "nl": "print all the angles"}
{"code": "import java . io . * ; import java . lang . Math ; class GFG {", "nl": "Java program to find the Distance between two parallel Planes in 3 D ."}
{"code": "static void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = Math . abs ( ( c2 * z1 + d2 ) ) / ( float ) ( Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; System . out . println ( \" Perpendicular \u2581 distance \u2581 is \u2581 \" + d ) ; } else System . out . println ( \" Planes \u2581 are \u2581 not \u2581 parallel \" ) ; }", "nl": "Function to find distance"}
{"code": "public static void main ( String [ ] args ) { float a1 = 1 ; float b1 = 2 ; float c1 = - 1 ; float d1 = 1 ; float a2 = 3 ; float b2 = 6 ; float c2 = - 3 ; float d2 = - 4 ; distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }", "nl": "Function to calculate factorial"}
{"code": "static long numOfNecklace ( int N ) {", "nl": "Function to count number of ways to make 2 necklace having exactly N / 2 beads if each bead is considered different"}
{"code": "long ans = factorial ( N ) / ( factorial ( N / 2 ) * factorial ( N / 2 ) ) ;", "nl": "Number of ways to choose N / 2 beads from N beads"}
{"code": "ans = ans * factorial ( N / 2 - 1 ) ; ans = ans * factorial ( N / 2 - 1 ) ;", "nl": "Number of ways to permute N / 2 beads"}
{"code": "ans /= 2 ;", "nl": "Divide ans by 2 to remove repetitions"}
{"code": "return ans ; }", "nl": "Return ans"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 4 ;", "nl": "Given Input"}
{"code": "System . out . println ( numOfNecklace ( N ) ) ; } }", "nl": "Function Call"}
{"code": "import java . lang . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static String isDivisibleByDivisor ( int S , int D ) {", "nl": "Function to check if S is divisible by D while changing S to ( S + S % D )"}
{"code": "S %= D ;", "nl": "V ( 0 ) = S % D"}
{"code": "Set < Integer > hashMap = new HashSet < > ( ) ; hashMap . add ( S ) ; for ( int i = 0 ; i <= D ; i ++ ) {", "nl": "Stores the encountered values"}
{"code": "S += ( S % D ) ; S %= D ;", "nl": "V ( i ) = ( V ( i - 1 ) + V ( i - 1 ) % D ) % D"}
{"code": "if ( hashMap . contains ( S ) ) {", "nl": "Check if the value has already been encountered"}
{"code": "if ( S == 0 ) { return \" Yes \" ; } return \" No \" ; }", "nl": "Edge Case"}
{"code": "else hashMap . add ( S ) ; } return \" Yes \" ; }", "nl": "Otherwise , insert it into the hashmap"}
{"code": "public static void main ( String [ ] args ) { int S = 3 , D = 6 ; System . out . println ( isDivisibleByDivisor ( S , D ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for above approach"}
{"code": "static void minimumSteps ( int x , int y ) {", "nl": "Function to count the number of steps required to convert ( x , y ) to ( 1 , 1 )"}
{"code": "int cnt = 0 ;", "nl": "Store the required result"}
{"code": "while ( x != 0 && y != 0 ) {", "nl": "Iterate while both x and y are not equal to 0"}
{"code": "if ( x > y ) {", "nl": "If x is greater than y"}
{"code": "cnt += x / y ; x %= y ; }", "nl": "Update count and value of x"}
{"code": "else {", "nl": "Otherwise"}
{"code": "cnt += y / x ; y %= x ; } } cnt -- ;", "nl": "Update count and value of y"}
{"code": "if ( x > 1 y > 1 ) cnt = - 1 ;", "nl": "If both x and y > 1"}
{"code": "System . out . println ( cnt ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int x = 3 , y = 1 ; minimumSteps ( x , y ) ; } }", "nl": "Given X and Y"}
{"code": "import java . util . Stack ; class GFG {", "nl": "Java implementation of above approach ."}
{"code": "static boolean check ( int A [ ] , int N ) {", "nl": "Function to check if A [ ] is Stack Sortable or Not ."}
{"code": "Stack < Integer > S = new Stack < Integer > ( ) ;", "nl": "Stack S"}
{"code": "int B_end = 0 ;", "nl": "Pointer to the end value of array B ."}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traversing each element of A [ ] from starting Checking if there is a valid operation that can be performed ."}
{"code": "if ( ! S . empty ( ) ) {", "nl": "If the stack is not empty"}
{"code": "int top = S . peek ( ) ;", "nl": "Top of the Stack ."}
{"code": "while ( top == B_end + 1 ) {", "nl": "If the top of the stack is Equal to B_end + 1 , we will pop it And increment B_end by 1."}
{"code": "B_end = B_end + 1 ;", "nl": "if current top is equal to B_end + 1 , we will increment B_end to B_end + 1"}
{"code": "S . pop ( ) ;", "nl": "Pop the top element ."}
{"code": "if ( S . empty ( ) ) { break ; }", "nl": "If the stack is empty We cannot further perfom this operation . Therefore break"}
{"code": "top = S . peek ( ) ; }", "nl": "Current Top"}
{"code": "if ( S . empty ( ) ) { S . push ( A [ i ] ) ; } else { top = S . peek ( ) ;", "nl": "If stack is empty Push the Current element"}
{"code": "if ( A [ i ] < top ) { S . push ( A [ i ] ) ;", "nl": "If the Current element of the array A [ ] if smaller than the top of the stack We can push it in the Stack ."}
{"code": "} else {", "nl": "Else We cannot sort the array Using any valid operations ."}
{"code": "return false ; } } } else {", "nl": "Not Stack Sortable"}
{"code": "S . push ( A [ i ] ) ; } }", "nl": "If the stack is empty push the current element in the stack ."}
{"code": "return true ; }", "nl": "Stack Sortable"}
{"code": "public static void main ( String [ ] args ) { int A [ ] = { 4 , 1 , 2 , 3 } ; int N = A . length ; if ( check ( A , N ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }", "nl": "Driver 's Code"}
{"code": "import java . util . Stack ; public class GFG {", "nl": "Java Code to count minimum reversal for making an expression balanced ."}
{"code": "static int countMinReversals ( String expr ) { int len = expr . length ( ) ;", "nl": "Method count minimum reversal for making an expression balanced . Returns - 1 if expression cannot be balanced"}
{"code": "if ( len % 2 != 0 ) return - 1 ;", "nl": "length of expression must be even to make it balanced by using reversals ."}
{"code": "Stack < Character > s = new Stack < > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = expr . charAt ( i ) ; if ( c == ' } ' && ! s . empty ( ) ) { if ( s . peek ( ) == ' { ' ) s . pop ( ) ; else s . push ( c ) ; } else s . push ( c ) ; }", "nl": "After this loop , stack contains unbalanced part of expression , i . e . , expression of the form \" } } . . } { { . . { \""}
{"code": "int red_len = s . size ( ) ;", "nl": "Length of the reduced expression red_len = ( m + n )"}
{"code": "int n = 0 ; while ( ! s . empty ( ) && s . peek ( ) == ' { ' ) { s . pop ( ) ; n ++ ; }", "nl": "count opening brackets at the end of stack"}
{"code": "return ( red_len / 2 + n % 2 ) ; }", "nl": "return ceil ( m / 2 ) + ceil ( n / 2 ) which is actually equal to ( m + n ) / 2 + n % 2 when m + n is even ."}
{"code": "public static void main ( String [ ] args ) { String expr = \" } } { { \" ; System . out . println ( countMinReversals ( expr ) ) ; } }", "nl": "Driver method"}
{"code": "import java . util . * ; public class GFG {", "nl": "Java Code to count minimum reversal for making an expression balanced ."}
{"code": "static int countMinReversals ( String expr ) { int len = expr . length ( ) ; int ans ;", "nl": "Method count minimum reversal for making an expression balanced . Returns - 1 if expression cannot be balanced"}
{"code": "if ( len % 2 != 0 ) { return - 1 ; } int left_brace = 0 , right_brace = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char ch = expr . charAt ( i ) ;", "nl": "Expressions of odd lengths cannot be balanced"}
{"code": "if ( ch == ' { ' ) { left_brace ++ ; }", "nl": "If we find a left bracket then we simply increment the left bracket"}
{"code": "else { if ( left_brace == 0 ) { right_brace ++ ; } else { left_brace -- ; } } } ans = ( int ) ( Math . ceil ( ( 0.0 + left_brace ) / 2 ) + Math . ceil ( ( 0.0 + right_brace ) / 2 ) ) ; return ans ; }", "nl": "Else if left bracket is 0 then we find unbalanced right bracket and increment right bracket or if the expression is balanced then we decrement left"}
{"code": "public static void main ( String [ ] args ) { String expr = \" } } { { \" ; System . out . println ( countMinReversals ( expr ) ) ; } }", "nl": "Driver method"}
{"code": "class GFG {", "nl": "Java program to print minimum number that can be formed from a given sequence of Is and Ds"}
{"code": "static void PrintMinNumberForPattern ( String arr ) {", "nl": "Prints the minimum number that can be formed from input sequence of I ' s \u2581 and \u2581 D ' s"}
{"code": "int curr_max = 0 ;", "nl": "Initialize current_max ( to make sure that we don 't use repeated character"}
{"code": "int last_entry = 0 ; int j ;", "nl": "Initialize last_entry ( Keeps track for last printed digit )"}
{"code": "for ( int i = 0 ; i < arr . length ( ) ; i ++ ) {", "nl": "Iterate over input array"}
{"code": "int noOfNextD = 0 ; switch ( arr . charAt ( i ) ) { case ' I ' :", "nl": "Initialize ' noOfNextD ' to get count of next D 's available"}
{"code": "j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == ' D ' ) { noOfNextD ++ ; j ++ ; } if ( i == 0 ) { curr_max = noOfNextD + 2 ;", "nl": "If letter is ' I ' Calculate number of next consecutive D 's  available"}
{"code": "System . out . print ( \" \u2581 \" + ++ last_entry ) ; System . out . print ( \" \u2581 \" + curr_max ) ;", "nl": "If ' I ' is first letter , print incremented sequence from 1"}
{"code": "last_entry = curr_max ; } else {", "nl": "Set max digit reached"}
{"code": "curr_max = curr_max + noOfNextD + 1 ;", "nl": "If not first letter Get next digit to print"}
{"code": "last_entry = curr_max ; System . out . print ( \" \u2581 \" + last_entry ) ; }", "nl": "Print digit for I"}
{"code": "for ( int k = 0 ; k < noOfNextD ; k ++ ) { System . out . print ( \" \u2581 \" + -- last_entry ) ; i ++ ; } break ;", "nl": "For all next consecutive ' D ' print decremented sequence"}
{"code": "case ' D ' : if ( i == 0 ) {", "nl": "If letter is ' D '"}
{"code": "j = i + 1 ; while ( j < arr . length ( ) && arr . charAt ( j ) == ' D ' ) { noOfNextD ++ ; j ++ ; }", "nl": "If ' D ' is first letter in sequence Find number of Next D 's available"}
{"code": "curr_max = noOfNextD + 2 ;", "nl": "Calculate first digit to print based on number of consecutive D 's"}
{"code": "System . out . print ( \" \u2581 \" + curr_max + \" \u2581 \" + ( curr_max - 1 ) ) ;", "nl": "Print twice for the first time"}
{"code": "last_entry = curr_max - 1 ; } else {", "nl": "Store last entry"}
{"code": "System . out . print ( \" \u2581 \" + ( last_entry - 1 ) ) ; last_entry -- ; } break ; } } System . out . println ( ) ; }", "nl": "If current ' D ' is not first letter Decrement last_entry"}
{"code": "public static void main ( String [ ] args ) { PrintMinNumberForPattern ( \" IDID \" ) ; PrintMinNumberForPattern ( \" I \" ) ; PrintMinNumberForPattern ( \" DD \" ) ; PrintMinNumberForPattern ( \" II \" ) ; PrintMinNumberForPattern ( \" DIDI \" ) ; PrintMinNumberForPattern ( \" IIDDD \" ) ; PrintMinNumberForPattern ( \" DDIDDIID \" ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; public class GFG { static void printLeast ( String arr ) {", "nl": "Java program to print minimum number that can be formed from a given sequence of Is and Ds"}
{"code": "int min_avail = 1 , pos_of_I = 0 ;", "nl": "min_avail represents the minimum number which is still available for inserting in the output vector . pos_of_I keeps track of the most recent index where ' I ' was encountered w . r . t the output vector"}
{"code": "ArrayList < Integer > al = new ArrayList < > ( ) ;", "nl": "vector to store the output"}
{"code": "if ( arr . charAt ( 0 ) == ' I ' ) { al . add ( 1 ) ; al . add ( 2 ) ; min_avail = 3 ; pos_of_I = 1 ; } else { al . add ( 2 ) ; al . add ( 1 ) ; min_avail = 3 ; pos_of_I = 0 ; }", "nl": "cover the base cases"}
{"code": "for ( int i = 1 ; i < arr . length ( ) ; i ++ ) { if ( arr . charAt ( i ) == ' I ' ) { al . add ( min_avail ) ; min_avail ++ ; pos_of_I = i + 1 ; } else { al . add ( al . get ( i ) ) ; for ( int j = pos_of_I ; j <= i ; j ++ ) al . set ( j , al . get ( j ) + 1 ) ; min_avail ++ ; } }", "nl": "Traverse rest of the input"}
{"code": "for ( int i = 0 ; i < al . size ( ) ; i ++ ) System . out . print ( al . get ( i ) + \" \u2581 \" ) ; System . out . println ( ) ; }", "nl": "print the number"}
{"code": "public static void main ( String args [ ] ) { printLeast ( \" IDID \" ) ; printLeast ( \" I \" ) ; printLeast ( \" DD \" ) ; printLeast ( \" II \" ) ; printLeast ( \" DIDI \" ) ; printLeast ( \" IIDDD \" ) ; printLeast ( \" DDIDDIID \" ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Stack ; class GFG {", "nl": "Java program to print minimum number that can be formed from a given sequence of Is and Ds"}
{"code": "static void PrintMinNumberForPattern ( String seq ) {", "nl": "Function to decode the given sequence to construct minimum number without repeated digits"}
{"code": "String result = \" \" ;", "nl": "result store output string"}
{"code": "Stack < Integer > stk = new Stack < Integer > ( ) ;", "nl": "create an empty stack of integers"}
{"code": "for ( int i = 0 ; i <= seq . length ( ) ; i ++ ) {", "nl": "run n + 1 times where n is length of input sequence"}
{"code": "stk . push ( i + 1 ) ;", "nl": "push number i + 1 into the stack"}
{"code": "if ( i == seq . length ( ) || seq . charAt ( i ) == ' I ' ) {", "nl": "if all characters of the input sequence are processed or current character is ' I ' ( increasing )"}
{"code": "while ( ! stk . empty ( ) ) {", "nl": "run till stack is empty"}
{"code": "result += String . valueOf ( stk . peek ( ) ) ; result += \" \u2581 \" ; stk . pop ( ) ; } } } System . out . println ( result ) ; }", "nl": "remove top element from the stack and add it to solution"}
{"code": "public static void main ( String [ ] args ) { PrintMinNumberForPattern ( \" IDID \" ) ; PrintMinNumberForPattern ( \" I \" ) ; PrintMinNumberForPattern ( \" DD \" ) ; PrintMinNumberForPattern ( \" II \" ) ; PrintMinNumberForPattern ( \" DIDI \" ) ; PrintMinNumberForPattern ( \" IIDDD \" ) ; PrintMinNumberForPattern ( \" DDIDDIID \" ) ; } }", "nl": "main function"}
{"code": "import java . io . IOException ; public class Test {", "nl": "Java program of above approach"}
{"code": "static String getMinNumberForPattern ( String seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return \" - 1\" ; char result [ ] = new char [ n + 1 ] ; int count = 1 ;", "nl": "Returns minimum number made from given sequence without repeating digits"}
{"code": "for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n || seq . charAt ( i ) == ' I ' ) { for ( int j = i - 1 ; j >= - 1 ; j -- ) { result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++ ) ; if ( j >= 0 && seq . charAt ( j ) == ' I ' ) break ; } } } return new String ( result ) ; }", "nl": "The loop runs for each input character as well as one additional time for assigning rank to each remaining characters"}
{"code": "public static void main ( String [ ] args ) throws IOException { String inputs [ ] = { \" IDID \" , \" I \" , \" DD \" , \" II \" , \" DIDI \" , \" IIDDD \" , \" DDIDDIID \" } ; for ( String input : inputs ) { System . out . println ( getMinNumberForPattern ( input ) ) ; } } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class SmallPrime {", "nl": "Java implementation of above approach"}
{"code": "static boolean isPrime ( int n ) { int i , c = 0 ; for ( i = 1 ; i < n / 2 ; i ++ ) { if ( n % i == 0 ) c ++ ; } if ( c == 1 ) { return true ; } else { return false ; } }", "nl": "function to check prime"}
{"code": "static void findMinNum ( int arr [ ] , int n ) {", "nl": "Function to generate smallest possible number with given digits"}
{"code": "int first = 0 , last = 0 , num , rev , i ; int hash [ ] = new int [ 10 ] ;", "nl": "Declare a hash array of size 10 and initialize all the elements to zero"}
{"code": "for ( i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; }", "nl": "store the number of occurrences of the digits in the given array into the hash table"}
{"code": "System . out . print ( \" Minimum \u2581 number : \u2581 \" ) ; for ( i = 0 ; i <= 9 ; i ++ ) {", "nl": "Traverse the hash in ascending order to print the required number"}
{"code": "for ( int j = 0 ; j < hash [ i ] ; j ++ ) System . out . print ( i ) ; } System . out . println ( ) ; System . out . println ( ) ;", "nl": "Print the number of times a digits occurs"}
{"code": "for ( i = 0 ; i <= 9 ; i ++ ) { if ( hash [ i ] != 0 ) { first = i ; break ; } }", "nl": "extracting the first digit"}
{"code": "for ( i = 9 ; i >= 0 ; i -- ) { if ( hash [ i ] != 0 ) { last = i ; break ; } } num = first * 10 + last ; rev = last * 10 + first ;", "nl": "extracting the last digit"}
{"code": "System . out . print ( \" Prime \u2581 combinations : \u2581 \" ) ; if ( isPrime ( num ) && isPrime ( rev ) ) { System . out . println ( num + \" \u2581 \" + rev ) ; } else if ( isPrime ( num ) ) { System . out . println ( num ) ; } else if ( isPrime ( rev ) ) { System . out . println ( rev ) ; } else { System . out . println ( \" No \u2581 combinations \u2581 exist \" ) ; } }", "nl": "printing the prime combinations"}
{"code": "public static void main ( String [ ] args ) { SmallPrime smallprime = new SmallPrime ( ) ; int arr [ ] = { 1 , 2 , 4 , 7 , 8 } ; smallprime . findMinNum ( arr , 5 ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find possible non transitive triplets btw L and R"}
{"code": "static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }", "nl": "Function to return gcd of a and b"}
{"code": "static boolean coprime ( int a , int b ) {", "nl": "function to check for gcd"}
{"code": "return ( gcd ( a , b ) == 1 ) ; }", "nl": "a and b are coprime if their gcd is 1."}
{"code": "static void possibleTripletInRange ( int L , int R ) { boolean flag = false ; int possibleA = 0 , possibleB = 0 , possibleC = 0 ;", "nl": "Checks if any possible triplet ( a , b , c ) satifying the condition that ( a , b ) is coprime , ( b , c ) is coprime but ( a , c ) isnt"}
{"code": "for ( int a = L ; a <= R ; a ++ ) { for ( int b = a + 1 ; b <= R ; b ++ ) { for ( int c = b + 1 ; c <= R ; c ++ ) {", "nl": "Generate and check for all possible triplets between L and R"}
{"code": "if ( coprime ( a , b ) && coprime ( b , c ) && ! coprime ( a , c ) ) { flag = true ; possibleA = a ; possibleB = b ; possibleC = c ; break ; } } } }", "nl": "if we find any such triplets set flag to true"}
{"code": "if ( flag == true ) { System . out . println ( \" ( \" + possibleA + \" , \u2581 \" + possibleB + \" , \u2581 \" + possibleC + \" ) \" + \" \u2581 is \u2581 one \u2581 such \u2581 possible \u2581 triplet \u2581 \" + \" between \u2581 \" + L + \" \u2581 and \u2581 \" + R ) ; } else { System . out . println ( \" No \u2581 Such \u2581 Triplet \u2581 exists \" + \" between \u2581 \" + L + \" \u2581 and \u2581 \" + R ) ; } }", "nl": "flag = True indicates that a pair exists between L and R"}
{"code": "public static void main ( String [ ] args ) { int L , R ;", "nl": "Driver code"}
{"code": "L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ;", "nl": "finding possible Triplet between 2 and 10"}
{"code": "L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; } }", "nl": "finding possible Triplet between 23 and 46"}
{"code": "class GFG {", "nl": "Java program to determine if A and B can be reached starting from 1 , 1 following the given steps ."}
{"code": "static boolean possibleToReach ( int a , int b ) {", "nl": "function to check is it is possible to reach A and B starting from 1 and 1"}
{"code": "int c = ( int ) Math . cbrt ( a * b ) ;", "nl": "find the cuberoot of the number"}
{"code": "int re1 = a / c ; int re2 = b / c ;", "nl": "divide the number by cuberoot"}
{"code": "if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; }", "nl": "if it is a perfect cuberoot and divides a and b"}
{"code": "public static void main ( String [ ] args ) { int A = 60 , B = 450 ; if ( possibleToReach ( A , B ) ) System . out . println ( \" yes \" ) ; else System . out . println ( \" no \" ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { public static boolean isUndulating ( String n ) {", "nl": "Java program to check whether a number is undulating or not"}
{"code": "if ( n . length ( ) <= 2 ) return false ;", "nl": "Considering the definition with restriction that there should be at least 3 digits"}
{"code": "for ( int i = 2 ; i < n . length ( ) ; i ++ ) if ( n . charAt ( i - 2 ) != n . charAt ( i ) ) return false ; return true ; }", "nl": "Check if all alternate digits are same or not ."}
{"code": "public static void main ( String [ ] args ) { String n = \"1212121\" ; if ( isUndulating ( n ) == true ) System . out . println ( \" yes \" ) ; else System . out . println ( \" no \" ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to calculate the following series"}
{"code": "static int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; }", "nl": "Function to calculate the following series"}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; int res = Series ( n ) ; System . out . println ( res ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; import java . lang . * ; public class GfG {", "nl": "Efficient Java program to count numbers with last digit as k in given range ."}
{"code": "public static int counLastDigitK ( int low , int high , int k ) { int mlow = 10 * ( int ) Math . ceil ( low / 10.0 ) ; int mhigh = 10 * ( int ) Math . floor ( high / 10.0 ) ; int count = ( mhigh - mlow ) / 10 ; if ( high % 10 >= k ) count ++ ; if ( low % 10 <= k && ( low % 10 ) > 0 ) count ++ ; return count ; }", "nl": "Returns count of numbers with k as last digit ."}
{"code": "public static void main ( String argc [ ] ) { int low = 3 , high = 35 , k = 3 ; System . out . println ( counLastDigitK ( low , high , k ) ) ; } }", "nl": "driver function"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find sum of numbers divisible by 6 in a given range ."}
{"code": "static int sum ( int L , int R ) {", "nl": "function to calculate the sum of all numbers divisible by 6 in range L - R . ."}
{"code": "int p = R / 6 ;", "nl": "no of multiples of 6 upto r"}
{"code": "int q = ( L - 1 ) / 6 ;", "nl": "no of multiples of 6 upto l - 1"}
{"code": "int sumR = 3 * ( p * ( p + 1 ) ) ;", "nl": "summation of all multiples of 6 upto r"}
{"code": "int sumL = ( q * ( q + 1 ) ) * 3 ;", "nl": "summation of all multiples of 6 upto l - 1"}
{"code": "return sumR - sumL ; }", "nl": "returns the answer"}
{"code": "public static void main ( String [ ] args ) { int L = 1 , R = 20 ; System . out . println ( sum ( L , R ) ) ; } }", "nl": "driver program"}
{"code": "class GFG {", "nl": "Java program to find the largest smaller number by swapping one digit ."}
{"code": "static String prevNum ( String str ) { int len = str . length ( ) ; int index = - 1 ;", "nl": "Returns largest possible number with one swap such that the number is smaller than str . It is assumed that there are leading 0 s ."}
{"code": "for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) > str . charAt ( i + 1 ) ) { index = i ; break ; } }", "nl": "Traverse from right until we find a digit which is greater than its next digit . For example , in 34125 , our index is 4."}
{"code": "int smallGreatDgt = - 1 ; for ( int i = len - 1 ; i > index ; i -- ) { if ( str . charAt ( i ) < str . charAt ( index ) ) { if ( smallGreatDgt == - 1 ) { smallGreatDgt = i ; } else if ( str . charAt ( i ) >= str . charAt ( smallGreatDgt ) ) { smallGreatDgt = i ; } } }", "nl": "We can also use binary search here as digits after index are sorted in increasing order . Find the biggest digit in the right of arr [ index ] which is smaller than arr [ index ]"}
{"code": "if ( index == - 1 ) { return \" - 1\" ; }", "nl": "If index is - 1 i . e . digits are in increasing order ."}
{"code": "if ( smallGreatDgt != - 1 ) { str = swap ( str , index , smallGreatDgt ) ; return str ; } return \" - 1\" ; } static String swap ( String str , int i , int j ) { char ch [ ] = str . toCharArray ( ) ; char temp = ch [ i ] ; ch [ i ] = ch [ j ] ; ch [ j ] = temp ; return String . valueOf ( ch ) ; }", "nl": "Swap both values"}
{"code": "public static void main ( String [ ] args ) { String str = \"34125\" ; System . out . println ( prevNum ( str ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find sign value of a polynomial"}
{"code": "static int horner ( int poly [ ] , int n , int x ) {", "nl": "returns value of poly [ 0 ] x ( n - 1 ) + poly [ 1 ] x ( n - 2 ) + . . + poly [ n - 1 ]"}
{"code": "int result = poly [ 0 ] ;", "nl": "Initialize result"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; }", "nl": "Evaluate value of polynomial using Horner 's method"}
{"code": "static int findSign ( int poly [ ] , int n , int x ) { int result = horner ( poly , n , x ) ; if ( result > 0 ) return 1 ; else if ( result < 0 ) return - 1 ; return 0 ; }", "nl": "Returns sign value of polynomial"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int poly [ ] = { 2 , - 6 , 2 , - 1 } ; int x = 3 ; int n = poly . length ; System . out . print ( \" Sign \u2581 of \u2581 polynomial \u2581 is \u2581 \" + findSign ( poly , n , x ) ) ; } }", "nl": "Let us evaluate value of 2 x3 - 6 x2 + 2 x - 1 for x = 3"}
{"code": "class GFG { static int MAX = 100005 ;", "nl": "Java program to find minimum number to insert in array so their sum is prime"}
{"code": "static boolean [ ] isPrime = new boolean [ MAX ] ;", "nl": "Array to store primes"}
{"code": "static void sieveOfEratostheneses ( ) { isPrime [ 1 ] = true ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( ! isPrime [ i ] ) { for ( int j = 2 * i ; j < MAX ; j += i ) isPrime [ j ] = true ; } } }", "nl": "function to calculate primes using sieve of eratosthenes"}
{"code": "static int findPrime ( int n ) { int num = n + 1 ;", "nl": "Find prime number greater than a number"}
{"code": "while ( num > 0 ) {", "nl": "To return prime number greater than n"}
{"code": "if ( ! isPrime [ num ] ) return num ;", "nl": "check if num is prime"}
{"code": "num = num + 1 ; } return 0 ; }", "nl": "increment num"}
{"code": "static int minNumber ( int arr [ ] , int n ) {", "nl": "To find number to be added so sum of array is prime"}
{"code": "sieveOfEratostheneses ( ) ; int sum = 0 ;", "nl": "call sieveOfEratostheneses to calculate primes"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( ! isPrime [ sum ] ) return 0 ;", "nl": "To find sum of array elements"}
{"code": "int num = findPrime ( sum ) ;", "nl": "To find prime number greater then sum"}
{"code": "return num - sum ; }", "nl": "Return difference of sum and num"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; int n = arr . length ; System . out . println ( minNumber ( arr , n ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Simple Java program to compute sum of subarray elements"}
{"code": "public static long SubArraySum ( int arr [ ] , int n ) { long result = 0 , temp = 0 ;", "nl": "Computes sum all sub - array"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Pick starting point"}
{"code": "temp = 0 ; for ( int j = i ; j < n ; j ++ ) {", "nl": "Pick ending point"}
{"code": "temp += arr [ j ] ; result += temp ; } } return result ; }", "nl": "sum subarray between current starting and ending points"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . println ( \" Sum \u2581 of \u2581 SubArray \u2581 : \u2581 \" + SubArraySum ( arr , n ) ) ; } }", "nl": "Driver program to test above function"}
{"code": "import java . io . * ; class GFG { static int highestPowerof2 ( int n ) { int p = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return ( int ) Math . pow ( 2 , p ) ; }", "nl": "Java program to find highest power of 2 smaller than or equal to n ."}
{"code": "public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( highestPowerof2 ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class KeyComparator implements Comparator < Key > {", "nl": "Java program to rearrange characters in a string so that no two adjacent characters are same ."}
{"code": "public int compare ( Key k1 , Key k2 ) { if ( k1 . freq < k2 . freq ) return 1 ; else if ( k1 . freq > k2 . freq ) return - 1 ; return 0 ; } } class Key {", "nl": "Overriding compare ( ) method of Comparator"}
{"code": "int freq ; char ch ; Key ( int val , char c ) { freq = val ; ch = c ; } } class GFG { static int MAX_CHAR = 26 ;", "nl": "store frequency of character"}
{"code": "static void rearrangeString ( String str ) { int n = str . length ( ) ;", "nl": "Function to rearrange character of a string so that no char repeat twice"}
{"code": "int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str . charAt ( i ) - ' a ' ] ++ ;", "nl": "Store frequencies of all characters in string"}
{"code": "PriorityQueue < Key > pq = new PriorityQueue < > ( new KeyComparator ( ) ) ; for ( char c = ' a ' ; c <= ' z ' ; c ++ ) { int val = c - ' a ' ; if ( count [ val ] > 0 ) pq . add ( new Key ( count [ val ] , c ) ) ; }", "nl": "Insert all characters with their frequencies into a priority_queue"}
{"code": "str = \" \" ;", "nl": "' str ' that will store resultant value"}
{"code": "Key prev = new Key ( - 1 , ' # ' ) ;", "nl": "work as the previous visited element initial previous element be . ( ' # ' and it ' s \u2581 frequency \u2581 ' - 1 ' )"}
{"code": "while ( pq . size ( ) != 0 ) {", "nl": "traverse queue"}
{"code": "Key k = pq . peek ( ) ; pq . poll ( ) ; str = str + k . ch ;", "nl": "pop top element from queue and add it to string ."}
{"code": "if ( prev . freq > 0 ) pq . add ( prev ) ;", "nl": "If frequency of previous character is less than zero that means it is useless , we need not to push it"}
{"code": "( k . freq ) -- ; prev = k ; }", "nl": "make current character as the previous ' char ' decrease frequency by ' one '"}
{"code": "if ( n != str . length ( ) ) System . out . println ( \" \u2581 Not \u2581 valid \u2581 String \u2581 \" ) ;", "nl": "If length of the resultant string and original string is not same then string is not valid"}
{"code": "else System . out . println ( str ) ; }", "nl": "valid string"}
{"code": "public static void main ( String args [ ] ) { String str = \" bbbaa \" ; rearrangeString ( str ) ; } }", "nl": "Driver program to test above function"}
{"code": "public class GFG {", "nl": "Java program to find ( a ^ b ) mod m for a large ' a '"}
{"code": "static int aModM ( String s , int mod ) { int number = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) {", "nl": "utility function to calculate a % m"}
{"code": "number = ( number * 10 ) ; int x = Character . getNumericValue ( s . charAt ( i ) ) ; number = number + x ; number %= mod ; } return number ; }", "nl": "( s [ i ] - '0' ) gives the digit value and form the number"}
{"code": "static int ApowBmodM ( String a , int b , int m ) {", "nl": "Returns find ( a ^ b ) % m"}
{"code": "int ans = aModM ( a , m ) ; int mul = ans ;", "nl": "Find a % m"}
{"code": "for ( int i = 1 ; i < b ; i ++ ) ans = ( ans * mul ) % m ; return ans ; }", "nl": "now multiply ans by b - 1 times and take mod with m"}
{"code": "public static void main ( String args [ ] ) { String a = \"987584345091051645734583954832576\" ; int b = 3 , m = 11 ; System . out . println ( ApowBmodM ( a , b , m ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for implementation of Lagrange 's Interpolation"}
{"code": "static class Data { int x , y ; public Data ( int x , int y ) { super ( ) ; this . x = x ; this . y = y ; } } ;", "nl": "To represent a data point corresponding to x and y = f ( x )"}
{"code": "static double interpolate ( Data f [ ] , int xi , int n ) {", "nl": "function to interpolate the given data points using Lagrange 's formula xi corresponds to the new data point whose value is to be obtained n represents the number of known data points"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "double result = 0 ; Initialize result"}
{"code": "double term = f [ i ] . y ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != i ) term = term * ( xi - f [ j ] . x ) / ( f [ i ] . x - f [ j ] . x ) ; }", "nl": "Compute individual terms of above formula"}
{"code": "result += term ; } return result ; }", "nl": "Add current term to result"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "Data f [ ] = { new Data ( 0 , 2 ) , new Data ( 1 , 3 ) , new Data ( 2 , 12 ) , new Data ( 5 , 147 ) } ;", "nl": "creating an array of 4 known data points"}
{"code": "System . out . print ( \" Value \u2581 of \u2581 f ( 3 ) \u2581 is \u2581 : \u2581 \" + ( int ) interpolate ( f , 3 , 4 ) ) ; } }", "nl": "Using the interpolate function to obtain a data point corresponding to x = 3"}
{"code": "import java . util . Arrays ; class GFG {", "nl": "Java program to print primes smaller than n using Sieve of Sundaram ."}
{"code": "static int SieveOfSundaram ( int n ) {", "nl": "Prints all prime numbers smaller"}
{"code": "int nNew = ( n - 1 ) / 2 ;", "nl": "In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x . Since we want primes smaller than n , we reduce n to half"}
{"code": "boolean marked [ ] = new boolean [ nNew + 1 ] ;", "nl": "This array is used to separate numbers of the form i + j + 2 ij from others where 1 <= i <= j"}
{"code": "Arrays . fill ( marked , false ) ;", "nl": "Initialize all elements as not marked"}
{"code": "for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ;", "nl": "Main logic of Sundaram . Mark all numbers of the form i + j + 2 ij as true where 1 <= i <= j"}
{"code": "if ( n > 2 ) System . out . print ( 2 + \" \u2581 \" ) ;", "nl": "Since 2 is a prime number"}
{"code": "for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) System . out . print ( 2 * i + 1 + \" \u2581 \" ) ; return - 1 ; }", "nl": "Print other primes . Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false ."}
{"code": "public static void main ( String [ ] args ) { int n = 20 ; SieveOfSundaram ( n ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static void constructArray ( int A [ ] , int N , int K ) {", "nl": "Function to construct an array with each element equal to XOR of all array elements except the element at the same index"}
{"code": "int B [ ] = new int [ N ] ;", "nl": "Original array"}
{"code": "int totalXOR = A [ 0 ] ^ K ;", "nl": "Stores Bitwise XOR of array"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ;", "nl": "Calculate XOR of all array elements"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( B [ i ] + \" \u2581 \" ) ; } }", "nl": "Print the original array B [ ]"}
{"code": "public static void main ( String [ ] args ) { int A [ ] = { 13 , 14 , 10 , 6 } , K = 2 ; int N = A . length ;", "nl": "Driver Code"}
{"code": "constructArray ( A , N , K ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int extraElement ( int A [ ] , int B [ ] , int n ) {", "nl": "Function to return the extra element in B [ ]"}
{"code": "int ans = 0 ;", "nl": "To store the result"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; }", "nl": "Find the XOR of all the element of array A [ ] and array B [ ]"}
{"code": "public static void main ( String [ ] args ) { int A [ ] = { 10 , 15 , 5 } ; int B [ ] = { 10 , 100 , 15 , 5 } ; int n = A . length ; System . out . println ( extraElement ( A , B , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of above approach"}
{"code": "static int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; }", "nl": "Function to calculate hamming distance"}
{"code": "public static void main ( String [ ] args ) { int n1 = 9 , n2 = 14 ; System . out . println ( hammingDistance ( n1 , n2 ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "JAVA program to print all bitwise subsets of N ( Naive approach )"}
{"code": "static void printSubsets ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( ( n & i ) == i ) System . out . print ( i + \" \u2581 \" ) ; }", "nl": "function to find bitwise subsets Naive approach"}
{"code": "public static void main ( String [ ] args ) { int n = 9 ; printSubsets ( n ) ; } }", "nl": "Driver function"}
{"code": "class GFG { static int setBitNumber ( int n ) {", "nl": "Java program to find MSB number for given n ."}
{"code": "int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ;", "nl": "To find the position of the most significant set bit"}
{"code": "return 1 << k ; }", "nl": "To return the the value of the number with set bit at k - th position"}
{"code": "public static void main ( String arg [ ] ) { int n = 273 ; System . out . print ( setBitNumber ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; import java . lang . * ; public class GfG {", "nl": "A sorting based solution to find the minimum number of subsets of a set such that every subset contains distinct elements ."}
{"code": "public static int subset ( int ar [ ] , int n ) {", "nl": "Function to count subsets such that all subsets have distinct elements ."}
{"code": "int res = 0 ;", "nl": "Take input and initialize res = 0"}
{"code": "Arrays . sort ( ar ) ;", "nl": "Sort the array"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ;", "nl": "Traverse the input array and find maximum frequency"}
{"code": "for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; }", "nl": "For each number find its repetition / frequency"}
{"code": "res = Math . max ( res , count ) ; } return res ; }", "nl": "Update res"}
{"code": "public static void main ( String argc [ ] ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = 7 ; System . out . println ( subset ( arr , n ) ) ; } }", "nl": "Driver function"}
{"code": "import java . util . HashMap ; import java . util . Map ; class GFG {", "nl": "A hashing based solution to find the minimum number of subsets of a set such that every subset contains distinct elements ."}
{"code": "static int subset ( int arr [ ] , int n ) {", "nl": "Function to count subsets such that all subsets have distinct elements ."}
{"code": "HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ;", "nl": "Traverse the input array and store frequencies of elements"}
{"code": "int res = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) res = Math . max ( res , entry . getValue ( ) ) ; return res ; }", "nl": "Find the maximum value in map ."}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = arr . length ; System . out . println ( subset ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG {", "nl": "Java program for the above approach"}
{"code": "static ArrayList < Integer > psquare = new ArrayList < > ( ) ;", "nl": "Store perfect squares less than or equal to N"}
{"code": "static void calcPsquare ( int N ) { for ( int i = 1 ; i * i <= N ; i ++ ) psquare . add ( i * i ) ; }", "nl": "Utility function to calculate perfect squares less than or equal to N"}
{"code": "static int countWays ( int index , int target ) {", "nl": "Function to find the number of ways to represent a number as sum of perfect squares"}
{"code": "if ( target == 0 ) return 1 ; if ( index < 0 target < 0 ) return 0 ;", "nl": "Handle the base cases"}
{"code": "int inc = countWays ( index , target - psquare . get ( index ) ) ;", "nl": "Include the i - th index element"}
{"code": "int exc = countWays ( index - 1 , target ) ;", "nl": "Exclude the i - th index element"}
{"code": "return inc + exc ; }", "nl": "Return the result"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 9 ;", "nl": "Given Input"}
{"code": "calcPsquare ( N ) ;", "nl": "Precalculate perfect squares <= N"}
{"code": "System . out . print ( countWays ( psquare . size ( ) - 1 , N ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } }", "nl": "Java program for the above approach"}
{"code": "static class TreeNode { int data , size ; TreeNode left ; TreeNode right ; } ;", "nl": "Structure of a binary tree node"}
{"code": "static TreeNode newNode ( int data ) { TreeNode Node = new TreeNode ( ) ; Node . data = data ; Node . left = null ; Node . right = null ;", "nl": "Function that allocates a new node with the given data and null to its left and right pointers"}
{"code": "return ( Node ) ; }", "nl": "Return newly created node"}
{"code": "static pair sumofsubtree ( TreeNode root ) {", "nl": "Function to count the number of nodes in the left and right subtrees"}
{"code": "pair p = new pair ( 1 , 0 ) ;", "nl": "Initialize a pair that stores the pair { number of nodes , depth }"}
{"code": "if ( root . left != null ) { pair ptemp = sumofsubtree ( root . left ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; }", "nl": "Finding the number of nodes in the left subtree"}
{"code": "if ( root . right != null ) { pair ptemp = sumofsubtree ( root . right ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; }", "nl": "Find the number of nodes in the right subtree"}
{"code": "root . size = p . first ; return p ; }", "nl": "Filling up size field"}
{"code": "static int sum = 0 ;", "nl": "Stores the sum of distances of all nodes from the given node"}
{"code": "static void distance ( TreeNode root , int target , int distancesum , int n ) {", "nl": "Function to find the total distance"}
{"code": "if ( root . data == target ) { sum = distancesum ; }", "nl": "If target node matches with the current node"}
{"code": "if ( root . left != null ) {", "nl": "If root . left is not null"}
{"code": "int tempsum = distancesum - root . left . size + ( n - root . left . size ) ;", "nl": "Update sum"}
{"code": "distance ( root . left , target , tempsum , n ) ; }", "nl": "Recur for the left subtree"}
{"code": "if ( root . right != null ) {", "nl": "If root . right is not null"}
{"code": "int tempsum = distancesum - root . right . size + ( n - root . right . size ) ;", "nl": "Apply the formula given in the approach"}
{"code": "distance ( root . right , target , tempsum , n ) ; } }", "nl": "Recur for the right subtree"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "TreeNode root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 5 ) ; root . right . left = newNode ( 6 ) ; root . right . right = newNode ( 7 ) ; root . left . left . left = newNode ( 8 ) ; root . left . left . right = newNode ( 9 ) ; int target = 3 ; pair p = sumofsubtree ( root ) ;", "nl": "Input tree"}
{"code": "int totalnodes = p . first ; distance ( root , target , p . second , totalnodes ) ;", "nl": "Total number of nodes"}
{"code": "System . out . print ( sum + \"NEW_LINE\"); } }", "nl": "Print the sum of distances"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int [ ] reverse ( int a [ ] ) { int i , n = a . length , t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } return a ; }", "nl": "Reverse array"}
{"code": "static void rearrangeArray ( int A [ ] , int B [ ] , int N , int K ) {", "nl": "Function to rearrange array such that sum of similar indexed elements does not exceed K"}
{"code": "Arrays . sort ( B ) ; B = reverse ( B ) ; boolean flag = true ; for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Sort the array B [ ] in descending order"}
{"code": "if ( A [ i ] + B [ i ] > K ) { flag = false ; break ; } } if ( ! flag ) { System . out . print ( \" - 1\" + \"NEW_LINE\"); } else {", "nl": "If condition fails"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( B [ i ] + \" \u2581 \" ) ; } } }", "nl": "Print the array"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int A [ ] = { 1 , 2 , 3 , 4 , 2 } ; int B [ ] = { 1 , 2 , 3 , 1 , 1 } ; int N = A . length ; int K = 5 ; rearrangeArray ( A , B , N , K ) ; } }", "nl": "Given arrays"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void countRows ( int [ ] [ ] mat ) {", "nl": "Function to count the number of rows whose sum exceeds the sum of elements of the remaining matrix"}
{"code": "int n = mat . length ; int m = mat [ 0 ] . length ;", "nl": "Stores the matrix dimensions"}
{"code": "int count = 0 ;", "nl": "To store the result"}
{"code": "int totalSum = 0 ;", "nl": "Stores the total sum of the matrix elements"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { totalSum += mat [ i ] [ j ] ; } }", "nl": "Calculate the total sum"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse to check for each row"}
{"code": "int currSum = 0 ;", "nl": "Stores the sum of elements of the current row"}
{"code": "for ( int j = 0 ; j < m ; j ++ ) { currSum += mat [ i ] [ j ] ; }", "nl": "Calculate the sum of elements of the current row"}
{"code": "if ( currSum > totalSum - currSum )", "nl": "If sum of current row exceeds the sum of rest of the matrix"}
{"code": "count ++ ; }", "nl": "Increase count"}
{"code": "System . out . println ( count ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int [ ] [ ] mat = { { 2 , - 1 , 5 } , { - 3 , 0 , - 2 } , { 5 , 1 , 2 } } ;", "nl": "Given matrix"}
{"code": "countRows ( mat ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Sorting based Java implementation to check whether the array contains a set of contiguous integers"}
{"code": "static boolean areElementsContiguous ( int arr [ ] , int n ) {", "nl": "function to check whether the array contains a set of contiguous integers"}
{"code": "Arrays . sort ( arr ) ;", "nl": "Sort the array"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] > 1 ) return false ; return true ; }", "nl": "After sorting , check if current element is either same as previous or is one more ."}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver program to test above function"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to check whether the array contains a set of contiguous integers"}
{"code": "static boolean areElementsContiguous ( int arr [ ] , int n ) {", "nl": "function to check whether the array contains a set of contiguous integers"}
{"code": "int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } int m = max - min + 1 ;", "nl": "Find maximum and minimum elements ."}
{"code": "if ( m > n ) return false ;", "nl": "There should be at least m elements in aaray to make them contiguous ."}
{"code": "boolean visited [ ] = new boolean [ n ] ;", "nl": "Create a visited array and initialize false ."}
{"code": "for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ;", "nl": "Mark elements as true ."}
{"code": "for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; }", "nl": "If any element is not marked , all elements are not contiguous ."}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver program"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java implementation to check whether the array contains a set of contiguous integers"}
{"code": "static Boolean areElementsContiguous ( int arr [ ] , int n ) {", "nl": "Function to check whether the array contains a set of contiguous integers"}
{"code": "HashSet < Integer > us = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) us . add ( arr [ i ] ) ;", "nl": "Storing elements of ' arr [ ] ' in a hash table ' us '"}
{"code": "int count = 1 ;", "nl": "As arr [ 0 ] is present in ' us '"}
{"code": "int curr_ele = arr [ 0 ] - 1 ;", "nl": "Starting with previous smaller element of arr [ 0 ]"}
{"code": "while ( us . contains ( curr_ele ) == true ) {", "nl": "If ' curr _ ele ' is present in ' us '"}
{"code": "count ++ ;", "nl": "increment count"}
{"code": "curr_ele -- ; }", "nl": "update 'curr_ele\""}
{"code": "curr_ele = arr [ 0 ] + 1 ;", "nl": "Starting with next greater element of arr [ 0 ]"}
{"code": "while ( us . contains ( curr_ele ) == true ) {", "nl": "If ' curr _ ele ' is present in ' us '"}
{"code": "count ++ ;", "nl": "increment count"}
{"code": "curr_ele ++ ; }", "nl": "update 'curr_ele\""}
{"code": "return ( count == ( us . size ( ) ) ) ; }", "nl": "Returns true if array contains a set of contiguous integers else returns false"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find longest subarray with k or less distinct elements ."}
{"code": "static void longest ( int a [ ] , int n , int k ) { int [ ] freq = new int [ 7 ] ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "function to print the longest sub - array"}
{"code": "freq [ a [ i ] ] ++ ;", "nl": "mark the element visited"}
{"code": "if ( freq [ a [ i ] ] == 1 ) now ++ ;", "nl": "if its visited first time , then increase the counter of distinct elements by 1"}
{"code": "while ( now > k ) {", "nl": "When the counter of distinct elements increases from k , then reduce it to k"}
{"code": "freq [ a [ l ] ] -- ;", "nl": "from the left , reduce the number of time of visit"}
{"code": "if ( freq [ a [ l ] ] == 0 ) now -- ;", "nl": "if the reduced visited time element is not present in further segment then decrease the count of distinct elements"}
{"code": "l ++ ; }", "nl": "increase the subsegment mark"}
{"code": "if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } }", "nl": "check length of longest sub - segment when greater then previous best then change it"}
{"code": "for ( int i = start ; i <= end ; i ++ ) System . out . print ( a [ i ] + \" \u2581 \" ) ; }", "nl": "print the longest sub - segment"}
{"code": "public static void main ( String args [ ] ) { int a [ ] = { 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 } ; int n = a . length ; int k = 3 ; longest ( a , n , k ) ; } }", "nl": "Driver code"}
{"code": "import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . Stack ; class GFG { static class Pair { int first , second ; public Pair ( int first , int second ) { this . first = first ; this . second = second ; } }", "nl": "Java implementation of the approach"}
{"code": "static boolean kOverlap ( ArrayList < Pair > pairs , int k ) {", "nl": "Function that returns true if any k segments overlap at any point"}
{"code": "ArrayList < Pair > vec = new ArrayList < > ( ) ; for ( int i = 0 ; i < pairs . size ( ) ; i ++ ) {", "nl": "Vector to store the starting point and the ending point"}
{"code": "vec . add ( new Pair ( pairs . get ( i ) . first , - 1 ) ) ; vec . add ( new Pair ( pairs . get ( i ) . second , + 1 ) ) ; }", "nl": "Starting points are marked by - 1 and ending points by + 1"}
{"code": "Collections . sort ( vec , new Comparator < Pair > ( ) {", "nl": "Sort the vector by first element"}
{"code": "public int compare ( Pair a , Pair b ) { if ( a . first != b . first ) return a . first - b . first ; return ( a . second - b . second ) ; } } ) ;", "nl": "Comparator to sort the vector of pairs"}
{"code": "Stack < Pair > st = new Stack < > ( ) ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) {", "nl": "Stack to store the overlaps"}
{"code": "Pair cur = vec . get ( i ) ;", "nl": "Get the current element"}
{"code": "if ( cur . second == - 1 ) {", "nl": "If it is the starting point"}
{"code": "st . push ( cur ) ; }", "nl": "Push it in the stack"}
{"code": "else {", "nl": "It is the ending point"}
{"code": "st . pop ( ) ; }", "nl": "Pop an element from stack"}
{"code": "if ( st . size ( ) >= k ) { return true ; } } return false ; }", "nl": "If more than k ranges overlap"}
{"code": "public static void main ( String [ ] args ) { ArrayList < Pair > pairs = new ArrayList < > ( ) ; pairs . add ( new Pair ( 1 , 3 ) ) ; pairs . add ( new Pair ( 2 , 4 ) ) ; pairs . add ( new Pair ( 3 , 5 ) ) ; pairs . add ( new Pair ( 7 , 10 ) ) ; int n = pairs . size ( ) , k = 3 ; if ( kOverlap ( pairs , k ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static final int N = 5 ;", "nl": "Java program to finds out smallest range that includes elements from each of the given sorted lists ."}
{"code": "static int ptr [ ] = new int [ 501 ] ;", "nl": "array for storing the current index of list i"}
{"code": "static void findSmallestRange ( int arr [ ] [ ] , int n , int k ) { int i , minval , maxval , minrange , minel = 0 , maxel = 0 , flag , minind ;", "nl": "This function takes an k sorted lists in the form of 2D array as an argument . It finds out smallest range that includes elements from each of the k lists ."}
{"code": "for ( i = 0 ; i <= k ; i ++ ) { ptr [ i ] = 0 ; } minrange = Integer . MAX_VALUE ; while ( true ) {", "nl": "initializing to 0 index ;"}
{"code": "minind = - 1 ; minval = Integer . MAX_VALUE ; maxval = Integer . MIN_VALUE ; flag = 0 ;", "nl": "for maintaining the index of list containing the minimum element"}
{"code": "for ( i = 0 ; i < k ; i ++ ) {", "nl": "iterating over all the list"}
{"code": "if ( ptr [ i ] == n ) { flag = 1 ; break ; }", "nl": "if every element of list [ i ] is traversed then break the loop"}
{"code": "if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) {", "nl": "find minimum value among all the list elements pointing by the ptr [ ] array"}
{"code": "minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; }", "nl": "update the index of the list"}
{"code": "if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } }", "nl": "find maximum value among all the list elements pointing by the ptr [ ] array"}
{"code": "if ( flag == 1 ) { break ; } ptr [ minind ] ++ ;", "nl": "if any list exhaust we will not get any better answer , so break the while loop"}
{"code": "if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } System . out . printf ( \"The smallest range is [%d, %d]NEW_LINE\", minel, maxel); }", "nl": "updating the minrange"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 4 , 7 , 9 , 12 , 15 } , { 0 , 8 , 10 , 14 , 20 } , { 6 , 12 , 16 , 30 , 50 } } ; int k = arr . length ; findSmallestRange ( arr , N , k ) ; } }", "nl": "Driver program to test above function"}
{"code": "import java . io . * ; import java . util . Arrays ; class GFG {", "nl": "Java Program to find the largest such that d = a + b + c"}
{"code": "static int findLargestd ( int [ ] S , int n ) { boolean found = false ;", "nl": "function to find largest d"}
{"code": "Arrays . sort ( S ) ;", "nl": "sort the array in ascending order"}
{"code": "for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) {", "nl": "iterating from backwards to find the required largest d"}
{"code": "if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ;", "nl": "since all four a , b , c , d should be distinct"}
{"code": "if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return Integer . MAX_VALUE ; return - 1 ; }", "nl": "if the current combination of j , k , l in the set is equal to S [ i ] return this value as this would be the largest d since we are iterating in descending order"}
{"code": "public static void main ( String [ ] args ) { int [ ] S = new int [ ] { 2 , 3 , 5 , 7 , 12 } ; int n = S . length ; int ans = findLargestd ( S , n ) ; if ( ans == Integer . MAX_VALUE ) System . out . println ( \" No \u2581 Solution \" ) ; else System . out . println ( \" Largest \u2581 d \u2581 such \u2581 that \u2581 \" + \" a \u2581 + \u2581 \" + \" b \u2581 + \u2581 c \u2581 = \u2581 d \u2581 is \u2581 \" + ans ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . HashMap ; import java . lang . Math ;", "nl": "A hashing based Java program to find largest d such that a + b + c = d ."}
{"code": "class Indexes { int i , j ; Indexes ( int i , int j ) { this . i = i ; this . j = j ; } int getI ( ) { return i ; } int getJ ( ) { return j ; } } class GFG {", "nl": "To store and retrieve indices pair i & j"}
{"code": "static int findFourElements ( int [ ] arr , int n ) { HashMap < Integer , Indexes > map = new HashMap < > ( ) ;", "nl": "The function finds four elements with given sum X"}
{"code": "for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { map . put ( arr [ i ] + arr [ j ] , new Indexes ( i , j ) ) ; } } int d = Integer . MIN_VALUE ;", "nl": "Store sums ( a + b ) of all pairs ( a , b ) in a hash table"}
{"code": "for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = Math . abs ( arr [ i ] - arr [ j ] ) ;", "nl": "Traverse through all pairs and find ( d - c ) is present in hash table"}
{"code": "if ( map . containsKey ( abs_diff ) ) { Indexes indexes = map . get ( abs_diff ) ;", "nl": "If d - c is present in hash table ,"}
{"code": "if ( indexes . getI ( ) != i && indexes . getI ( ) != j && indexes . getJ ( ) != i && indexes . getJ ( ) != j ) { d = Math . max ( d , Math . max ( arr [ i ] , arr [ j ] ) ) ; } } } } return d ; }", "nl": "Making sure that all elements are distinct array elements and an element is not considered more than once ."}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 7 , 12 } ; int n = arr . length ; int res = findFourElements ( arr , n ) ; if ( res == Integer . MIN_VALUE ) System . out . println ( \" No \u2581 Solution \" ) ; else System . out . println ( res ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Arrays ; public class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static int CountMaximum ( int arr [ ] , int n , int k ) {", "nl": "Function to count maximum number of elements that can be selected"}
{"code": "Arrays . sort ( arr ) ; int sum = 0 , count = 0 ;", "nl": "Sorting the array"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse the array"}
{"code": "sum += arr [ i ] ;", "nl": "Add the current element to the sum"}
{"code": "if ( sum > k ) break ;", "nl": "If sum exceeds k"}
{"code": "count ++ ; }", "nl": "Increment count"}
{"code": "return count ; }", "nl": "Returning the count"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = 4 ; int k = 50 ;", "nl": "Driver code"}
{"code": "System . out . println ( CountMaximum ( arr , n , k ) ) ; } }", "nl": "Function call"}
{"code": "class RotateArray {", "nl": "Java program to rotate an array by d elements"}
{"code": "void leftRotatebyOne ( int arr [ ] , int n ) { int i , temp ; temp = arr [ 0 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; }", "nl": "Function to left Rotate arr [ ] of size n by 1"}
{"code": "void leftRotate ( int arr [ ] , int d , int n ) { for ( int i = 0 ; i < d ; i ++ ) leftRotatebyOne ( arr , n ) ; }", "nl": "Function to left rotate arr [ ] of size n by d"}
{"code": "void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }", "nl": "utility function to print an array"}
{"code": "public static void main ( String [ ] args ) { RotateArray rotate = new RotateArray ( ) ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; rotate . leftRotate ( arr , 2 , 7 ) ; rotate . printArray ( arr , 7 ) ; } }", "nl": "Driver program to test above functions"}
{"code": "import java . io . * ; import java . util . * ; import java . lang . * ; class GFG {", "nl": "Java program to sort the array in a given index range"}
{"code": "static void partSort ( int [ ] arr , int N , int a , int b ) {", "nl": "Function to sort the elements of the array from index a to index b"}
{"code": "int l = Math . min ( a , b ) ; int r = Math . max ( a , b ) ;", "nl": "Variables to store start and end of the index range"}
{"code": "int [ ] temp = new int [ r - l + 1 ] ; int j = 0 ; for ( int i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; }", "nl": "Temporary array"}
{"code": "Arrays . sort ( temp ) ;", "nl": "Sort the temporary array"}
{"code": "j = 0 ; for ( int i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; }", "nl": "Modifying original array with temporary array elements"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }", "nl": "Print the modified array"}
{"code": "public static void main ( String args [ ] ) { int [ ] arr = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 , b = 4 ;", "nl": "Driver code"}
{"code": "int N = arr . length ; partSort ( arr , N , a , b ) ; } }", "nl": "length of the array"}
{"code": "import java . util . * ; class GFG { static int MAX_SIZE = 10 ;", "nl": "Java implementation to sort the rows of matrix in descending order followed by sorting the columns in ascending order"}
{"code": "static void sortByRow ( int [ ] [ ] mat , int n , boolean descending ) { int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( descending == true ) { int t = i ; for ( int p = 0 ; p < n ; p ++ ) { for ( int j = p + 1 ; j < n ; j ++ ) { if ( mat [ t ] [ p ] < mat [ t ] [ j ] ) { temp = mat [ t ] [ p ] ; mat [ t ] [ p ] = mat [ t ] [ j ] ; mat [ t ] [ j ] = temp ; } } } } else Arrays . sort ( mat [ i ] ) ; } }", "nl": "function to sort each row of the matrix according to the order specified by descending ."}
{"code": "static void transpose ( int mat [ ] [ ] , int n ) { int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) {", "nl": "function to find transpose of the matrix"}
{"code": "temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } } }", "nl": "swapping element at index ( i , j ) by element at index ( j , i )"}
{"code": "static void sortMatRowAndColWise ( int mat [ ] [ ] , int n ) {", "nl": "function to sort the matrix row - wise and column - wise"}
{"code": "sortByRow ( mat , n , true ) ;", "nl": "sort rows of mat [ ] [ ] in descending order"}
{"code": "transpose ( mat , n ) ;", "nl": "get transpose of mat [ ] [ ]"}
{"code": "sortByRow ( mat , n , false ) ;", "nl": "again sort rows of mat [ ] [ ] in ascending order ."}
{"code": "transpose ( mat , n ) ; }", "nl": "again get transpose of mat [ ] [ ]"}
{"code": "static void printMat ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( mat [ i ] [ j ] + \" \u2581 \" ) ; System . out . println ( ) ; } }", "nl": "function to print the matrix"}
{"code": "public static void main ( String args [ ] ) { int n = 3 ; int [ ] [ ] mat = { { 3 , 2 , 1 } , { 9 , 8 , 7 } , { 6 , 5 , 4 } } ; System . out . println ( \" Original \u2581 Matrix : \" ) ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; System . out . println ( \" \" \u2581 + \u2581 \" Matrix After Sorting : \"); printMat ( mat , n ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class PushZero {", "nl": "Java program to push zeroes to back of array"}
{"code": "static void pushZerosToEnd ( int arr [ ] , int n ) {", "nl": "Function which pushes all zeros to end of an array ."}
{"code": "int count = 0 ;", "nl": "Count of non - zero elements"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 )", "nl": "Traverse the array . If element encountered is non - zero , then replace the element at index ' count ' with this element"}
{"code": "arr [ count ++ ] = arr [ i ] ;", "nl": "here count is"}
{"code": "while ( count < n ) arr [ count ++ ] = 0 ; }", "nl": "incremented Now all non - zero elements have been shifted to front and ' count ' is set as index of first 0. Make all elements 0 from count to end ."}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = arr . length ; pushZerosToEnd ( arr , n ) ; System . out . println ( \" Array \u2581 after \u2581 pushing \u2581 zeros \u2581 to \u2581 the \u2581 back : \u2581 \" ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }", "nl": "Driver function to check for above functions"}
{"code": "import java . io . * ; class GFG {", "nl": "Java implementation to move all zeroes at the end of array"}
{"code": "static void moveZerosToEnd ( int arr [ ] , int n ) {", "nl": "function to move all zeroes at the end of array"}
{"code": "int count = 0 ; int temp ;", "nl": "Count of non - zero elements"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] != 0 ) ) { temp = arr [ count ] ; arr [ count ] = arr [ i ] ; arr [ i ] = temp ; count = count + 1 ; } } }", "nl": "Traverse the array . If arr [ i ] is non - zero , then swap the element at index ' count ' with the element at index ' i '"}
{"code": "static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }", "nl": "function to print the array elements"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 0 , 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = arr . length ; System . out . print ( \" Original \u2581 array : \u2581 \" ) ; printArray ( arr , n ) ; moveZerosToEnd ( arr , n ) ; System . out . print ( \" Modified array : \"); printArray ( arr , n ) ; } }", "nl": "Driver program to test above"}
{"code": "class GFG {", "nl": "Java implementation to rearrange the array elements after modification"}
{"code": "static void pushZerosToEnd ( int arr [ ] , int n ) {", "nl": "function which pushes all zeros to end of an array ."}
{"code": "int count = 0 ;", "nl": "Count of non - zero elements"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 )", "nl": "Traverse the array . If element encountered is non - zero , then replace the element at index ' count ' with this element"}
{"code": "arr [ count ++ ] = arr [ i ] ;", "nl": "here count is incremented"}
{"code": "while ( count < n ) arr [ count ++ ] = 0 ; }", "nl": "Now all non - zero elements have been shifted to front and ' count ' is set as index of first 0. Make all elements 0 from count to end ."}
{"code": "static void modifyAndRearrangeArr ( int arr [ ] , int n ) {", "nl": "function to rearrange the array elements after modification"}
{"code": "if ( n == 1 ) return ;", "nl": "if ' arr [ ] ' contains a single element only"}
{"code": "for ( int i = 0 ; i < n - 1 ; i ++ ) {", "nl": "traverse the array"}
{"code": "if ( ( arr [ i ] != 0 ) && ( arr [ i ] == arr [ i + 1 ] ) ) {", "nl": "if true , perform the required modification"}
{"code": "arr [ i ] = 2 * arr [ i ] ;", "nl": "double current index value"}
{"code": "arr [ i + 1 ] = 0 ;", "nl": "put 0 in the next index"}
{"code": "i ++ ; } }", "nl": "increment by 1 so as to move two indexes ahead during loop iteration"}
{"code": "pushZerosToEnd ( arr , n ) ; }", "nl": "push all the zeros at the end of ' arr [ ] '"}
{"code": "static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; System . out . println ( ) ; }", "nl": "function to print the array elements"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 0 , 2 , 2 , 2 , 0 , 6 , 6 , 0 , 0 , 8 } ; int n = arr . length ; System . out . print ( \" Original \u2581 array : \u2581 \" ) ; printArray ( arr , n ) ; modifyAndRearrangeArr ( arr , n ) ; System . out . print ( \" Modified \u2581 array : \u2581 \" ) ; printArray ( arr , n ) ; } }", "nl": "Driver program to test above"}
{"code": "public static void swap ( int [ ] A , int i , int j ) { int temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; }", "nl": "Function For Swaping Two Element Of An Array"}
{"code": "static void shiftAllZeroToLeft ( int array [ ] , int n ) {", "nl": "shift all zero to left side of an array"}
{"code": "int lastSeenNonZero = 0 ; for ( int index = 0 ; index < n ; index ++ ) {", "nl": "Maintain last index with positive value"}
{"code": "if ( array [ index ] != 0 ) {", "nl": "If Element is non - zero"}
{"code": "swap ( array , array [ index ] , array [ lastSeenNonZero ] ) ;", "nl": "swap current index , with lastSeen non - zero"}
{"code": "lastSeenNonZero ++ ; } } } }", "nl": "next element will be last seen non - zero"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to Rearrange positive and negative numbers in a array"}
{"code": "static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; System . out . println ( ) ; }", "nl": "A utility function to print an array of size n"}
{"code": "static void RearrangePosNeg ( int arr [ ] , int n ) { int key , j ; for ( int i = 1 ; i < n ; i ++ ) { key = arr [ i ] ;", "nl": "Function to Rearrange positive and negative numbers in a array"}
{"code": "if ( key > 0 ) continue ;", "nl": "if current element is positive do nothing"}
{"code": "j = i - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; }", "nl": "if current element is negative , shift positive elements of arr [ 0. . i - 1 ] , to one position to their right"}
{"code": "arr [ j + 1 ] = key ; } }", "nl": "Put negative element at its right position"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; int n = arr . length ; RearrangePosNeg ( arr , n ) ; printArray ( arr , n ) ; } }", "nl": "Driver program"}
{"code": "class GFG {", "nl": "Java program to Rearrange positive and negative numbers in a array"}
{"code": "static void printArray ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( A [ i ] + \" \u2581 \" ) ; System . out . println ( \" \" ) ; ; }", "nl": "Function to print an array"}
{"code": "static void reverse ( int arr [ ] , int l , int r ) { if ( l < r ) { arr = swap ( arr , l , r ) ; reverse ( arr , ++ l , -- r ) ; } }", "nl": "Function to reverse an array . An array can be reversed in O ( n ) time and O ( 1 ) space ."}
{"code": "static void merge ( int arr [ ] , int l , int m , int r ) {", "nl": "Merges two subarrays of arr [ ] . First subarray is arr [ l . . m ] Second subarray is arr [ m + 1. . r ]"}
{"code": "int i = l ;", "nl": "Initial index of 1 st subarray"}
{"code": "int j = m + 1 ; while ( i <= m && arr [ i ] < 0 ) i ++ ;", "nl": "Initial index of IInd"}
{"code": "while ( j <= r && arr [ j ] < 0 ) j ++ ;", "nl": "arr [ i . . m ] is positive"}
{"code": "reverse ( arr , i , m ) ;", "nl": "arr [ j . . r ] is positive reverse positive part of left sub - array ( arr [ i . . m ] )"}
{"code": "reverse ( arr , m + 1 , j - 1 ) ;", "nl": "reverse negative part of right sub - array ( arr [ m + 1. . j - 1 ] )"}
{"code": "reverse ( arr , i , j - 1 ) ; }", "nl": "reverse arr [ i . . j - 1 ]"}
{"code": "static void RearrangePosNeg ( int arr [ ] , int l , int r ) { if ( l < r ) {", "nl": "Function to Rearrange positive and negative numbers in a array"}
{"code": "int m = l + ( r - l ) / 2 ;", "nl": "Same as ( l + r ) / 2 , but avoids overflow for large l and h"}
{"code": "RearrangePosNeg ( arr , l , m ) ; RearrangePosNeg ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; }", "nl": "Sort first and second halves"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; int arr_size = arr . length ; RearrangePosNeg ( arr , 0 , arr_size - 1 ) ; printArray ( arr , arr_size ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { public static void RearrangePosNeg ( int arr [ ] ) { int i = 0 ; int j = arr . length - 1 ; while ( true ) {", "nl": "Java implementation of the above approach"}
{"code": "while ( arr [ i ] < 0 && i < arr . length ) i ++ ;", "nl": "Loop until arr [ i ] < 0 and still inside the array"}
{"code": "while ( arr [ j ] > 0 && j >= 0 ) j -- ;", "nl": "Loop until arr [ j ] > 0 and still inside the array"}
{"code": "if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } else break ; } }", "nl": "if i is less than j"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; RearrangePosNeg ( arr ) ; for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static void winner ( int arr [ ] , int N ) {", "nl": "Function to find the winner of the game played based on given conditions"}
{"code": "if ( N % 2 == 1 ) { System . out . print ( \" A \" ) ; }", "nl": "A wins if size of array is odd"}
{"code": "else { System . out . print ( \" B \" ) ; } }", "nl": "Otherwise , B wins"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 24 , 45 , 45 , 24 } ;", "nl": "Input array"}
{"code": "int N = arr . length ; winner ( arr , N ) ; } }", "nl": "Size of the array"}
{"code": "import java . util . * ; class GFG { static int sz = 20 ; static int sqr = ( int ) ( Math . sqrt ( sz ) ) + 1 ;", "nl": "Java program for the above approach"}
{"code": "static void precomputeExpressionForAllVal ( int arr [ ] , int N , int dp [ ] [ ] ) {", "nl": "Function to sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all possible values of X and Y , where Y is less than or equal to Math . sqrt ( N ) ."}
{"code": "for ( int i = N - 1 ; i >= 0 ; i -- ) {", "nl": "Iterate over all possible values of X"}
{"code": "for ( int j = 1 ; j <= Math . sqrt ( N ) ; j ++ ) {", "nl": "Precompute for all possible values of an expression such that y <= Math . sqrt ( N )"}
{"code": "if ( i + j < N ) {", "nl": "If i + j less than N"}
{"code": "dp [ i ] [ j ] = arr [ i ] + dp [ i + j ] [ j ] ; } else {", "nl": "Update dp [ i ] [ j ]"}
{"code": "dp [ i ] [ j ] = arr [ i ] ; } } } }", "nl": "Update dp [ i ] [ j ]"}
{"code": "static void querySum ( int arr [ ] , int N , int Q [ ] [ ] , int M ) {", "nl": "Function to Find the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all queries"}
{"code": "int [ ] [ ] dp = new int [ sz ] [ sqr ] ; precomputeExpressionForAllVal ( arr , N , dp ) ;", "nl": "dp [ x ] [ y ] : Stores sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ..."}
{"code": "for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ;", "nl": "Traverse the query array , Q [ ] [ ]"}
{"code": "if ( y <= Math . sqrt ( N ) ) { System . out . print ( dp [ x ] [ y ] + \" \u2581 \" ) ; continue ; }", "nl": "If y is less than or equal to Math . sqrt ( N )"}
{"code": "int sum = 0 ;", "nl": "Stores the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ..."}
{"code": "while ( x < N ) {", "nl": "Traverse the array , arr [ ]"}
{"code": "sum += arr [ x ] ;", "nl": "Update sum"}
{"code": "x += y ; } System . out . print ( sum + \" \u2581 \" ) ; } }", "nl": "Update x"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 7 , 5 , 4 } ; int Q [ ] [ ] = { { 2 , 1 } , { 3 , 2 } } ; int N = arr . length ; int M = Q . length ; querySum ( arr , N , Q , M ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; import java . io . * ; class GFG { static void findElements ( int arr [ ] , int n ) {", "nl": "Java program to find all elements in array which have at - least two greater elements itself ."}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }", "nl": "Pick elements one by one and count greater elements . If count is more than 2 , print that element ."}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; import java . io . * ; class GFG { static void findElements ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }", "nl": "Sorting based Java program to find all elements in array which have atleast two greater elements itself ."}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; import java . io . * ; class GFG { static void findElements ( int arr [ ] , int n ) { int first = Integer . MIN_VALUE ; int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Java program to find all elements in array which have atleast two greater elements itself ."}
{"code": "if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; }", "nl": "If current element is smaller than first then update both first and second"}
{"code": "else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }", "nl": "If arr [ i ] is in between first and second then update second"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 2 , - 6 , 3 , 5 , 1 } ; int n = arr . length ; findElements ( arr , n ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static int getMinOps ( int [ ] arr ) {", "nl": "Function to find the minimum number of operations required to make the array non - increasing"}
{"code": "int res = 0 ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) {", "nl": "Stores the count of required operations"}
{"code": "res += Math . max ( arr [ i + 1 ] - arr [ i ] , 0 ) ; }", "nl": "If arr [ i ] > arr [ i + 1 ] , no increments required . Otherwise , add their difference to the answer"}
{"code": "return res ; }", "nl": "Return the result res"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 4 , 1 , 2 } ; System . out . println ( getMinOps ( arr ) ) ; } }", "nl": "Driver Code"}
{"code": "int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ;", "nl": "function that returns smallest elements missing in a sorted array ."}
{"code": "if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }", "nl": "Left half has all elements from 0 to mid"}
{"code": "public static void main ( String [ ] args ) { SmallestMissing small = new SmallestMissing ( ) ; int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 } ; int n = arr . length ; System . out . println ( \" First \u2581 Missing \u2581 element \u2581 is \u2581 : \u2581 \" + small . findFirstMissing ( arr , 0 , n - 1 ) ) ; } }", "nl": "Driver program to test the above function"}
{"code": "import java . io . * ; class GFG {", "nl": "Java Program for above approach"}
{"code": "int findFirstMissing ( int [ ] arr , int start , int end , int first ) { if ( start < end ) { int mid = ( start + end ) / 2 ;", "nl": "Program to find missing element"}
{"code": "if ( arr [ mid ] != mid + first ) return findFirstMissing ( arr , start , mid , first ) ; else return findFirstMissing ( arr , mid + 1 , end , first ) ; } return start + first ; }", "nl": "* Index matches with value at that index , means missing element cannot be upto that point"}
{"code": "int findSmallestMissinginSortedArray ( int [ ] arr ) {", "nl": "Program to find Smallest Missing in Sorted Array"}
{"code": "if ( arr [ 0 ] != 0 ) return 0 ;", "nl": "Check if 0 is missing in the array"}
{"code": "if ( arr [ arr . length - 1 ] == arr . length - 1 ) return arr . length ; int first = arr [ 0 ] ; return findFirstMissing ( arr , 0 , arr . length - 1 , first ) ; }", "nl": "Check is all numbers 0 to n - 1 are prsent in array"}
{"code": "public static void main ( String [ ] args ) { GFG small = new GFG ( ) ; int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 7 } ; int n = arr . length ;", "nl": "Driver program to test the above function"}
{"code": "System . out . println ( \" First \u2581 Missing \u2581 element \u2581 is \u2581 : \u2581 \" + small . findSmallestMissinginSortedArray ( arr ) ) ; } }", "nl": "Function Call"}
{"code": "int FindMaxSum ( int arr [ ] , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) {", "nl": "Function to return max sum such that no two elements are adjacent"}
{"code": "excl_new = ( incl > excl ) ? incl : excl ;", "nl": "current max excluding i"}
{"code": "incl = excl + arr [ i ] ; excl = excl_new ; }", "nl": "current max including i"}
{"code": "return ( ( incl > excl ) ? incl : excl ) ; }", "nl": "return max of incl and excl"}
{"code": "public static void main ( String [ ] args ) { MaximumSum sum = new MaximumSum ( ) ; int arr [ ] = new int [ ] { 5 , 5 , 10 , 100 , 10 , 5 } ; System . out . println ( sum . FindMaxSum ( arr , arr . length ) ) ; } }", "nl": "Driver program to test above functions"}
{"code": "import java . util . * ; class GFG { static final int N = 7 ;", "nl": "Java program for the above approach"}
{"code": "static int countChanges ( int matrix [ ] [ ] , int n , int m ) {", "nl": "Function for counting minimum number of changes"}
{"code": "int dist = n + m - 1 ;", "nl": "Distance of elements from ( 0 , 0 ) will is i range [ 0 , n + m - 2 ]"}
{"code": "int [ ] [ ] freq = new int [ dist ] [ 10 ] ;", "nl": "Store frequencies of [ 0 , 9 ] at distance i"}
{"code": "for ( int i = 0 ; i < dist ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) freq [ i ] [ j ] = 0 ; }", "nl": "Initialize frequencies as 0"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) {", "nl": "Count frequencies of [ 0 , 9 ]"}
{"code": "freq [ i + j ] [ matrix [ i ] [ j ] ] ++ ; } } int min_changes_sum = 0 ; for ( int i = 0 ; i < dist / 2 ; i ++ ) { int maximum = 0 ; int total_values = 0 ;", "nl": "Increment frequency of value matrix [ i ] [ j ] at distance i + j"}
{"code": "for ( int j = 0 ; j < 10 ; j ++ ) { maximum = Math . max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; }", "nl": "Find value with max frequency and count total cells at distance i from front end and rear end"}
{"code": "min_changes_sum += ( total_values - maximum ) ; }", "nl": "Change all values to the value with max frequency"}
{"code": "return min_changes_sum ; }", "nl": "Return the answer"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int mat [ ] [ ] = { { 1 , 2 } , { 3 , 5 } } ;", "nl": "Given matrix"}
{"code": "System . out . print ( countChanges ( mat , 2 , 2 ) ) ; } }", "nl": "Function call"}
{"code": "import java . io . * ; class GFG { static int MAX = 500 ;", "nl": "Java program to do range minimum query using sparse table"}
{"code": "static int [ ] [ ] lookup = new int [ MAX ] [ MAX ] ;", "nl": "lookup [ i ] [ j ] is going to store minimum value in arr [ i . . j ] . Ideally lookup table size should not be fixed and should be determined using n Log n . It is kept constant to keep code simple ."}
{"code": "static void buildSparseTable ( int arr [ ] , int n ) {", "nl": "Fills lookup array lookup [ ] [ ] in bottom up manner ."}
{"code": "for ( int i = 0 ; i < n ; i ++ ) lookup [ i ] [ 0 ] = arr [ i ] ;", "nl": "Initialize M for the intervals with length 1"}
{"code": "for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) {", "nl": "Compute values from smaller to bigger intervals"}
{"code": "for ( int i = 0 ; ( i + ( 1 << j ) - 1 ) < n ; i ++ ) {", "nl": "Compute minimum value for all intervals with size 2 ^ j"}
{"code": "if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] ; else lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ; } } }", "nl": "For arr [ 2 ] [ 10 ] , we compare arr [ lookup [ 0 ] [ 7 ] ] and arr [ lookup [ 3 ] [ 10 ] ]"}
{"code": "static int query ( int L , int R ) {", "nl": "Returns minimum of arr [ L . . R ]"}
{"code": "int j = ( int ) Math . log ( R - L + 1 ) ;", "nl": "Find highest power of 2 that is smaller than or equal to count of elements in given range . For [ 2 , 10 ] , j = 3"}
{"code": "if ( lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] ) return lookup [ L ] [ j ] ; else return lookup [ R - ( 1 << j ) + 1 ] [ j ] ; }", "nl": "Compute minimum of last 2 ^ j elements with first 2 ^ j elements in range . For [ 2 , 10 ] , we compare arr [ lookup [ 0 ] [ 3 ] ] and arr [ lookup [ 3 ] [ 3 ] ] ,"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = a . length ; buildSparseTable ( a , n ) ; System . out . println ( query ( 0 , 4 ) ) ; System . out . println ( query ( 4 , 7 ) ) ; System . out . println ( query ( 7 , 8 ) ) ; } }", "nl": "Driver program"}
{"code": "import java . util . * ; class GFG { static final int MAX = 500 ;", "nl": "Java program to do range minimum query using sparse table"}
{"code": "static int [ ] [ ] table = new int [ MAX ] [ MAX ] ;", "nl": "lookup [ i ] [ j ] is going to store GCD of arr [ i . . j ] . Ideally lookup table size should not be fixed and should be determined using n Log n . It is kept constant to keep code simple ."}
{"code": "static void buildSparseTable ( int arr [ ] , int n ) {", "nl": "it builds sparse table ."}
{"code": "for ( int i = 0 ; i < n ; i ++ ) table [ i ] [ 0 ] = arr [ i ] ;", "nl": "GCD of single element is element itself"}
{"code": "for ( int j = 1 ; j <= n ; j ++ ) for ( int i = 0 ; i <= n - ( 1 << j ) ; i ++ ) table [ i ] [ j ] = __gcd ( table [ i ] [ j - 1 ] , table [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) ; }", "nl": "Build sparse table"}
{"code": "static int query ( int L , int R ) {", "nl": "Returns GCD of arr [ L . . R ]"}
{"code": "int j = ( int ) Math . log ( R - L + 1 ) ;", "nl": "Find highest power of 2 that is smaller than or equal to count of elements in given range . For [ 2 , 10 ] , j = 3"}
{"code": "return __gcd ( table [ L ] [ j ] , table [ R - ( 1 << j ) + 1 ] [ j ] ) ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; }", "nl": "Compute GCD of last 2 ^ j elements with first 2 ^ j elements in range . For [ 2 , 10 ] , we find GCD of arr [ lookup [ 0 ] [ 3 ] ] and arr [ lookup [ 3 ] [ 3 ] ] ,"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = a . length ; buildSparseTable ( a , n ) ; System . out . print ( query ( 0 , 2 ) + \"NEW_LINE\"); System . out . print ( query ( 1 , 3 ) + \"NEW_LINE\"); System . out . print ( query ( 4 , 5 ) + \"NEW_LINE\"); } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to find lexicographically minimum value after k swaps ."}
{"code": "static void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) {", "nl": "Modifies arr [ 0. . n - 1 ] to lexicographically smallest with k swaps ."}
{"code": "int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) {", "nl": "Set the position where we want to put the smallest integer"}
{"code": "if ( j - i > k ) break ;", "nl": "If we exceed the Max swaps then terminate the loop"}
{"code": "if ( arr [ j ] < arr [ pos ] ) pos = j ; }", "nl": "Find the minimum value from i + 1 to max k or n"}
{"code": "int temp ; for ( int j = pos ; j > i ; -- j ) { temp = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = temp ; }", "nl": "Swap the elements from Minimum position we found till now to the i index"}
{"code": "k -= pos - i ; } }", "nl": "Set the final value after swapping pos - i elements"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 7 , 6 , 9 , 2 , 1 } ; int n = arr . length ; int k = 3 ;", "nl": "Driver method"}
{"code": "minimizeWithKSwaps ( arr , n , k ) ;", "nl": "Function calling"}
{"code": "for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }", "nl": "Print the final Array"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find maximum average subarray of given length ."}
{"code": "static int findMaxAverage ( int [ ] arr , int n , int k ) {", "nl": "Returns beginning index of maximum average subarray of length ' k '"}
{"code": "if ( k > n ) return - 1 ;", "nl": "Check if ' k ' is valid"}
{"code": "int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ;", "nl": "Create and fill array to store cumulative sum . csum [ i ] stores sum of arr [ 0 ] to arr [ i ]"}
{"code": "int max_sum = csum [ k - 1 ] , max_end = k - 1 ;", "nl": "Initialize max_sm as sum of first subarray"}
{"code": "for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } }", "nl": "Find sum of other subarrays and update max_sum if required ."}
{"code": "return max_end - k + 1 ; }", "nl": "Return starting index"}
{"code": "static public void main ( String [ ] args ) { int [ ] arr = { 1 , 12 , - 5 , - 6 , 50 , 3 } ; int k = 4 ; int n = arr . length ; System . out . println ( \" The \u2581 maximum \u2581 \" + \" average \u2581 subarray \u2581 of \u2581 length \u2581 \" + k + \" \u2581 begins \u2581 at \u2581 index \u2581 \" + findMaxAverage ( arr , n , k ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find maximum average subarray of given length ."}
{"code": "static int findMaxAverage ( int arr [ ] , int n , int k ) {", "nl": "Returns beginning index of maximum average subarray of length ' k '"}
{"code": "if ( k > n ) return - 1 ;", "nl": "Check if ' k ' is valid"}
{"code": "int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ;", "nl": "Compute sum of first ' k ' elements"}
{"code": "for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } }", "nl": "Compute sum of remaining subarrays"}
{"code": "return max_end - k + 1 ; }", "nl": "Return starting index"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 12 , - 5 , - 6 , 50 , 3 } ; int k = 4 ; int n = arr . length ; System . out . println ( \" The \u2581 maximum \u2581 average \" + \" \u2581 subarray \u2581 of \u2581 length \u2581 \" + k + \" \u2581 begins \u2581 at \u2581 index \u2581 \" + findMaxAverage ( arr , n , k ) ) ; } }", "nl": "Driver program"}
{"code": "import java . io . * ; import java . util . * ; class GFG { static class R { int x , y ; public R ( int x , int y ) { this . x = x ; this . y = y ; } }", "nl": "Java program for the above approach"}
{"code": "static HashMap < R , Integer > m = new HashMap < > ( ) ;", "nl": "Stores the minimum score for each states as map < pair < pos , myturn > , ans >"}
{"code": "public static int findMinimum ( int [ ] arr , int N , int pos , int turn ) {", "nl": "Function to find the minimum score after choosing element from array"}
{"code": "R x = new R ( pos , turn ) ; if ( m . containsKey ( x ) ) { return m . get ( x ) ; }", "nl": "Return the stored state"}
{"code": "if ( pos >= N - 1 ) { return 0 ; }", "nl": "Base Case"}
{"code": "if ( turn == 0 ) {", "nl": "Player A 's turn"}
{"code": "int ans = Math . min ( findMinimum ( arr , N , pos + 1 , 1 ) + arr [ pos ] , findMinimum ( arr , N , pos + 2 , 1 ) + arr [ pos ] + arr [ pos + 1 ] ) ;", "nl": "Find the minimum score"}
{"code": "R v = new R ( pos , turn ) ; m . put ( v , ans ) ;", "nl": "Store the current state"}
{"code": "return ans ; }", "nl": "Return the result"}
{"code": "if ( turn != 0 ) {", "nl": "Player B 's turn"}
{"code": "int ans = Math . min ( findMinimum ( arr , N , pos + 1 , 0 ) , findMinimum ( arr , N , pos + 2 , 0 ) ) ;", "nl": "Find minimum score"}
{"code": "R v = new R ( pos , turn ) ; m . put ( v , ans ) ;", "nl": "Store the current state"}
{"code": "return ans ; } return 0 ; }", "nl": "Return the result"}
{"code": "public static int countPenality ( int [ ] arr , int N ) {", "nl": "Function that finds the minimum penality after choosing element from the given binary array"}
{"code": "int pos = 0 ;", "nl": "Starting position of choosing element from array"}
{"code": "int turn = 0 ;", "nl": "0 denotes player A turn 1 denotes player B turn"}
{"code": "return findMinimum ( arr , N , pos , turn ) + 1 ; }", "nl": "Function Call"}
{"code": "public static void printAnswer ( int [ ] arr , int N ) {", "nl": "Function to print the answer"}
{"code": "int a = countPenality ( arr , N ) ;", "nl": "Minimum penalty"}
{"code": "int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; }", "nl": "Calculate sum of all arr elements"}
{"code": "System . out . println ( a ) ; }", "nl": "Print the minimum score"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 } ; int N = 8 ; printAnswer ( arr , N ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG { static int MAX = 1000001 ; static int prime [ ] = new int [ MAX ] ;", "nl": "Java program for the above approach"}
{"code": "static void SieveOfEratosthenes ( ) {", "nl": "Function to find the prime numbers"}
{"code": "Arrays . fill ( prime , 1 ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) {", "nl": "Create a boolean array prime [ ] and initialize all entries it as true A value in prime [ i ] will finally be false if i is Not a prime"}
{"code": "if ( prime [ p ] == 1 ) {", "nl": "Check if prime [ p ] is not changed , then it is a prime"}
{"code": "for ( int i = p * p ; i <= MAX - 1 ; i += p ) prime [ i ] = 0 ; } } }", "nl": "Update all multiples of p greater than or equal to the square of it numbers which are multiple of p and are less than p ^ 2 are already been marked"}
{"code": "static int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; }", "nl": "Function to get the middle index from corner indexes"}
{"code": "static int getSumUtil ( int [ ] st , int ss , int se , int qs , int qe , int si ) {", "nl": "Function to get the sum of values in the given range of the array"}
{"code": "if ( qs <= ss && qe >= se ) return st [ si ] ;", "nl": "If segment of this node is a part of given range , then return the sum of the segment"}
{"code": "if ( se < qs ss > qe ) return 0 ;", "nl": "If segment of this node is outside the given range"}
{"code": "int mid = getMid ( ss , se ) ; return getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ; }", "nl": "If a part of this segment overlaps with the given range"}
{"code": "static void updateValueUtil ( int [ ] st , int ss , int se , int i , int diff , int si ) {", "nl": "Function to update the nodes which have the given index in their range"}
{"code": "if ( i < ss i > se ) return ;", "nl": "If the input index lies outside the range of this segment"}
{"code": "st [ si ] = st [ si ] + diff ; if ( se != ss ) { int mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } }", "nl": "If the input index is in range of this node , then update the value of the node and its children"}
{"code": "static void updateValue ( int arr [ ] , int [ ] st , int n , int i , int new_val ) {", "nl": "Function to update a value in input array and segment tree"}
{"code": "if ( i < 0 i > n - 1 ) { System . out . print ( \" - 1\" ) ; return ; }", "nl": "Check for erroneous input index"}
{"code": "int diff = new_val - arr [ i ] ; int prev_val = arr [ i ] ;", "nl": "Get the difference between new value and old value"}
{"code": "arr [ i ] = new_val ;", "nl": "Update the value in array"}
{"code": "if ( ( prime [ new_val ] prime [ prev_val ] ) != 0 ) {", "nl": "Update the values of nodes in segment tree only if either previous value or new value or both are prime"}
{"code": "if ( prime [ prev_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) ;", "nl": "If only new value is prime"}
{"code": "else if ( prime [ new_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) ;", "nl": "If only new value is prime"}
{"code": "else updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; } }", "nl": "If both are prime"}
{"code": "static int getSum ( int [ ] st , int n , int qs , int qe ) {", "nl": "Return sum of elements in range from index qs ( query start ) to qe ( query end ) . It mainly uses getSumUtil ( )"}
{"code": "if ( qs < 0 qe > n - 1 qs > qe ) { System . out . println ( \" - 1\" ) ; return - 1 ; } return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) ; }", "nl": "Check for erroneous input values"}
{"code": "static int constructSTUtil ( int arr [ ] , int ss , int se , int [ ] st , int si ) {", "nl": "Function that constructs Segment Tree"}
{"code": "if ( ss == se ) {", "nl": "If there is one element in array , store it in current node of segment tree and return"}
{"code": "if ( prime [ arr [ ss ] ] != 0 ) st [ si ] = arr [ ss ] ; else st [ si ] = 0 ; return st [ si ] ; }", "nl": "Only add those elements in segment tree which are prime"}
{"code": "int mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ; return st [ si ] ; }", "nl": "If there are more than one elements , then recur for left and right subtrees and store the sum of values in this node"}
{"code": "static int [ ] constructST ( int arr [ ] , int n ) {", "nl": "Function to construct segment tree from given array"}
{"code": "int x = ( int ) ( Math . ceil ( Math . log ( n ) / Math . log ( 2 ) ) ) ;", "nl": "Height of segment tree"}
{"code": "int max_size = 2 * ( int ) Math . pow ( 2 , x ) - 1 ;", "nl": "Maximum size of segment tree"}
{"code": "int [ ] st = new int [ max_size ] ;", "nl": "Allocate memory"}
{"code": "constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ;", "nl": "Fill the allocated memory st"}
{"code": "return st ; }", "nl": "Return the constructed segment tree"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 , 11 } ; int n = arr . length ; int Q [ ] [ ] = { { 1 , 1 , 3 } , { 2 , 1 , 10 } , { 1 , 1 , 3 } } ;", "nl": "Driver Code"}
{"code": "SieveOfEratosthenes ( ) ;", "nl": "Function call"}
{"code": "int [ ] st = constructST ( arr , n ) ;", "nl": "Build segment tree from given array"}
{"code": "System . out . println ( getSum ( st , n , 1 , 3 ) ) ;", "nl": "Print sum of values in array from index 1 to 3"}
{"code": "updateValue ( arr , st , n , 1 , 10 ) ;", "nl": "Update : set arr [ 1 ] = 10 and update corresponding segment tree nodes"}
{"code": "System . out . println ( getSum ( st , n , 1 , 3 ) ) ; } }", "nl": "Find sum after the value is updated"}
{"code": "import java . util . * ; class GFG { static int mod = 1000000007 ; static int [ ] [ ] dp = new int [ 1000 ] [ 1000 ] ; static int calculate ( int pos , int prev , String s , Vector < Integer > index ) {", "nl": "Java Program to Count the number of ways to construct the target String"}
{"code": "if ( pos == s . length ( ) ) return 1 ;", "nl": "base case"}
{"code": "if ( dp [ pos ] [ prev ] != - 1 ) return dp [ pos ] [ prev ] ;", "nl": "If current subproblem has been solved , use the value"}
{"code": "int answer = 0 ; for ( int i = 0 ; i < index . size ( ) ; i ++ ) { if ( index . get ( i ) . compareTo ( prev ) >= 0 ) { answer = ( answer % mod + calculate ( pos + 1 , index . get ( i ) , s , index ) % mod ) % mod ; } }", "nl": "search through all the indiced at which the current character occurs . For each index greater than prev , take the index and move to the next position , and add to the answer ."}
{"code": "return dp [ pos ] [ prev ] = answer ; } static int countWays ( Vector < String > a , String s ) { int n = a . size ( ) ;", "nl": "Store and return the solution for this subproblem"}
{"code": "Vector < Integer > [ ] index = new Vector [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) index [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < a . get ( i ) . length ( ) ; j ++ ) {", "nl": "preprocess the Strings by storing for each character of every String , the index of their occurrence we will use a common list for all because of only the index matter in the String from which the character was picked"}
{"code": "index [ a . get ( i ) . charAt ( j ) - ' a ' ] . add ( j + 1 ) ; } }", "nl": "we are storing j + 1 because the initial picked index in the recursive step will ne 0. This is just for ease of implementation"}
{"code": "for ( int i = 0 ; i < 1000 ; i ++ ) { for ( int j = 0 ; j < 1000 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return calculate ( 0 , 0 , s , index [ 0 ] ) ; }", "nl": "initialise dp table . - 1 represents that the subproblem hasn 't been solved"}
{"code": "public static void main ( String [ ] args ) { Vector < String > A = new Vector < String > ( ) ; A . add ( \" adc \" ) ; A . add ( \" aec \" ) ; A . add ( \" erg \" ) ; String S = \" ac \" ; System . out . print ( countWays ( A , S ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static final int MAX = 100005 ; static final int MOD = 1000000007 ;", "nl": "Java implementation of the approach"}
{"code": "static int [ ] [ ] [ ] dp = new int [ MAX ] [ 101 ] [ 2 ] ;", "nl": "To store the states of the dp"}
{"code": "static int countNum ( int idx , int sum , int tight , Vector < Integer > num , int len , int k ) { if ( len == idx ) { if ( sum == 0 ) return 1 ; else return 0 ; } if ( dp [ idx ] [ sum ] [ tight ] != - 1 ) return dp [ idx ] [ sum ] [ tight ] ; int res = 0 , limit ;", "nl": "Function to return the count of numbers from the range [ 0 , n ] whose digit sum is a multiple of k using bottom - up dp"}
{"code": "if ( tight == 0 ) { limit = num . get ( idx ) ; }", "nl": "The digit in this index can only be from [ 0 , num [ idx ] ]"}
{"code": "else { limit = 9 ; } for ( int i = 0 ; i <= limit ; i ++ ) {", "nl": "The digit in this index can be anything from [ 0 , 9 ]"}
{"code": "int new_tight = tight ; if ( tight == 0 && i < limit ) new_tight = 1 ; res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len , k ) ; res %= MOD ; }", "nl": "new_tight is the flag value for the next position"}
{"code": "if ( res < 0 ) res += MOD ; return dp [ idx ] [ sum ] [ tight ] = res ; }", "nl": "res can 't be negative"}
{"code": "static Vector < Integer > process ( String s ) { Vector < Integer > num = new Vector < Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { num . add ( s . charAt ( i ) - '0' ) ; } return num ; }", "nl": "Function to process the String to a vector of digits from MSD to LSD"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "String n = \"98765432109876543210\" ;", "nl": "For large input number n"}
{"code": "int len = n . length ( ) ; int k = 58 ;", "nl": "Total number of digits in n"}
{"code": "for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < 101 ; j ++ ) { for ( int l = 0 ; l < 2 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } }", "nl": "Clean dp table"}
{"code": "Vector < Integer > num = process ( n ) ; System . out . print ( countNum ( 0 , 0 , 0 , num , len , k ) ) ; } }", "nl": "Process the String to a vector of digits from MSD to LSD"}
{"code": "import java . util . * ; import java . lang . * ; class GFG { public static int [ ] countSum ( int arr [ ] , int n ) { int result = 0 ;", "nl": "Java implementation to find the number of Subsequences with Even and Odd Sum"}
{"code": "int [ ] countODD = new int [ n + 1 ] ; int [ ] countEVEN = new int [ n + 1 ] ;", "nl": "Arrays to store the count of even subsequences and odd subsequences"}
{"code": "countODD [ 0 ] = 0 ; countEVEN [ 0 ] = 0 ;", "nl": "Initialising countEVEN [ 0 ] and countODD [ 0 ] to 0 since as there is no subsequence before the iteration with even or odd count ."}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) {", "nl": "Here countODD [ i ] denotes count of odd subsequences till i"}
{"code": "if ( arr [ i - 1 ] % 2 == 0 ) { countEVEN [ i ] = countEVEN [ i - 1 ] + countEVEN [ i - 1 ] + 1 ; countODD [ i ] = countODD [ i - 1 ] + countODD [ i - 1 ] ; }", "nl": "if the number is even"}
{"code": "else { countEVEN [ i ] = countEVEN [ i - 1 ] + countODD [ i - 1 ] ; countODD [ i ] = countODD [ i - 1 ] + countEVEN [ i - 1 ] + 1 ; } } int [ ] ans = new int [ 2 ] ; ans [ 0 ] = countEVEN [ n ] ; ans [ 1 ] = countODD [ n ] ; return ans ; }", "nl": "if the number is odd"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 1 , 2 , 2 , 3 } ; int n = 4 ; int [ ] ans = countSum ( arr , n ) ; System . out . println ( \" EvenSum \u2581 = \u2581 \" + ans [ 0 ] ) ; System . out . println ( \" OddSum \u2581 = \u2581 \" + ans [ 1 ] ) ; } }", "nl": "Driver Code"}
{"code": "class GFG { static int maxN = 31 ; static int maxW = 31 ;", "nl": "Java implementation of the above approach"}
{"code": "static int dp [ ] [ ] [ ] = new int [ maxN ] [ maxW ] [ maxW ] ;", "nl": "3D array to store states of DP"}
{"code": "static int maxWeight ( int arr [ ] , int n , int w1_r , int w2_r , int i ) {", "nl": "w1_r represents remaining capacity of 1 st knapsack w2_r represents remaining capacity of 2 nd knapsack i represents index of the array arr we are working on"}
{"code": "if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != - 1 ) return dp [ i ] [ w1_r ] [ w2_r ] ;", "nl": "Base case"}
{"code": "int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ;", "nl": "Variables to store the result of three parts of recurrence relation"}
{"code": "dp [ i ] [ w1_r ] [ w2_r ] = Math . max ( fill_none , Math . max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; }", "nl": "Store the state in the 3D array"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int arr [ ] = { 8 , 2 , 3 } ;", "nl": "Input array"}
{"code": "for ( int i = 0 ; i < maxN ; i ++ ) for ( int j = 0 ; j < maxW ; j ++ ) for ( int k = 0 ; k < maxW ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ;", "nl": "Initializing the array with - 1"}
{"code": "int n = arr . length ;", "nl": "Number of elements in the array"}
{"code": "int w1 = 10 , w2 = 3 ;", "nl": "Capacity of knapsacks"}
{"code": "System . out . println ( maxWeight ( arr , n , w1 , w2 , 0 ) ) ; } }", "nl": "Function to be called"}
{"code": "import java . util . * ; class GFG { static int n = 3 ;", "nl": "Java program to find sum of Bit - wise AND of all submatrices"}
{"code": "static void findPrefixCount ( int p_arr [ ] [ ] , boolean set_bit [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( ! set_bit [ i ] [ j ] ) continue ; if ( j != n - 1 ) p_arr [ i ] [ j ] += p_arr [ i ] [ j + 1 ] ; p_arr [ i ] [ j ] += ( set_bit [ i ] [ j ] ) ? 1 : 0 ; } } } static class pair { int first , second ; pair ( ) { } pair ( int a , int b ) { first = a ; second = b ; } }", "nl": "Function to find prefix - count for each row from right to left"}
{"code": "static int matrixAllOne ( boolean set_bit [ ] [ ] ) {", "nl": "Function to find the number of submatrices with all 1 s"}
{"code": "int p_arr [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) p_arr [ i ] [ j ] = 0 ; findPrefixCount ( p_arr , set_bit ) ;", "nl": "Array to store required prefix count of 1 s from right to left for boolean array"}
{"code": "int ans = 0 ;", "nl": "Variable to store the final answer"}
{"code": "for ( int j = 0 ; j < n ; j ++ ) { int i = n - 1 ;", "nl": "For each index of a column , determine the number of sub - matrices starting from that index and has all 1 s"}
{"code": "Stack < pair > q = new Stack < pair > ( ) ;", "nl": "Stack to store elements and the count of the numbers they popped First part of pair is value of inserted element Second part is count of the number of elements pushed before with a greater value"}
{"code": "int to_sum = 0 ; while ( i >= 0 ) { int c = 0 ; while ( q . size ( ) != 0 && q . peek ( ) . first > p_arr [ i ] [ j ] ) { to_sum -= ( q . peek ( ) . second + 1 ) * ( q . peek ( ) . first - p_arr [ i ] [ j ] ) ; c += q . peek ( ) . second + 1 ; q . pop ( ) ; } to_sum += p_arr [ i ] [ j ] ; ans += to_sum ; q . push ( new pair ( p_arr [ i ] [ j ] , c ) ) ; i -- ; } } return ans ; }", "nl": "variable to store the number of submatrices with all 1 s"}
{"code": "static int sumAndMatrix ( int arr [ ] [ ] ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) {", "nl": "Function to find sum of Bitwise - OR of all submatrices"}
{"code": "boolean set_bit [ ] [ ] = new boolean [ n ] [ n ] ; for ( int R = 0 ; R < n ; R ++ ) for ( int C = 0 ; C < n ; C ++ ) set_bit [ R ] [ C ] = ( ( arr [ R ] [ C ] & ( 1 << i ) ) != 0 ) ; sum += ( mul * matrixAllOne ( set_bit ) ) ; mul *= 2 ; } return sum ; }", "nl": "matrix to store the status of ith bit of each element of matrix arr"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] [ ] = { { 9 , 7 , 4 } , { 8 , 9 , 2 } , { 11 , 11 , 5 } } ; System . out . println ( sumAndMatrix ( arr ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG { static int CountWays ( int n ) {", "nl": "Bottom up approach for counting ways to reach a score using 1 and 2 with consecutive 2 allowed"}
{"code": "int noOfWays [ ] = new int [ n + 3 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ;", "nl": "noOfWays [ i ] will store count for last 3 values before i ."}
{"code": "for ( int i = 3 ; i < n + 1 ; i ++ ) { noOfWays [ i ] =", "nl": "Loop till \" n + 1\" to compute value for \" n \""}
{"code": "noOfWays [ 3 - 1 ]", "nl": "number of ways if first run is 1"}
{"code": "+ noOfWays [ 3 - 3 ] ;", "nl": "number of ways if first run is 2 and second run is 1"}
{"code": "noOfWays [ 0 ] = noOfWays [ 1 ] ; noOfWays [ 1 ] = noOfWays [ 2 ] ; noOfWays [ 2 ] = noOfWays [ i ] ; } return noOfWays [ n ] ; }", "nl": "Remember last 3 values"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( CountWays ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; public class Main { static class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int MAX = 105 , q = 0 ; static int [ ] prime = new int [ MAX ] ; static void sieve ( ) { for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * i ; j < MAX ; j += i ) prime [ j ] = 1 ; } } }", "nl": "Java implementation of above approach"}
{"code": "static void dfs ( int i , int j , int k , int n , int m , int [ ] [ ] mappedMatrix , int [ ] [ ] mark , pair [ ] ans ) {", "nl": "Depth First Search"}
{"code": "if ( ( mappedMatrix [ i ] [ j ] == 0 ? true : false ) || ( i > n ? true : false ) || ( j > m ? true : false ) || ( mark [ i ] [ j ] != 0 ? true : false ) || ( q != 0 ? true : false ) ) return ;", "nl": "Return if cell contain non prime number or obstacle , or going out of matrix or already visited the cell or already found the lexicographical largest path"}
{"code": "mark [ i ] [ j ] = 1 ;", "nl": "Marking cell is already visited"}
{"code": "ans [ k ] = new pair ( i , j ) ;", "nl": "Storing the lexicographical largest path index"}
{"code": "if ( i == n && j == m ) {", "nl": "If reached the end of the matrix"}
{"code": "( q ) = k ; return ; }", "nl": "Updating the final number of steps in lexicographical largest path"}
{"code": "dfs ( i + 1 , j + 1 , k + 1 , n , m , mappedMatrix , mark , ans ) ;", "nl": "Moving diagonal ( trying lexicographical largest path )"}
{"code": "dfs ( i + 1 , j , k + 1 , n , m , mappedMatrix , mark , ans ) ;", "nl": "Moving cell right to current cell"}
{"code": "dfs ( i , j + 1 , k + 1 , n , m , mappedMatrix , mark , ans ) ; }", "nl": "Moving cell down to current cell ."}
{"code": "static void lexicographicalPath ( int n , int m , int [ ] [ ] mappedMatrix ) {", "nl": "Print lexicographical largest prime path"}
{"code": "int q = 0 ;", "nl": "To count the number of step in lexicographical largest prime path"}
{"code": "pair [ ] ans = new pair [ MAX ] ;", "nl": "To store the lexicographical largest prime path index"}
{"code": "int [ ] [ ] mark = new int [ MAX ] [ MAX ] ;", "nl": "To mark if the cell is already traversed or not"}
{"code": "dfs ( 1 , 1 , 1 , n , m , mappedMatrix , mark , ans ) ; int [ ] [ ] anss = { { 1 , 1 } , { 2 , 1 } , { 3 , 2 } , { 3 , 3 } } ;", "nl": "Traversing by DFS"}
{"code": "for ( int i = 0 ; i < 4 ; i ++ ) System . out . println ( anss [ i ] [ 0 ] + \" \u2581 \" + anss [ i ] [ 1 ] ) ; }", "nl": "Printing the lexicographical largest prime path"}
{"code": "static void countPrimePath ( int [ ] [ ] mappedMatrix , int n , int m ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 1 ] [ 1 ] = 1 ;", "nl": "Return the number of prime path in ther matrix ."}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) {", "nl": "For each cell"}
{"code": "if ( i == 1 && j == 1 ) continue ; dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) ;", "nl": "If on the top row or leftmost column , there is no path there ."}
{"code": "if ( mappedMatrix [ i ] [ j ] == 0 ) dp [ i ] [ j ] = 0 ; } } System . out . println ( dp [ n ] [ m ] ) ; }", "nl": "If non prime number"}
{"code": "static void preprocessMatrix ( int [ ] [ ] mappedMatrix , int [ ] [ ] a , int n , int m ) {", "nl": "Finding the matrix mapping by considering non prime number as obstacle and prime number be valid path ."}
{"code": "sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) {", "nl": "Sieve"}
{"code": "if ( prime [ a [ i ] [ j ] ] == 0 ) mappedMatrix [ i + 1 ] [ j + 1 ] = 1 ;", "nl": "If prime"}
{"code": "else mappedMatrix [ i + 1 ] [ j + 1 ] = 0 ; } } }", "nl": "If non prime"}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; int m = 3 ; int [ ] [ ] a = { { 2 , 3 , 7 } , { 5 , 4 , 2 } , { 3 , 7 , 11 } } ; int [ ] [ ] mappedMatrix = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { mappedMatrix [ i ] [ j ] = 0 ; } } preprocessMatrix ( mappedMatrix , a , n , m ) ; countPrimePath ( mappedMatrix , n , m ) ; lexicographicalPath ( n , m , mappedMatrix ) ; } }", "nl": "Driver code"}
{"code": "class sumofSub {", "nl": "A Dynamic Programming solution for subset sum problem + maximal subset value ."}
{"code": "static int isSubsetSum ( int set [ ] , int n , int sum ) {", "nl": "Returns size of maximum sized subset if there is a subset of set [ ] with sun equal to given sum . It returns - 1 if there is no subset with given sum ."}
{"code": "boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ] ; int count [ ] [ ] = new int [ sum + 1 ] [ n + 1 ] ;", "nl": "The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i"}
{"code": "for ( int i = 0 ; i <= n ; i ++ ) { subset [ 0 ] [ i ] = true ; count [ 0 ] [ i ] = 0 ; }", "nl": "If sum is 0 , then answer is true"}
{"code": "for ( int i = 1 ; i <= sum ; i ++ ) { subset [ i ] [ 0 ] = false ; count [ i ] [ 0 ] = - 1 ; }", "nl": "If sum is not 0 and set is empty , then answer is false"}
{"code": "for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; count [ i ] [ j ] = count [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) { subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; if ( subset [ i ] [ j ] ) count [ i ] [ j ] = Math . max ( count [ i ] [ j - 1 ] , count [ i - set [ j - 1 ] ] [ j - 1 ] + 1 ) ; } } } return count [ sum ] [ n ] ; }", "nl": "Fill the subset table in bottom up manner"}
{"code": "public static void main ( String args [ ] ) { int set [ ] = { 2 , 3 , 5 , 10 } ; int sum = 20 ; int n = set . length ; System . out . println ( isSubsetSum ( set , n , sum ) ) ; } }", "nl": "Driver program to test above function"}
{"code": "class GFG { static int MAX = 100 ;", "nl": "Java program to find all LCS of two strings in sorted order ."}
{"code": "static int lcslen = 0 ;", "nl": "length of lcs"}
{"code": "static int [ ] [ ] dp = new int [ MAX ] [ MAX ] ;", "nl": "dp matrix to store result of sub calls for lcs"}
{"code": "static int lcs ( String str1 , String str2 , int len1 , int len2 , int i , int j ) { int ret = dp [ i ] [ j ] ;", "nl": "A memoization based function that returns LCS of str1 [ i . . len1 - 1 ] and str2 [ j . . len2 - 1 ]"}
{"code": "if ( i == len1 j == len2 ) return ret = 0 ;", "nl": "base condition"}
{"code": "if ( ret != - 1 ) return ret ; ret = 0 ;", "nl": "if lcs has been computed"}
{"code": "if ( str1 . charAt ( i ) == str2 . charAt ( j ) ) ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) ; else ret = Math . max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) ; return ret ; }", "nl": "if characters are same return previous + 1 else max of two sequences after removing i ' th \u2581 and \u2581 j ' th char one by one"}
{"code": "static void printAll ( String str1 , String str2 , int len1 , int len2 , char [ ] data , int indx1 , int indx2 , int currlcs ) {", "nl": "Function to print all routes common sub - sequences of length lcslen"}
{"code": "if ( currlcs == lcslen ) { data [ currlcs ] = ' \\0' ; System . out . println ( new String ( data ) ) ; return ; }", "nl": "if currlcs is equal to lcslen then print it"}
{"code": "if ( indx1 == len1 indx2 == len2 ) return ;", "nl": "if we are done with all the characters of both string"}
{"code": "for ( char ch = ' a ' ; ch <= ' z ' ; ch ++ ) {", "nl": "here we have to print all sub - sequences lexicographically , that ' s \u2581 why \u2581 we \u2581 start \u2581 from \u2581 ' a ' to ' z ' if this character is  present in both of them then append it in data[] and same  remaining part"}
{"code": "boolean done = false ; for ( int i = indx1 ; i < len1 ; i ++ ) {", "nl": "done is a flag to tell that we have printed all the subsequences corresponding to current character"}
{"code": "if ( ch == str1 . charAt ( i ) ) { for ( int j = indx2 ; j < len2 ; j ++ ) {", "nl": "if character ch is present in str1 then check if it is present in str2"}
{"code": "if ( ch == str2 . charAt ( j ) && dp [ i ] [ j ] == lcslen - currlcs ) { data [ currlcs ] = ch ; printAll ( str1 , str2 , len1 , len2 , data , i + 1 , j + 1 , currlcs + 1 ) ; done = true ; break ; } } }", "nl": "if ch is present in both of them and remaining length is equal to remaining lcs length then add ch in sub - sequenece"}
{"code": "if ( done ) break ; } } }", "nl": "If we found LCS beginning with current character ."}
{"code": "static void prinlAllLCSSorted ( String str1 , String str2 ) {", "nl": "This function prints all LCS of str1 and str2 in lexicographic order ."}
{"code": "int len1 = str1 . length ( ) , len2 = str2 . length ( ) ;", "nl": "Find lengths of both strings"}
{"code": "for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) ;", "nl": "Find length of LCS"}
{"code": "char [ ] data = new char [ MAX ] ; printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) ; }", "nl": "Print all LCS using recursive backtracking data [ ] is used to store individual LCS ."}
{"code": "public static void main ( String [ ] args ) { String str1 = \" abcabcaa \" , str2 = \" acbacba \" ; prinlAllLCSSorted ( str1 , str2 ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class Majority { static boolean isMajority ( int arr [ ] , int n , int x ) { int i , last_index = 0 ;", "nl": "Program to check for majority element in a sorted array"}
{"code": "last_index = ( n % 2 == 0 ) ? n / 2 : n / 2 + 1 ;", "nl": "get last index according to n ( even or odd )"}
{"code": "for ( i = 0 ; i < last_index ; i ++ ) {", "nl": "search for first occurrence of x in arr [ ]"}
{"code": "if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return true ; } return false ; }", "nl": "check if x is present and is present more than n / 2 times"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 4 } ; int n = arr . length ; int x = 4 ; if ( isMajority ( arr , n , x ) == true ) System . out . println ( x + \" \u2581 appears \u2581 more \u2581 than \u2581 \" + n / 2 + \" \u2581 times \u2581 in \u2581 arr [ ] \" ) ; else System . out . println ( x + \" \u2581 does \u2581 not \u2581 appear \u2581 more \u2581 than \u2581 \" + n / 2 + \" \u2581 times \u2581 in \u2581 arr [ ] \" ) ; } }", "nl": "Driver function to check for above functions"}
{"code": "import java . io . * ; class Majority {", "nl": "Java Program to check for majority element in a sorted array"}
{"code": "static int _binarySearch ( int arr [ ] , int low , int high , int x ) { if ( high >= low ) { int mid = ( low + high ) / 2 ;", "nl": "If x is present in arr [ low ... high ] then returns the index of first occurrence of x , otherwise returns - 1"}
{"code": "if ( ( mid == 0 x > arr [ mid - 1 ] ) && ( arr [ mid ] == x ) ) return mid ; else if ( x > arr [ mid ] ) return _binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return _binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return - 1 ; }", "nl": "Check if arr [ mid ] is the first occurrence of x . arr [ mid ] is first occurrence if x is one of the following is true : ( i ) mid == 0 and arr [ mid ] = = x ( ii ) arr [ mid - 1 ] < x and arr [ mid ] == x"}
{"code": "static boolean isMajority ( int arr [ ] , int n , int x ) {", "nl": "This function returns true if the x is present more than n / 2 times in arr [ ] of size n"}
{"code": "int i = _binarySearch ( arr , 0 , n - 1 , x ) ;", "nl": "Find the index of first occurrence of x in arr [ ]"}
{"code": "if ( i == - 1 ) return false ;", "nl": "If element is not present at all , return false"}
{"code": "if ( ( ( i + n / 2 ) <= ( n - 1 ) ) && arr [ i + n / 2 ] == x ) return true ; else return false ; }", "nl": "check if the element is present more than n / 2 times"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = arr . length ; int x = 3 ; if ( isMajority ( arr , n , x ) == true ) System . out . println ( x + \" \u2581 appears \u2581 more \u2581 than \u2581 \" + n / 2 + \" \u2581 times \u2581 in \u2581 arr [ ] \" ) ; else System . out . println ( x + \" \u2581 does \u2581 not \u2581 appear \u2581 more \u2581 than \u2581 \" + n / 2 + \" \u2581 times \u2581 in \u2581 arr [ ] \" ) ; } }", "nl": "Driver function to check for above functions"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = arr . length ; int x = 3 ; if ( isMajorityElement ( arr , n , x ) ) System . out . printf ( \" % d \u2581 appears \u2581 more \u2581 than \u2581 % d \u2581 \" + \" times \u2581 in \u2581 arr [ ] \" , x , n / 2 ) ; else System . out . printf ( \" % d \u2581 does \u2581 not \u2581 appear \u2581 more \u2581 \" + \" than \u2581 % d \u2581 times \u2581 in \u2581 \" + \" arr [ ] \" , x , n / 2 ) ; } }", "nl": "Driver Code"}
{"code": "class RodCutting {", "nl": "A Dynamic Programming solution for Rod cutting problem"}
{"code": "static int cutRod ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; val [ 0 ] = 0 ;", "nl": "Returns the best obtainable price for a rod of length n and price [ ] as prices of different pieces"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) { int max_val = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }", "nl": "Build the table val [ ] in bottom up manner and return the last entry from the table"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = arr . length ; System . out . println ( \" Maximum \u2581 Obtainable \u2581 Value \u2581 is \u2581 \" + cutRod ( arr , size ) ) ; } }", "nl": "Driver program to test above functions"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "public static boolean isPossible ( int [ ] target ) {", "nl": "Function to check if the arr [ ] can be converted to target [ ] by replacing any element in arr [ ] by the sum of arr [ ]"}
{"code": "int max = 0 ;", "nl": "Store the maximum element"}
{"code": "int index = 0 ;", "nl": "Store the index of the maximum element"}
{"code": "for ( int i = 0 ; i < target . length ; i ++ ) {", "nl": "Traverse the array target [ ]"}
{"code": "if ( max < target [ i ] ) { max = target [ i ] ; index = i ; } }", "nl": "If current element is greater than max"}
{"code": "if ( max == 1 ) return true ;", "nl": "If max element is 1"}
{"code": "for ( int i = 0 ; i < target . length ; i ++ ) {", "nl": "Traverse the array , target [ ]"}
{"code": "if ( i != index ) {", "nl": "If current index is not equal to maximum element index"}
{"code": "max -= target [ i ] ;", "nl": "Update max"}
{"code": "if ( max <= 0 ) return false ; } }", "nl": "If max is less than or equal to 0 ,"}
{"code": "target [ index ] = max ;", "nl": "Update the maximum element"}
{"code": "return isPossible ( target ) ; }", "nl": "Recursively call the function"}
{"code": "public static void main ( String [ ] args ) { int [ ] target = { 9 , 3 , 5 } ; boolean res = isPossible ( target ) ; if ( res ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static int nCr ( int n , int r ) {", "nl": "Function returns nCr i . e . Binomial Coefficient"}
{"code": "int res = 1 ;", "nl": "Initialize res with 1"}
{"code": "if ( r > n - r ) r = n - r ;", "nl": "Since C ( n , r ) = C ( n , n - r )"}
{"code": "for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }", "nl": "Evaluating expression"}
{"code": "public static void main ( String [ ] args ) { int n = 3 , m = 2 , k = 2 ; System . out . print ( nCr ( n + m , k ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to check if N can be obtained from 1 by repetitive multiplication by 10 or 20"}
{"code": "static void Is_possible ( long N ) { long C = 0 ; long D = 0 ;", "nl": "Function to check if N can be obtained or not"}
{"code": "while ( N % 10 == 0 ) { N = N / 10 ; C += 1 ; }", "nl": "Count and remove trailing zeroes"}
{"code": "if ( Math . pow ( 2 , ( long ) ( Math . log ( N ) / ( Math . log ( 2 ) ) ) ) == N ) { D = ( long ) ( Math . log ( N ) / ( Math . log ( 2 ) ) ) ;", "nl": "Check if remaining N is a power of 2"}
{"code": "if ( C >= D ) System . out . print ( \" YES \" ) ; else System . out . print ( \" NO \" ) ; } else System . out . print ( \" NO \" ) ; }", "nl": "To check the condition to prlong YES or NO"}
{"code": "public static void main ( String args [ ] ) { long N = 2000000000000L ; Is_possible ( N ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find N - th term in the series"}
{"code": "static void findNthTerm ( int n ) { System . out . println ( n * n - n + 1 ) ; }", "nl": "Function to find N - th term in the series"}
{"code": "public static void main ( String [ ] args ) { int N = 4 ; findNthTerm ( N ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static int rev ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; }", "nl": "Iterative function to reverse digits of num"}
{"code": "return rev_num ; }", "nl": "Return the reversed num"}
{"code": "static int divSum ( int num ) {", "nl": "Function to calculate sum of reverse all proper divisors"}
{"code": "int result = 0 ;", "nl": "Final result of summation of divisors"}
{"code": "for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) {", "nl": "Find all divisors of num"}
{"code": "if ( num % i == 0 ) {", "nl": "If ' i ' is divisor of ' num '"}
{"code": "if ( i == ( num / i ) ) result += rev ( i ) ; else result += ( rev ( i ) + rev ( num / i ) ) ; } }", "nl": "If both divisors are same then add it only once else add both"}
{"code": "return ( result + 1 ) ; }", "nl": "Add 1 to the result as 1 is also a divisor"}
{"code": "static boolean isAntiPerfect ( int n ) { return divSum ( n ) == n ; }", "nl": "Function to check if N is anti - perfect or not"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 244 ;", "nl": "Given Number N"}
{"code": "if ( isAntiPerfect ( N ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to print the N terms of the series whose three terms are given"}
{"code": "static void printSeries ( int n , int a , int b , int c ) { int d ;", "nl": "Function to print the series"}
{"code": "if ( n == 1 ) { System . out . print ( a + \" \u2581 \" ) ; return ; } if ( n == 2 ) { System . out . print ( a + \" \u2581 \" + b + \" \u2581 \" ) ; return ; } System . out . print ( a + \" \u2581 \" + b + \" \u2581 \" + c + \" \u2581 \" ) ; for ( int i = 4 ; i <= n ; i ++ ) { d = a + b + c ; System . out . print ( d + \" \u2581 \" ) ; a = b ; b = c ; c = d ; } }", "nl": "Generate the ith term and print it"}
{"code": "public static void main ( String [ ] args ) { int N = 7 , a = 1 , b = 3 ; int c = 4 ;", "nl": "Driver Code"}
{"code": "printSeries ( N , a , b , c ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int diameter ( int n ) {", "nl": "Function to find diameter of BIT with N + 1 nodes"}
{"code": "int L , H , templen ; L = 1 ;", "nl": "L is size of subtree just before subtree in which N lies"}
{"code": "H = 0 ;", "nl": "H is the height of subtree just before subtree in which N lies"}
{"code": "if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 2 ; } if ( n == 3 ) { return 3 ; }", "nl": "Base Cases"}
{"code": "while ( L * 2 <= n ) { L *= 2 ; H ++ ; }", "nl": "Size of subtree are power of 2"}
{"code": "if ( n >= L * 2 - 1 ) return 2 * H + 1 ; else if ( n >= L + ( L / 2 ) - 1 ) return 2 * H ; return 2 * H - 1 ; }", "nl": "3 Cases as explained in Approach"}
{"code": "public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( diameter ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void compareValues ( int a , int b , int c , int d ) {", "nl": "Function to find whether a ^ b is greater or c ^ d"}
{"code": "double log1 = Math . log10 ( a ) ; double num1 = log1 * b ;", "nl": "Find b * log ( a )"}
{"code": "double log2 = Math . log10 ( c ) ; double num2 = log2 * d ;", "nl": "Find d * log ( c )"}
{"code": "if ( num1 > num2 ) System . out . println ( a + \" ^ \" + b ) ; else System . out . println ( c + \" ^ \" + d ) ; }", "nl": "Compare both values"}
{"code": "public static void main ( String [ ] args ) { int a = 8 , b = 29 , c = 60 , d = 59 ; compareValues ( a , b , c , d ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static int MAX = 100005 ;", "nl": "Java program for above approach"}
{"code": "static Vector < Integer > addPrimes ( ) { int n = MAX ; boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } Vector < Integer > ans = new Vector < Integer > ( ) ;", "nl": "Find all prime numbers"}
{"code": "for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . add ( p ) ; return ans ; }", "nl": "Store all prime numbers"}
{"code": "static boolean is_prime ( int n ) { return ( n == 3 n == 5 n == 7 ) ; }", "nl": "Function to check if a digit is odd prime or not"}
{"code": "static int find_Sum ( int n ) {", "nl": "Function to find sum"}
{"code": "int sum = 0 ;", "nl": "To store required answer"}
{"code": "Vector < Integer > v = addPrimes ( ) ;", "nl": "Get all prime numbers"}
{"code": "for ( int i = 0 ; i < v . size ( ) && n > 0 ; i ++ ) {", "nl": "Traverse through all the prime numbers"}
{"code": "int flag = 1 ; int a = v . get ( i ) ;", "nl": "Flag stores 1 if a number does not contain any odd primes"}
{"code": "while ( a != 0 ) { int d = a % 10 ; a = a / 10 ; if ( is_prime ( d ) ) { flag = 0 ; break ; } }", "nl": "Find all digits of a number"}
{"code": "if ( flag == 1 ) { n -- ; sum = sum + v . get ( i ) ; } }", "nl": "If number does not contain any odd primes"}
{"code": "return sum ; }", "nl": "Return the required answer"}
{"code": "public static void main ( String [ ] args ) { int n = 7 ;", "nl": "Driver code"}
{"code": "System . out . println ( find_Sum ( n ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int max_element ( int a [ ] ) { int m = a [ 0 ] ; for ( int i = 0 ; i < a . length ; i ++ ) m = Math . max ( a [ i ] , m ) ; return m ; }", "nl": "returns the max element"}
{"code": "static int primeCount ( int arr [ ] , int n ) {", "nl": "Function to return the count of primes in the given array"}
{"code": "int max_val = max_element ( arr ) ;", "nl": "Find maximum value in the array"}
{"code": "boolean prime [ ] = new boolean [ max_val + 1 ] ; for ( int p = 0 ; p <= max_val ; p ++ ) prime [ p ] = true ;", "nl": "USE SIEVE TO FIND ALL PRIME NUMBERS LESS THAN OR EQUAL TO max_val Create a boolean array \" prime [ 0 . . n ] \" . A value in prime [ i ] will finally be false if i is Not a prime , else true ."}
{"code": "prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) {", "nl": "Remaining part of SIEVE"}
{"code": "if ( prime [ p ] == true ) {", "nl": "If prime [ p ] is not changed , then it is a prime"}
{"code": "for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } }", "nl": "Update all multiples of p"}
{"code": "int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] ) count ++ ; return count ; }", "nl": "Find all primes in arr [ ]"}
{"code": "static int [ ] getPrefixArray ( int arr [ ] , int n , int pre [ ] ) {", "nl": "Function to generate the prefix array"}
{"code": "pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } return pre ; }", "nl": "Fill the prefix array"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 1 , 4 , 8 , 4 } ; int n = arr . length ;", "nl": "Driver code"}
{"code": "int pre [ ] = new int [ n ] ; pre = getPrefixArray ( arr , n , pre ) ;", "nl": "Prefix array of arr [ ]"}
{"code": "System . out . println ( primeCount ( pre , n ) ) ; } }", "nl": "Count of primes in the prefix array"}
{"code": "import java . lang . Math ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int minValue ( int n , int x , int y ) {", "nl": "Function to return the required value that must be added to x so that it is at least y percent of n"}
{"code": "float val = ( y * n ) / 100 ;", "nl": "Required value"}
{"code": "if ( x >= val ) return 0 ; else return ( int ) ( Math . ceil ( val ) - x ) ; }", "nl": "If x is already >= y percent of n"}
{"code": "public static void main ( String [ ] args ) { int n = 10 , x = 2 , y = 40 ; System . out . println ( minValue ( n , x , y ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to check if given number is a factorial prime"}
{"code": "static boolean isPrime ( long n ) {", "nl": "Utility function to check if a number is prime or not"}
{"code": "if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;", "nl": "Corner cases"}
{"code": "if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }", "nl": "This is checked so that we can skip middle five numbers in below loop"}
{"code": "static boolean isFactorialPrime ( long n ) {", "nl": "Function that returns true if n is a factorial prime"}
{"code": "if ( ! isPrime ( n ) ) return false ; long fact = 1 ; int i = 1 ; while ( fact <= n + 1 ) {", "nl": "If n is not prime then return false"}
{"code": "fact = fact * i ;", "nl": "Calculate factorial"}
{"code": "if ( n + 1 == fact n - 1 == fact ) return true ; i ++ ; }", "nl": "If n is a factorial prime"}
{"code": "return false ; }", "nl": "n is not a factorial prime"}
{"code": "public static void main ( String args [ ] ) { int n = 23 ; if ( isFactorialPrime ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find number of ways in which n boys and n girls can sit alternatively sound a round table ."}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "long n = 5 ;", "nl": "Get n"}
{"code": "long fac1 = 1 ; for ( int i = 2 ; i <= n - 1 ; i ++ ) fac1 = fac1 * i ;", "nl": "find fac1 = ( n - 1 ) !"}
{"code": "long fac2 = fac1 * n ;", "nl": "Find fac2 = n !"}
{"code": "long totalWays = fac1 * fac2 ;", "nl": "Find total number of ways"}
{"code": "System . out . println ( totalWays ) ; } }", "nl": "Print the total number of ways"}
{"code": "import java . util . * ; class GFG { static final int MAX = 10000 ; static Vector < Integer > arr = new Vector < Integer > ( ) ;", "nl": "Java program to check Euclid Number"}
{"code": "static void SieveOfEratosthenes ( ) {", "nl": "Function to get the prime numbers"}
{"code": "boolean [ ] prime = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) {", "nl": "Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true ."}
{"code": "if ( prime [ p ] == true ) {", "nl": "If prime [ p ] is not changed , then it is a prime"}
{"code": "for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } }", "nl": "Update all multiples of p"}
{"code": "for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . add ( p ) ; }", "nl": "store all prime numbers to vector ' arr '"}
{"code": "static boolean isEuclid ( long n ) { long product = 1 ; int i = 0 ; while ( product < n ) {", "nl": "Function to check the number for Euclid Number"}
{"code": "product = product * arr . get ( i ) ; if ( product + 1 == n ) return true ; i ++ ; } return false ; }", "nl": "Multiply next prime number and check if product + 1 = n holds or not"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "SieveOfEratosthenes ( ) ;", "nl": "Get the prime numbers"}
{"code": "long n = 31 ;", "nl": "Get n"}
{"code": "if ( isEuclid ( n ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ;", "nl": "Check if n is Euclid Number"}
{"code": "n = 42 ;", "nl": "Get n"}
{"code": "if ( isEuclid ( n ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }", "nl": "Check if n is Euclid Number"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {", "nl": "Java implementation of above approach"}
{"code": "static int nextPerfectCube ( int N ) { int nextN = ( int ) Math . floor ( Math . cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; }", "nl": "Function to find the next perfect cube"}
{"code": "public static void main ( String args [ ] ) { int n = 35 ; System . out . print ( nextPerfectCube ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to find sum of prime divisors of N"}
{"code": "static boolean isPrime ( int n ) {", "nl": "Function to check if the number is prime or not ."}
{"code": "if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;", "nl": "Corner cases"}
{"code": "if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }", "nl": "This is checked so that we can skip middle five numbers in below loop"}
{"code": "static int SumOfPrimeDivisors ( int n ) { int sum = 0 ;", "nl": "Function to find sum of prime divisors of N"}
{"code": "int root_n = ( int ) Math . sqrt ( n ) ; for ( int i = 1 ; i <= root_n ; i ++ ) { if ( n % i == 0 ) {", "nl": "Return type of sqrt function if float"}
{"code": "if ( i == n / i && isPrime ( i ) ) { sum += i ; } else {", "nl": "Both factors are same"}
{"code": "if ( isPrime ( i ) ) { sum += i ; } if ( isPrime ( n / i ) ) { sum += ( n / i ) ; } } } } return sum ; }", "nl": "Both factors are not same ( i and n / i )"}
{"code": "public static void main ( String [ ] args ) { int n = 60 ; System . out . println ( \" Sum \u2581 of \u2581 prime \u2581 divisors \u2581 of \u2581 60 \u2581 is \u2581 \" + SumOfPrimeDivisors ( n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int findpos ( String n ) { int pos = 0 ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { switch ( n . charAt ( i ) ) {", "nl": "Java Program position of n among the numbers made of 2 , 3 , 5 & 7"}
{"code": "case '2' : pos = pos * 4 + 1 ; break ;", "nl": "If number is 2 then it is on the position pos * 2 + 1"}
{"code": "case '3' : pos = pos * 4 + 2 ; break ;", "nl": "If number is 3 then it is on the position pos * 2 + 2"}
{"code": "case '5' : pos = pos * 4 + 3 ; break ;", "nl": "If number is 5 then it is on the position pos * 2 + 3"}
{"code": "case '7' : pos = pos * 4 + 4 ; break ; } } return pos ; }", "nl": "If number is 7 then it is on the position pos * 2 + 4"}
{"code": "public static void main ( String args [ ] ) { String n = \"777\" ; System . out . println ( findpos ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find a non transitive co - prime triplets between L and R"}
{"code": "static void possibleTripletInRange ( int L , int R ) { boolean flag = false ; int possibleA = 0 , possibleB = 0 , possibleC = 0 ; int numbersInRange = ( R - L + 1 ) ;", "nl": "Checks if any possible triplet ( a , b , c ) satifying the condition that ( a , b ) is coprime , ( b , c ) is coprime but ( a , c ) isnt"}
{"code": "if ( numbersInRange < 3 ) { flag = false ; }", "nl": "Case 1 : Less than 3 numbers between L and R"}
{"code": "else if ( numbersInRange > 3 ) { flag = true ;", "nl": "Case 2 : More than 3 numbers between L and R"}
{"code": "if ( L % 2 > 0 ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else {", "nl": "triplets should always be of form ( 2 k , 2 k + 1 , 2 k + 2 )"}
{"code": "if ( ! ( L % 2 > 0 ) ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else {", "nl": "Case 3.1 : Exactly 3 numbers in range of form ( 2 k , 2 k + 1 , 2 k + 2 )"}
{"code": "flag = false ; } }", "nl": "Case 3.2 : Exactly 3 numbers in range of form ( 2 k - 1 , 2 k , 2 k + 1 )"}
{"code": "if ( flag == true ) { System . out . println ( \" ( \" + possibleA + \" , \u2581 \" + possibleB + \" , \u2581 \" + possibleC + \" ) \" + \" \u2581 is \u2581 one \u2581 such \u2581 possible \" + \" \u2581 triplet \u2581 between \u2581 \" + L + \" \u2581 and \u2581 \" + R ) ; } else { System . out . println ( \" No \u2581 Such \u2581 Triplet \" + \" \u2581 exists \u2581 between \u2581 \" + L + \" \u2581 and \u2581 \" + R ) ; } }", "nl": "flag = True indicates that a pair exists between L and R"}
{"code": "public static void main ( String [ ] args ) { int L , R ;", "nl": "Driver code"}
{"code": "L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ;", "nl": "finding possible Triplet between 2 and 10"}
{"code": "L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; } }", "nl": "finding possible Triplet between 23 and 46"}
{"code": "import java . lang . * ; class GFG { static final int mod = 1000000007 ;", "nl": "Java Implementation of above method"}
{"code": "static int digitNumber ( long n ) {", "nl": "Finding number of possible number with n digits excluding a particular digit"}
{"code": "if ( n == 0 ) return 1 ;", "nl": "Checking if number of digits is zero"}
{"code": "if ( n == 1 ) return 9 ;", "nl": "Checking if number of digits is one"}
{"code": "if ( n % 2 != 0 ) {", "nl": "Checking if number of digits is odd"}
{"code": "int temp = digitNumber ( ( n - 1 ) / 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else {", "nl": "Calling digitNumber function with ( digit - 1 ) / 2 digits"}
{"code": "int temp = digitNumber ( n / 2 ) % mod ; return ( temp * temp ) % mod ; } } static int countExcluding ( int n , int d ) {", "nl": "Calling digitNumber function with n / 2 digits"}
{"code": "if ( d == 0 ) return ( 9 * digitNumber ( n - 1 ) ) % mod ; else return ( 8 * digitNumber ( n - 1 ) ) % mod ; }", "nl": "Calling digitNumber function Checking if excluding digit is zero or non - zero"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver function to run above program"}
{"code": "int d = 9 ; int n = 3 ; System . out . println ( countExcluding ( n , d ) ) ; } }", "nl": "Initializing variables"}
{"code": "import java . io . * ; class Emirp {", "nl": "Java program to check if given number is Emirp or not ."}
{"code": "public static boolean isPrime ( int n ) {", "nl": "Returns true if n is prime . Else false ."}
{"code": "if ( n <= 1 ) return false ;", "nl": "Corner case"}
{"code": "for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }", "nl": "Check from 2 to n - 1"}
{"code": "public static boolean isEmirp ( int n ) {", "nl": "Function will check whether number is Emirp or not"}
{"code": "if ( isPrime ( n ) == false ) return false ;", "nl": "Check if n is prime"}
{"code": "int rev = 0 ; while ( n != 0 ) { int d = n % 10 ; rev = rev * 10 + d ; n /= 10 ; }", "nl": "Find reverse of n"}
{"code": "return isPrime ( rev ) ; }", "nl": "If both Original and Reverse are Prime , then it is an Emirp number"}
{"code": "public static void main ( String args [ ] ) throws IOException {", "nl": "Driver Function"}
{"code": "int n = 13 ; if ( isEmirp ( n ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Input number"}
{"code": "import java . io . * ; class GFG {", "nl": "Java code to convert radian to degree"}
{"code": "static double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; }", "nl": "Function for convertion"}
{"code": "public static void main ( String [ ] args ) { double radian = 5.0 ; double degree = Convert ( radian ) ; System . out . println ( \" degree \u2581 = \u2581 \" + degree ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; public class GFG {", "nl": "Java program to find trace of matrix formed by adding Row - major and Column - major order of same matrix"}
{"code": "static int sn ( int n , int an ) { return ( n * ( 1 + an ) ) / 2 ; }", "nl": "Return sum of first n integers of an AP"}
{"code": "static int trace ( int n , int m ) {", "nl": "Return the trace of sum of row - major matrix and column - major matrix"}
{"code": "int an = 1 + ( n - 1 ) * ( m + 1 ) ;", "nl": "Finding nth element in AP in case of Row major matrix ."}
{"code": "int rowmajorSum = sn ( n , an ) ;", "nl": "Finding sum of first n integers of AP in case of Row major matrix"}
{"code": "an = 1 + ( n - 1 ) * ( n + 1 ) ;", "nl": "Finding nth element in AP in case of Row major matrix"}
{"code": "int colmajorSum = sn ( n , an ) ; return rowmajorSum + colmajorSum ; }", "nl": "Finding sum of first n integers of AP in case of Column major matrix"}
{"code": "static public void main ( String [ ] args ) { int N = 3 , M = 3 ; System . out . println ( trace ( N , M ) ) ; } }", "nl": "Driven Program"}
{"code": "class GFG {", "nl": "Java code for Maximum of smallest possible area that can get with exactly k cut of given rectangular"}
{"code": "static void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) System . out . println ( \" Not \u2581 possible \" ) ; else { int result ;", "nl": "Utility Function"}
{"code": "if ( k < Math . max ( m , n ) - 1 ) { result = Math . max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; }", "nl": "for the 1 st case"}
{"code": "else { result = Math . max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; }", "nl": "for the second case"}
{"code": "System . out . println ( result ) ; } }", "nl": "print final result"}
{"code": "public static void main ( String [ ] args ) { int n = 3 , m = 4 , k = 1 ; max_area ( n , m , k ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find the area of a square"}
{"code": "static int area_fun ( int side ) { int area = side * side ; return area ; }", "nl": "function to find the area"}
{"code": "public static void main ( String arg [ ] ) { int side = 4 ; int area = area_fun ( side ) ; System . out . println ( area ) ; } }", "nl": "Driver code"}
{"code": "public class SumConsecutiveNumber {", "nl": "A Java program to count number of ways to express N as sum of consecutive numbers ."}
{"code": "static int countConsecutive ( int N ) {", "nl": "Utility method to compute number of ways in which N can be represented as sum of consecutive number"}
{"code": "int count = 0 ; for ( int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( double ) ( ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; }", "nl": "constraint on values of L gives us the time Complexity as O ( N ^ 0.5 )"}
{"code": "public static void main ( String [ ] args ) { int N = 15 ; System . out . println ( countConsecutive ( N ) ) ; N = 10 ; System . out . println ( countConsecutive ( N ) ) ; } }", "nl": "Driver code to test above function"}
{"code": "class Test {", "nl": "Java program to check if a number is Authomorphic"}
{"code": "static boolean isAutomorphic ( int N ) {", "nl": "Function to check Automorphic number"}
{"code": "int sq = N * N ;", "nl": "Store the square"}
{"code": "while ( N > 0 ) {", "nl": "Start Comparing digits"}
{"code": "if ( N % 10 != sq % 10 ) return false ;", "nl": "Return false , if any digit of N doesn ' t \u2581 \u2581 match \u2581 with \u2581 its \u2581 square ' s digits from last"}
{"code": "N /= 10 ; sq /= 10 ; } return true ; }", "nl": "Reduce N and square"}
{"code": "public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( isAutomorphic ( N ) ? \" Automorphic \" : \" Not \u2581 Automorphic \" ) ; } }", "nl": "Driver method"}
{"code": "import java . util . Vector ; public class GFG {", "nl": "Java program to find integer having maximum number of prime factor in first N natural numbers"}
{"code": "static int maxPrimefactorNum ( int N ) {", "nl": "Return smallest number having maximum prime factors ."}
{"code": "boolean arr [ ] = new boolean [ N + 5 ] ;", "nl": "default value of boolean is false"}
{"code": "for ( int i = 3 ; i * i <= N ; i += 2 ) { if ( ! arr [ i ] ) { for ( int j = i * i ; j <= N ; j += i ) { arr [ j ] = true ; } } }", "nl": "Sieve of eratosthenes"}
{"code": "Vector < Integer > prime = new Vector < > ( ) ; prime . add ( prime . size ( ) , 2 ) ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( ! arr [ i ] ) { prime . add ( prime . size ( ) , i ) ; } }", "nl": "Storing prime numbers ."}
{"code": "int i = 0 , ans = 1 ; while ( ans * prime . get ( i ) <= N && i < prime . size ( ) ) { ans *= prime . get ( i ) ; i ++ ; } return ans ; }", "nl": "Generating number having maximum prime factors ."}
{"code": "public static void main ( String [ ] args ) { int N = 40 ; System . out . println ( maxPrimefactorNum ( N ) ) ; } }", "nl": "Driver program"}
{"code": "import java . io . * ; class GFG { static int highestPowerof2 ( int x ) {", "nl": "Java program to find highest power of 2 smaller than or equal to n ."}
{"code": "x |= x >> 1 ; x |= x >> 2 ; x |= x >> 4 ; x |= x >> 8 ; x |= x >> 16 ;", "nl": "check for the set bits"}
{"code": "return x ^ ( x >> 1 ) ; }", "nl": "Then we remove all but the top bit by xor ' ing \u2581 the \u2581 \u2581 string \u2581 of \u2581 1' s with that string of 1 ' s \u2581 shifted \u2581 one \u2581 to \u2581 \u2581 the \u2581 left , \u2581 and \u2581 we \u2581 end \u2581 up \u2581 with \u2581 just \u2581 the \u2581 one \u2581 top \u2581 bit \u2581 \u2581 followed \u2581 by \u2581 0' s ."}
{"code": "public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( highestPowerof2 ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . math . * ; class GFG {", "nl": "JAVA program to find sum of all divisors of a natural number"}
{"code": "static int divSum ( int num ) {", "nl": "Function to calculate sum of all proper divisors num -- > given natural number"}
{"code": "int result = 0 ;", "nl": "Final result of summation of divisors"}
{"code": "for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) {", "nl": "find all divisors which divides ' num '"}
{"code": "if ( num % i == 0 ) {", "nl": "if ' i ' is divisor of ' num '"}
{"code": "if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } }", "nl": "if both divisors are same then add it only once else add both"}
{"code": "return ( result + 1 ) ; }", "nl": "Add 1 to the result as 1 is also a divisor"}
{"code": "public static void main ( String [ ] args ) { int num = 36 ; System . out . println ( divSum ( num ) ) ; } }", "nl": "Driver program to run the case"}
{"code": "public class GFG {", "nl": "An efficient Java program to find square root under modulo p when p is 7 , 11 , 19 , 23 , 31 , ... etc ."}
{"code": "static int power ( int x , int y , int p ) {", "nl": "Utility function to do modular exponentiation . It returns ( x ^ y ) % p ."}
{"code": "while ( y > 0 ) {", "nl": "int res = 1 ; Initialize result x = x % p ; Update x if it is more than or equal to p"}
{"code": "if ( y % 2 == 1 ) res = ( res * x ) % p ;", "nl": "If y is odd , multiply x with result"}
{"code": "x = ( x * x ) % p ; } return res ; }", "nl": "y must be even now y = y >> 1 ; y = y / 2"}
{"code": "static void squareRoot ( int n , int p ) { if ( p % 4 != 3 ) { System . out . print ( \" Invalid \u2581 Input \" ) ; return ; }", "nl": "Returns true if square root of n under modulo p exists Assumption : p is of the form 3 * i + 4 where i >= 1"}
{"code": "n = n % p ; int x = power ( n , ( p + 1 ) / 4 , p ) ; if ( ( x * x ) % p == n ) { System . out . print ( \" Square \u2581 root \u2581 is \u2581 \" + x ) ; return ; }", "nl": "Try \" + ( n ^ ( ( p \u2581 + \u2581 1 ) / 4 ) ) \""}
{"code": "x = p - x ; if ( ( x * x ) % p == n ) { System . out . print ( \" Square \u2581 root \u2581 is \u2581 \" + x ) ; return ; }", "nl": "Try \" - ( n \u2581 ^ \u2581 ( ( p \u2581 + \u2581 1 ) / 4 ) ) \""}
{"code": "System . out . print ( \" Square \u2581 root \u2581 doesn ' t \u2581 exist \u2581 \" ) ; }", "nl": "If none of the above two work , then square root doesn 't exist"}
{"code": "static public void main ( String [ ] args ) { int p = 7 ; int n = 2 ; squareRoot ( n , p ) ; } }", "nl": "Driver program to test"}
{"code": "import java . io . * ; import java . math . * ; class GFG {", "nl": "Java program Miller - Rabin primality test"}
{"code": "static int power ( int x , int y , int p ) {", "nl": "Utility function to do modular exponentiation . It returns ( x ^ y ) % p"}
{"code": "int res = 1 ;", "nl": "Initialize result"}
{"code": "x = x % p ; while ( y > 0 ) {", "nl": "Update x if it is more than or equal to p"}
{"code": "if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ;", "nl": "If y is odd , multiply x with result"}
{"code": "x = ( x * x ) % p ; } return res ; }", "nl": "y must be even now y = y >> 1 ; y = y / 2"}
{"code": "static boolean miillerTest ( int d , int n ) {", "nl": "This function is called for all k trials . It returns false if n is composite and returns false if n is probably prime . d is an odd number such that d * 2 < sup > r < / sup > = n - 1 for some r >= 1"}
{"code": "int a = 2 + ( int ) ( Math . random ( ) % ( n - 4 ) ) ;", "nl": "Pick a random number in [ 2. . n - 2 ] Corner cases make sure that n > 4"}
{"code": "int x = power ( a , d , n ) ; if ( x == 1 x == n - 1 ) return true ;", "nl": "Compute a ^ d % n"}
{"code": "while ( d != n - 1 ) { x = ( x * x ) % n ; d *= 2 ; if ( x == 1 ) return false ; if ( x == n - 1 ) return true ; }", "nl": "Keep squaring x while one of the following doesn 't happen  (i) d does not reach n-1  (ii) (x^2) % n is not 1  (iii) (x^2) % n is not n-1"}
{"code": "return false ; }", "nl": "Return composite"}
{"code": "static boolean isPrime ( int n , int k ) {", "nl": "It returns false if n is composite and returns true if n is probably prime . k is an input parameter that determines accuracy level . Higher value of k indicates more accuracy ."}
{"code": "if ( n <= 1 n == 4 ) return false ; if ( n <= 3 ) return true ;", "nl": "Corner cases"}
{"code": "int d = n - 1 ; while ( d % 2 == 0 ) d /= 2 ;", "nl": "Find r such that n = 2 ^ d * r + 1 for some r >= 1"}
{"code": "for ( int i = 0 ; i < k ; i ++ ) if ( ! miillerTest ( d , n ) ) return false ; return true ; }", "nl": "Iterate given nber of ' k ' times"}
{"code": "public static void main ( String args [ ] ) { int k = 4 ; System . out . println ( \" All \u2581 primes \u2581 smaller \u2581 \" + \" than \u2581 100 : \u2581 \" ) ; for ( int n = 1 ; n < 100 ; n ++ ) if ( isPrime ( n , k ) ) System . out . print ( n + \" \u2581 \" ) ; } }", "nl": "Driver program"}
{"code": "class MaxConsecutiveOnes {", "nl": "Java program to find length of the longest consecutive 1 s in binary representation of a number ."}
{"code": "private static int maxConsecutiveOnes ( int x ) {", "nl": "Function to find length of the longest consecutive 1 s in binary representation of a number"}
{"code": "int count = 0 ;", "nl": "Initialize result"}
{"code": "while ( x != 0 ) {", "nl": "Count the number of iterations to reach x = 0."}
{"code": "x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; }", "nl": "This operation reduces length of every sequence of 1 s by one ."}
{"code": "public static void main ( String strings [ ] ) { System . out . println ( maxConsecutiveOnes ( 14 ) ) ; System . out . println ( maxConsecutiveOnes ( 222 ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static int subtract ( int x , int y ) {", "nl": "Java Program to subtract two Number without using arithmetic operator"}
{"code": "while ( y != 0 ) {", "nl": "Iterate till there is no carry"}
{"code": "int borrow = ( ~ x ) & y ;", "nl": "borrow contains common set bits of y and unset bits of x"}
{"code": "x = x ^ y ;", "nl": "Subtraction of bits of x and y where at least one of the bits is not set"}
{"code": "y = borrow << 1 ; } return x ; }", "nl": "Borrow is shifted by one so that subtracting it from x gives the required sum"}
{"code": "public static void main ( String [ ] args ) { int x = 29 , y = 13 ; System . out . println ( \" x \u2581 - \u2581 y \u2581 is \u2581 \" + subtract ( x , y ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG { static int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; }", "nl": "Java Program to subtract two Number without using arithmetic operator Recursive implementation ."}
{"code": "public static void main ( String [ ] args ) { int x = 29 , y = 13 ; System . out . printf ( \" x \u2581 - \u2581 y \u2581 is \u2581 % d \" , subtract ( x , y ) ) ; } }", "nl": "Driver program"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static void addEdge ( Vector < Integer > v [ ] , int x , int y ) { v [ x ] . add ( y ) ; v [ y ] . add ( x ) ; }", "nl": "Function to add an edge in the tree"}
{"code": "static void dfs ( Vector < Integer > tree [ ] , Vector < Integer > temp , int ancestor [ ] , int u , int parent , int k ) {", "nl": "DFS to find the Kth ancestor of every node"}
{"code": "temp . add ( u ) ;", "nl": "Pushing current node in the vector"}
{"code": "for ( int i : tree [ u ] ) { if ( i == parent ) continue ; dfs ( tree , temp , ancestor , i , u , k ) ; } temp . remove ( temp . size ( ) - 1 ) ;", "nl": "Traverse its neighbors"}
{"code": "if ( temp . size ( ) < k ) { ancestor [ u ] = - 1 ; } else {", "nl": "If K ancestors are not found for current node"}
{"code": "ancestor [ u ] = temp . get ( temp . size ( ) - k ) ; } }", "nl": "Add the Kth ancestor for the node"}
{"code": "static void KthAncestor ( int N , int K , int E , int edges [ ] [ ] ) {", "nl": "Function to find Kth ancestor of each node"}
{"code": "@ SuppressWarnings ( \" unchecked \" ) Vector < Integer > [ ] tree = new Vector [ N + 1 ] ; for ( int i = 0 ; i < tree . length ; i ++ ) tree [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < E ; i ++ ) { addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) ; }", "nl": "Building the tree"}
{"code": "Vector < Integer > temp = new Vector < Integer > ( ) ;", "nl": "Stores all parents of a node"}
{"code": "int [ ] ancestor = new int [ N + 1 ] ; dfs ( tree , temp , ancestor , 1 , 0 , K ) ;", "nl": "Store Kth ancestor of all nodes"}
{"code": "for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( ancestor [ i ] + \" \u2581 \" ) ; } }", "nl": "Print the ancestors"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int N = 9 ; int K = 2 ;", "nl": "Given N and K"}
{"code": "int E = 8 ; int edges [ ] [ ] = { { 1 , 2 } , { 1 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 7 } , { 3 , 8 } , { 3 , 9 } } ;", "nl": "Given edges of n - ary tree"}
{"code": "KthAncestor ( N , K , E , edges ) ; } }", "nl": "Function call"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void build ( Vector < Integer > sum , Vector < Integer > a , int l , int r , int rt ) {", "nl": "Function to build a segment tree"}
{"code": "if ( l == r ) { sum . set ( rt , a . get ( l - 1 ) ) ; return ; }", "nl": "Check for base case"}
{"code": "int m = ( l + r ) >> 1 ;", "nl": "Find mid point"}
{"code": "build ( sum , a , l , m , rt << 1 ) ; build ( sum , a , m + 1 , r , rt << 1 1 ) ; }", "nl": "Recursively build the segment tree"}
{"code": "static void pushDown ( Vector < Integer > sum , Vector < Integer > add , int rt , int ln , int rn ) { if ( add . get ( rt ) != 0 ) { add . set ( rt << 1 , add . get ( rt ) ) ; add . set ( rt << 1 | 1 , add . get ( rt ) ) ; sum . set ( rt << 1 , sum . get ( rt << 1 ) + add . get ( rt ) * ln ) ; sum . set ( rt << 1 | 1 , sum . get ( rt << 1 1 ) + add . get ( rt ) * rn ) ; add . set ( rt , 0 ) ; } }", "nl": "Function for push down operation on the segment tree"}
{"code": "static void update ( Vector < Integer > sum , Vector < Integer > add , int L , int R , int C , int l , int r , int rt ) {", "nl": "Function to update the segment tree"}
{"code": "if ( L <= l && r <= R ) { sum . set ( rt , sum . get ( rt ) + C * ( r - l + 1 ) ) ; add . set ( rt , add . get ( rt ) + C ) ; return ; }", "nl": "Complete overlap"}
{"code": "int m = ( l + r ) >> 1 ;", "nl": "Find mid"}
{"code": "pushDown ( sum , add , rt , m - l + 1 , r - m ) ;", "nl": "Perform push down operation on segment tree"}
{"code": "if ( L <= m ) { update ( sum , add , L , R , C , l , m , rt << 1 ) ; } if ( R > m ) { update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) ; } }", "nl": "Recursively update the segment tree"}
{"code": "static int query ( Vector < Integer > sum , Vector < Integer > add , int L , int R , int l , int r , int rt ) {", "nl": "Function to process the query"}
{"code": "if ( L <= l && r <= R ) { return sum . get ( rt ) ; }", "nl": "Base case"}
{"code": "int m = ( l + r ) >> 1 ;", "nl": "Find mid"}
{"code": "pushDown ( sum , add , rt , m - l + 1 , r - m ) ; int ans = 0 ;", "nl": "Perform push down operation on segment tree"}
{"code": "if ( L <= m ) { ans += query ( sum , add , L , R , l , m , rt << 1 ) ; } if ( R > m ) { ans += query ( sum , add , L , R , m + 1 , r , rt << 1 1 ) ; }", "nl": "Recursively calculate the result of the query"}
{"code": "return ans ; }", "nl": "Return the result"}
{"code": "static void sequenceMaintenance ( int n , int q , Vector < Integer > a , Vector < Integer > b , int m ) {", "nl": "Function to count the numbers which are greater than the given query"}
{"code": "Collections . sort ( a ) ;", "nl": "Sort the input array"}
{"code": "Vector < Integer > sum = new Vector < Integer > ( ) ; Vector < Integer > ad = new Vector < Integer > ( ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < ( n << 2 ) ; i ++ ) { sum . add ( 0 ) ; ad . add ( 0 ) ; }", "nl": "Create segment tree of size 4 * n"}
{"code": "build ( sum , a , 1 , n , 1 ) ;", "nl": "Build the segment tree"}
{"code": "for ( int i = 0 ; i < q ; i ++ ) { int l = 1 , r = n , pos = - 1 ; while ( l <= r ) { m = ( l + r ) >> 1 ; if ( query ( sum , ad , m , m , 1 , n , 1 ) >= b . get ( i ) ) { r = m - 1 ; pos = m ; } else { l = m + 1 ; } } if ( pos == - 1 ) { ans . add ( 0 ) ; } else {", "nl": "Iterate over the queries"}
{"code": "ans . add ( n - pos + 1 ) ;", "nl": "Store result in array"}
{"code": "update ( sum , ad , pos , n , - m , 1 , n , 1 ) ; } }", "nl": "Update the elements in the given range"}
{"code": "for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) + \" \u2581 \" ) ; } }", "nl": "Print the result of queries"}
{"code": "public static void main ( String [ ] args ) { int N = 4 ; int Q = 3 ; int M = 1 ; Vector < Integer > arr = new Vector < Integer > ( ) ; arr . add ( 1 ) ; arr . add ( 2 ) ; arr . add ( 3 ) ; arr . add ( 4 ) ; Vector < Integer > query = new Vector < Integer > ( ) ; query . add ( 4 ) ; query . add ( 3 ) ; query . add ( 1 ) ;", "nl": "Driver Code"}
{"code": "sequenceMaintenance ( N , Q , arr , query , M ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java Program for the above approach"}
{"code": "static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; }", "nl": "Recursive function to return gcd of a and b"}
{"code": "static boolean hasCoprimePair ( int [ ] arr , int n ) {", "nl": "Function to find the final array length by replacing coprime pair with 1"}
{"code": "for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) {", "nl": "Iterate over all pairs of element"}
{"code": "if ( ( __gcd ( arr [ i ] , arr [ j ] ) ) == 1 ) { return true ; } } }", "nl": "Check if gcd is 1"}
{"code": "return false ; }", "nl": "If no coprime pair found return false"}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; int [ ] arr = { 6 , 9 , 15 } ;", "nl": "Driver code"}
{"code": "if ( hasCoprimePair ( arr , n ) ) { System . out . print ( 1 + \"NEW_LINE\"); }", "nl": "Check if atleast one coprime pair exists in the array"}
{"code": "else { System . out . print ( n + \"NEW_LINE\"); } } }", "nl": "If no such pair exists"}
{"code": "import java . io . * ; class GFG {", "nl": "Java Program to implement the above approach"}
{"code": "static int Numberofways ( int n ) { int count = 0 ; for ( int a = 1 ; a < n ; a ++ ) { for ( int b = 0 ; b < n ; b ++ ) { int c = n - ( a + b ) ;", "nl": "Function to return the required number of ways"}
{"code": "if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } }", "nl": "Check if a , b , c can form a triangle"}
{"code": "return count ; }", "nl": "Return number of ways"}
{"code": "public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( Numberofways ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java Program to implement the above approach"}
{"code": "static void countPairs ( int N , int [ ] arr ) { int count = 0 ;", "nl": "Function to print the count of pair"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) {", "nl": "Iterate over all the elements of the array"}
{"code": "count ++ ; } }", "nl": "Increment the count"}
{"code": "System . out . println ( count / 2 ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 4 , 3 } ; int N = arr . length ; countPairs ( N , arr ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; public class GFG {", "nl": "Java implementation of above approach"}
{"code": "static int LongestFibSubseq ( int A [ ] , int n ) {", "nl": "Function to return the max Length of Fibonacci subsequence"}
{"code": "TreeSet < Integer > S = new TreeSet < > ( ) ; for ( int t : A ) { S . add ( t ) ; } int maxLen = 0 , x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { x = A [ j ] ; y = A [ i ] + A [ j ] ; int length = 3 ;", "nl": "Store all array elements in a hash table"}
{"code": "while ( S . contains ( y ) && ( y != S . last ( ) ) ) {", "nl": "check until next fib element is found"}
{"code": "int z = x + y ; x = y ; y = z ; maxLen = Math . max ( maxLen , ++ length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; }", "nl": "next element of fib subseq"}
{"code": "public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = A . length ; System . out . print ( LongestFibSubseq ( A , n ) ) ; } }", "nl": "Driver program"}
{"code": "import java . util . Arrays ; public class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static int CountMaximum ( int arr [ ] , int n , int k ) {", "nl": "Function to count maximum number of elements that can be selected"}
{"code": "Arrays . sort ( arr ) ; int sum = 0 , count = 0 ;", "nl": "Sorting the array"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse the array"}
{"code": "sum += arr [ i ] ;", "nl": "Add the current element to the sum"}
{"code": "if ( sum > k ) break ;", "nl": "If sum exceeds k"}
{"code": "count ++ ; }", "nl": "Increment count"}
{"code": "return count ; }", "nl": "Returning the count"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = 4 ; int k = 50 ;", "nl": "Driver code"}
{"code": "System . out . println ( CountMaximum ( arr , n , k ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static int num_candyTypes ( int [ ] candies ) {", "nl": "Function to find number of candy types"}
{"code": "Dictionary < Integer , Integer > s = new Hashtable < Integer , Integer > ( ) ;", "nl": "Declare a hashset to store candies"}
{"code": "for ( int i = 0 ; i < candies . length ; i ++ ) { s . put ( candies [ i ] , 1 ) ; }", "nl": "Traverse the given array and inserts element into set"}
{"code": "return s . size ( ) ; }", "nl": "Return the result"}
{"code": "public static void distribute_candies ( int [ ] candies ) {", "nl": "Function to find maximum number of types of candies a person can eat"}
{"code": "int allowed = candies . length / 2 ;", "nl": "Store the number of candies allowed to eat"}
{"code": "int types = num_candyTypes ( candies ) ;", "nl": "Store the number of candy types"}
{"code": "if ( types < allowed ) System . out . println ( types ) ; else System . out . println ( allowed ) ; }", "nl": "Return the result"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int candies [ ] = { 4 , 4 , 5 , 5 , 3 , 3 } ;", "nl": "Given Input"}
{"code": "distribute_candies ( candies ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static double [ ] Length_Diagonals ( int a , double theta ) { double p = a * Math . sqrt ( 2 + ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; double q = a * Math . sqrt ( 2 - ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; return new double [ ] { p , q } ; }", "nl": "Function to calculate the length of diagonals of a rhombus using length of sides and vertex angle"}
{"code": "public static void main ( String [ ] args ) { int A = 6 ; double theta = 45 ; double [ ] ans = Length_Diagonals ( A , theta ) ; System . out . printf ( \" % .2f \" + \" \u2581 \" + \" % .2f \" , ans [ 0 ] , ans [ 1 ] ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to count the set bits after taking XOR with a number K"}
{"code": "static int __builtin_popcount ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }", "nl": "Function to get no of set bits in binary representation of positive integer n"}
{"code": "static void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ;", "nl": "Function to store EVEN and odd variable"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Store the count of even and odd set bit"}
{"code": "int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ;", "nl": "Count the set bit using in built function"}
{"code": "y = __builtin_popcount ( K ) ;", "nl": "Count of set - bit of K"}
{"code": "if ( ( y & 1 ) != 0 ) { System . out . println ( \" Even \u2581 = \u2581 \" + odd + \" , \u2581 Odd \u2581 = \u2581 \" + even ) ; }", "nl": "If y is odd then , count of even and odd set bit will be interchanged"}
{"code": "else { System . out . println ( \" Even \u2581 = \u2581 \" + even + \" , \u2581 Odd \u2581 = \u2581 \" + odd ) ; } }", "nl": "Else it will remain same as the original array"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = arr . length ;", "nl": "Driver 's Code"}
{"code": "countEvenOdd ( arr , n , K ) ; } }", "nl": "Function call to count even and odd"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {", "nl": "Java implementation of the above approach"}
{"code": "public static void main ( String args [ ] ) { int N = 6 ; int Even = N / 2 ; int Odd = N - Even ; System . out . println ( Even * Odd ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "public static Integer longestSubSequence ( int [ ] [ ] A , int N , int ind , int lastf , int lasts ) { ind = ( ind > 0 ? ind : 0 ) ; lastf = ( lastf > 0 ? lastf : Integer . MIN_VALUE ) ; lasts = ( lasts > 0 ? lasts : Integer . MAX_VALUE ) ;", "nl": "Recursive function to find the length of the longest subsequence of pairs whose first element is increasing and second is decreasing"}
{"code": "if ( ind == N ) return 0 ;", "nl": "Base case"}
{"code": "int ans = longestSubSequence ( A , N , ind + 1 , lastf , lasts ) ;", "nl": "Not include the current pair in the longest subsequence"}
{"code": "if ( A [ ind ] [ 0 ] > lastf && A [ ind ] [ 1 ] < lasts ) ans = Math . max ( ans , longestSubSequence ( A , N , ind + 1 , A [ ind ] [ 0 ] , A [ ind ] [ 1 ] ) + 1 ) ; return ans ; }", "nl": "Including the current pair in the longest subsequence"}
{"code": "public static int longestSubSequence ( int [ ] [ ] A , int N ) { return longestSubSequence ( A , N , 0 , 0 , 0 ) ; }", "nl": "Function"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "int [ ] [ ] A = { { 1 , 2 } , { 2 , 2 } , { 3 , 1 } } ; int N = A . length ;", "nl": "Given Input"}
{"code": "System . out . println ( longestSubSequence ( A , N ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int countTriplets ( int [ ] A ) {", "nl": "Function to find the number of triplets whose Bitwise AND is 0."}
{"code": "int cnt = 0 ;", "nl": "Stores the count of triplets having bitwise AND equal to 0"}
{"code": "HashMap < Integer , Integer > tuples = new HashMap < Integer , Integer > ( ) ;", "nl": "Stores frequencies of all possible A [ i ] & A [ j ]"}
{"code": "for ( int a : A )", "nl": "Traverse the array"}
{"code": "for ( int b : A ) { if ( tuples . containsKey ( a & b ) ) tuples . put ( a & b , tuples . get ( a & b ) + 1 ) ; else tuples . put ( a & b , 1 ) ; }", "nl": "Update frequency of Bitwise AND of all array elements with a"}
{"code": "for ( int a : A )", "nl": "Traverse the array"}
{"code": "for ( Map . Entry < Integer , Integer > t : tuples . entrySet ( ) )", "nl": "Iterate the map"}
{"code": "if ( ( t . getKey ( ) & a ) == 0 ) cnt += t . getValue ( ) ;", "nl": "If bitwise AND of triplet is zero , increment cnt"}
{"code": "return cnt ; }", "nl": "Return the number of triplets whose Bitwise AND is 0."}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int [ ] A = { 2 , 1 , 3 } ;", "nl": "Input Array"}
{"code": "System . out . print ( countTriplets ( A ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . Arrays ; class GfG { static int CountWays ( int n ) {", "nl": "Bottom up approach for counting ways to reach a score using 1 and 2 with consecutive 2 allowed"}
{"code": "int noOfWays [ ] = new int [ n + 3 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ;", "nl": "noOfWays [ i ] will store count for value i . 3 extra values are to take care of cornser case n = 0"}
{"code": "for ( int i = 3 ; i < n + 1 ; i ++ ) {", "nl": "Loop till \" n + 1\" to compute value for \" n \""}
{"code": "noOfWays [ i ] = noOfWays [ i - 1 ] + noOfWays [ i - 3 ] ; } return noOfWays [ n ] ; }", "nl": "number of ways if first run is 1"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( CountWays ( n ) ) ; } }", "nl": "Driver code"}
{"code": "int row = 0 , col = 0 ; int boundary = size - 1 ; int sizeLeft = size - 1 ; int flag = 1 ;", "nl": "Create row and col to traverse rows and columns"}
{"code": "char move = ' r ' ;", "nl": "Variable to determine the movement r = right , l = left , d = down , u = upper"}
{"code": "int matrix [ ] [ ] = new int [ size ] [ size ] ; for ( int i = 1 ; i < size * size + 1 ; i ++ ) {", "nl": "Array for matrix"}
{"code": "matrix [ row ] [ col ] = i ;", "nl": "Assign the value"}
{"code": "switch ( move ) {", "nl": "switch - case to determine the next index"}
{"code": "case ' r ' : col += 1 ; break ;", "nl": "If right , go right"}
{"code": "case ' l ' : col -= 1 ; break ;", "nl": "if left , go left"}
{"code": "case ' u ' : row -= 1 ; break ;", "nl": "if up , go up"}
{"code": "case ' d ' : row += 1 ; break ; }", "nl": "if down , go down"}
{"code": "if ( i == boundary ) {", "nl": "Check if the matrix has reached array boundary"}
{"code": "boundary += sizeLeft ;", "nl": "Add the left size for the next boundary"}
{"code": "if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; }", "nl": "If 2 rotations has been made , decrease the size left by 1"}
{"code": "switch ( move ) {", "nl": "switch - case to rotate the movement"}
{"code": "case ' r ' : move = ' d ' ; break ;", "nl": "if right , rotate to down"}
{"code": "case ' d ' : move = ' l ' ; break ;", "nl": "if down , rotate to left"}
{"code": "case ' l ' : move = ' u ' ; break ;", "nl": "if left , rotate to up"}
{"code": "case ' u ' : move = ' r ' ; break ; } } }", "nl": "if up , rotate to right"}
{"code": "for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { int n = matrix [ row ] [ col ] ; System . out . print ( ( n < 10 ) ? ( n + \" \u2581 \" ) : ( n + \" \u2581 \" ) ) ; } System . out . println ( ) ; } }", "nl": "Print the matrix"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int size = 5 ;", "nl": "Get the size of size"}
{"code": "printSpiral ( size ) ; } }", "nl": "Print the Spiral Pattern"}
{"code": "import java . util . * ; public class GFG {", "nl": "Java program for the above approach"}
{"code": "static void findWinner ( String a , int n ) {", "nl": "Function to check if player A wins the game or not"}
{"code": "Vector < Integer > v = new Vector < Integer > ( ) ;", "nl": "Stores size of the groups of 0 s"}
{"code": "int c = 0 ;", "nl": "Stores size of the group of 0 s"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse the array"}
{"code": "if ( a . charAt ( i ) == '0' ) { c ++ ; }", "nl": "Increment c by 1 if a [ i ] is 0"}
{"code": "else { if ( c != 0 ) v . add ( c ) ; c = 0 ; } } if ( c != 0 ) v . add ( c ) ;", "nl": "Otherwise , push the size in array and reset c to 0"}
{"code": "if ( v . size ( ) == 0 ) { System . out . print ( \" Player \u2581 B \" ) ; return ; }", "nl": "If there is no substring of odd length consisting only of 0 s"}
{"code": "if ( v . size ( ) == 1 ) { if ( ( v . get ( 0 ) & 1 ) != 0 ) System . out . print ( \" Player \u2581 A \" ) ;", "nl": "If there is only 1 substring of odd length consisting only of 0 s"}
{"code": "else System . out . print ( \" Player \u2581 B \" ) ; return ; }", "nl": "Otherwise"}
{"code": "int first = Integer . MIN_VALUE ; int second = Integer . MIN_VALUE ;", "nl": "Stores the size of the largest and second largest substrings of 0 s"}
{"code": "for ( int i = 0 ; i < v . size ( ) ; i ++ ) {", "nl": "Traverse the array v [ ]"}
{"code": "if ( a . charAt ( i ) > first ) { second = first ; first = a . charAt ( i ) ; }", "nl": "If current element is greater than first , then update both first and second"}
{"code": "else if ( a . charAt ( i ) > second && a . charAt ( i ) != first ) second = a . charAt ( i ) ; }", "nl": "If arr [ i ] is in between first and second , then update second"}
{"code": "if ( ( first & 1 ) != 0 && ( first + 1 ) / 2 > second ) System . out . print ( \" Player \u2581 A \" ) ; else System . out . print ( \" Player \u2581 B \" ) ; }", "nl": "If the condition is satisfied"}
{"code": "public static void main ( String [ ] args ) { String S = \"1100011\" ; int N = S . length ( ) ; findWinner ( S , N ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to check whether the string is K palindrome or not"}
{"code": "static boolean can_Construct ( String S , int K ) {", "nl": "Function to check whether the string is K palindrome or not"}
{"code": "Map < Character , Integer > m = new HashMap < > ( ) ; int p = 0 ;", "nl": "Map to frequency of character"}
{"code": "if ( S . length ( ) == K ) return true ;", "nl": "Check when k is given as same as length of string"}
{"code": "for ( int i = 0 ; i < S . length ( ) ; i ++ ) m . put ( S . charAt ( i ) , m . getOrDefault ( S . charAt ( i ) , 0 ) + 1 ) ;", "nl": "Storing the frequency of every character in map"}
{"code": "if ( K > S . length ( ) ) return false ; else {", "nl": "If K is greater than size of then return false"}
{"code": "for ( Integer h : m . values ( ) ) { if ( h % 2 != 0 ) p = p + 1 ; } }", "nl": "Check that number of character having the odd frequency"}
{"code": "if ( K < p ) return false ; return true ; }", "nl": "If k is less than number of odd frequency character then it is again false otherwise true"}
{"code": "public static void main ( String [ ] args ) { String S = \" annabelle \" ; int K = 4 ; if ( can_Construct ( S , K ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "A Java Program to find the longest common prefix"}
{"code": "static boolean equalIgnoreCase ( String str1 , String str2 ) { int i = 0 ;", "nl": "Function to compare two strings ignoring their cases"}
{"code": "str1 = str1 . toLowerCase ( ) ; str2 = str2 . toLowerCase ( ) ;", "nl": "Convert to lowercase using toLowerCase function"}
{"code": "int x = str1 . compareTo ( str2 ) ;", "nl": "Comparing both using inbuilt function"}
{"code": "return x == 0 ; }", "nl": "if strings are equal , return true otherwise false"}
{"code": "static void equalIgnoreCaseUtil ( String str1 , String str2 ) { boolean res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) System . out . println ( \" Same \" ) ; else System . out . println ( \" Not \u2581 Same \" ) ; }", "nl": "Function to print the same or not same if strings are equal or not equal"}
{"code": "public static void main ( String [ ] args ) { String str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class solution {", "nl": "Java Program to print Step Pattern"}
{"code": "static void steps ( String str , int n ) {", "nl": "function to print the steps"}
{"code": "boolean flag = false ; int x = 0 ;", "nl": "declare a flag"}
{"code": "for ( int i = 0 ; i < str . length ( ) ; i ++ ) {", "nl": "traverse through all the characters in the string"}
{"code": "if ( x == 0 ) flag = true ;", "nl": "if the x value is 0. . then we must increment till n ... set flag to true"}
{"code": "if ( x == n - 1 ) flag = false ;", "nl": "if the x value is n - 1 then we must decrement till 0 ... set flag as false"}
{"code": "for ( int j = 0 ; j < x ; j ++ ) System . out . print ( \" * \" ) ; System . out . print ( str . charAt ( i ) + \"NEW_LINE\");", "nl": "print x * s"}
{"code": "if ( flag == true ) x ++ ; else x -- ; } }", "nl": "checking whether to increment or decrement x"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver code"}
{"code": "int n = 4 ; String str = \" GeeksForGeeks \" ; System . out . println ( \" String : \u2581 \" + str ) ; System . out . println ( \" Max \u2581 Length \u2581 of \u2581 Steps : \u2581 \" + n ) ;", "nl": "Get the String and the number n"}
{"code": "steps ( str , n ) ; } }", "nl": "calling the function"}
{"code": "import java . util . * ; class GFG { static void countFreq ( int arr [ ] , int n ) {", "nl": "Java program to count frequencies of array items"}
{"code": "boolean [ ] visited = new boolean [ n ] ;", "nl": "Mark all array elements as not visited"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse through array elements and count frequencies"}
{"code": "if ( visited [ i ] == true ) continue ;", "nl": "Skip this element if already processed"}
{"code": "int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } System . out . println ( arr [ i ] + \" \u2581 \" + count ) ; } }", "nl": "Count frequency"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 } ; int n = arr . length ; countFreq ( arr , n ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation to check whether given binary number is evenly divisible by 2 ^ k or not"}
{"code": "static boolean isDivisible ( String str , int k ) { int n = str . length ( ) ; int c = 0 ;", "nl": "function to check whether given binary number is evenly divisible by 2 ^ k or not"}
{"code": "for ( int i = 0 ; i < k ; i ++ ) if ( str . charAt ( n - i - 1 ) == '0' ) c ++ ;", "nl": "count of number of 0 from last"}
{"code": "return ( c == k ) ; }", "nl": "if count = k , number is evenly divisible , so returns true else false"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver program to test above"}
{"code": "String str1 = \"10101100\" ; int k = 2 ; if ( isDivisible ( str1 , k ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ;", "nl": "first example"}
{"code": "String str2 = \"111010100\" ; k = 2 ; if ( isDivisible ( str2 , k ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Second example"}
{"code": "public class GFG { static final int NO_OF_CHARS = 256 ;", "nl": "Java program to Check if any anagram of a string is palindrome or not"}
{"code": "static boolean canFormPalindrome ( String str ) {", "nl": "function to check whether characters of a string can form a palindrome"}
{"code": "int [ ] count = new int [ NO_OF_CHARS ] ;", "nl": "Create a count array and initialize all values as 0"}
{"code": "for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str . charAt ( i ) ] ++ ;", "nl": "For each character in input strings , increment count in the corresponding count array"}
{"code": "int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] & 1 ) != 0 ) odd ++ ; if ( odd > 1 ) return false ; }", "nl": "Count odd occurring characters"}
{"code": "return true ; }", "nl": "Return true if odd count is 0 or 1 ,"}
{"code": "public static void main ( String args [ ] ) { System . out . println ( canFormPalindrome ( \" geeksforgeeks \" ) ? \" Yes \" : \" No \" ) ; System . out . println ( canFormPalindrome ( \" geeksogeeks \" ) ? \" Yes \" : \" No \" ) ; } }", "nl": "Driver program to test to print printDups"}
{"code": "import java . io . * ; public class GFG {", "nl": "Java program to check if a given string is a valid integer"}
{"code": "static boolean isNumber ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( Character . isDigit ( s . charAt ( i ) ) == false ) return false ; return true ; }", "nl": "Returns true if s is a number else false"}
{"code": "static public void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "String str = \"6790\" ;", "nl": "Saving the input in a string"}
{"code": "if ( isNumber ( str ) ) System . out . println ( \" Integer \" ) ;", "nl": "Function returns 1 if all elements are in range '0 \u2581 - \u2581 9'"}
{"code": "else System . out . println ( \" String \" ) ; } }", "nl": "Function returns 0 if the input is not an integer"}
{"code": "class StringReverse {", "nl": "Java program to reverse a string using recursion"}
{"code": "void reverse ( String str ) { if ( ( str == null ) || ( str . length ( ) <= 1 ) ) System . out . println ( str ) ; else { System . out . print ( str . charAt ( str . length ( ) - 1 ) ) ; reverse ( str . substring ( 0 , str . length ( ) - 1 ) ) ; } }", "nl": "Function to print reverse of the passed string"}
{"code": "public static void main ( String [ ] args ) { String str = \" Geeks \u2581 for \u2581 Geeks \" ; StringReverse obj = new StringReverse ( ) ; obj . reverse ( str ) ; } }", "nl": "Driver program to test above function"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int box1 = 0 ;", "nl": "Stores the count of distinct colors in box1"}
{"code": "static int box2 = 0 ; static int [ ] fact = new int [ 11 ] ;", "nl": "Stores the count of distinct colors in box2"}
{"code": "public static double getProbability ( int [ ] balls ) {", "nl": "Function to calculate the required probability"}
{"code": "factorial ( 10 ) ;", "nl": "Calculate factorial from [ 1 , 10 ]"}
{"code": "box2 = balls . length ;", "nl": "Assign all distinct balls to second box"}
{"code": "int K = 0 ;", "nl": "Total number of balls"}
{"code": "for ( int i = 0 ; i < balls . length ; i ++ ) K += balls [ i ] ;", "nl": "Calculate total number of balls"}
{"code": "if ( K % 2 == 1 ) return 0 ;", "nl": "If K is an odd number"}
{"code": "long all = comb ( K , K / 2 ) ;", "nl": "Total ways of distributing the balls in two equal halves"}
{"code": "long validPermutations = validPermutations ( K / 2 , balls , 0 , 0 ) ;", "nl": "Required number of ways"}
{"code": "return ( double ) validPermutations / all ; }", "nl": "Return the required probability"}
{"code": "static long validPermutations ( int n , int [ ] balls , int usedBalls , int i ) {", "nl": "Function to calculate total number of possible distributions which satisfies the given conditions"}
{"code": "if ( usedBalls == n ) {", "nl": "If used balls is equal to K / 2"}
{"code": "return box1 == box2 ? 1 : 0 ; }", "nl": "If box1 is equal to box2"}
{"code": "if ( i >= balls . length ) return 0 ;", "nl": "Base condition"}
{"code": "long res = validPermutations ( n , balls , usedBalls , i + 1 ) ;", "nl": "Stores the number of ways of distributing remaining balls without including the current balls in box1"}
{"code": "box1 ++ ;", "nl": "Increment box1 by one"}
{"code": "for ( int j = 1 ; j <= balls [ i ] ; j ++ ) {", "nl": "Iterate over the range [ 1 , balls [ i ] ]"}
{"code": "if ( j == balls [ i ] ) box2 -- ;", "nl": "If all the balls goes to box1 , then decrease box2 by one"}
{"code": "long combinations = comb ( balls [ i ] , j ) ;", "nl": "Total number of ways of selecting j balls"}
{"code": "res += combinations * validPermutations ( n , balls , usedBalls + j , i + 1 ) ; }", "nl": "Increment res by total number of valid ways of distributing the remaining balls"}
{"code": "box1 -- ;", "nl": "Decrement box1 by one"}
{"code": "box2 ++ ; return res ; }", "nl": "Increment box2 by 1"}
{"code": "static void factorial ( int N ) {", "nl": "Function to calculate factorial of N"}
{"code": "fact [ 0 ] = 1 ;", "nl": "Base Case"}
{"code": "for ( int i = 1 ; i <= N ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; }", "nl": "Iterate over the range [ 1 , N ]"}
{"code": "static long comb ( int n , int r ) { long res = fact [ n ] / fact [ r ] ; res /= fact [ n - r ] ; return res ; }", "nl": "Function to calculate NcR"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 1 } ; int N = 4 ;", "nl": "Driver Code"}
{"code": "System . out . println ( getProbability ( arr ) ) ; } }", "nl": "Print the result"}
{"code": "import java . util . * ; class GFG {", "nl": "Java Program to find the area of a regular polygon with given radius"}
{"code": "static double polyarea ( double n , double r ) {", "nl": "Function to find the area of a regular polygon"}
{"code": "if ( r < 0 && n < 0 ) return - 1 ;", "nl": "Side and radius cannot be negative"}
{"code": "double A = ( ( r * r * n ) * Math . sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; }", "nl": "Area degree converted to radians"}
{"code": "public static void main ( String [ ] args ) { float r = 9 , n = 6 ; System . out . println ( polyarea ( n , r ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static void is_partition_possible ( int n , int x [ ] , int y [ ] , int w [ ] ) { Map < Integer , Integer > weight_at_x = new HashMap < Integer , Integer > ( ) ; int max_x = ( int ) - 2e3 , min_x = ( int ) 2e3 ;", "nl": "Checking if a plane can be divide by a line at 45 degrees such that weight sum is equal"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { int new_x = x [ i ] - y [ i ] ; max_x = Math . max ( max_x , new_x ) ; min_x = Math . min ( min_x , new_x ) ;", "nl": "Rotating each point by 45 degrees and calculating prefix sum . Also , finding maximum and minimum x coordinates"}
{"code": "if ( weight_at_x . containsKey ( new_x ) ) { weight_at_x . put ( new_x , weight_at_x . get ( new_x ) + w [ i ] ) ; } else { weight_at_x . put ( new_x , w [ i ] ) ; } } Vector < Integer > sum_till = new Vector < > ( ) ; sum_till . add ( 0 ) ;", "nl": "storing weight sum upto x - y point"}
{"code": "for ( int s = min_x ; s <= max_x ; s ++ ) { if ( weight_at_x . get ( s ) == null ) sum_till . add ( sum_till . lastElement ( ) ) ; else sum_till . add ( sum_till . lastElement ( ) + weight_at_x . get ( s ) ) ; } int total_sum = sum_till . lastElement ( ) ; int partition_possible = 0 ; for ( int i = 1 ; i < sum_till . size ( ) ; i ++ ) { if ( sum_till . get ( i ) == total_sum - sum_till . get ( i ) ) partition_possible = 1 ;", "nl": "Finding prefix sum"}
{"code": "if ( sum_till . get ( i - 1 ) == total_sum - sum_till . get ( i ) ) partition_possible = 1 ; } System . out . printf ( partition_possible == 1 ? \"YES \" \u2581 : \u2581 \" NO \"); }", "nl": "Line passes through i , so it neither falls left nor right ."}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; int x [ ] = { - 1 , - 2 , 1 } ; int y [ ] = { 1 , 1 , - 1 } ; int w [ ] = { 3 , 1 , 4 } ; is_partition_possible ( n , x , y , w ) ; } }", "nl": "Driven code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program find slope of perpendicular line"}
{"code": "static double findPCSlope ( double m ) { return - 1.0 / m ; }", "nl": "Function to find the Slope of other line"}
{"code": "public static void main ( String [ ] args ) { double m = 2.0 ; System . out . println ( findPCSlope ( m ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static float pi = 3.14159f ; static float", "nl": "Java Program to find area of segment of a circle"}
{"code": "area_of_segment ( float radius , float angle ) {", "nl": "Function to find area of segment"}
{"code": "float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ;", "nl": "Calculating area of sector"}
{"code": "float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * ( float ) Math . sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }", "nl": "Calculating area of triangle"}
{"code": "public static void main ( String [ ] args ) { float radius = 10.0f , angle = 90.0f ; System . out . println ( \" Area \u2581 of \u2581 minor \u2581 segment \u2581 = \u2581 \" + area_of_segment ( radius , angle ) ) ; System . out . println ( \" Area \u2581 of \u2581 major \u2581 segment \u2581 = \u2581 \" + area_of_segment ( radius , ( 360 - angle ) ) ) ; } }", "nl": "Driver Function"}
{"code": "class GFG { static void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) System . out . println ( \" Angle \u2581 not \u2581 possible \" ) ;", "nl": "Java program to find Area of a Sector"}
{"code": "else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; System . out . println ( sector ) ; } }", "nl": "Calculating area of the sector"}
{"code": "public static void main ( String [ ] args ) { double radius = 9 ; double angle = 60 ; SectorArea ( radius , angle ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; public class Main { static int gcd ( int a , int b ) {", "nl": "Java program for the above approach"}
{"code": "if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; }", "nl": "Everything divides 0"}
{"code": "static HashMap < Integer , Integer > PrimeFactor ( int N ) { HashMap < Integer , Integer > primef = new HashMap < Integer , Integer > ( ) ;", "nl": "Function to calculate total number of prime factor with their prime factor"}
{"code": "while ( N % 2 == 0 ) { if ( primef . containsKey ( 2 ) ) { primef . put ( 2 , primef . get ( 2 ) + 1 ) ; } else { primef . put ( 2 , 1 ) ; }", "nl": "Iterate while the number is even"}
{"code": "N = N / 2 ; }", "nl": "Reduce to half"}
{"code": "for ( int i = 3 ; i <= Math . sqrt ( N ) ; i ++ ) {", "nl": "Iterate up to sqrt ( N )"}
{"code": "while ( N % i == 0 ) { if ( primef . containsKey ( i ) ) { primef . put ( i , primef . get ( i ) + 1 ) ; } else { primef . put ( i , 1 ) ; }", "nl": "Iterate while N has factors of i"}
{"code": "N = N / 2 ; } } if ( N > 2 ) { primef . put ( N , 1 ) ; } return primef ; }", "nl": "Removing one factor of i"}
{"code": "static int CountToMakeEqual ( int X , int Y ) {", "nl": "Function to count the number of factors"}
{"code": "int gcdofXY = gcd ( X , Y ) ;", "nl": "Find the GCD"}
{"code": "int newX = Y / gcdofXY ; int newY = X / gcdofXY ;", "nl": "Find multiples left in X and Y"}
{"code": "HashMap < Integer , Integer > primeX = PrimeFactor ( newX ) ; HashMap < Integer , Integer > primeY = PrimeFactor ( newY ) ;", "nl": "Find prime factor of multiple left in X and Y"}
{"code": "int ans = 0 ;", "nl": "Initialize ans"}
{"code": "for ( Map . Entry keys : primeX . entrySet ( ) ) { if ( X % ( int ) keys . getKey ( ) != 0 ) { return - 1 ; } ans += primeX . get ( keys . getKey ( ) ) ; }", "nl": "Check if it possible to obtain X or not"}
{"code": "for ( Map . Entry keys : primeY . entrySet ( ) ) { if ( Y % ( int ) keys . getKey ( ) != 0 ) { return - 1 ; } ans += primeY . get ( keys . getKey ( ) ) ; }", "nl": "Check if it possible to obtain Y or not"}
{"code": "return ans ; }", "nl": "Return main ans"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int X = 36 ; int Y = 48 ;", "nl": "Given Input"}
{"code": "int ans = CountToMakeEqual ( X , Y ) ; System . out . println ( ans ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; import java . lang . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static class Node { int L , R , V ; Node ( int L , int R , int V ) { this . L = L ; this . R = R ; this . V = V ; } }", "nl": "Stores the details of the Segment"}
{"code": "static boolean check ( ArrayList < Integer > Adj [ ] , int Src , int N , boolean visited [ ] ) { int color [ ] = new int [ N ] ;", "nl": "Function to check whether the graph is bipartite or not"}
{"code": "visited [ Src ] = true ; ArrayDeque < Integer > q = new ArrayDeque < > ( ) ;", "nl": "Mark source node as visited"}
{"code": "q . addLast ( Src ) ; while ( ! q . isEmpty ( ) ) {", "nl": "Push the source vertex in queue"}
{"code": "int u = q . removeFirst ( ) ;", "nl": "Get the front of the queue"}
{"code": "int Col = color [ u ] ;", "nl": "Assign the color to the popped node"}
{"code": "for ( int x : Adj [ u ] ) {", "nl": "Traverse the adjacency list of the node u"}
{"code": "if ( visited [ x ] == true && color [ x ] == Col ) { return false ; } else if ( visited [ x ] == false ) {", "nl": "If any node is visited & a different colors has been assigned , then return false"}
{"code": "visited [ x ] = true ;", "nl": "Set visited [ x ]"}
{"code": "q . addLast ( x ) ;", "nl": "Push the node x into the queue"}
{"code": "color [ x ] = 1 - Col ; } } }", "nl": "Update color of node"}
{"code": "return true ; }", "nl": "If the graph is bipartite"}
{"code": "static void addEdge ( ArrayList < Integer > Adj [ ] , int u , int v ) { Adj [ u ] . add ( v ) ; Adj [ v ] . add ( u ) ; }", "nl": "Function to add an edge between the nodes u and v"}
{"code": "static void isPossible ( Node Arr [ ] , int N ) {", "nl": "Function to check if the assignment of direction can be possible to all the segments , such that they do not intersect after a long period of time"}
{"code": "@ SuppressWarnings ( \" unchecked \" ) ArrayList < Integer > [ ] Adj = ( ArrayList < Integer > [ ] ) new ArrayList [ N ] ;", "nl": "Stores the adjacency list of the created graph"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) Adj [ i ] = new ArrayList < > ( ) ;", "nl": "Initialize"}
{"code": "for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) {", "nl": "Generate all possible pairs"}
{"code": "if ( Arr [ i ] . R < Arr [ j ] . L Arr [ i ] . L > Arr [ j ] . R ) { continue ; }", "nl": "If segments do not overlap"}
{"code": "else { if ( Arr [ i ] . V == Arr [ j ] . V ) {", "nl": "Otherwise , the segments overlap"}
{"code": "addEdge ( Adj , i , j ) ; } } } }", "nl": "If both segments have same speed , then add an edge"}
{"code": "boolean visited [ ] = new boolean [ N ] ;", "nl": "Keep the track of visited nodes"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { if ( visited [ i ] == false && Adj [ i ] . size ( ) > 0 ) {", "nl": "Iterate for all possible nodes"}
{"code": "if ( check ( Adj , i , N , visited ) == false ) { System . out . println ( \" No \" ) ; return ; } } }", "nl": "Check whether graph is bipartite or not"}
{"code": "System . out . println ( \" Yes \" ) ; }", "nl": "If the graph is bipartite"}
{"code": "public static void main ( String [ ] args ) { Node arr [ ] = { new Node ( 5 , 7 , 2 ) , new Node ( 4 , 6 , 1 ) , new Node ( 1 , 5 , 2 ) , new Node ( 6 , 5 , 1 ) } ; int N = arr . length ; isPossible ( arr , N ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; import java . util . * ; class GFG { public static void lexNumbers ( int n ) { List < Integer > sol = new ArrayList < > ( ) ; dfs ( 1 , n , sol ) ; System . out . println ( sol ) ; } public static void dfs ( int temp , int n , List < Integer > sol ) { if ( temp > n ) return ; sol . add ( temp ) ; dfs ( temp * 10 , n , sol ) ; if ( temp % 10 != 9 ) dfs ( temp + 1 , n , sol ) ; }", "nl": "Java program for the above approach"}
{"code": "public static void main ( String [ ] args ) { int n = 15 ; lexNumbers ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GfG {", "nl": "Java program to find the minimum number of swaps required to sort the given array"}
{"code": "static int minimumSwaps ( int [ ] arr ) {", "nl": "Function to find minimum swaps"}
{"code": "int count = 0 ; int i = 0 ; while ( i < arr . length ) {", "nl": "Initialise count variable"}
{"code": "if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { int temp = 0 ;", "nl": "If current element is not at the right position"}
{"code": "temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } }", "nl": "Swap current element with correct position of that element"}
{"code": "i ++ ; } return count ; }", "nl": "Increment for next index when current element is at correct position"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 1 , 5 } ;", "nl": "Driver code"}
{"code": "System . out . println ( minimumSwaps ( arr ) ) ; } }", "nl": "Function to find minimum swaps"}
{"code": "class GFG {", "nl": "Java program to merge K sorted doubly linked list in sorted order"}
{"code": "static class Node { int data ; Node next ; Node prev ; } ;", "nl": "A linked list node"}
{"code": "static Node append ( Node head_ref , int new_data ) {", "nl": "Given a reference ( pointer to pointer ) to the head Of a DLL and an int , appends a new node at the end"}
{"code": "Node new_node = new Node ( ) ; Node last = head_ref ;", "nl": "Allocate node"}
{"code": "new_node . data = new_data ;", "nl": "Put in the data"}
{"code": "new_node . next = null ;", "nl": "This new node is going to be the last node , so make next of it as null"}
{"code": "if ( head_ref == null ) { new_node . prev = null ; head_ref = new_node ; return head_ref ; }", "nl": "If the Linked List is empty , then make the new node as head"}
{"code": "while ( last . next != null ) last = last . next ;", "nl": "Else traverse till the last node"}
{"code": "last . next = new_node ;", "nl": "Change the next of last node"}
{"code": "new_node . prev = last ; return head_ref ; }", "nl": "Make last node as previous of new node"}
{"code": "static void printList ( Node node ) { Node last ;", "nl": "Function to print the list"}
{"code": "while ( node != null ) { System . out . print ( node . data + \" \u2581 \" ) ; last = node ; node = node . next ; } }", "nl": "Run while loop unless node becomes null"}
{"code": "static Node mergeList ( Node p , Node q ) { Node s = null ;", "nl": "Function to merge two sorted doubly linked lists"}
{"code": "if ( p == null q == null ) { return ( p == null ? q : p ) ; }", "nl": "If any of the list is empty"}
{"code": "if ( p . data < q . data ) { p . prev = s ; s = p ; p = p . next ; } else { q . prev = s ; s = q ; q = q . next ; }", "nl": "Comparison the data of two linked list"}
{"code": "Node head = s ; while ( p != null && q != null ) { if ( p . data < q . data ) {", "nl": "Store head pointer before merge the list"}
{"code": "s . next = p ; p . prev = s ; s = s . next ; p = p . next ; } else {", "nl": "Changing of pointer between Two list for merging"}
{"code": "s . next = q ; q . prev = s ; s = s . next ; q = q . next ; } }", "nl": "Changing of pointer between Two list for merging"}
{"code": "if ( p == null ) { s . next = q ; q . prev = s ; } if ( q == null ) { s . next = p ; p . prev = s ; }", "nl": "Condition to check if any anyone list not end"}
{"code": "return head ; }", "nl": "Return head pointer of merged list"}
{"code": "static Node mergeAllList ( Node head [ ] , int k ) { Node finalList = null ; for ( int i = 0 ; i < k ; i ++ ) {", "nl": "Function to merge all sorted linked list in sorted order"}
{"code": "finalList = mergeList ( finalList , head [ i ] ) ; }", "nl": "Function call to merge two sorted doubly linked list at a time"}
{"code": "return finalList ; }", "nl": "Return final sorted doubly linked list"}
{"code": "public static void main ( String args [ ] ) { int k = 3 ; Node head [ ] = new Node [ k ] ;", "nl": "Driver code"}
{"code": "for ( int i = 0 ; i < k ; i ++ ) { head [ i ] = null ; }", "nl": "Loop to initialize all the lists to empty"}
{"code": "head [ 0 ] = append ( head [ 0 ] , 1 ) ; head [ 0 ] = append ( head [ 0 ] , 5 ) ; head [ 0 ] = append ( head [ 0 ] , 9 ) ;", "nl": "Create first doubly linked List List1 . 1 <= > 5 <= > 9"}
{"code": "head [ 1 ] = append ( head [ 1 ] , 2 ) ; head [ 1 ] = append ( head [ 1 ] , 3 ) ; head [ 1 ] = append ( head [ 1 ] , 7 ) ; head [ 1 ] = append ( head [ 1 ] , 12 ) ;", "nl": "Create second doubly linked List List2 . 2 <= > 3 <= > 7 <= > 12"}
{"code": "head [ 2 ] = append ( head [ 2 ] , 8 ) ; head [ 2 ] = append ( head [ 2 ] , 11 ) ; head [ 2 ] = append ( head [ 2 ] , 13 ) ; head [ 2 ] = append ( head [ 2 ] , 18 ) ;", "nl": "Create third doubly linked List List3 . 8 <= > 11 <= > 13 <= > 18"}
{"code": "Node finalList = mergeAllList ( head , k ) ;", "nl": "Function call to merge all sorted doubly linked lists in sorted order"}
{"code": "printList ( finalList ) ; } }", "nl": "Print final sorted list"}
{"code": "class Test {", "nl": "Recursive Java program to sort an array using selection sort"}
{"code": "static int minIndex ( int a [ ] , int i , int j ) { if ( i == j ) return i ;", "nl": "Return minimum index"}
{"code": "int k = minIndex ( a , i + 1 , j ) ;", "nl": "Find minimum of remaining elements"}
{"code": "return ( a [ i ] < a [ k ] ) ? i : k ; }", "nl": "Return minimum of current and remaining ."}
{"code": "static void recurSelectionSort ( int a [ ] , int n , int index ) {", "nl": "Recursive selection sort . n is size of a [ ] and index is index of starting element ."}
{"code": "if ( index == n ) return ;", "nl": "Return when starting and size are same"}
{"code": "int k = minIndex ( a , index , n - 1 ) ;", "nl": "calling minimum index function for minimum index"}
{"code": "if ( k != index ) {", "nl": "Swapping when index nd minimum index are not same"}
{"code": "int temp = a [ k ] ; a [ k ] = a [ index ] ; a [ index ] = temp ; }", "nl": "swap"}
{"code": "recurSelectionSort ( a , n , index + 1 ) ; }", "nl": "Recursively calling selection sort function"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 3 , 1 , 5 , 2 , 7 , 0 } ;", "nl": "Driver method"}
{"code": "recurSelectionSort ( arr , arr . length , 0 ) ;", "nl": "Calling function"}
{"code": "for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }", "nl": "printing sorted array"}
{"code": "import java . util . Arrays ; public class GFG {", "nl": "Recursive Java program for insertion sort"}
{"code": "static void insertionSortRecursive ( int arr [ ] , int n ) {", "nl": "Recursive function to sort an array using insertion sort"}
{"code": "if ( n <= 1 ) return ;", "nl": "Base case"}
{"code": "insertionSortRecursive ( arr , n - 1 ) ;", "nl": "Sort first n - 1 elements"}
{"code": "int last = arr [ n - 1 ] ; int j = n - 2 ;", "nl": "Insert last element at its correct position in sorted array ."}
{"code": "while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = last ; }", "nl": "Move elements of arr [ 0. . i - 1 ] , that are greater than key , to one position ahead of their current position"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; insertionSortRecursive ( arr , arr . length ) ; System . out . println ( Arrays . toString ( arr ) ) ; } }", "nl": "Driver Method"}
{"code": "import java . util . Arrays ; public class GFG {", "nl": "Java program for recursive implementation of Bubble sort"}
{"code": "static void bubbleSort ( int arr [ ] , int n ) {", "nl": "A function to implement bubble sort"}
{"code": "if ( n == 1 ) return ;", "nl": "Base case"}
{"code": "for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) {", "nl": "One pass of bubble sort . After this pass , the largest element is moved ( or bubbled ) to end ."}
{"code": "int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; }", "nl": "swap arr [ i ] , arr [ i + 1 ]"}
{"code": "bubbleSort ( arr , n - 1 ) ; }", "nl": "Largest element is fixed , recur for remaining array"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 64 , 34 , 25 , 12 , 22 , 11 , 90 } ; bubbleSort ( arr , arr . length ) ; System . out . println ( \" Sorted \u2581 array \u2581 : \u2581 \" ) ; System . out . println ( Arrays . toString ( arr ) ) ; } }", "nl": "Driver Method"}
{"code": "import java . io . * ; import java . util . * ; class GFG { static int maxSumAfterPartition ( int arr [ ] , int n ) {", "nl": "package whatever do not write package name here"}
{"code": "ArrayList < Integer > pos = new ArrayList < Integer > ( ) ;", "nl": "Stores the positive elements"}
{"code": "ArrayList < Integer > neg = new ArrayList < Integer > ( ) ;", "nl": "Stores the negative elements"}
{"code": "int zero = 0 ;", "nl": "Stores the count of 0 s"}
{"code": "int pos_sum = 0 ;", "nl": "Sum of all positive numbers"}
{"code": "int neg_sum = 0 ;", "nl": "Sum of all negative numbers"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { pos . add ( arr [ i ] ) ; pos_sum += arr [ i ] ; } else if ( arr [ i ] < 0 ) { neg . add ( arr [ i ] ) ; neg_sum += arr [ i ] ; } else { zero ++ ; } }", "nl": "Iterate over the array"}
{"code": "int ans = 0 ;", "nl": "Stores the difference"}
{"code": "Collections . sort ( pos ) ;", "nl": "Sort the positive numbers in ascending order"}
{"code": "Collections . sort ( neg ) ;", "nl": "Sort the negative numbers in decreasing order"}
{"code": "if ( pos . size ( ) > 0 && neg . size ( ) > 0 ) { ans = ( pos_sum - neg_sum ) ; } else if ( pos . size ( ) > 0 ) { if ( zero > 0 ) {", "nl": "Case 1 : Include both positive and negative numbers"}
{"code": "ans = ( pos_sum ) ; } else {", "nl": "Put all numbers in subset A and one 0 in subset B"}
{"code": "ans = ( pos_sum - 2 * pos . get ( 0 ) ) ; } } else { if ( zero > 0 ) {", "nl": "Put all numbers in subset A except the smallest positive number which is put in B"}
{"code": "ans = ( - 1 * neg_sum ) ; } else {", "nl": "Put all numbers in subset B and one 0 in subset A"}
{"code": "ans = ( neg . get ( 0 ) - ( neg_sum - neg . get ( 0 ) ) ) ; } } return ans ; }", "nl": "Place the largest negative number in subset A and remaining in B"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , - 5 , - 7 } ; int n = 5 ; System . out . println ( maxSumAfterPartition ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . lang . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int MaxXOR ( int arr [ ] , int N ) {", "nl": "Function to find the bitwise OR of array elements"}
{"code": "int res = 0 ;", "nl": "Stores the resultant maximum value of Bitwise XOR"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; }", "nl": "Traverse the array arr [ ]"}
{"code": "return res ; }", "nl": "Return the maximum value res"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 7 } ; int N = arr . length ; System . out . println ( MaxXOR ( arr , N ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . lang . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int countEqual ( int A [ ] , int B [ ] , int N ) {", "nl": "Function to count the number of elements common in both the arrays"}
{"code": "int first = 0 ; int second = N - 1 ;", "nl": "Used to traverse array A [ ] and B [ ] from the front and the back"}
{"code": "int count = 0 ; while ( first < N && second >= 0 ) {", "nl": "Stores the count of numbers common in both array"}
{"code": "if ( A [ first ] < B [ second ] ) {", "nl": "If A [ first ] is less than B [ second ]"}
{"code": "first ++ ; }", "nl": "Increment the value of first"}
{"code": "else if ( B [ second ] < A [ first ] ) {", "nl": "IF B [ second ] is less than A [ first ]"}
{"code": "second -- ; }", "nl": "Decrement the value of second"}
{"code": "else {", "nl": "A [ first ] is equal to B [ second ]"}
{"code": "count ++ ;", "nl": "Increment the value of count"}
{"code": "first ++ ;", "nl": "Increment the value of first"}
{"code": "second -- ; } }", "nl": "Decrement the value of second"}
{"code": "return count ; }", "nl": "Return the value of count"}
{"code": "public static void main ( String [ ] args ) { int A [ ] = { 2 , 4 , 5 , 8 , 12 , 13 , 17 , 18 , 20 , 22 , 309 , 999 } ; int B [ ] = { 109 , 99 , 68 , 54 , 22 , 19 , 17 , 13 , 11 , 5 , 3 , 1 } ; int N = A . length ; System . out . println ( countEqual ( A , B , N ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG { static int [ ] arr = new int [ 100005 ] ;", "nl": "Java program for the above approach"}
{"code": "static boolean isPalindrome ( int N ) {", "nl": "Function to check if the number N is palindrome or not"}
{"code": "int temp = N ;", "nl": "Store the value of N"}
{"code": "int res = 0 ;", "nl": "Store the reverse of number N"}
{"code": "while ( temp != 0 ) { int rem = temp % 10 ; res = res * 10 + rem ; temp /= 10 ; }", "nl": "Reverse temp and store in res"}
{"code": "if ( res == N ) { return true ; } else { return false ; } }", "nl": "If N is the same as res , then return true"}
{"code": "static int sumOfDigits ( int N ) {", "nl": "Function to find the sum of the digits of the number N"}
{"code": "int sum = 0 ; while ( N != 0 ) {", "nl": "Stores the sum of the digits"}
{"code": "sum += N % 10 ;", "nl": "Add the last digit of the number N to the sum"}
{"code": "N /= 10 ; }", "nl": "Remove the last digit from N"}
{"code": "return sum ; }", "nl": "Return the resultant sum"}
{"code": "static boolean isPrime ( int n ) {", "nl": "Function to check if N is prime or not"}
{"code": "if ( n <= 1 ) { return false ; }", "nl": "If i is 1 or 0 , then return false"}
{"code": "for ( int i = 2 ; i <= n / 2 ; ++ i ) {", "nl": "Check if i is divisible by any number in the range [ 2 , n / 2 ]"}
{"code": "if ( n % i == 0 ) return false ; } return true ; }", "nl": "If n is divisible by i"}
{"code": "static void precompute ( ) {", "nl": "Function to precompute all the numbers till 10 ^ 5 that are palindromic and whose sum of digits is prime numbers"}
{"code": "for ( int i = 1 ; i <= 100000 ; i ++ ) {", "nl": "Iterate over the range 1 to 10 ^ 5"}
{"code": "if ( isPalindrome ( i ) ) {", "nl": "If i is a palindrome number"}
{"code": "int sum = sumOfDigits ( i ) ;", "nl": "Stores the sum of the digits in i"}
{"code": "if ( isPrime ( sum ) ) arr [ i ] = 1 ; else arr [ i ] = 0 ; } else arr [ i ] = 0 ; }", "nl": "If the sum of digits in i is a prime number"}
{"code": "for ( int i = 1 ; i <= 100000 ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; } }", "nl": "Find the prefix sum of arr [ ]"}
{"code": "static void countNumbers ( int [ ] [ ] Q , int N ) {", "nl": "Function to count all the numbers in the given ranges that are palindromic and the sum of digits is prime numbers"}
{"code": "precompute ( ) ;", "nl": "Function Call to precompute all the numbers till 10 ^ 5"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the given queries Q [ ]"}
{"code": "System . out . println ( ( arr [ Q [ i ] [ 1 ] ] - arr [ Q [ i ] [ 0 ] - 1 ] ) ) ; } }", "nl": "Print the result for each query"}
{"code": "public static void main ( String [ ] args ) { int [ ] [ ] Q = { { 5 , 9 } , { 1 , 101 } } ; int N = Q . length ;", "nl": "Driver Code"}
{"code": "countNumbers ( Q , N ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int sum ( int n ) { int res = 0 ; while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; }", "nl": "Function to calculate sum digits of n"}
{"code": "static int smallestNumber ( int n , int s ) {", "nl": "Function to find the smallest possible integer satisfying the given condition"}
{"code": "if ( sum ( n ) <= s ) { return n ; }", "nl": "If the sum of digits is already smaller than S"}
{"code": "int ans = n , k = 1 ; for ( int i = 0 ; i < 9 ; ++ i ) {", "nl": "Initialize variables"}
{"code": "int digit = ( ans / k ) % 10 ;", "nl": "Finding last kth digit"}
{"code": "int add = k * ( ( 10 - digit ) % 10 ) ; ans += add ;", "nl": "Add remaining to make digit 0"}
{"code": "if ( sum ( ans ) <= s ) { break ; }", "nl": "If sum of digits does not exceed S"}
{"code": "k *= 10 ; } return ans ; }", "nl": "Update k"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 3 , S = 2 ;", "nl": "Given N and S"}
{"code": "System . out . println ( smallestNumber ( N , S ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int maxSubsequences ( int arr [ ] , int n ) {", "nl": "Function to find the maximum number number of required subsequences"}
{"code": "HashMap < Integer , Integer > map = new HashMap < > ( ) ;", "nl": "HashMap to store number of arrows available with height of arrow as key"}
{"code": "int maxCount = 0 ;", "nl": "Stores the maximum count of possible subsequences"}
{"code": "int count ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Stores the count of possible subsequences"}
{"code": "if ( map . containsKey ( arr [ i ] ) ) {", "nl": "Check if i - th element can be part of any of the previous subsequence"}
{"code": "count = map . get ( arr [ i ] ) ;", "nl": "Count of subsequences possible with arr [ i ] as the next element"}
{"code": "if ( count > 1 ) {", "nl": "If more than one such subsequence exists"}
{"code": "map . put ( arr [ i ] , count - 1 ) ; }", "nl": "Include arr [ i ] in a subsequence"}
{"code": "else map . remove ( arr [ i ] ) ;", "nl": "Otherwise"}
{"code": "if ( arr [ i ] - 1 > 0 ) map . put ( arr [ i ] - 1 , map . getOrDefault ( arr [ i ] - 1 , 0 ) + 1 ) ; } else {", "nl": "Increase count of subsequence possible with arr [ i ] - 1 as the next element"}
{"code": "maxCount ++ ;", "nl": "Start a new subsequence"}
{"code": "if ( arr [ i ] - 1 > 0 ) map . put ( arr [ i ] - 1 , map . getOrDefault ( arr [ i ] - 1 , 0 ) + 1 ) ; } }", "nl": "Increase count of subsequence possible with arr [ i ] - 1 as the next element"}
{"code": "return maxCount ; }", "nl": "Return the answer"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; int arr [ ] = { 4 , 5 , 2 , 1 , 4 } ; System . out . println ( maxSubsequences ( arr , n ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java Program to implement the above approach"}
{"code": "static String removeOcc ( String s , char ch ) {", "nl": "Function to remove first and last occurrence of a given character from the given String"}
{"code": "for ( int i = 0 ; i < s . length ( ) ; i ++ ) {", "nl": "Traverse the given String from the beginning"}
{"code": "if ( s . charAt ( i ) == ch ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; break ; } }", "nl": "If ch is found"}
{"code": "for ( int i = s . length ( ) - 1 ; i > - 1 ; i -- ) {", "nl": "Traverse the given String from the end"}
{"code": "if ( s . charAt ( i ) == ch ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; break ; } } return s ; }", "nl": "If ch is found"}
{"code": "public static void main ( String [ ] args ) { String s = \" hello \u2581 world \" ; char ch = ' l ' ; System . out . print ( removeOcc ( s , ch ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; public class GFG {", "nl": "Java program for the above approach"}
{"code": "public static void minSteps ( int N , int [ ] increasing , int [ ] decreasing ) {", "nl": "Function that finds the minimum steps to reach either 0 or N for given increasing and decreasing arrays"}
{"code": "int min = Integer . MAX_VALUE ;", "nl": "Initialize variable to find the minimum element"}
{"code": "for ( int i : increasing ) { if ( min > i ) min = i ; }", "nl": "Find minimum element in increasing [ ] array"}
{"code": "int max = Integer . MIN_VALUE ;", "nl": "Initialize variable to find the maximum element"}
{"code": "for ( int i : decreasing ) { if ( max < i ) max = i ; }", "nl": "Find maximum element in decreasing [ ] array"}
{"code": "int minSteps = Math . max ( max , N - min ) ;", "nl": "Find the minimum steps"}
{"code": "System . out . println ( minSteps ) ; }", "nl": "Print the minimum steps"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 7 ;", "nl": "Given N"}
{"code": "int increasing [ ] = { 3 , 5 } ; int decreasing [ ] = { 6 } ;", "nl": "Given increasing and decreasing array"}
{"code": "minSteps ( N , increasing , decreasing ) ; } }", "nl": "Function call"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void solve ( int P [ ] , int n ) {", "nl": "Function to find the minimum number of swaps"}
{"code": "int arr [ ] = new int [ n + 1 ] ; arr [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i + 1 ] = P [ i ] ;", "nl": "New array to convert to 1 - based indexing"}
{"code": "int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) {", "nl": "Keeps count of swaps"}
{"code": "if ( arr [ i ] == i ) { int t = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ i ] ; arr [ i ] = t ; cnt ++ ; } }", "nl": "Check if it is an ' X ' position"}
{"code": "if ( arr [ n ] == n ) {", "nl": "Corner Case"}
{"code": "int t = arr [ n - 1 ] ; arr [ n - 1 ] = arr [ n ] ; arr [ n ] = t ; cnt ++ ; }", "nl": "Swap"}
{"code": "System . out . println ( cnt ) ; }", "nl": "Print the minimum swaps"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int N = 9 ;", "nl": "Given Number N"}
{"code": "int P [ ] = new int [ ] { 1 , 2 , 4 , 9 , 5 , 8 , 7 , 3 , 6 } ;", "nl": "Given Permutation of N numbers"}
{"code": "solve ( P , N ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find the number of interesting primes up to N ."}
{"code": "static void SieveOfEratosthenes ( int n , HashSet < Integer > allPrimes ) {", "nl": "Function to find all prime numbers"}
{"code": "boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) {", "nl": "Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries as true . A value in prime [ i ] will finally be false if i is Not a prime ."}
{"code": "if ( prime [ p ] == true ) {", "nl": "If prime [ p ] is not changed , then it is a prime"}
{"code": "for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } }", "nl": "Update all multiples of p greater than or equal to the square of it"}
{"code": "for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . add ( p ) ; }", "nl": "Store all prime numbers"}
{"code": "static int countInterestingPrimes ( int n ) {", "nl": "Function to check if a number is perfect square or not"}
{"code": "HashSet < Integer > allPrimes = new HashSet < Integer > ( ) ; SieveOfEratosthenes ( n , allPrimes ) ;", "nl": "To store all primes"}
{"code": "HashSet < Integer > intersetingPrimes = new HashSet < Integer > ( ) ; Vector < Integer > squares = new Vector < Integer > ( ) , quadruples = new Vector < Integer > ( ) ;", "nl": "To store all interseting primes"}
{"code": "for ( int i = 1 ; i * i <= n ; i ++ ) { squares . add ( i * i ) ; }", "nl": "Store all perfect squares"}
{"code": "for ( int i = 1 ; i * i * i * i <= n ; i ++ ) { quadruples . add ( i * i * i * i ) ; }", "nl": "Store all perfect quadruples"}
{"code": "for ( int a : squares ) { for ( int b : quadruples ) { if ( allPrimes . contains ( a + b ) ) intersetingPrimes . add ( a + b ) ; } }", "nl": "Store all interseting primes"}
{"code": "return intersetingPrimes . size ( ) ; }", "nl": "Return count of interseting primes"}
{"code": "public static void main ( String [ ] args ) { int N = 10 ; System . out . print ( countInterestingPrimes ( N ) ) ; } }", "nl": "Driver code"}
{"code": "public class GFG {", "nl": "Java code to check if the array is wave array"}
{"code": "static boolean isWaveArray ( int arr [ ] , int n ) { boolean result = true ;", "nl": "Function to check if array is wave array arr : input array n : size of array"}
{"code": "if ( arr [ 1 ] > arr [ 0 ] && arr [ 1 ] > arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } }", "nl": "Check the wave form * If arr [ 1 ] is greater than left and right * Same pattern will be followed by whole * elements , else reverse pattern * will be followed by array elements"}
{"code": "if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] <= arr [ n - 2 ] ) { result = false ; } } } else if ( arr [ 1 ] < arr [ 0 ] && arr [ 1 ] < arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } }", "nl": "Check for last element"}
{"code": "if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] >= arr [ n - 2 ] ) { result = false ; } } } return result ; }", "nl": "Check for last element"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver code"}
{"code": "int arr [ ] = { 1 , 3 , 2 , 4 } ; int n = arr . length ; if ( isWaveArray ( arr , n ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }", "nl": "Array"}
{"code": "import java . io . * ; class GFG {", "nl": "Java Program for the above approach"}
{"code": "static void countPossiblities ( int arr [ ] , int n ) {", "nl": "Function to count number of sequences satisfying the given criteria"}
{"code": "int [ ] lastOccur = new int [ 100000 ] ; for ( int i = 0 ; i < n ; i ++ ) { lastOccur [ i ] = - 1 ; }", "nl": "Stores the index of the last occurrence of the element"}
{"code": "int [ ] dp = new int [ n + 1 ] ;", "nl": "Initialize an array to store the number of different sequences that are possible of length i"}
{"code": "dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int curEle = arr [ i - 1 ] ;", "nl": "Base Case"}
{"code": "dp [ i ] = dp [ i - 1 ] ;", "nl": "If no operation is applied on ith element"}
{"code": "if ( lastOccur [ curEle ] != - 1 & lastOccur [ curEle ] < i - 1 ) { dp [ i ] += dp [ lastOccur [ curEle ] ] ; }", "nl": "If operation is applied on ith element"}
{"code": "lastOccur [ curEle ] = i ; }", "nl": "Update the last occurrence of curEle"}
{"code": "System . out . println ( dp [ n ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 1 , 2 , 2 } ; int N = arr . length ; countPossiblities ( arr , N ) ; } }", "nl": "Finally , print the answer"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void maxSum ( int [ ] [ ] arr , int n , int m ) {", "nl": "Function to print the maximum sum"}
{"code": "int [ ] [ ] dp = new int [ n ] [ m + 1 ] ;", "nl": "Dp table"}
{"code": "for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; } }", "nl": "Initializing dp array with 0 s"}
{"code": "dp [ 0 ] [ m - 1 ] = arr [ 0 ] [ m - 1 ] ; dp [ 1 ] [ m - 1 ] = arr [ 1 ] [ m - 1 ] ;", "nl": "Base case"}
{"code": "for ( int j = m - 2 ; j >= 0 ; j -- ) {", "nl": "Traverse each column"}
{"code": "for ( int i = 0 ; i < 2 ; i ++ ) { if ( i == 1 ) { dp [ i ] [ j ] = Math . max ( arr [ i ] [ j ] + dp [ 0 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 0 ] [ j + 2 ] ) ; } else { dp [ i ] [ j ] = Math . max ( arr [ i ] [ j ] + dp [ 1 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 1 ] [ j + 2 ] ) ; } } }", "nl": "Update answer for both rows"}
{"code": "System . out . println ( Math . max ( dp [ 0 ] [ 0 ] , dp [ 1 ] [ 0 ] ) ) ; }", "nl": "Print the maximum sum"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int [ ] [ ] arr = { { 1 , 50 , 21 , 5 } , { 2 , 10 , 10 , 5 } } ;", "nl": "Given array"}
{"code": "int N = arr [ 0 ] . length ;", "nl": "Number of Columns"}
{"code": "maxSum ( arr , 2 , N ) ; } }", "nl": "Function calls"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java code for the above approach"}
{"code": "static void maxSum ( int [ ] [ ] arr , int n ) {", "nl": "Function to print the maximum sum possible by selecting at most one element from each column such that no consecutive pairs are selected from a single row"}
{"code": "int r1 = 0 , r2 = 0 ;", "nl": "Initialize variables"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { int temp = r1 ; r1 = Math . max ( r1 , r2 + arr [ 0 ] [ i ] ) ; r2 = Math . max ( r2 , temp + arr [ 1 ] [ i ] ) ; }", "nl": "Traverse each column"}
{"code": "System . out . println ( Math . max ( r1 , r2 ) ) ; }", "nl": "Print answer"}
{"code": "public static void main ( String args [ ] ) { int [ ] [ ] arr = { { 1 , 50 , 21 , 5 } , { 2 , 10 , 10 , 5 } } ;", "nl": "Driver Code"}
{"code": "int n = arr [ 0 ] . length ; maxSum ( arr , n ) ; } }", "nl": "Numberof columns"}
{"code": "class GFG { static int mod = ( int ) ( 1e9 + 7 ) ; static int mx = ( int ) 1e6 ; static int [ ] fact = new int [ ( int ) mx + 1 ] ;", "nl": "Java program for the above approach"}
{"code": "static void Calculate_factorial ( ) { fact [ 0 ] = 1 ;", "nl": "Function to calculate the factorials up to a number"}
{"code": "for ( int i = 1 ; i <= mx ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; fact [ i ] %= mod ; } }", "nl": "Calculate the factorial"}
{"code": "static int UniModal_per ( int a , int b ) { int res = 1 ;", "nl": "Function to find power ( a , b )"}
{"code": "while ( b > 0 ) {", "nl": "Iterate until b exists"}
{"code": "if ( b % 2 != 0 ) res = res * a ; res %= mod ; a = a * a ; a %= mod ;", "nl": "If b is divisible by 2"}
{"code": "b /= 2 ; }", "nl": "Decrease the value of b"}
{"code": "return res ; }", "nl": "Return the answer"}
{"code": "static void countPermutations ( int n ) {", "nl": "Function that counts the unimodal and non - unimodal permutations of a given integer N"}
{"code": "Calculate_factorial ( ) ;", "nl": "Function Call for finding factorials up to N"}
{"code": "int uni_modal = UniModal_per ( 2 , n - 1 ) ;", "nl": "Function to count unimodal permutations"}
{"code": "int nonuni_modal = fact [ n ] - uni_modal ; System . out . print ( uni_modal + \" \u2581 \" + nonuni_modal ) ; return ; }", "nl": "Non - unimodal permutation is N ! - unimodal permutations"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 4 ;", "nl": "Given Number N"}
{"code": "countPermutations ( N ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; class GFG { static void longestSubseq ( String s , int length ) {", "nl": "Java program to find the longest subsequence possible that starts and ends with 1 and filled with 0 in the middle"}
{"code": "int [ ] ones = new int [ length + 1 ] ; int [ ] zeroes = new int [ length + 1 ] ;", "nl": "Prefix array to store the occurences of '1' and '0'"}
{"code": "for ( int i = 0 ; i < length ; i ++ ) {", "nl": "Iterate over the length of the string"}
{"code": "if ( s . charAt ( i ) == '1' ) { ones [ i + 1 ] = ones [ i ] + 1 ; zeroes [ i + 1 ] = zeroes [ i ] ; }", "nl": "If current character is '1'"}
{"code": "else { zeroes [ i + 1 ] = zeroes [ i ] + 1 ; ones [ i + 1 ] = ones [ i ] ; } } int answer = Integer . MIN_VALUE ; int x = 0 ; for ( int i = 0 ; i <= length ; i ++ ) { for ( int j = i ; j <= length ; j ++ ) {", "nl": "If current character is '0'"}
{"code": "x += ones [ i ] ;", "nl": "Add '1' available for the first string"}
{"code": "x += ( zeroes [ j ] - zeroes [ i ] ) ;", "nl": "Add '0' available for the second string"}
{"code": "x += ( ones [ length ] - ones [ j ] ) ;", "nl": "Add '1' available for the third string"}
{"code": "answer = Math . max ( answer , x ) ; x = 0 ; } }", "nl": "Update answer"}
{"code": "System . out . println ( answer ) ; }", "nl": "Print the final result"}
{"code": "public static void main ( String [ ] args ) { String s = \"10010010111100101\" ; int length = s . length ( ) ; longestSubseq ( s , length ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int MAX = 100 ;", "nl": "Java implementation to find the largest square in the matrix such that it contains atmost K 1 's"}
{"code": "static void largestSquare ( int matrix [ ] [ ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) {", "nl": "Function to calculate the largest square with atmost K 1 s for Q queries"}
{"code": "for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int count = 0 ;", "nl": "Loop to solve for each query"}
{"code": "for ( int row = i - k ; row <= i + k ; row ++ ) for ( int col = j - k ; col <= j + k ; col ++ ) count += matrix [ row ] [ col ] ;", "nl": "Traversing the each sub square and counting total"}
{"code": "if ( count > K ) break ; ans = 2 * k + 1 ; } System . out . print ( ans + \"NEW_LINE\"); } }", "nl": "Breaks when exceeds the maximum count"}
{"code": "public static void main ( String [ ] args ) { int matrix [ ] [ ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static int MAX = 100 ;", "nl": "Java implementation to find the largest square in the matrix such that it contains atmost K 1 's"}
{"code": "static void largestSquare ( int matrix [ ] [ ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int [ ] [ ] countDP = new int [ R ] [ C ] ;", "nl": "Function to find the largest square in the matrix such that it contains atmost K 1 's"}
{"code": "countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ;", "nl": "Precomputing the countDP prefix sum of the matrix"}
{"code": "for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ;", "nl": "Loop to solve Queries"}
{"code": "int min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int x1 = i - k , x2 = i + k ; int y1 = j - k , y2 = j + k ;", "nl": "Calculating the maximum possible distance of the centre from edge"}
{"code": "int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } System . out . print ( ans + \"NEW_LINE\"); } }", "nl": "Calculating the number of 1 s in the submatrix"}
{"code": "public static void main ( String [ ] args ) { int matrix [ ] [ ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int MinCost ( int arr [ ] , int n ) {", "nl": "Function to return the minimum cost to connect the given ropes"}
{"code": "int [ ] [ ] dp = new int [ n + 5 ] [ n + 5 ] ; int [ ] [ ] sum = new int [ n + 5 ] [ n + 5 ] ;", "nl": "dp [ i ] [ j ] = minimum cost in range ( i , j ) sum [ i ] [ j ] = sum of range ( i , j )"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { int k = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { if ( i == j ) sum [ i ] [ j ] = k ; else { k += arr [ j ] ; sum [ i ] [ j ] = k ; } } }", "nl": "Initializing the sum table memset ( sum , 0 , sizeof ( 0 ) ) ;"}
{"code": "for ( int i = n - 1 ; i >= 0 ; i -- ) {", "nl": "Computing minimum cost for all the possible interval ( i , j ) Left range"}
{"code": "for ( int j = i ; j < n ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ;", "nl": "Right range"}
{"code": "if ( i == j ) dp [ i ] [ j ] = 0 ; else { for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum [ i ] [ j ] ) ; } } } } return dp [ 0 ] [ n - 1 ] ; }", "nl": "No cost for a single rope"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 7 , 6 , 8 , 6 , 1 , 1 } ; int n = arr . length ; System . out . println ( MinCost ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int f ( int i , int state , int A [ ] , int dp [ ] [ ] , int N ) { if ( i >= N ) return 0 ;", "nl": "Function to recursively fill the dp array"}
{"code": "else if ( dp [ i ] [ state ] != - 1 ) { return dp [ i ] [ state ] ; }", "nl": "If f ( i , state ) is already calculated then return the value"}
{"code": "else { if ( i == N - 1 ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] > A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 2 && A [ i ] < A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] <= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 2 , A , dp , N ) ; else if ( state == 2 && A [ i ] >= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 1 , A , dp , N ) ; return dp [ i ] [ state ] ; } }", "nl": "Calculate f ( i , state ) according to the recurrence relation and store in dp [ ] [ ]"}
{"code": "static int maxLenSeq ( int A [ ] , int N ) { int i , j , tmp , y , ans ;", "nl": "Function that calls the resucrsive function to fill the dp array and then returns the result"}
{"code": "int dp [ ] [ ] = new int [ 1000 ] [ 3 ] ;", "nl": "dp [ ] [ ] array for storing result of f ( i , 1 ) and f ( 1 , 2 )"}
{"code": "for ( i = 0 ; i < 1000 ; i ++ ) for ( j = 0 ; j < 3 ; j ++ ) dp [ i ] [ j ] = - 1 ;", "nl": "Populating the array dp [ ] with - 1"}
{"code": "for ( i = 0 ; i < N ; i ++ ) { tmp = f ( i , 1 , A , dp , N ) ; tmp = f ( i , 2 , A , dp , N ) ; }", "nl": "Make sure that longest UD and DU sequence starting at each index is calculated"}
{"code": "ans = - 1 ; for ( i = 0 ; i < N ; i ++ ) {", "nl": "Assume the answer to be - 1 This value will only increase"}
{"code": "y = dp [ i ] [ 1 ] ; if ( i + y >= N ) ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 ) ;", "nl": "y is the length of the longest UD sequence starting at i"}
{"code": "else if ( y % 2 == 0 ) { ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 2 ] ) ; }", "nl": "If length is even then add an integer and then a DU sequence starting at i + y"}
{"code": "else if ( y % 2 == 1 ) { ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 1 ] ) ; } } return ans ; }", "nl": "If length is odd then add an integer and then a UD sequence starting at i + y"}
{"code": "public static void main ( String [ ] args ) { int A [ ] = { 1 , 10 , 3 , 20 , 25 , 24 } ; int n = A . length ; System . out . println ( maxLenSeq ( A , n ) ) ; } }", "nl": "Driver code"}
{"code": "class Test {", "nl": "Java implementation of the above approach"}
{"code": "static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }", "nl": "Recursive function to return gcd of a and b"}
{"code": "static int MaxGCD ( int a [ ] , int n ) {", "nl": "Function to return the maximized gcd after removing a single element from the given array"}
{"code": "int Prefix [ ] = new int [ n + 2 ] ; int Suffix [ ] = new int [ n + 2 ] ;", "nl": "Prefix and Suffix arrays"}
{"code": "Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; }", "nl": "Single state dynamic programming relation for storing gcd of first i elements from the left in Prefix [ i ]"}
{"code": "Suffix [ n ] = a [ n - 1 ] ;", "nl": "Initializing Suffix array"}
{"code": "for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; }", "nl": "Single state dynamic programming relation for storing gcd of all the elements having greater than or equal to i in Suffix [ i ]"}
{"code": "int ans = Math . max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ;", "nl": "If first or last element of the array has to be removed"}
{"code": "for ( int i = 2 ; i < n ; i += 1 ) { ans = Math . max ( ans , gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; }", "nl": "If any other element is replaced"}
{"code": "return ans ; }", "nl": "Return the maximized gcd"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 14 , 17 , 28 , 70 } ; int n = a . length ; System . out . println ( MaxGCD ( a , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Arrays ; class GFG { static int right = 2 ; static int left = 4 ; static int [ ] [ ] dp = new int [ left ] [ right ] ;", "nl": "Java implementation of the approach"}
{"code": "static int findSubarraySum ( int ind , int flips , int n , int [ ] a , int k ) {", "nl": "Function to find the maximum subarray sum with flips starting from index i"}
{"code": "if ( flips > k ) return ( int ) ( - 1e9 ) ;", "nl": "If the number of flips have exceeded"}
{"code": "if ( ind == n ) return 0 ;", "nl": "Complete traversal"}
{"code": "if ( dp [ ind ] [ flips ] != - 1 ) return dp [ ind ] [ flips ] ;", "nl": "If the state has previously been visited"}
{"code": "int ans = 0 ;", "nl": "Initially"}
{"code": "ans = Math . max ( 0 , a [ ind ] + findSubarraySum ( ind + 1 , flips , n , a , k ) ) ; ans = Math . max ( ans , - a [ ind ] + findSubarraySum ( ind + 1 , flips + 1 , n , a , k ) ) ;", "nl": "Use Kadane 's algorithm and call two states"}
{"code": "return dp [ ind ] [ flips ] = ans ; }", "nl": "Memoize the answer and return it"}
{"code": "static int findMaxSubarraySum ( int [ ] a , int n , int k ) {", "nl": "Utility function to call flips from index and return the answer"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < k + 1 ; j ++ ) dp [ i ] [ j ] = - 1 ; int ans = ( int ) ( - 1e9 ) ;", "nl": "Create DP array int dp [ n , k + 1 ] ;"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , findSubarraySum ( i , 0 , n , a , k ) ) ;", "nl": "Iterate and call recursive function from every index to get the maximum subarray sum"}
{"code": "if ( ans == 0 && k == 0 ) return Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; return ans ; }", "nl": "corner case"}
{"code": "public static void main ( String [ ] args ) { int [ ] a = { - 1 , - 2 , - 100 , - 10 } ; int n = a . length ; int k = 1 ; System . out . println ( findMaxSubarraySum ( a , n , k ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG { static int mod = 1000000007 ;", "nl": "Java program to Find the sum of first N odd Fibonacci numbers"}
{"code": "static int sumOddFibonacci ( int n ) { int Sum [ ] = new int [ n + 1 ] ;", "nl": "Function to calculate sum of first N odd Fibonacci numbers"}
{"code": "Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( int i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; }", "nl": "base values"}
{"code": "public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( sumOddFibonacci ( n ) ) ; }", "nl": "Driver code"}
{"code": "public class GFG { static long fun ( int marks [ ] , int n ) {", "nl": "Java implementation of the above approach"}
{"code": "long dp [ ] = new long [ n ] ; int temp ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) {", "nl": "Initializing one tablet for each student"}
{"code": "if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } }", "nl": "if left adjacent is having higher marks review and change all the dp values assigned before until assigned dp values are found wrong according to given constrains"}
{"code": "else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; }", "nl": "if right adjacent is having higher marks add one in dp of left adjacent and assign to right one"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "int n = 6 ;", "nl": "n number of students"}
{"code": "int marks [ ] = { 1 , 4 , 5 , 2 , 2 , 1 } ;", "nl": "marks of students"}
{"code": "System . out . println ( fun ( marks , n ) ) ; } }", "nl": "solution of problem"}
{"code": "class GFG { static int solve ( int N , int K ) {", "nl": "Java program to reach N - th stair by taking a maximum of K leap"}
{"code": "int [ ] combo ; combo = new int [ 50 ] ;", "nl": "elements of combo [ ] stores the no . of possible ways to reach it by all combinations of k leaps or less"}
{"code": "combo [ 0 ] = 1 ;", "nl": "assuming leap 0 exist and assigning its value to 1 for calculation"}
{"code": "for ( int i = 1 ; i <= K ; i ++ ) {", "nl": "loop to iterate over all possible leaps upto k ;"}
{"code": "for ( int j = 0 ; j <= N ; j ++ ) {", "nl": "in this loop we count all possible leaps to reach the jth stair with the help of ith leap or less"}
{"code": "if ( j >= i ) {", "nl": "if the leap is not more than the i - j"}
{"code": "combo [ j ] += combo [ j - i ] ; } } }", "nl": "calculate the value and store in combo [ j ] to reuse it for next leap calculation for the jth stair"}
{"code": "return combo [ N ] ; }", "nl": "returns the no of possible number of leaps to reach the top of building of n stairs"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "int N = 29 ; int K = 5 ; System . out . println ( solve ( N , K ) ) ; solve ( N , K ) ; } }", "nl": "N i the no of total stairs K is the value of the greatest leap"}
{"code": "class Test {", "nl": "Java implementation to find LIS in circular way"}
{"code": "static int computeLIS ( int circBuff [ ] , int start , int end , int n ) { int LIS [ ] = new int [ n + end - start ] ;", "nl": "Utility method to find LIS using Dynamic programming"}
{"code": "for ( int i = start ; i < end ; i ++ ) LIS [ i ] = 1 ;", "nl": "Initialize LIS values for all indexes"}
{"code": "for ( int i = start + 1 ; i < end ; i ++ )", "nl": "Compute optimized LIS values in bottom up manner"}
{"code": "for ( int j = start ; j < i ; j ++ ) if ( circBuff [ i ] > circBuff [ j ] && LIS [ i ] < LIS [ j ] + 1 ) LIS [ i ] = LIS [ j ] + 1 ;", "nl": "Set j on the basis of current window i . e . first element of the current window"}
{"code": "int res = Integer . MIN_VALUE ; for ( int i = start ; i < end ; i ++ ) res = Math . max ( res , LIS [ i ] ) ; return res ; }", "nl": "Pick maximum of all LIS values"}
{"code": "static int LICS ( int arr [ ] , int n ) {", "nl": "Function to find Longest Increasing subsequence in Circular manner"}
{"code": "int circBuff [ ] = new int [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) circBuff [ i ] = arr [ i ] ; for ( int i = n ; i < 2 * n ; i ++ ) circBuff [ i ] = arr [ i - n ] ;", "nl": "Make a copy of given array by appending same array elements to itself"}
{"code": "int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) res = Math . max ( computeLIS ( circBuff , i , i + n , n ) , res ) ; return res ; }", "nl": "Perform LIS for each window of size n"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 1 , 4 , 6 , 2 , 3 } ; System . out . println ( \" Length \u2581 of \u2581 LICS \u2581 is \u2581 \" + LICS ( arr , arr . length ) ) ; } }", "nl": "Driver method"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java Program for above approach"}
{"code": "static int min ( int a , int b ) { return a < b ? a : b ; }", "nl": "utility min"}
{"code": "static int binomialCoeff ( int n , int k ) { int C [ ] = new int [ k + 1 ] ; C [ 0 ] = 1 ;", "nl": "Function for binomial Coefficient"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }", "nl": "Constructing Pascal 's Triangle"}
{"code": "public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( \" Number \u2581 of \u2581 Paths : \u2581 \" + binomialCoeff ( n + m , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "A Java Program to find length of the Longest Common Increasing Subsequence ( LCIS )"}
{"code": "static int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) {", "nl": "Returns the length and the LCIS of two arrays arr1 [ 0. . n - 1 ] and arr2 [ 0. . m - 1 ]"}
{"code": "int table [ ] = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ;", "nl": "table [ j ] is going to store length of LCIS ending with arr2 [ j ] . We initialize it as 0 ,"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse all elements of arr1 [ ]"}
{"code": "int current = 0 ;", "nl": "Initialize current length of LCIS"}
{"code": "for ( int j = 0 ; j < m ; j ++ ) {", "nl": "For each element of arr1 [ ] , trvarse all elements of arr2 [ ] ."}
{"code": "if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ;", "nl": "If both the array have same elements . Note that we don 't  break the loop here."}
{"code": "if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } }", "nl": "Now seek for previous smaller common element for current element of arr1"}
{"code": "int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }", "nl": "The maximum value in table [ ] is out result"}
{"code": "public static void main ( String [ ] args ) { int arr1 [ ] = { 3 , 4 , 9 , 1 } ; int arr2 [ ] = { 5 , 3 , 8 , 9 , 10 , 2 , 1 } ; int n = arr1 . length ; int m = arr2 . length ; System . out . println ( \" Length \u2581 of \u2581 LCIS \u2581 is \u2581 \" + LCIS ( arr1 , n , arr2 , m ) ) ; } }", "nl": "Driver program to test above function"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int longComPre ( String arr [ ] , int N ) {", "nl": "Function to get the length of the longest common prefix by rearranging the Strings"}
{"code": "int [ ] [ ] freq = new int [ N ] [ 256 ] ;", "nl": "freq [ i ] [ j ] : stores the frequency of a character ( = j ) in a String arr [ i ]"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the given array"}
{"code": "int M = arr [ i ] . length ( ) ;", "nl": "Stores length of current String"}
{"code": "for ( int j = 0 ; j < M ; j ++ ) {", "nl": "Traverse current String of the given array"}
{"code": "freq [ i ] [ arr [ i ] . charAt ( j ) ] ++ ; } }", "nl": "Update the value of freq [ i ] [ arr [ i ] [ j ] ]"}
{"code": "int maxLen = 0 ;", "nl": "Stores the length of longest common prefix"}
{"code": "for ( int j = 0 ; j < 256 ; j ++ ) {", "nl": "Count the minimum frequency of each character in in all the Strings of arr [ ]"}
{"code": "int minRowVal = Integer . MAX_VALUE ;", "nl": "Stores minimum value in each row of freq [ ] [ ]"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Calculate minimum frequency of current character in all the Strings ."}
{"code": "minRowVal = Math . min ( minRowVal , freq [ i ] [ j ] ) ; }", "nl": "Update minRowVal"}
{"code": "maxLen += minRowVal ; } return maxLen ; }", "nl": "Update maxLen"}
{"code": "public static void main ( String [ ] args ) { String arr [ ] = { \" aabdc \" , \" abcd \" , \" aacd \" } ; int N = 3 ; System . out . print ( longComPre ( arr , N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static int MAX_CHAR = 26 ;", "nl": "Java program to remove characters from a String that appears exactly K times"}
{"code": "static String removeChars ( char arr [ ] , int k ) {", "nl": "Function to reduce the String by removing the characters which appears exactly k times"}
{"code": "int [ ] hash = new int [ MAX_CHAR ] ;", "nl": "Hash table initialised to 0"}
{"code": "int n = arr . length ; for ( int i = 0 ; i < n ; ++ i ) hash [ arr [ i ] - ' a ' ] ++ ;", "nl": "Increment the frequency of the character"}
{"code": "String ans = \" \" ;", "nl": "To store answer"}
{"code": "for ( int i = 0 ; i < n ; ++ i ) {", "nl": "Next index in reduced string"}
{"code": "if ( hash [ arr [ i ] - ' a ' ] != k ) { ans += arr [ i ] ; } } return ans ; }", "nl": "Append the characters which appears exactly k times"}
{"code": "public static void main ( String [ ] args ) { char str [ ] = \" geeksforgeeks \" . toCharArray ( ) ; int k = 2 ;", "nl": "Driver code"}
{"code": "System . out . print ( removeChars ( str , k ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void sub_segments ( String str , int n ) { int l = str . length ( ) ; for ( int x = 0 ; x < l ; x += n ) { String newlist = str . substring ( x , x + n ) ;", "nl": "Function that prints the segments"}
{"code": "List < Character > arr = new ArrayList < Character > ( ) ; for ( char y : newlist . toCharArray ( ) ) {", "nl": "New array for every iteration"}
{"code": "if ( ! arr . contains ( y ) ) arr . add ( y ) ; } for ( char y : arr ) System . out . print ( y ) ; System . out . println ( ) ; } }", "nl": "Check if the character is in the array"}
{"code": "public static void main ( String [ ] args ) { String str = \" geeksforgeeksgfg \" ; int n = 4 ; sub_segments ( str , n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; import java . io . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "public static void findWord ( String c , int n ) { int co = 0 , i ;", "nl": "Static function declared to find the encrypted string"}
{"code": "char s [ ] = new char [ n ] ; for ( i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) co ++ ; else co = n - i ;", "nl": "Character array to store the encrypted string"}
{"code": "if ( ( c . charAt ( i ) + co ) <= 122 ) s [ i ] = ( char ) ( ( int ) c . charAt ( i ) + co ) ; else s [ i ] = ( char ) ( ( int ) c . charAt ( i ) + co - 26 ) ; }", "nl": "after ' z ' , it should go to a ."}
{"code": "String str = Arrays . toString ( s ) ; System . out . println ( str ) ; }", "nl": "storing the character array in the string ."}
{"code": "public static void main ( String args [ ] ) { String s = \" abcd \" ; findWord ( s , s . length ( ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static boolean equalIgnoreCase ( String str1 , String str2 ) { int i = 0 ;", "nl": "Function to compare two strings ignoring their cases"}
{"code": "int len1 = str1 . length ( ) ;", "nl": "length of first string"}
{"code": "int len2 = str2 . length ( ) ;", "nl": "length of second string"}
{"code": "if ( len1 != len2 ) return false ;", "nl": "if length is not same simply return false since both string can not be same if length is not equal"}
{"code": "while ( i < len1 ) {", "nl": "loop to match one by one all characters of both string"}
{"code": "if ( str1 . charAt ( i ) == str2 . charAt ( i ) ) { i ++ ; }", "nl": "if current characters of both string are same , increase value of i to compare next character"}
{"code": "else if ( ! ( ( str1 . charAt ( i ) >= ' a ' && str1 . charAt ( i ) <= ' z ' ) || ( str1 . charAt ( i ) >= ' A ' && str1 . charAt ( i ) <= ' Z ' ) ) ) { return false ; }", "nl": "if any character of first string is some special character or numeric character and not same as corresponding character of second string then return false"}
{"code": "else if ( ! ( ( str2 . charAt ( i ) >= ' a ' && str2 . charAt ( i ) <= ' z ' ) || ( str2 . charAt ( i ) >= ' A ' && str2 . charAt ( i ) <= ' Z ' ) ) ) { return false ; }", "nl": "do the same for second string"}
{"code": "else {", "nl": "this block of code will be executed if characters of both strings are of different cases"}
{"code": "if ( str1 . charAt ( i ) >= ' a ' && str1 . charAt ( i ) <= ' z ' ) { if ( str1 . charAt ( i ) - 32 != str2 . charAt ( i ) ) return false ; } else if ( str1 . charAt ( i ) >= ' A ' && str1 . charAt ( i ) <= ' Z ' ) { if ( str1 . charAt ( i ) + 32 != str2 . charAt ( i ) ) return false ; }", "nl": "compare characters by ASCII value"}
{"code": "i ++ ;", "nl": "if characters matched , increase the value of i to compare next char"}
{"code": "return true ;", "nl": "if all characters of the first string are matched with corresponding characters of the second string , then return true"}
{"code": "static void equalIgnoreCaseUtil ( String str1 , String str2 ) { boolean res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) System . out . println ( \" Same \" ) ; else System . out . println ( \" Not \u2581 Same \" ) ; }", "nl": "Function to print the same or not same if strings are equal or not equal"}
{"code": "public static void main ( String args [ ] ) { String str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static String maxValue ( char [ ] a , char [ ] b ) {", "nl": "Function to return the maximized value of A"}
{"code": "Arrays . sort ( b ) ; int n = a . length ; int m = b . length ;", "nl": "Sort digits in ascending order"}
{"code": "int j = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "j points to largest digit in B"}
{"code": "if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ;", "nl": "If all the digits of b have been used"}
{"code": "j -- ; } }", "nl": "Current digit has been used"}
{"code": "return String . valueOf ( a ) ; }", "nl": "Return the maximized value"}
{"code": "public static void main ( String [ ] args ) { String a = \"1234\" ; String b = \"4321\" ; System . out . print ( maxValue ( a . toCharArray ( ) , b . toCharArray ( ) ) ) ; } }", "nl": "Driver code"}
{"code": "class GfG {", "nl": "Java program for above approach"}
{"code": "static boolean checkIfUnequal ( int n , int q ) {", "nl": "Function to check if all of the digits in a number and it 's product with q  are unequal or not"}
{"code": "String s1 = Integer . toString ( n ) ; int a [ ] = new int [ 26 ] ;", "nl": "convert first number into string"}
{"code": "for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) a [ s1 . charAt ( i ) - '0' ] ++ ;", "nl": "Insert elements from 1 st number to hash"}
{"code": "int prod = n * q ;", "nl": "Calculate corresponding product"}
{"code": "String s2 = Integer . toString ( prod ) ;", "nl": "Convert the product to string"}
{"code": "for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) {", "nl": "Using the hash check if any digit of product matches with the digits of input number"}
{"code": "if ( a [ s2 . charAt ( i ) - '0' ] > 0 ) return false ; }", "nl": "If yes , return false"}
{"code": "return true ; }", "nl": "else , return true"}
{"code": "static int countInRange ( int l , int r , int q ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) {", "nl": "Function to count numbers in the range [ l , r ] such that all of the digits of the number and it 's product with q are unequal"}
{"code": "if ( checkIfUnequal ( i , q ) ) count ++ ; } return count ; }", "nl": "check for every number between l and r"}
{"code": "public static void main ( String [ ] args ) { int l = 10 , r = 12 , q = 2 ;", "nl": "Driver Code"}
{"code": "System . out . println ( countInRange ( l , r , q ) ) ; } }", "nl": "Function Call"}
{"code": "import java . lang . Math ; public class GfG {", "nl": "Java program to check if we can rearrange a string such that it has alternate 0 s and 1 s ."}
{"code": "public static boolean is_possible ( String s ) {", "nl": "function to check the binary string"}
{"code": "int l = s . length ( ) ; int one = 0 , zero = 0 ; for ( int i = 0 ; i < l ; i ++ ) {", "nl": "length of string"}
{"code": "if ( s . charAt ( i ) == '0' ) zero ++ ;", "nl": "count zero 's"}
{"code": "else one ++ ; }", "nl": "count one 's"}
{"code": "if ( l % 2 == 0 ) return ( one == zero ) ;", "nl": "if length is even"}
{"code": "else return ( Math . abs ( one - zero ) == 1 ) ; } public static void main ( String [ ] args ) { String s = \"100110\" ; if ( is_possible ( s ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "if length is odd"}
{"code": "class GFG { static int limit = 255 ; static void countFreq ( String str ) {", "nl": "Java program to count frequencies of array items"}
{"code": "int [ ] count = new int [ limit + 1 ] ;", "nl": "Create an array to store counts . The size of array is limit + 1 and all values are initially 0"}
{"code": "for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str . charAt ( i ) ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) System . out . println ( ( char ) i + \" \u2581 \" + count [ i ] ) ; }", "nl": "Traverse through string characters and count frequencies"}
{"code": "public static void main ( String [ ] args ) { String str = \" GeeksforGeeks \" ; countFreq ( str ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to count the set bits after taking XOR with a number K"}
{"code": "static int __builtin_popcount ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }", "nl": "Function to get no of set bits in binary representation of positive integer n"}
{"code": "static void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ;", "nl": "Function to store EVEN and odd variable"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Store the count of even and odd set bit"}
{"code": "int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ;", "nl": "Count the set bit using in built function"}
{"code": "y = __builtin_popcount ( K ) ;", "nl": "Count of set - bit of K"}
{"code": "if ( ( y & 1 ) != 0 ) { System . out . println ( \" Even \u2581 = \u2581 \" + odd + \" , \u2581 Odd \u2581 = \u2581 \" + even ) ; }", "nl": "If y is odd then , count of even and odd set bit will be interchanged"}
{"code": "else { System . out . println ( \" Even \u2581 = \u2581 \" + even + \" , \u2581 Odd \u2581 = \u2581 \" + odd ) ; } }", "nl": "Else it will remain same as the original array"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = arr . length ;", "nl": "Driver 's Code"}
{"code": "countEvenOdd ( arr , n , K ) ; } }", "nl": "Function call to count even and odd"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to convert given sentence to camel case ."}
{"code": "static String convert ( String s ) { int n = s . length ( ) ; String s1 = \" \" ; s1 = s1 + Character . toLowerCase ( s . charAt ( 0 ) ) ; for ( int i = 1 ; i < n ; i ++ ) {", "nl": "Function to remove spaces and convert into camel case"}
{"code": "if ( s . charAt ( i ) == ' \u2581 ' && i < n ) {", "nl": "check for spaces in the sentence"}
{"code": "s1 = s1 + \" \u2581 \" + Character . toLowerCase ( s . charAt ( i + 1 ) ) ; i ++ ; }", "nl": "conversion into upper case"}
{"code": "else s1 = s1 + Character . toUpperCase ( s . charAt ( i ) ) ; }", "nl": "If not space , copy character"}
{"code": "return s1 ; }", "nl": "return string to main"}
{"code": "public static void main ( String [ ] args ) { String str = \" I \u2581 get \u2581 intern \u2581 at \u2581 geeksforgeeks \" ; System . out . println ( convert ( str ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class Gfg {", "nl": "Java code to transform string"}
{"code": "public static String change_case ( String a ) { String temp = \" \" ; int l = a . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { char ch = a . charAt ( i ) ;", "nl": "Function to change character 's case"}
{"code": "if ( ch >= ' a ' && ch <= ' z ' ) ch = ( char ) ( 65 + ( int ) ( ch - ' a ' ) ) ;", "nl": "If character is lowercase change to uppercase"}
{"code": "else if ( ch >= ' A ' && ch <= ' Z ' ) ch = ( char ) ( 97 + ( int ) ( ch - ' A ' ) ) ; temp += ch ; } return temp ; }", "nl": "If character is uppercase change to lowercase"}
{"code": "public static String delete_vowels ( String a ) { String temp = \" \" ; int l = a . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { char ch = a . charAt ( i ) ;", "nl": "Function to delete vowels"}
{"code": "if ( ch != ' a ' && ch != ' e ' && ch != ' i ' && ch != ' o ' && ch != ' u ' && ch != ' A ' && ch != ' E ' && ch != ' O ' && ch != ' U ' && ch != ' I ' ) temp += ch ; } return temp ; }", "nl": "If character is consonant"}
{"code": "public static String insert_hash ( String a ) { String temp = \" \" ; int l = a . length ( ) ; char hash = ' # ' ; for ( int i = 0 ; i < l ; i ++ ) { char ch = a . charAt ( i ) ;", "nl": "Function to insert \" # \""}
{"code": "if ( ( ch >= ' a ' && ch <= ' z ' ) || ( ch >= ' A ' && ch <= ' Z ' ) ) temp = temp + hash + ch ; else temp = temp + ch ; } return temp ; }", "nl": "If character is not special character"}
{"code": "public static void transformString ( String a ) { String b = delete_vowels ( a ) ; String c = change_case ( b ) ; String d = insert_hash ( c ) ; System . out . println ( d ) ; }", "nl": "Function to transform string"}
{"code": "public static void main ( String args [ ] ) { String a = \" SunshinE ! ! \" ;", "nl": "Driver function"}
{"code": "transformString ( a ) ; } }", "nl": "Calling function"}
{"code": "class GFG {", "nl": "Java program for above approach"}
{"code": "static int reverse ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }", "nl": "Iterative function to reverse digits of num"}
{"code": "static int properDivSum ( int num ) {", "nl": "Function to calculate sum of all proper divisors num -- > given natural number"}
{"code": "int result = 0 ;", "nl": "Final result of summation of divisors"}
{"code": "for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) {", "nl": "find all divisors which divides ' num '"}
{"code": "if ( num % i == 0 ) {", "nl": "if ' i ' is divisor of ' num '"}
{"code": "if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } }", "nl": "if both divisors are same then add it only once else add both"}
{"code": "return ( result + 1 ) ; } static boolean isTcefrep ( int n ) { return properDivSum ( n ) == reverse ( n ) ; }", "nl": "Add 1 to the result as 1 is also a divisor"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 6 ;", "nl": "Given Number N"}
{"code": "if ( isTcefrep ( N ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }", "nl": "Function Call"}
{"code": "public class GFG { static String findNthNo ( int n ) { String res = \" \" ; while ( n >= 1 ) {", "nl": "java program to find n - th number containing only 3 and 5."}
{"code": "if ( ( n & 1 ) == 1 ) { res = res + \"3\" ; n = ( n - 1 ) / 2 ; }", "nl": "If n is odd , append 3 and move to parent"}
{"code": "else { res = res + \"5\" ; n = ( n - 2 ) / 2 ; } }", "nl": "If n is even , append 5 and move to parent"}
{"code": "StringBuilder sb = new StringBuilder ( res ) ; sb . reverse ( ) ; return new String ( sb ) ; }", "nl": "Reverse res and return ."}
{"code": "public static void main ( String args [ ] ) { int n = 5 ; System . out . print ( findNthNo ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; import java . lang . * ; class GFG {", "nl": "Java program to find n - th non - square number ."}
{"code": "static int findNthNonSquare ( int n ) {", "nl": "function to find the nth Non - Square Number"}
{"code": "double x = ( double ) n ;", "nl": "conversion from int to long double is necessary in order to preserve decimal places after square root ."}
{"code": "double ans = x + Math . floor ( 0.5 + Math . sqrt ( x ) ) ; return ( int ) ans ; }", "nl": "calculating the result"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int n = 16 ;", "nl": "initializing the term number"}
{"code": "System . out . print ( \" The \u2581 \" + n + \" th \u2581 Non - Square \u2581 number \u2581 is \u2581 \" ) ; System . out . print ( findNthNonSquare ( n ) ) ; } }", "nl": "Print the result"}
{"code": "import java . io . * ; import java . lang . * ; import java . util . * ; class GFG {", "nl": "Efficient Java program to find sum of series with alternate signed square AP sums ."}
{"code": "static int seiresSum ( int n , int [ ] a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }", "nl": "function to calculate series sum"}
{"code": "public static void main ( String args [ ] ) { int n = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; System . out . println ( seiresSum ( n , a ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find nth number that contains the digit k or divisible by k ."}
{"code": "public static boolean checkdigit ( int n , int k ) { while ( n != 0 ) {", "nl": "Function for checking if digit k is in n or not"}
{"code": "int rem = n % 10 ;", "nl": "finding remainder"}
{"code": "if ( rem == k ) return true ; n = n / 10 ; } return false ; }", "nl": "if digit found"}
{"code": "public static int findNthNumber ( int n , int k ) {", "nl": "Function for finding nth number"}
{"code": "for ( int i = k + 1 , count = 1 ; count < n ; i ++ ) {", "nl": "since k is the first which satisfy th criteria , so consider it in count making count = 1 and starting from i = k + 1"}
{"code": "if ( checkdigit ( i , k ) || ( i % k == 0 ) ) count ++ ; if ( count == n ) return i ; } return - 1 ; }", "nl": "checking that the number contain k digit or divisible by k"}
{"code": "public static void main ( String [ ] args ) { int n = 10 , k = 2 ; System . out . println ( findNthNumber ( n , k ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { public static int find_permutations ( Vector < Integer > arr ) { int cnt = 0 ; int max_ind = - 1 , min_ind = 10000000 ; int n = arr . size ( ) ; HashMap < Integer , Integer > index_of = new HashMap < > ( ) ;", "nl": "Java program to implement the above approach"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { index_of . put ( arr . get ( i ) , i + 1 ) ; } for ( int i = 1 ; i <= n ; i ++ ) {", "nl": "Save index of numbers of the array"}
{"code": "max_ind = Math . max ( max_ind , index_of . get ( i ) ) ; min_ind = Math . min ( min_ind , index_of . get ( i ) ) ; if ( max_ind - min_ind + 1 == i ) cnt ++ ; } return cnt ; }", "nl": "Update min and max index with the current index and check if it 's a valid permutation"}
{"code": "public static void main ( String [ ] args ) { Vector < Integer > nums = new Vector < Integer > ( ) ; nums . add ( 2 ) ; nums . add ( 3 ) ; nums . add ( 1 ) ; nums . add ( 5 ) ; nums . add ( 4 ) ; System . out . print ( find_permutations ( nums ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int calgcd ( int a , int b ) { if ( b == 0 ) return a ; return calgcd ( b , a % b ) ; }", "nl": "Recursive function to return gcd"}
{"code": "static int getCount ( int [ ] a , int n ) {", "nl": "Function to return the count of the required integers"}
{"code": "int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = calgcd ( gcd , a [ i ] ) ;", "nl": "To store the gcd of the array elements"}
{"code": "int cnt = 0 ; for ( int i = 1 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) {", "nl": "To store the count of factors of the found gcd"}
{"code": "if ( i * i == gcd ) cnt ++ ;", "nl": "If g is a perfect square"}
{"code": "else cnt += 2 ; } } return cnt ; }", "nl": "Factors appear in pairs"}
{"code": "public static void main ( String [ ] args ) { int [ ] a = { 4 , 16 , 1024 , 48 } ; int n = a . length ; System . out . println ( getCount ( a , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "public static int delCost ( String s , int [ ] cost ) {", "nl": "Function to find the minimum cost of removing characters to make the string unique"}
{"code": "boolean visited [ ] = new boolean [ s . length ( ) ] ;", "nl": "stores the visited character"}
{"code": "int ans = 0 ;", "nl": "stores the answer"}
{"code": "for ( int i = 0 ; i < s . length ( ) ; i ++ ) {", "nl": "traverse the string"}
{"code": "if ( visited [ i ] ) { continue ; }", "nl": "if already visited"}
{"code": "int maxDel = 0 ;", "nl": "Stores the maximum cost of removing a particular character"}
{"code": "int totalCost = 0 ;", "nl": "Store the total deletion cost of a particular character"}
{"code": "visited [ i ] = true ;", "nl": "Mark the current character visited"}
{"code": "for ( int j = i ; j < s . length ( ) ; j ++ ) {", "nl": "Traverse the indices of the string [ i , N - 1 ]"}
{"code": "if ( s . charAt ( i ) == s . charAt ( j ) ) {", "nl": "If any duplicate is found"}
{"code": "maxDel = Math . max ( maxDel , cost [ j ] ) ; totalCost += cost [ j ] ;", "nl": "Update the maximum cost and total cost"}
{"code": "visited [ j ] = true ; } }", "nl": "Mark the current character visited"}
{"code": "ans += totalCost - maxDel ; }", "nl": "Keep the character with maximum cost and delete the rest"}
{"code": "return ans ; }", "nl": "return the minimum cost"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "String s = \" AAABBB \" ;", "nl": "input string"}
{"code": "int [ ] cost = { 1 , 2 , 3 , 4 , 5 , 6 } ;", "nl": "input array"}
{"code": "System . out . println ( delCost ( s , cost ) ) ; } }", "nl": "function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void checkXOR ( int arr [ ] , int N ) {", "nl": "Function to find triplets such that replacing them with their XOR make all array elements equal"}
{"code": "if ( N % 2 == 0 ) {", "nl": "If N is even"}
{"code": "int xro = 0 ;", "nl": "Calculate xor of array elements"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array"}
{"code": "xro ^= arr [ i ] ; }", "nl": "Update xor"}
{"code": "if ( xro != 0 ) { System . out . println ( - 1 ) ; return ; }", "nl": "If xor is not equal to 0"}
{"code": "for ( int i = 0 ; i < N - 3 ; i += 2 ) { System . out . println ( i + \" \u2581 \" + ( i + 1 ) + \" \u2581 \" + ( i + 2 ) ) ; }", "nl": "Selecting the triplets such that elements of the pairs ( arr [ 0 ] , arr [ 1 ] ) , ( arr [ 2 ] , arr [ 3 ] ) . . . can be made equal"}
{"code": "for ( int i = 0 ; i < N - 3 ; i += 2 ) { System . out . println ( i + \" \u2581 \" + ( i + 1 ) + \" \u2581 \" + ( N - 1 ) ) ; } } else {", "nl": "Selecting the triplets such that all array elements can be made equal to arr [ N - 1 ]"}
{"code": "for ( int i = 0 ; i < N - 2 ; i += 2 ) { System . out . println ( i + \" \u2581 \" + ( i + 1 ) + \" \u2581 \" + ( i + 2 ) ) ; }", "nl": "Selecting the triplets such that elements of the pairs ( arr [ 0 ] , arr [ 1 ] ) , ( arr [ 2 ] , arr [ 3 ] ) . . . can be made equal"}
{"code": "for ( int i = 0 ; i < N - 2 ; i += 2 ) { System . out . println ( i + \" \u2581 \" + ( i + 1 ) + \" \u2581 \" + ( N - 1 ) ) ; } } }", "nl": "Selecting the triplets such that all array elements can be made equal to arr [ N - 1 ]"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int arr [ ] = { 4 , 2 , 1 , 7 , 2 } ;", "nl": "Given array"}
{"code": "int N = arr . length ;", "nl": "Size of array"}
{"code": "checkXOR ( arr , N ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int make_array_element_even ( int arr [ ] , int N ) {", "nl": "Function to find minimum count of operations required to make all array elements even"}
{"code": "int res = 0 ;", "nl": "Stores minimum count of replacements to make all array elements even"}
{"code": "int odd_cont_seg = 0 ;", "nl": "Stores the count of odd continuous numbers"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array"}
{"code": "if ( arr [ i ] % 2 == 1 ) {", "nl": "If arr [ i ] is an odd number"}
{"code": "odd_cont_seg ++ ; } else { if ( odd_cont_seg > 0 ) {", "nl": "Update odd_cont_seg"}
{"code": "if ( odd_cont_seg % 2 == 0 ) {", "nl": "If odd_cont_seg is even"}
{"code": "res += odd_cont_seg / 2 ; } else {", "nl": "Update res"}
{"code": "res += ( odd_cont_seg / 2 ) + 2 ; }", "nl": "Update res"}
{"code": "odd_cont_seg = 0 ; } } }", "nl": "Reset odd_cont_seg = 0"}
{"code": "if ( odd_cont_seg > 0 ) {", "nl": "If odd_cont_seg exceeds 0"}
{"code": "if ( odd_cont_seg % 2 == 0 ) {", "nl": "If odd_cont_seg is even"}
{"code": "res += odd_cont_seg / 2 ; } else {", "nl": "Update res"}
{"code": "res += odd_cont_seg / 2 + 2 ; } }", "nl": "Update res"}
{"code": "return res ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 5 , 11 , 6 } ; int N = arr . length ; System . out . print ( make_array_element_even ( arr , N ) ) ; } }", "nl": "Drivers Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static int zvalue ( int [ ] nums ) {", "nl": "Function to find K for which there are exactly K array elements greater than or equal to K"}
{"code": "int m = max_element ( nums ) ; int cnt = 0 ;", "nl": "Finding the largest array element"}
{"code": "for ( int i = 0 ; i <= m ; i ++ ) { cnt = 0 ;", "nl": "Possible values of K"}
{"code": "for ( int j = 0 ; j < nums . length ; j ++ ) {", "nl": "Traverse the array"}
{"code": "if ( nums [ j ] >= i ) cnt ++ ; }", "nl": "If current array element is greater than or equal to i"}
{"code": "if ( cnt == i ) return i ; }", "nl": "If i array elements are greater than or equal to i"}
{"code": "return - 1 ; }", "nl": "Otherwise"}
{"code": "public static int max_element ( int [ ] nums ) { int max = nums [ 0 ] ; for ( int i = 1 ; i < nums . length ; i ++ ) max = Math . max ( max , nums [ i ] ) ; return max ; }", "nl": "To find maximum Element"}
{"code": "public static void main ( String args [ ] ) { int [ ] nums = { 7 , 8 , 9 , 0 , 0 , 1 } ; System . out . println ( zvalue ( nums ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . lang . * ; import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static String [ ] lexico_smallest ( String s1 , String s2 ) {", "nl": "Function to find the lexicographically smallest anagram of string which contains another string"}
{"code": "Map < Character , Integer > M = new HashMap < > ( ) ; Set < Character > S = new TreeSet < > ( ) ;", "nl": "Initializing the map and set"}
{"code": "for ( int i = 0 ; i <= s1 . length ( ) - 1 ; ++ i ) {", "nl": "Iterating over s1"}
{"code": "if ( ! M . containsKey ( s1 . charAt ( i ) ) ) M . put ( s1 . charAt ( i ) , 1 ) ; else M . replace ( s1 . charAt ( i ) , M . get ( s1 . charAt ( i ) ) + 1 ) ;", "nl": "Storing the frequency of characters present in s1"}
{"code": "S . add ( s1 . charAt ( i ) ) ; }", "nl": "Storing the distinct characters present in s1"}
{"code": "for ( int i = 0 ; i <= s2 . length ( ) - 1 ; ++ i ) { if ( M . containsKey ( s2 . charAt ( i ) ) ) M . replace ( s2 . charAt ( i ) , M . get ( s2 . charAt ( i ) ) - 1 ) ; } char c = s2 . charAt ( 0 ) ; int index = 0 ; String res = \" \" ;", "nl": "Decreasing the frequency of characters from M that are already present in s2"}
{"code": "Iterator < Character > it = S . iterator ( ) ; while ( it . hasNext ( ) ) { char x = it . next ( ) ;", "nl": "Traversing alphabets in sorted order"}
{"code": "if ( x != c ) { for ( int i = 1 ; i <= M . get ( x ) ; ++ i ) { res += x ; } } else {", "nl": "If current character of set is not equal to current character of s2"}
{"code": "int j = 0 ; index = res . length ( ) ;", "nl": "If element is equal to current character of s2"}
{"code": "while ( s2 . charAt ( j ) == x ) { j ++ ; }", "nl": "Checking for second distinct character in s2"}
{"code": "if ( s2 . charAt ( j ) < c ) { res += s2 ; for ( int i = 1 ; i <= M . get ( x ) ; ++ i ) { res += x ; } } else { for ( int i = 1 ; i <= M . get ( x ) ; ++ i ) { res += x ; } index += M . get ( x ) ; res += s2 ; } } } String pr [ ] = { res , index + \" \" } ; return pr ; }", "nl": "s2 [ j ] will store second distinct character"}
{"code": "return pr ; }", "nl": "Return the answer"}
{"code": "static String lexico_largest ( String s1 , String s2 ) {", "nl": "Function to find the lexicographically largest anagram of string which contains another string"}
{"code": "String pr [ ] = lexico_smallest ( s1 , s2 ) ;", "nl": "Getting the lexicographically smallest anagram"}
{"code": "String d1 = \" \" ; for ( int i = Integer . valueOf ( pr [ 1 ] ) - 1 ; i >= 0 ; i -- ) { d1 += pr [ 0 ] . charAt ( i ) ; }", "nl": "d1 stores the prefix"}
{"code": "String d2 = \" \" ; for ( int i = pr [ 0 ] . length ( ) - 1 ; i >= Integer . valueOf ( pr [ 1 ] ) + s2 . length ( ) ; -- i ) { d2 += pr [ 0 ] . charAt ( i ) ; } String res = d2 + s2 + d1 ;", "nl": "d2 stores the suffix"}
{"code": "return res ; }", "nl": "Return the result"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "String s1 = \" ethgakagmenpgs \" ; String s2 = \" geeks \" ;", "nl": "Given two strings"}
{"code": "System . out . println ( lexico_smallest ( s1 , s2 ) [ 0 ] ) ; System . out . println ( lexico_largest ( s1 , s2 ) ) ; } }", "nl": "Function Calls"}
{"code": "import java . util . * ; class GFG { static int sz = ( int ) 1e5 ;", "nl": "Java implementation for the above approach"}
{"code": "static Vector < Integer > [ ] tree = new Vector [ sz ] ;", "nl": "Adjacency list to represent the tree"}
{"code": "static int n ;", "nl": "Number of vertices"}
{"code": "static boolean [ ] vis = new boolean [ sz ] ;", "nl": "Mark visited / unvisited vertices"}
{"code": "static int [ ] subtreeSize = new int [ sz ] ;", "nl": "Stores the subtree size of the corresponding nodes"}
{"code": "static void addEdge ( int a , int b ) {", "nl": "Function to create an edge between two vertices"}
{"code": "tree [ a ] . add ( b ) ;", "nl": "Add a to b 's list"}
{"code": "tree [ b ] . add ( a ) ; }", "nl": "Add b to a 's list"}
{"code": "static void dfs ( int x ) {", "nl": "Function to perform DFS"}
{"code": "vis [ x ] = true ;", "nl": "Mark the vertex visited"}
{"code": "subtreeSize [ x ] = 1 ;", "nl": "Include the node in the subtree"}
{"code": "for ( int i : tree [ x ] ) { if ( ! vis [ i ] ) { dfs ( i ) ; subtreeSize [ x ] += subtreeSize [ i ] ; } } }", "nl": "Traverse all its children"}
{"code": "static void countPairs ( int a , int b ) { int sub = Math . min ( subtreeSize [ a ] , subtreeSize [ b ] ) ; System . out . print ( sub * ( n - sub ) + \"NEW_LINE\"); }", "nl": "Function to print the required number of paths"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "n = 6 ; for ( int i = 0 ; i < tree . length ; i ++ ) tree [ i ] = new Vector < Integer > ( ) ; addEdge ( 0 , 1 ) ; addEdge ( 0 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 3 , 4 ) ; addEdge ( 3 , 5 ) ;", "nl": "Number of vertices"}
{"code": "dfs ( 0 ) ;", "nl": "Calling modified dfs function"}
{"code": "countPairs ( 1 , 3 ) ; countPairs ( 0 , 2 ) ; } }", "nl": "Count pairs of vertices in the tree"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int findPermutation ( Set < Integer > arr , int N ) { int pos = arr . size ( ) + 1 ;", "nl": "Function to find the count of desired permutations"}
{"code": "if ( pos > N ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) {", "nl": "Base case"}
{"code": "if ( ! arr . contains ( i ) ) {", "nl": "If i has not been inserted"}
{"code": "if ( i % pos == 0 pos % i == 0 ) {", "nl": "Backtrack"}
{"code": "arr . add ( i ) ;", "nl": "Insert i"}
{"code": "res += findPermutation ( arr , N ) ;", "nl": "Recur to find valid permutations"}
{"code": "arr . remove ( i ) ; } } }", "nl": "Remove i"}
{"code": "return res ; }", "nl": "Return the final count"}
{"code": "public static void main ( String [ ] args ) { int N = 5 ; Set < Integer > arr = new HashSet < Integer > ( ) ; System . out . print ( findPermutation ( arr , N ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void solve ( int arr [ ] , int n , int X , int Y ) {", "nl": "Function to check if it is possible to obtain sum Y from a sequence of sum X from the array arr [ ]"}
{"code": "int diff = Y - X ;", "nl": "Store the difference"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } }", "nl": "Iterate over the array"}
{"code": "if ( diff == 0 ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; }", "nl": "If diff reduced to 0"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 7 , 9 , 10 } ; int n = arr . length ; int X = 11 , Y = 13 ; solve ( arr , n , X , Y ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static final int maxN = 100001 ;", "nl": "Java program to implement the above approach"}
{"code": "@ SuppressWarnings ( \" unchecked \" ) static Vector < Integer > [ ] adj = new Vector [ maxN ] ;", "nl": "Adjacency List to store the graph"}
{"code": "static int [ ] height = new int [ maxN ] ;", "nl": "Stores the height of each node"}
{"code": "static int [ ] dist = new int [ maxN ] ;", "nl": "Stores the maximum distance of a node from its ancestors"}
{"code": "static void addEdge ( int u , int v ) {", "nl": "Function to add edge between two vertices"}
{"code": "adj [ u ] . add ( v ) ;", "nl": "Insert edge from u to v"}
{"code": "adj [ v ] . add ( u ) ; }", "nl": "Insert edge from v to u"}
{"code": "static void dfs1 ( int cur , int par ) {", "nl": "Function to calculate height of each Node"}
{"code": "for ( int u : adj [ cur ] ) { if ( u != par ) {", "nl": "Iterate in the adjacency list of the current node"}
{"code": "dfs1 ( u , cur ) ;", "nl": "Dfs for child node"}
{"code": "height [ cur ] = Math . max ( height [ cur ] , height [ u ] ) ; } }", "nl": "Calculate height of nodes"}
{"code": "height [ cur ] += 1 ; }", "nl": "Increase height"}
{"code": "static void dfs2 ( int cur , int par ) { int max1 = 0 ; int max2 = 0 ;", "nl": "Function to calculate the maximum distance of a node from its ancestor"}
{"code": "for ( int u : adj [ cur ] ) { if ( u != par ) {", "nl": "Iterate in the adjacency list of the current node"}
{"code": "if ( height [ u ] >= max1 ) { max2 = max1 ; max1 = height [ u ] ; } else if ( height [ u ] > max2 ) { max2 = height [ u ] ; } } } int sum = 0 ; for ( int u : adj [ cur ] ) { if ( u != par ) {", "nl": "Find two children with maximum heights"}
{"code": "sum = ( ( max1 == height [ u ] ) ? max2 : max1 ) ; if ( max1 == height [ u ] ) dist [ u ] = 1 + Math . max ( 1 + max2 , dist [ cur ] ) ; else dist [ u ] = 1 + Math . max ( 1 + max1 , dist [ cur ] ) ;", "nl": "Calculate the maximum distance with ancestor for every node"}
{"code": "dfs2 ( u , cur ) ; } } }", "nl": "Calculating for children"}
{"code": "public static void main ( String [ ] args ) { int n = 6 ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; addEdge ( 1 , 2 ) ; addEdge ( 2 , 3 ) ; addEdge ( 2 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 5 , 6 ) ;", "nl": "Driver Code"}
{"code": "dfs1 ( 1 , 0 ) ;", "nl": "Calculate height of nodes of the tree"}
{"code": "dfs2 ( 1 , 0 ) ;", "nl": "Calculate the maximum distance with ancestors"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( ( Math . max ( dist [ i ] , height [ i ] ) - 1 ) + \" \u2581 \" ) ; } }", "nl": "Print the maximum of the two distances from each node"}
{"code": "import java . util . * ; class Middle {", "nl": "Java program to find middle of three distinct numbers"}
{"code": "public static int middleOfThree ( int a , int b , int c ) {", "nl": "Function to find the middle of three number"}
{"code": "if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ;", "nl": "Checking for b"}
{"code": "else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }", "nl": "Checking for a"}
{"code": "public static void main ( String [ ] args ) { int a = 20 , b = 30 , c = 40 ; System . out . println ( middleOfThree ( a , b , c ) ) ; } }", "nl": "driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for implementation of selection sort"}
{"code": "static void selectionSort ( int arr [ ] , int n ) { int i , j , min_idx ;", "nl": "Function to implement the selection sort"}
{"code": "for ( i = 0 ; i < n - 1 ; i ++ ) {", "nl": "One by one move boundary of unsorted subarray"}
{"code": "min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ;", "nl": "Find the minimum element in unsorted array"}
{"code": "int temp = arr [ min_idx ] ; arr [ min_idx ] = arr [ i ] ; arr [ i ] = temp ; } }", "nl": "Swap the found minimum element with the first element"}
{"code": "static void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } System . out . println ( ) ; }", "nl": "Function to print an array"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 64 , 25 , 12 , 22 , 11 } ; int n = arr . length ;", "nl": "Driver Code"}
{"code": "selectionSort ( arr , n ) ; System . out . print ( \"Sorted array: NEW_LINE\");", "nl": "Function Call"}
{"code": "printArray ( arr , n ) ; } }", "nl": "Print the array"}
{"code": "import java . util . * ; class GFG { static boolean checkStr1CanConStr2 ( String str1 , String str2 ) {", "nl": "Java program to implement the above approach"}
{"code": "int N = str1 . length ( ) ;", "nl": "Stores length of str1"}
{"code": "int M = str2 . length ( ) ;", "nl": "Stores length of str2"}
{"code": "HashSet < Integer > st1 = new HashSet < > ( ) ;", "nl": "Stores distinct characters of str1"}
{"code": "HashSet < Integer > st2 = new HashSet < > ( ) ;", "nl": "Stores distinct characters of str2"}
{"code": "int hash1 [ ] = new int [ 256 ] ;", "nl": "Stores frequency of each character of str1"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the String str1"}
{"code": "hash1 [ str1 . charAt ( i ) ] ++ ; }", "nl": "Update frequency of str1 [ i ]"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the String str1"}
{"code": "st1 . add ( ( int ) str1 . charAt ( i ) ) ; }", "nl": "Insert str1 [ i ] into st1"}
{"code": "for ( int i = 0 ; i < M ; i ++ ) {", "nl": "Traverse the String str2"}
{"code": "st2 . add ( ( int ) str2 . charAt ( i ) ) ; }", "nl": "Insert str1 [ i ] into st1"}
{"code": "if ( ! st1 . equals ( st2 ) ) { return false ; }", "nl": "If distinct characters in str1 and str2 are not same"}
{"code": "int hash2 [ ] = new int [ 256 ] ;", "nl": "Stores frequency of each character of str2"}
{"code": "for ( int i = 0 ; i < M ; i ++ ) {", "nl": "Traverse the String str2"}
{"code": "hash2 [ str2 . charAt ( i ) ] ++ ; }", "nl": "Update frequency of str2 [ i ]"}
{"code": "Arrays . sort ( hash1 ) ;", "nl": "Sort hash1 [ ] array"}
{"code": "Arrays . sort ( hash2 ) ;", "nl": "Sort hash2 [ ] array"}
{"code": "for ( int i = 0 ; i < 256 ; i ++ ) {", "nl": "Traverse hash1 [ ] and hash2 [ ]"}
{"code": "if ( hash1 [ i ] != hash2 [ i ] ) { return false ; } } return true ; }", "nl": "If hash1 [ i ] not equal to hash2 [ i ]"}
{"code": "public static void main ( String [ ] args ) { String str1 = \" xyyzzlll \" ; String str2 = \" yllzzxxx \" ; if ( checkStr1CanConStr2 ( str1 , str2 ) ) { System . out . print ( \" True \" ) ; } else { System . out . print ( \" False \" ) ; } } }", "nl": "Driver Code"}
{"code": "import java . io . * ; import java . util . * ; import java . lang . * ; class GFG {", "nl": "Java program to sort the array in a given index range"}
{"code": "static void partSort ( int [ ] arr , int N , int a , int b ) {", "nl": "Function to sort the elements of the array from index a to index b"}
{"code": "int l = Math . min ( a , b ) ; int r = Math . max ( a , b ) ;", "nl": "Variables to store start and end of the index range"}
{"code": "Arrays . sort ( arr , l , r + 1 ) ;", "nl": "Sort the subarray from arr [ l ] to arr [ r ]"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }", "nl": "Print the modified array"}
{"code": "public static void main ( String args [ ] ) { int [ ] arr = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 , b = 4 ; int N = arr . length ; partSort ( arr , N , a , b ) ; } }", "nl": "Driver code"}
{"code": "class shortest_path { static int INF = Integer . MAX_VALUE , N = 4 ;", "nl": "A Dynamic Programming based solution to find min cost to reach station N - 1 from station 0."}
{"code": "static int minCost ( int cost [ ] [ ] ) {", "nl": "A recursive function to find the shortest path from source ' s ' to destination ' d ' . This function returns the smallest possible cost to reach station N - 1 from station 0."}
{"code": "int dist [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ;", "nl": "dist [ i ] stores minimum cost to reach station i from station 0."}
{"code": "for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }", "nl": "Go through every station and check if using it as an intermediate station gives better path"}
{"code": "public static void main ( String args [ ] ) { int cost [ ] [ ] = { { 0 , 15 , 80 , 90 } , { INF , 0 , 40 , 50 } , { INF , INF , 0 , 70 } , { INF , INF , INF , 0 } } ; System . out . println ( \" The \u2581 Minimum \u2581 cost \u2581 to \u2581 reach \u2581 station \u2581 \" + N + \" \u2581 is \u2581 \" + minCost ( cost ) ) ; } }", "nl": "Driver program to test above function"}
{"code": "public class GFG {", "nl": "Java Program to find number of cycles of length k in a graph with n nodes ."}
{"code": "static int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 != 0 ) p = - 1 ; return ( int ) ( Math . pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; }", "nl": "Return the Number of ways from a node to make a loop of size K in undirected complete connected graph of N nodes"}
{"code": "public static void main ( String args [ ] ) { int n = 4 , k = 2 ; System . out . println ( numOfways ( n , k ) ) ; } }", "nl": "Driver code"}
{"code": "public class GFG {", "nl": "Java program to find largest and smallest characters in a string ."}
{"code": "static char largest_alphabet ( String a , int n ) {", "nl": "function that return the largest alphabet ."}
{"code": "char max = ' A ' ;", "nl": "initializing max alphabet to ' a '"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) if ( a . charAt ( i ) > max ) max = a . charAt ( i ) ;", "nl": "find largest alphabet"}
{"code": "return max ; }", "nl": "returning largest element"}
{"code": "static char smallest_alphabet ( String a , int n ) {", "nl": "function that return the smallest alphabet"}
{"code": "char min = ' z ' ;", "nl": "initializing smallest alphabet to ' z '"}
{"code": "for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a . charAt ( i ) < min ) min = a . charAt ( i ) ;", "nl": "find smallest alphabet"}
{"code": "return min ; }", "nl": "returning smallest alphabet"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "String a = \" GeEksforGeeks \" ;", "nl": "Input String"}
{"code": "int size = a . length ( ) ;", "nl": "Calculating size of the string"}
{"code": "System . out . print ( \" Largest \u2581 and \u2581 smallest \u2581 alphabet \u2581 is \u2581 : \u2581 \" ) ; System . out . print ( largest_alphabet ( a , size ) + \" \u2581 and \u2581 \" ) ; System . out . println ( smallest_alphabet ( a , size ) ) ; } }", "nl": "calling functions and print returned value"}
{"code": "import java . text . ParseException ; class GFG {", "nl": "Java program to get largest palindrome changing atmost K digits"}
{"code": "static String maximumPalinUsingKChanges ( String str , int k ) { char palin [ ] = str . toCharArray ( ) ; String ans = \" \" ;", "nl": "Returns maximum possible palindrome using k changes"}
{"code": "int l = 0 ; int r = str . length ( ) - 1 ;", "nl": "Initialize l and r by leftmost and rightmost ends"}
{"code": "while ( l < r ) {", "nl": "First try to make String palindrome"}
{"code": "if ( str . charAt ( l ) != str . charAt ( r ) ) { palin [ l ] = palin [ r ] = ( char ) Math . max ( str . charAt ( l ) , str . charAt ( r ) ) ; k -- ; } l ++ ; r -- ; }", "nl": "Replace left and right character by maximum of both"}
{"code": "if ( k < 0 ) { return \" Not \u2581 possible \" ; } l = 0 ; r = str . length ( ) - 1 ; while ( l <= r ) {", "nl": "If k is negative then we can 't make  String palindrome"}
{"code": "if ( l == r ) { if ( k > 0 ) { palin [ l ] = '9' ; } }", "nl": "At mid character , if K > 0 then change it to 9"}
{"code": "if ( palin [ l ] < '9' ) {", "nl": "If character at lth ( same as rth ) is less than 9"}
{"code": "if ( k >= 2 && palin [ l ] == str . charAt ( l ) && palin [ r ] == str . charAt ( r ) ) { k -= 2 ; palin [ l ] = palin [ r ] = '9' ; }", "nl": "If none of them is changed in the previous loop then subtract 2 from K and convert both to 9"}
{"code": "else if ( k >= 1 && ( palin [ l ] != str . charAt ( l ) || palin [ r ] != str . charAt ( r ) ) ) { k -- ; palin [ l ] = palin [ r ] = '9' ; } } l ++ ; r -- ; } for ( int i = 0 ; i < palin . length ; i ++ ) ans += palin [ i ] ; return ans ; }", "nl": "If one of them is changed in the previous loop then subtract 1 from K ( 1 more is subtracted already ) and make them 9"}
{"code": "public static void main ( String [ ] args ) throws ParseException { String str = \"43435\" ; int k = 3 ; System . out . println ( maximumPalinUsingKChanges ( str , k ) ) ; } }", "nl": "Driver code to test above methods"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int countTriplets ( int [ ] A ) {", "nl": "Function to find the number of triplets whose Bitwise AND is 0."}
{"code": "int cnt = 0 ;", "nl": "Stores the count of triplets having bitwise AND equal to 0"}
{"code": "HashMap < Integer , Integer > tuples = new HashMap < Integer , Integer > ( ) ;", "nl": "Stores frequencies of all possible A [ i ] & A [ j ]"}
{"code": "for ( int a : A )", "nl": "Traverse the array"}
{"code": "for ( int b : A ) { if ( tuples . containsKey ( a & b ) ) tuples . put ( a & b , tuples . get ( a & b ) + 1 ) ; else tuples . put ( a & b , 1 ) ; }", "nl": "Update frequency of Bitwise AND of all array elements with a"}
{"code": "for ( int a : A )", "nl": "Traverse the array"}
{"code": "for ( Map . Entry < Integer , Integer > t : tuples . entrySet ( ) )", "nl": "Iterate the map"}
{"code": "if ( ( t . getKey ( ) & a ) == 0 ) cnt += t . getValue ( ) ;", "nl": "If bitwise AND of triplet is zero , increment cnt"}
{"code": "return cnt ; }", "nl": "Return the number of triplets whose Bitwise AND is 0."}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int [ ] A = { 2 , 1 , 3 } ;", "nl": "Input Array"}
{"code": "System . out . print ( countTriplets ( A ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; public class Main { static int min ;", "nl": "Java implementation of above approach"}
{"code": "static void parity ( List < Integer > even , List < Integer > odd , List < Integer > v , int i ) {", "nl": "Recursive function to calculate minimum adjacent pairs with different parity"}
{"code": "if ( i == v . size ( ) || even . size ( ) == 0 && odd . size ( ) == 0 ) { int count = 0 ; for ( int j = 0 ; j < v . size ( ) - 1 ; j ++ ) { if ( v . get ( j ) % 2 != v . get ( j + 1 ) % 2 ) count ++ ; } if ( count < min ) min = count ; return ; }", "nl": "If all the numbers are placed"}
{"code": "if ( v . get ( i ) != - 1 ) parity ( even , odd , v , i + 1 ) ;", "nl": "If replacement is not required"}
{"code": "else { if ( even . size ( ) != 0 ) { int x = even . get ( even . size ( ) - 1 ) ; even . remove ( even . size ( ) - 1 ) ; v . set ( i , x ) ; parity ( even , odd , v , i + 1 ) ;", "nl": "If replacement is required"}
{"code": "even . add ( x ) ; } if ( odd . size ( ) != 0 ) { int x = odd . get ( odd . size ( ) - 1 ) ; odd . remove ( odd . size ( ) - 1 ) ; v . set ( i , x ) ; parity ( even , odd , v , i + 1 ) ;", "nl": "Backtracking"}
{"code": "odd . add ( x ) ; } } }", "nl": "Backtracking"}
{"code": "static void minDiffParity ( List < Integer > v , int n ) {", "nl": "Function to display the minimum number of adjacent elements with different parity"}
{"code": "List < Integer > even = new ArrayList < Integer > ( ) ;", "nl": "Store no of even numbers not present in the array"}
{"code": "List < Integer > odd = new ArrayList < Integer > ( ) ; HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( m . containsKey ( i ) ) { m . replace ( i , 1 ) ; } else { m . put ( i , 1 ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) {", "nl": "Store no of odd numbers not present in the array"}
{"code": "if ( v . get ( i ) != - 1 ) m . remove ( v . get ( i ) ) ; }", "nl": "Erase exisiting numbers"}
{"code": "for ( Map . Entry < Integer , Integer > i : m . entrySet ( ) ) { if ( i . getKey ( ) % 2 == 0 ) { even . add ( i . getKey ( ) ) ; } else { odd . add ( i . getKey ( ) ) ; } } min = 1000 ; parity ( even , odd , v , 0 ) ; System . out . println ( min ) ; }", "nl": "Store non - exisiting even and odd numbers"}
{"code": "public static void main ( String [ ] args ) { int n = 8 ; List < Integer > v = new ArrayList < Integer > ( ) ; v . add ( 2 ) ; v . add ( 1 ) ; v . add ( 4 ) ; v . add ( - 1 ) ; v . add ( - 1 ) ; v . add ( 6 ) ; v . add ( - 1 ) ; v . add ( 8 ) ; minDiffParity ( v , n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static int MAX = 100005 ; static Vector < Vector < Integer > > adjacent = new Vector < Vector < Integer > > ( ) ; static boolean visited [ ] = new boolean [ MAX ] ;", "nl": "Java implementation of the approach"}
{"code": "static int startnode , endnode , thirdnode ; static int maxi = - 1 , N ;", "nl": "To store the required nodes"}
{"code": "static int parent [ ] = new int [ MAX ] ;", "nl": "Parent array to retrace the nodes"}
{"code": "static boolean vis [ ] = new boolean [ MAX ] ;", "nl": "Visited array to prevent DFS in direction on Diameter path"}
{"code": "static void dfs ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent . get ( u ) . size ( ) ; i ++ ) { if ( ! visited [ adjacent . get ( u ) . get ( i ) ] ) { temp ++ ; dfs ( adjacent . get ( u ) . get ( i ) , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; startnode = u ; } } }", "nl": "DFS function to find the startnode"}
{"code": "static void dfs1 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent . get ( u ) . size ( ) ; i ++ ) { if ( ! visited [ adjacent . get ( u ) . get ( i ) ] ) { temp ++ ; parent [ adjacent . get ( u ) . get ( i ) ] = u ; dfs1 ( adjacent . get ( u ) . get ( i ) , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; endnode = u ; } } }", "nl": "DFS function to find the endnode of diameter and maintain the parent array"}
{"code": "static void dfs2 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent . get ( u ) . size ( ) ; i ++ ) { if ( ! visited [ adjacent . get ( u ) . get ( i ) ] && ! vis [ adjacent . get ( u ) . get ( i ) ] ) { temp ++ ; dfs2 ( adjacent . get ( u ) . get ( i ) , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; thirdnode = u ; } } }", "nl": "DFS function to find the end node of the Longest Branch to Diameter"}
{"code": "static void findNodes ( ) {", "nl": "Function to find the required nodes"}
{"code": "dfs ( 1 , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; maxi = - 1 ;", "nl": "To find start node of diameter"}
{"code": "dfs1 ( startnode , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ;", "nl": "To find end node of diameter"}
{"code": "int x = endnode ; vis [ startnode ] = true ;", "nl": "x is the end node of diameter"}
{"code": "while ( x != startnode ) { vis [ x ] = true ; x = parent [ x ] ; } maxi = - 1 ;", "nl": "Mark all the nodes on diameter using back tracking"}
{"code": "for ( int i = 1 ; i <= N ; i ++ ) { if ( vis [ i ] ) dfs2 ( i , 0 ) ; } }", "nl": "Find the end node of longest branch to diameter"}
{"code": "public static void main ( String args [ ] ) { for ( int i = 0 ; i < MAX ; i ++ ) adjacent . add ( new Vector < Integer > ( ) ) ; N = 4 ; adjacent . get ( 1 ) . add ( 2 ) ; adjacent . get ( 2 ) . add ( 1 ) ; adjacent . get ( 1 ) . add ( 3 ) ; adjacent . get ( 3 ) . add ( 1 ) ; adjacent . get ( 1 ) . add ( 4 ) ; adjacent . get ( 4 ) . add ( 1 ) ; findNodes ( ) ; System . out . print ( \" ( \" + startnode + \" , \u2581 \" + endnode + \" , \u2581 \" + thirdnode + \" ) \" ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static void newvol ( double x ) { System . out . print ( \" percentage \u2581 increase \u2581 in \u2581 the \" + \" \u2581 volume \u2581 of \u2581 the \u2581 sphere \u2581 is \u2581 \" + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + \" % \" ) ; }", "nl": "Java program to find percentage increase in the volume of the sphere if radius is increased by a given percentage"}
{"code": "public static void main ( String [ ] args ) { double x = 10 ; newvol ( x ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find the length chord of the circle whose radius and the angle subtended at the centre is also given"}
{"code": "static void length_of_chord ( double r , double x ) { System . out . println ( \" The \u2581 length \u2581 of \u2581 the \u2581 chord \" + \" \u2581 of \u2581 the \u2581 circle \u2581 is \u2581 \" + 2 * r * Math . sin ( x * ( 3.14 / 180 ) ) ) ; }", "nl": "Function to find the length of the chord"}
{"code": "public static void main ( String [ ] args ) { double r = 4 , x = 63 ; length_of_chord ( r , x ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java Program to find the area of the square inscribed within the circle which in turn is inscribed in an equilateral triangle"}
{"code": "static float area ( float a ) {", "nl": "Function to find the area of the square"}
{"code": "if ( a < 0 ) return - 1 ;", "nl": "a cannot be negative"}
{"code": "float area = ( float ) Math . sqrt ( a ) / 6 ; return area ; }", "nl": "area of the square"}
{"code": "public static void main ( String [ ] args ) { float a = 10 ; System . out . println ( area ( a ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find the longest rod that can fit in a cuboid"}
{"code": "static double longestRodInCuboid ( int length , int breadth , int height ) { double result ; int temp ;", "nl": "Function to find the length"}
{"code": "temp = length * length + breadth * breadth + height * height ;", "nl": "temporary variable to hold the intermediate result"}
{"code": "result = Math . sqrt ( temp ) ; return result ; }", "nl": "length of longest rod is calculated using square root function"}
{"code": "public static void main ( String [ ] args ) { int length = 12 , breadth = 9 , height = 8 ;", "nl": "Driver Code"}
{"code": "System . out . println ( ( int ) longestRodInCuboid ( length , breadth , height ) ) ; } }", "nl": "calling longestRodInCuboid ( ) function to get the length of longest rod"}
{"code": "class GFG {", "nl": "Java program to Check whether a given point lies inside or on the rectangle or not"}
{"code": "static boolean LiesInsieRectangle ( int a , int b , int x , int y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; }", "nl": "function to Check whether a given point lies inside or on the rectangle or not"}
{"code": "public static void main ( String [ ] args ) { int a = 7 , b = 2 , x = 4 , y = 5 ; if ( LiesInsieRectangle ( a , b , x , y ) ) System . out . println ( \" Given \u2581 point \u2581 lies \u2581 \" + \" inside \u2581 the \u2581 rectangle \" ) ; else System . out . println ( \" Given \u2581 point \u2581 does \u2581 not \u2581 \" + \" lie \u2581 on \u2581 the \u2581 rectangle \" ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java code to Maximize volume of cuboid with given sum of sides"}
{"code": "static int maxvolume ( int s ) { int maxvalue = 0 ;", "nl": "Return the maximum volume ."}
{"code": "for ( int i = 1 ; i <= s - 2 ; i ++ ) {", "nl": "for length"}
{"code": "for ( int j = 1 ; j <= s - 1 ; j ++ ) {", "nl": "for breadth"}
{"code": "int k = s - i - j ;", "nl": "for height"}
{"code": "maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; }", "nl": "calculating maximum volume ."}
{"code": "public static void main ( String [ ] args ) { int s = 8 ; System . out . println ( maxvolume ( s ) ) ; } }", "nl": "Driver function"}
{"code": "import java . io . * ; class GFG {", "nl": "Java code to Maximize volume of cuboid with given sum of sides"}
{"code": "static int maxvolume ( int s ) {", "nl": "Return the maximum volume ."}
{"code": "int length = s / 3 ; s -= length ;", "nl": "finding length"}
{"code": "int breadth = s / 2 ;", "nl": "finding breadth"}
{"code": "int height = s - breadth ; return length * breadth * height ; }", "nl": "finding height"}
{"code": "public static void main ( String [ ] args ) { int s = 8 ; System . out . println ( maxvolume ( s ) ) ; } }", "nl": "Driven Program"}
{"code": "class GFG {", "nl": "Java program to find area of a Hexagon"}
{"code": "public static double hexagonArea ( double s ) { return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }", "nl": "Create a function for calculating the area of the hexagon ."}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "double s = 4 ; System . out . print ( \" Area : \u2581 \" + hexagonArea ( s ) ) ; } }", "nl": "Length of a side"}
{"code": "public class GFG {", "nl": "Java program for finding maximum squares that can fit in right angle isosceles triangle"}
{"code": "static int maxSquare ( int b , int m ) {", "nl": "function for finding max squares"}
{"code": "return ( b / m - 1 ) * ( b / m ) / 2 ; }", "nl": "return in O ( 1 ) with derived formula"}
{"code": "public static void main ( String args [ ] ) { int b = 10 , m = 2 ; System . out . println ( maxSquare ( b , m ) ) ; } }", "nl": "driver program"}
{"code": "class GFG {", "nl": "Java program to check existence of right triangle ."}
{"code": "static void findRightAngle ( double A , double H ) {", "nl": "Prints three sides of a right triangle from given area and hypotenuse if triangle is possible , else prints - 1."}
{"code": "double D = Math . pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) {", "nl": "Descriminant of the equation"}
{"code": "double root1 = ( H * H + Math . sqrt ( D ) ) / 2 ; double root2 = ( H * H - Math . sqrt ( D ) ) / 2 ; double a = Math . sqrt ( root1 ) ; double b = Math . sqrt ( root2 ) ; if ( b >= a ) System . out . print ( a + \" \u2581 \" + b + \" \u2581 \" + H ) ; else System . out . print ( b + \" \u2581 \" + a + \" \u2581 \" + H ) ; } else System . out . print ( \" - 1\" ) ; }", "nl": "applying the linear equation formula to find both the roots"}
{"code": "public static void main ( String arg [ ] ) { findRightAngle ( 6 , 5 ) ; } }", "nl": "Driver code"}
{"code": "class Squares { public static int numberOfSquares ( int base ) {", "nl": "Java program to count number of 2 x 2 squares in a right isosceles triangle"}
{"code": "base = ( base - 2 ) ;", "nl": "removing the extra part we would always need"}
{"code": "base = Math . floorDiv ( base , 2 ) ; return base * ( base + 1 ) / 2 ; }", "nl": "Since each square has base of length of 2"}
{"code": "public static void main ( String args [ ] ) { int base = 8 ; System . out . println ( numberOfSquares ( base ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void performQuery ( int arr [ ] , int Q [ ] [ ] ) {", "nl": "Function to find the Bitwise OR of Bitwise AND of all possible subarrays after performing the every query"}
{"code": "for ( int i = 0 ; i < Q . length ; i ++ ) {", "nl": "Traversing each pair of the query"}
{"code": "int or = 0 ;", "nl": "Stores the Bitwise OR"}
{"code": "int x = Q [ i ] [ 0 ] ; arr [ x - 1 ] = Q [ i ] [ 1 ] ;", "nl": "Updating the array"}
{"code": "for ( int j = 0 ; j < arr . length ; j ++ ) { or = or | arr [ j ] ; }", "nl": "Find the Bitwise OR of new updated array"}
{"code": "System . out . print ( or + \" \u2581 \" ) ; } }", "nl": "Print the ans"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int Q [ ] [ ] = { { 1 , 4 } , { 3 , 0 } } ; performQuery ( arr , Q ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int smallest ( int k , int d ) { int cnt = 1 ; int m = d % k ;", "nl": "Function to form the smallest number possible"}
{"code": "int [ ] v = new int [ k ] ; Arrays . fill ( v , 0 ) ; v [ m ] = 1 ;", "nl": "Array to mark the remainders counted already"}
{"code": "while ( 1 != 0 ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ;", "nl": "Iterate over the range"}
{"code": "if ( v [ m ] == 1 ) return - 1 ; v [ m ] = 1 ; cnt ++ ; } }", "nl": "If that remainder is already found , return - 1"}
{"code": "public static void main ( String [ ] args ) { int d = 1 ; int k = 41 ; System . out . println ( smallest ( k , d ) ) ; } }", "nl": "Driver Code"}
{"code": "public class GFG {", "nl": "java code to find vertices in a fibonacci cube graph of order n"}
{"code": "static int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }", "nl": "function to find fibonacci number"}
{"code": "static int findVertices ( int n ) {", "nl": "function for finding number of vertices in fibonacci cube graph"}
{"code": "return fib ( n + 2 ) ; } public static void main ( String args [ ] ) {", "nl": "return fibonacci number for f ( n + 2 )"}
{"code": "int n = 3 ; System . out . println ( findVertices ( n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static void checkCommonDivisor ( int [ ] arr , int N , int X ) {", "nl": "Function to check if it is possible to modify the array such that there is no common factor between array elements except 1"}
{"code": "int G = 0 ;", "nl": "Stores GCD of the array"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { G = gcd ( G , arr [ i ] ) ; } int copy_G = G ; for ( int divisor = 2 ; divisor <= X ; divisor ++ ) {", "nl": "Calculate GCD of the array"}
{"code": "while ( G % divisor == 0 ) {", "nl": "If the current divisor is smaller than X"}
{"code": "G = G / divisor ; } }", "nl": "Divide GCD by the current divisor"}
{"code": "if ( G <= X ) { System . out . println ( \" Yes \" ) ;", "nl": "If possible"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) System . out . print ( ( arr [ i ] / copy_G ) + \" \u2581 \" ) ; System . out . println ( ) ; }", "nl": "Print the modified array"}
{"code": "else System . out . println ( \" No \" ) ; }", "nl": "Otherwise"}
{"code": "static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }", "nl": "Calculating gcd"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int [ ] arr = { 6 , 15 , 6 } ; int X = 6 ;", "nl": "Given array"}
{"code": "int N = arr . length ; checkCommonDivisor ( arr , N , X ) ; } }", "nl": "Size of the array"}
{"code": "public class GFG { public static void printSpiral ( int size ) { int row = 0 , col = 0 ; int boundary = size - 1 ; int sizeLeft = size - 1 ; int flag = 1 ;", "nl": "Create row and col to traverse rows and columns"}
{"code": "char move = ' r ' ;", "nl": "Variable to determine the movement r = right , l = left , d = down , u = upper"}
{"code": "int matrix [ ] [ ] = new int [ size ] [ size ] ; for ( int i = 1 ; i < size * size + 1 ; i ++ ) {", "nl": "Array for matrix"}
{"code": "matrix [ row ] [ col ] = i ;", "nl": "Assign the value"}
{"code": "switch ( move ) {", "nl": "switch - case to determine the next index"}
{"code": "case ' r ' : col += 1 ; break ;", "nl": "If right , go right"}
{"code": "case ' l ' : col -= 1 ; break ;", "nl": "if left , go left"}
{"code": "case ' u ' : row -= 1 ; break ;", "nl": "if up , go up"}
{"code": "case ' d ' : row += 1 ; break ; }", "nl": "if down , go down"}
{"code": "if ( i == boundary ) {", "nl": "Check if the matrix has reached array boundary"}
{"code": "boundary += sizeLeft ;", "nl": "Add the left size for the next boundary"}
{"code": "if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; }", "nl": "If 2 rotations has been made , decrease the size left by 1"}
{"code": "switch ( move ) {", "nl": "switch - case to rotate the movement"}
{"code": "case ' r ' : move = ' d ' ; break ;", "nl": "if right , rotate to down"}
{"code": "case ' d ' : move = ' l ' ; break ;", "nl": "if down , rotate to left"}
{"code": "case ' l ' : move = ' u ' ; break ;", "nl": "if left , rotate to up"}
{"code": "case ' u ' : move = ' r ' ; break ; } } }", "nl": "if up , rotate to right"}
{"code": "for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { int n = matrix [ row ] [ col ] ; System . out . print ( ( n < 10 ) ? ( n + \" \u2581 \" ) : ( n + \" \u2581 \" ) ) ; } System . out . println ( ) ; } }", "nl": "Print the matrix"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int size = 5 ;", "nl": "Get the size of size"}
{"code": "printSpiral ( size ) ; } }", "nl": "Print the Spiral Pattern"}
{"code": "class GFG {", "nl": "Java implementation to sort the biotonic doubly linked list"}
{"code": "static class Node { int data ; Node next ; Node prev ; }", "nl": "a node of the doubly linked list"}
{"code": "static Node reverse ( Node head_ref ) { Node temp = null ; Node current = head_ref ;", "nl": "Function to reverse a Doubly Linked List"}
{"code": "while ( current != null ) { temp = current . prev ; current . prev = current . next ; current . next = temp ; current = current . prev ; }", "nl": "swap next and prev for all nodes of doubly linked list"}
{"code": "if ( temp != null ) head_ref = temp . prev ; return head_ref ; }", "nl": "Before changing head , check for the cases like empty list and list with only one node"}
{"code": "static Node merge ( Node first , Node second ) {", "nl": "Function to merge two sorted doubly linked lists"}
{"code": "if ( first == null ) return second ;", "nl": "If first linked list is empty"}
{"code": "if ( second == null ) return first ;", "nl": "If second linked list is empty"}
{"code": "if ( first . data < second . data ) { first . next = merge ( first . next , second ) ; first . next . prev = first ; first . prev = null ; return first ; } else { second . next = merge ( first , second . next ) ; second . next . prev = second ; second . prev = null ; return second ; } }", "nl": "Pick the smaller value"}
{"code": "static Node sort ( Node head ) {", "nl": "function to sort a biotonic doubly linked list"}
{"code": "if ( head == null head . next == null ) return head ; Node current = head . next ; while ( current != null ) {", "nl": "if list is empty or if it contains a single node only"}
{"code": "if ( current . data < current . prev . data ) break ;", "nl": "if true , then ' current ' is the first node which is smaller than its previous node"}
{"code": "current = current . next ; }", "nl": "move to the next node"}
{"code": "if ( current == null ) return head ;", "nl": "if true , then list is already sorted"}
{"code": "current . prev . next = null ; current . prev = null ;", "nl": "spilt into two lists , one starting with ' head ' and other starting with ' current '"}
{"code": "current = reverse ( current ) ;", "nl": "reverse the list starting with ' current '"}
{"code": "return merge ( head , current ) ; }", "nl": "merge the two lists and return the final merged doubly linked list"}
{"code": "static Node push ( Node head_ref , int new_data ) {", "nl": "Function to insert a node at the beginning of the Doubly Linked List"}
{"code": "Node new_node = new Node ( ) ;", "nl": "allocate node"}
{"code": "new_node . data = new_data ;", "nl": "put in the data"}
{"code": "new_node . prev = null ;", "nl": "since we are adding at the beginning , prev is always null"}
{"code": "new_node . next = ( head_ref ) ;", "nl": "link the old list off the new node"}
{"code": "if ( ( head_ref ) != null ) ( head_ref ) . prev = new_node ;", "nl": "change prev of head node to new node"}
{"code": "( head_ref ) = new_node ; return head_ref ; }", "nl": "move the head to point to the new node"}
{"code": "static void printList ( Node head ) {", "nl": "Function to print nodes in a given doubly linked list"}
{"code": "if ( head == null ) System . out . println ( \" Doubly \u2581 Linked \u2581 list \u2581 empty \" ) ; while ( head != null ) { System . out . print ( head . data + \" \u2581 \" ) ; head = head . next ; } }", "nl": "if list is empty"}
{"code": "public static void main ( String args [ ] ) { Node head = null ;", "nl": "Driver Code"}
{"code": "head = push ( head , 1 ) ; head = push ( head , 4 ) ; head = push ( head , 6 ) ; head = push ( head , 10 ) ; head = push ( head , 12 ) ; head = push ( head , 7 ) ; head = push ( head , 5 ) ; head = push ( head , 2 ) ; System . out . println ( \" Original \u2581 Doubly \u2581 linked \u2581 list : n \" ) ; printList ( head ) ;", "nl": "Create the doubly linked list : 2 < .5 < .7 < .12 < .10 < .6 < .4 < .1"}
{"code": "head = sort ( head ) ; System . out . println ( \" Doubly linked list after sorting : n \"); printList ( head ) ; } }", "nl": "sort the biotonic DLL"}
{"code": "class GfG {", "nl": "Java program to arrange consonants and vowels nodes in a linked list"}
{"code": "static class Node { char data ; Node next ; }", "nl": "A linked list node"}
{"code": "static Node newNode ( char key ) { Node temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; }", "nl": "Function to add new node to the List"}
{"code": "static void printlist ( Node head ) { if ( head == null ) { System . out . println ( \" Empty \u2581 List \" ) ; return ; } while ( head != null ) { System . out . print ( head . data + \" \u2581 \" ) ; if ( head . next != null ) System . out . print ( \" - > \u2581 \" ) ; head = head . next ; } System . out . println ( ) ; }", "nl": "utility function to print linked list"}
{"code": "static boolean isVowel ( char x ) { return ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) ; }", "nl": "utility function for checking vowel"}
{"code": "static Node arrange ( Node head ) { Node newHead = head ;", "nl": "function to arrange consonants and vowels nodes"}
{"code": "Node latestVowel ; Node curr = head ;", "nl": "for keep track of vowel"}
{"code": "if ( head == null ) return null ;", "nl": "list is empty"}
{"code": "if ( isVowel ( head . data ) == true )", "nl": "We need to discover the first vowel in the list . It is going to be the returned head , and also the initial latestVowel ."}
{"code": "latestVowel = head ; else {", "nl": "first element is a vowel . It will also be the new head and the initial latestVowel ;"}
{"code": "while ( curr . next != null && ! isVowel ( curr . next . data ) ) curr = curr . next ;", "nl": "First element is not a vowel . Iterate through the list until we find a vowel . Note that curr points to the element * before * the element with the vowel ."}
{"code": "if ( curr . next == null ) return head ;", "nl": "This is an edge case where there are only consonants in the list ."}
{"code": "latestVowel = newHead = curr . next ; curr . next = curr . next . next ; latestVowel . next = head ; }", "nl": "Set the initial latestVowel and the new head to the vowel item that we found . Relink the chain of consonants after that vowel item : old_head_consonant -> consonant1 -> consonant2 -> vowel -> rest_of_list becomes vowel -> old_head_consonant -> consonant1 -> consonant2 -> rest_of_list"}
{"code": "while ( curr != null && curr . next != null ) { if ( isVowel ( curr . next . data ) == true ) {", "nl": "Now traverse the list . Curr is always the item * before * the one we are checking , so that we can use it to re - link ."}
{"code": "if ( curr == latestVowel ) {", "nl": "The next discovered item is a vowel"}
{"code": "latestVowel = curr = curr . next ; } else {", "nl": "If it comes directly after the previous vowel , we don 't need to  move items around, just mark the  new latestVowel and advance curr."}
{"code": "Node temp = latestVowel . next ;", "nl": "But if it comes after an intervening chain of consonants , we need to chain the newly discovered vowel right after the old vowel . Curr is not changed as after the re - linking it will have a new next , that has not been checked yet , and we always keep curr at one before the next to check ."}
{"code": "latestVowel . next = curr . next ;", "nl": "Chain in new vowel"}
{"code": "latestVowel = latestVowel . next ;", "nl": "Advance latestVowel"}
{"code": "curr . next = curr . next . next ;", "nl": "Remove found vowel from previous place"}
{"code": "latestVowel . next = temp ; } } else {", "nl": "Re - link chain of consonants after latestVowel"}
{"code": "curr = curr . next ; } } return newHead ; }", "nl": "No vowel in the next element , advance curr ."}
{"code": "public static void main ( String [ ] args ) { Node head = newNode ( ' a ' ) ; head . next = newNode ( ' b ' ) ; head . next . next = newNode ( ' c ' ) ; head . next . next . next = newNode ( ' e ' ) ; head . next . next . next . next = newNode ( ' d ' ) ; head . next . next . next . next . next = newNode ( ' o ' ) ; head . next . next . next . next . next . next = newNode ( ' x ' ) ; head . next . next . next . next . next . next . next = newNode ( ' i ' ) ; System . out . println ( \" Linked \u2581 list \u2581 before \u2581 : \u2581 \" ) ; printlist ( head ) ; head = arrange ( head ) ; System . out . println ( \" Linked \u2581 list \u2581 after \u2581 : \" ) ; printlist ( head ) ; } }", "nl": "Driver code"}
{"code": "class GfG {", "nl": "Java Program for finding K - th largest Node using O ( 1 ) extra memory and reverse Morris traversal ."}
{"code": "static class Node { int data ; Node left , right ; }", "nl": "Node structure"}
{"code": "static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . right = null ; temp . left = null ; return temp ; } static Node KthLargestUsingMorrisTraversal ( Node root , int k ) { Node curr = root ; Node Klargest = null ;", "nl": "helper function to create a new Node"}
{"code": "int count = 0 ; while ( curr != null ) {", "nl": "count variable to keep count of visited Nodes"}
{"code": "if ( curr . right == null ) {", "nl": "if right child is NULL"}
{"code": "if ( ++ count == k ) Klargest = curr ;", "nl": "first increment count and check if count = k"}
{"code": "curr = curr . left ; } else {", "nl": "otherwise move to the left child"}
{"code": "Node succ = curr . right ; while ( succ . left != null && succ . left != curr ) succ = succ . left ; if ( succ . left == null ) {", "nl": "find inorder successor of current Node"}
{"code": "succ . left = curr ;", "nl": "set left child of successor to the current Node"}
{"code": "curr = curr . right ; }", "nl": "move current to its right"}
{"code": "else { succ . left = null ; if ( ++ count == k ) Klargest = curr ;", "nl": "restoring the tree back to original binary search tree removing threaded links"}
{"code": "curr = curr . left ; } } } return Klargest ; }", "nl": "move current to its left child"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "Node root = newNode ( 4 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 7 ) ; root . left . left = newNode ( 1 ) ; root . left . right = newNode ( 3 ) ; root . right . left = newNode ( 6 ) ; root . right . right = newNode ( 10 ) ; System . out . println ( \" Finding \u2581 K - th \u2581 largest \u2581 Node \u2581 in \u2581 BST \u2581 : \u2581 \" + KthLargestUsingMorrisTraversal ( root , 2 ) . data ) ; } }", "nl": "Constructed binary tree is 4 / \\ 2 7 / \\ / \\ 1 3 6 10"}
{"code": "import java . util . Arrays ; import java . util . Collections ; class GFG { static int MAX_SIZE = 10 ;", "nl": "Java implementation to sort the rows of matrix in ascending order followed by sorting the columns in descending order"}
{"code": "static void sortByRow ( Integer mat [ ] [ ] , int n , boolean ascending ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ascending ) Arrays . sort ( mat [ i ] ) ; else Arrays . sort ( mat [ i ] , Collections . reverseOrder ( ) ) ; } }", "nl": "function to sort each row of the matrix according to the order specified by ascending ."}
{"code": "static void transpose ( Integer mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) {", "nl": "function to find transpose of the matrix"}
{"code": "int temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } }", "nl": "swapping element at index ( i , j ) by element at index ( j , i )"}
{"code": "static void sortMatRowAndColWise ( Integer mat [ ] [ ] , int n ) {", "nl": "function to sort the matrix row - wise and column - wise"}
{"code": "sortByRow ( mat , n , true ) ;", "nl": "sort rows of mat [ ] [ ]"}
{"code": "transpose ( mat , n ) ;", "nl": "get transpose of mat [ ] [ ]"}
{"code": "sortByRow ( mat , n , false ) ;", "nl": "again sort rows of mat [ ] [ ] in descending order ."}
{"code": "transpose ( mat , n ) ; }", "nl": "again get transpose of mat [ ] [ ]"}
{"code": "static void printMat ( Integer mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( mat [ i ] [ j ] + \" \u2581 \" ) ; System . out . println ( ) ; } }", "nl": "function to print the matrix"}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; Integer mat [ ] [ ] = { { 3 , 2 , 1 } , { 9 , 8 , 7 } , { 6 , 5 , 4 } } ; System . out . print ( \"Original Matrix:NEW_LINE\"); printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; System . out . print ( \" Matrix After Sorting : \"); printMat ( mat , n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Arrays ; class GFG { static final int MAX_SIZE = 10 ;", "nl": "Java implementation to sort the matrix row - wise and column - wise"}
{"code": "static void sortByRow ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ )", "nl": "function to sort each row of the matrix"}
{"code": "Arrays . sort ( mat [ i ] ) ; }", "nl": "sorting row number ' i '"}
{"code": "static void transpose ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) {", "nl": "function to find transpose of the matrix"}
{"code": "int temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } }", "nl": "swapping element at index ( i , j ) by element at index ( j , i )"}
{"code": "static void sortMatRowAndColWise ( int mat [ ] [ ] , int n ) {", "nl": "function to sort the matrix row - wise and column - wise"}
{"code": "sortByRow ( mat , n ) ;", "nl": "sort rows of mat [ ] [ ]"}
{"code": "transpose ( mat , n ) ;", "nl": "get transpose of mat [ ] [ ]"}
{"code": "sortByRow ( mat , n ) ;", "nl": "again sort rows of mat [ ] [ ]"}
{"code": "transpose ( mat , n ) ; }", "nl": "again get transpose of mat [ ] [ ]"}
{"code": "static void printMat ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( mat [ i ] [ j ] + \" \u2581 \" ) ; System . out . println ( ) ; } }", "nl": "function to print the matrix"}
{"code": "public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 4 , 1 , 3 } , { 9 , 6 , 8 } , { 5 , 2 , 7 } } ; int n = 3 ; System . out . print ( \"Original Matrix:NEW_LINE\"); printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; System . out . print ( \" Matrix After Sorting : \"); printMat ( mat , n ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to print Magic square of Doubly even order"}
{"code": "static void doublyEven ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; int i , j ;", "nl": "Function for calculating Magic square"}
{"code": "for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * i ) + j + 1 ;", "nl": "filling matrix with its count value starting from 1 ;"}
{"code": "for ( i = 0 ; i < n / 4 ; i ++ ) for ( j = 0 ; j < n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ;", "nl": "change value of Array elements at fix location as per rule ( n * n + 1 ) - arr [ i ] [ j ] Top Left corner of Matrix ( order ( n / 4 ) * ( n / 4 ) )"}
{"code": "for ( i = 0 ; i < n / 4 ; i ++ ) for ( j = 3 * ( n / 4 ) ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ;", "nl": "Top Right corner of Matrix ( order ( n / 4 ) * ( n / 4 ) )"}
{"code": "for ( i = 3 * n / 4 ; i < n ; i ++ ) for ( j = 0 ; j < n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ;", "nl": "Bottom Left corner of Matrix ( order ( n / 4 ) * ( n / 4 ) )"}
{"code": "for ( i = 3 * n / 4 ; i < n ; i ++ ) for ( j = 3 * n / 4 ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ;", "nl": "Bottom Right corner of Matrix ( order ( n / 4 ) * ( n / 4 ) )"}
{"code": "for ( i = n / 4 ; i < 3 * n / 4 ; i ++ ) for ( j = n / 4 ; j < 3 * n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ;", "nl": "Centre of Matrix ( order ( n / 2 ) * ( n / 2 ) )"}
{"code": "for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) System . out . print ( arr [ i ] [ j ] + \" \u2581 \" ) ; System . out . println ( ) ; } }", "nl": "Printing the magic - square"}
{"code": "public static void main ( String [ ] args ) { int n = 8 ;", "nl": "driver program"}
{"code": "doublyEven ( n ) ; } }", "nl": "Function call"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java code to find the Kronecker Product of two matrices and stores it as matrix C"}
{"code": "static int cola = 2 , rowa = 3 , colb = 3 , rowb = 2 ;", "nl": "rowa and cola are no of rows and columns of matrix A rowb and colb are no of rows and columns of matrix B"}
{"code": "static void Kroneckerproduct ( int A [ ] [ ] , int B [ ] [ ] ) { int [ ] [ ] C = new int [ rowa * rowb ] [ cola * colb ] ;", "nl": "Function to computes the Kronecker Product of two matrices"}
{"code": "for ( int i = 0 ; i < rowa ; i ++ ) {", "nl": "i loops till rowa"}
{"code": "for ( int k = 0 ; k < rowb ; k ++ ) {", "nl": "k loops till rowb"}
{"code": "for ( int j = 0 ; j < cola ; j ++ ) {", "nl": "j loops till cola"}
{"code": "for ( int l = 0 ; l < colb ; l ++ ) {", "nl": "l loops till colb"}
{"code": "C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; System . out . print ( C [ i + l + 1 ] [ j + k + 1 ] + \" \u2581 \" ) ; } } System . out . println ( ) ; } } }", "nl": "Each element of matrix A is multiplied by whole Matrix B resp and stored as Matrix C"}
{"code": "public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } } ; int B [ ] [ ] = { { 0 , 5 , 2 } , { 6 , 7 , 3 } } ; Kroneckerproduct ( A , B ) ; } }", "nl": "Driver program"}
{"code": "import java . io . * ; class Lower_triangular { int N = 4 ;", "nl": "Java Program to check for a lower triangular matrix ."}
{"code": "boolean isLowerTriangularMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }", "nl": "Function to check matrix is in lower triangular form or not ."}
{"code": "public static void main ( String args [ ] ) { Lower_triangular ob = new Lower_triangular ( ) ; int mat [ ] [ ] = { { 1 , 0 , 0 , 0 } , { 1 , 4 , 0 , 0 } , { 4 , 6 , 2 , 0 } , { 0 , 4 , 7 , 6 } } ;", "nl": "Driver function ."}
{"code": "if ( ob . isLowerTriangularMatrix ( mat ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; import java . lang . * ; public class GfG { private static final int N = 4 ;", "nl": "Java Program to check upper triangular matrix ."}
{"code": "public static Boolean isUpperTriangularMatrix ( int mat [ ] [ ] ) { for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; }", "nl": "Function to check matrix is in upper triangular form or not ."}
{"code": "public static void main ( String argc [ ] ) { int [ ] [ ] mat = { { 1 , 3 , 5 , 3 } , { 0 , 4 , 6 , 2 } , { 0 , 0 , 2 , 5 } , { 0 , 0 , 0 , 6 } } ; if ( isUpperTriangularMatrix ( mat ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "driver function"}
{"code": "class GFG {", "nl": "Java program to compute number of sets in a binary matrix ."}
{"code": "static final int m = 3 ;", "nl": "no of columns"}
{"code": "static final int n = 2 ;", "nl": "no of rows"}
{"code": "static long countSets ( int a [ ] [ ] ) {", "nl": "function to calculate the number of non empty sets of cell"}
{"code": "long res = 0 ;", "nl": "stores the final answer"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( a [ i ] [ j ] == 1 ) u ++ ; else v ++ ; } res += Math . pow ( 2 , u ) - 1 + Math . pow ( 2 , v ) - 1 ; }", "nl": "traverses row - wise"}
{"code": "for ( int i = 0 ; i < m ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] [ i ] == 1 ) u ++ ; else v ++ ; } res += Math . pow ( 2 , u ) - 1 + Math . pow ( 2 , v ) - 1 ; }", "nl": "traverses column wise"}
{"code": "return res - ( n * m ) ; }", "nl": "at the end subtract n * m as no of single sets have been added twice ."}
{"code": "public static void main ( String [ ] args ) { int a [ ] [ ] = { { 1 , 0 , 1 } , { 0 , 1 , 0 } } ; System . out . print ( countSets ( a ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static int MAX = 100 ;", "nl": "Simple java code for check a matrix is symmetric or not ."}
{"code": "static void transpose ( int mat [ ] [ ] , int tr [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) tr [ i ] [ j ] = mat [ j ] [ i ] ; }", "nl": "Fills transpose of mat [ N ] [ N ] in tr [ N ] [ N ]"}
{"code": "static boolean isSymmetric ( int mat [ ] [ ] , int N ) { int tr [ ] [ ] = new int [ N ] [ MAX ] ; transpose ( mat , tr , N ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != tr [ i ] [ j ] ) return false ; return true ; }", "nl": "Returns true if mat [ N ] [ N ] is symmetric , else false"}
{"code": "public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 3 , 5 } , { 3 , 2 , 4 } , { 5 , 4 , 1 } } ; if ( isSymmetric ( mat , 3 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static int MAX = 100 ;", "nl": "Efficient Java code for check a matrix is symmetric or no"}
{"code": "static boolean isSymmetric ( int mat [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }", "nl": "Returns true if mat [ N ] [ N ] is symmetric , else false"}
{"code": "public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 3 , 5 } , { 3 , 2 , 4 } , { 5 , 4 , 1 } } ; if ( isSymmetric ( mat , 3 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" NO \" ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find trace and normal of given matrix"}
{"code": "static int MAX = 100 ;", "nl": "Size of given matrix"}
{"code": "static int findNormal ( int mat [ ] [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] * mat [ i ] [ j ] ; return ( int ) Math . sqrt ( sum ) ; }", "nl": "Returns Normal of a matrix of size n x n"}
{"code": "static int findTrace ( int mat [ ] [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += mat [ i ] [ i ] ; return sum ; }", "nl": "Returns trace of a matrix of size n x n"}
{"code": "public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; System . out . println ( \" Trace \u2581 of \u2581 Matrix \u2581 = \u2581 \" + findTrace ( mat , 5 ) ) ; System . out . println ( \" Normal \u2581 of \u2581 Matrix \u2581 = \u2581 \" + findNormal ( mat , 5 ) ) ; } }", "nl": "Driven source"}
{"code": "import java . io . * ; public class GFG {", "nl": "Java program to find maximum possible determinant of 0 / n matrix ."}
{"code": "static int maxDet ( int n ) { return ( 2 * n * n * n ) ; }", "nl": "Function for maximum determinant"}
{"code": "void resMatrix ( int n ) { for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) {", "nl": "Function to print resulatant matrix"}
{"code": "if ( i == 0 && j == 2 ) System . out . print ( \"0 \u2581 \" ) ; else if ( i == 1 && j == 0 ) System . out . print ( \"0 \u2581 \" ) ; else if ( i == 2 && j == 1 ) System . out . print ( \"0 \u2581 \" ) ;", "nl": "three position where 0 appears"}
{"code": "else System . out . print ( n + \" \u2581 \" ) ; } System . out . println ( \" \" ) ; } }", "nl": "position where n appears"}
{"code": "static public void main ( String [ ] args ) { int n = 15 ; GFG geeks = new GFG ( ) ; System . out . println ( \" Maximum \u2581 Determinant \u2581 = \u2581 \" + maxDet ( n ) ) ; System . out . println ( \" Resultant \u2581 Matrix \u2581 : \" ) ; geeks . resMatrix ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ;", "nl": "Java implementation of Naive method to count of negative numbers in M [ n ] [ m ]"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ;", "nl": "Follow the path shown using arrows above"}
{"code": "else break ; } } return count ; }", "nl": "no more negative numbers in this row"}
{"code": "public static void main ( String [ ] args ) { int M [ ] [ ] = { { - 3 , - 2 , - 1 , 1 } , { - 2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; System . out . println ( countNegative ( M , 3 , 4 ) ) ; } }", "nl": "Driver program to test above functions"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {", "nl": "Java implementation of Efficient method to count of negative numbers in M [ n ] [ m ]"}
{"code": "static int countNegative ( int M [ ] [ ] , int n , int m ) {", "nl": "Function to count negative number"}
{"code": "int count = 0 ;", "nl": "initialize result"}
{"code": "int i = 0 ; int j = m - 1 ;", "nl": "Start with top right corner"}
{"code": "while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) {", "nl": "Follow the path shown using arrows above"}
{"code": "count += j + 1 ;", "nl": "j is the index of the last negative number in this row . So there must be ( j + 1 )"}
{"code": "i += 1 ; }", "nl": "negative numbers in this row ."}
{"code": "else j -= 1 ; } return count ; }", "nl": "move to the left and see if we can find a negative number there"}
{"code": "public static void main ( String [ ] args ) { int M [ ] [ ] = { { - 3 , - 2 , - 1 , 1 } , { - 2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; System . out . println ( countNegative ( M , 3 , 4 ) ) ; } }", "nl": "Driver program to test above functions"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {", "nl": "Java implementation of More efficient method to count number of negative numbers in row - column sorted matrix M [ n ] [ m ]"}
{"code": "static int getLastNegativeIndex ( int array [ ] , int start , int end ) {", "nl": "Recursive binary search to get last negative value in a row between a start and an end"}
{"code": "if ( start == end ) { return start ; }", "nl": "Base case"}
{"code": "int mid = start + ( end - start ) / 2 ;", "nl": "Get the mid for binary search"}
{"code": "if ( array [ mid ] < 0 ) {", "nl": "If current element is negative"}
{"code": "if ( mid + 1 < array . length && array [ mid + 1 ] >= 0 ) { return mid ; }", "nl": "If it is the rightmost negative element in the current row"}
{"code": "return getLastNegativeIndex ( array , mid + 1 , end ) ; } else {", "nl": "Check in the right half of the array"}
{"code": "return getLastNegativeIndex ( array , start , mid - 1 ) ; } }", "nl": "Check in the left half of the array"}
{"code": "static int countNegative ( int M [ ] [ ] , int n , int m ) {", "nl": "Function to return the count of negative numbers in the given matrix"}
{"code": "int count = 0 ;", "nl": "Initialize result"}
{"code": "int nextEnd = m - 1 ;", "nl": "To store the index of the rightmost negative element in the row under consideration"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Iterate over all rows of the matrix"}
{"code": "if ( M [ i ] [ 0 ] >= 0 ) { break ; }", "nl": "If the first element of the current row is positive then there will be no negatives in the matrix below or after it"}
{"code": "nextEnd = getLastNegativeIndex ( M [ i ] , 0 , nextEnd ) ; count += nextEnd + 1 ; } return count ; }", "nl": "Run binary search only until the index of last negative Integer in the above row"}
{"code": "public static void main ( String [ ] args ) { int M [ ] [ ] = { { - 3 , - 2 , - 1 , 1 } , { - 2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; int r = M . length ; int c = M [ 0 ] . length ; System . out . println ( countNegative ( M , r , c ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "A Naive method to find maximum value of mat1 [ d ] [ e ] - ma [ a ] [ b ] such that d > a and e > b"}
{"code": "static int findMaxValue ( int N , int mat [ ] [ ] ) {", "nl": "The function returns maximum value A ( d , e ) - A ( a , b ) over all choices of indexes such that both d > a and e > b ."}
{"code": "int maxValue = Integer . MIN_VALUE ;", "nl": "stores maximum value"}
{"code": "for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; }", "nl": "Consider all possible pairs mat [ a ] [ b ] and mat1 [ d ] [ e ]"}
{"code": "public static void main ( String [ ] args ) { int N = 5 ; int mat [ ] [ ] = { { 1 , 2 , - 1 , - 4 , - 20 } , { - 8 , - 3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { - 4 , - 1 , 1 , 7 , - 6 } , { 0 , - 4 , 10 , - 5 , 1 } } ; System . out . print ( \" Maximum \u2581 Value \u2581 is \u2581 \" + findMaxValue ( N , mat ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "An efficient method to find maximum value of mat1 [ d ] - ma [ a ] [ b ] such that c > a and d > b"}
{"code": "static int findMaxValue ( int N , int mat [ ] [ ] ) {", "nl": "The function returns maximum value A ( c , d ) - A ( a , b ) over all choices of indexes such that both c > a and d > b ."}
{"code": "int maxValue = Integer . MIN_VALUE ;", "nl": "stores maximum value"}
{"code": "int maxArr [ ] [ ] = new int [ N ] [ N ] ;", "nl": "maxArr [ i ] [ j ] stores max of elements in matrix from ( i , j ) to ( N - 1 , N - 1 )"}
{"code": "maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ;", "nl": "last element of maxArr will be same 's as of  the input matrix"}
{"code": "int maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] ; maxArr [ N - 1 ] [ j ] = maxv ; }", "nl": "preprocess last row Initialize max"}
{"code": "maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ] ; maxArr [ i ] [ N - 1 ] = maxv ; }", "nl": "preprocess last column Initialize max"}
{"code": "for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) {", "nl": "preprocess rest of the matrix from bottom"}
{"code": "if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ;", "nl": "Update maxValue"}
{"code": "maxArr [ i ] [ j ] = Math . max ( mat [ i ] [ j ] , Math . max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; }", "nl": "set maxArr ( i , j )"}
{"code": "public static void main ( String [ ] args ) { int N = 5 ; int mat [ ] [ ] = { { 1 , 2 , - 1 , - 4 , - 20 } , { - 8 , - 3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { - 4 , - 1 , 1 , 7 , - 6 } , { 0 , - 4 , 10 , - 5 , 1 } } ; System . out . print ( \" Maximum \u2581 Value \u2581 is \u2581 \" + findMaxValue ( N , mat ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static final int INF = Integer . MAX_VALUE ; static final int N = 4 ;", "nl": "A Java program to Print all elements in sorted order from row and column wise sorted matrix"}
{"code": "static void youngify ( int mat [ ] [ ] , int i , int j ) {", "nl": "A utility function to youngify a Young Tableau . This is different from standard youngify . It assumes that the value at mat [ 0 ] [ 0 ] is infinite ."}
{"code": "int downVal = ( i + 1 < N ) ? mat [ i + 1 ] [ j ] : INF ; int rightVal = ( j + 1 < N ) ? mat [ i ] [ j + 1 ] : INF ;", "nl": "Find the values at down and right sides of mat [ i ] [ j ]"}
{"code": "if ( downVal == INF && rightVal == INF ) { return ; }", "nl": "If mat [ i ] [ j ] is the down right corner element , return"}
{"code": "if ( downVal < rightVal ) { mat [ i ] [ j ] = downVal ; mat [ i + 1 ] [ j ] = INF ; youngify ( mat , i + 1 , j ) ; } else { mat [ i ] [ j ] = rightVal ; mat [ i ] [ j + 1 ] = INF ; youngify ( mat , i , j + 1 ) ; } }", "nl": "Move the smaller of two values ( downVal and rightVal ) to mat [ i ] [ j ] and recur for smaller value"}
{"code": "static int extractMin ( int mat [ ] [ ] ) { int ret = mat [ 0 ] [ 0 ] ; mat [ 0 ] [ 0 ] = INF ; youngify ( mat , 0 , 0 ) ; return ret ; }", "nl": "A utility function to extract minimum element from Young tableau"}
{"code": "static void printSorted ( int mat [ ] [ ] ) { System . out . println ( \" Elements \u2581 of \u2581 matrix \u2581 in \u2581 sorted \u2581 order \u2581 n \" ) ; for ( int i = 0 ; i < N * N ; i ++ ) { System . out . print ( extractMin ( mat ) + \" \u2581 \" ) ; } }", "nl": "This function uses extractMin ( ) to print elements in sorted order"}
{"code": "public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } } ; printSorted ( mat ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "A simple Java program to find sum of all subsquares of size k x k"}
{"code": "static final int n = 5 ;", "nl": "Size of given matrix"}
{"code": "static void printSumSimple ( int mat [ ] [ ] , int k ) {", "nl": "A simple function to find sum of all sub - squares of size k x k in a given square matrix of size n x n"}
{"code": "if ( k > n ) return ;", "nl": "k must be smaller than or equal to n"}
{"code": "for ( int i = 0 ; i < n - k + 1 ; i ++ ) {", "nl": "row number of first cell in current sub - square of size k x k"}
{"code": "for ( int j = 0 ; j < n - k + 1 ; j ++ ) {", "nl": "column of first cell in current sub - square of size k x k"}
{"code": "int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; System . out . print ( sum + \" \u2581 \" ) ; }", "nl": "Calculate and print sum of current sub - square"}
{"code": "System . out . println ( ) ; } }", "nl": "Line separator for sub - squares starting with next row"}
{"code": "public static void main ( String arg [ ] ) { int mat [ ] [ ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } } ; int k = 3 ; printSumSimple ( mat , k ) ; } }", "nl": "Driver Program to test above function"}
{"code": "import java . io . * ; class GFG {", "nl": "An efficient Java program to find sum of all subsquares of size k x k"}
{"code": "static int n = 5 ;", "nl": "Size of given matrix"}
{"code": "static void printSumTricky ( int mat [ ] [ ] , int k ) {", "nl": "A O ( n ^ 2 ) function to find sum of all sub - squares of size k x k in a given square matrix of size n x n"}
{"code": "if ( k > n ) return ;", "nl": "k must be smaller than or equal to n"}
{"code": "int stripSum [ ] [ ] = new int [ n ] [ n ] ;", "nl": "1 : PREPROCESSING To store sums of all strips of size k x 1"}
{"code": "for ( int j = 0 ; j < n ; j ++ ) {", "nl": "Go column by column"}
{"code": "int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; stripSum [ 0 ] [ j ] = sum ;", "nl": "Calculate sum of first k x 1 rectangle in this column"}
{"code": "for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; stripSum [ i ] [ j ] = sum ; } }", "nl": "Calculate sum of remaining rectangles"}
{"code": "for ( int i = 0 ; i < n - k + 1 ; i ++ ) {", "nl": "2 : CALCULATE SUM of Sub - Squares using stripSum [ ] [ ]"}
{"code": "int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += stripSum [ i ] [ j ] ; System . out . print ( sum + \" \u2581 \" ) ;", "nl": "Calculate and print sum of first subsquare in this row"}
{"code": "for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ; System . out . print ( sum + \" \u2581 \" ) ; } System . out . println ( ) ; } }", "nl": "Calculate sum of remaining squares in current row by removing the leftmost strip of previous sub - square and adding a new strip"}
{"code": "public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; printSumTricky ( mat , k ) ; } }", "nl": "Driver program to test above function"}
{"code": "class GFG { static final int M = 3 ; static final int N = 4 ;", "nl": "Java Program to find transpose of a matrix"}
{"code": "static void transpose ( int A [ ] [ ] , int B [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }", "nl": "This function stores transpose of A [ ] [ ] in B [ ] [ ]"}
{"code": "public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } } ; int B [ ] [ ] = new int [ N ] [ M ] , i , j ; transpose ( A , B ) ; System . out . print ( \"Result matrix is NEW_LINE\"); for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) System . out . print ( B [ i ] [ j ] + \" \u2581 \" ) ; System . out . print ( \"NEW_LINE\"); } } }", "nl": "Driver code"}
{"code": "class GFG { static final int N = 4 ;", "nl": "Java Program to find transpose of a matrix"}
{"code": "static void transpose ( int A [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { int temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] ; A [ j ] [ i ] = temp ; } }", "nl": "Finds transpose of A [ ] [ ] in - place"}
{"code": "public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; transpose ( A ) ; System . out . print ( \"Modified matrix is NEW_LINE\"); for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) System . out . print ( A [ i ] [ j ] + \" \u2581 \" ) ; System . out . print ( \"NEW_LINE\"); } } }", "nl": "Driver code"}
{"code": "class GFG { static final int R = 3 ; static final int C = 3 ;", "nl": "A Naive Recursive Java program to count paths with exactly ' k ' coins"}
{"code": "static int pathCountRec ( int mat [ ] [ ] , int m , int n , int k ) {", "nl": "Recursive function to count paths with sum k from ( 0 , 0 ) to ( m , n )"}
{"code": "if ( m < 0 n < 0 ) { return 0 ; } if ( m == 0 && n == 0 && ( k == mat [ m ] [ n ] ) ) { return 1 ; }", "nl": "Base cases"}
{"code": "return pathCountRec ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountRec ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; }", "nl": "( m , n ) can be reached either through ( m - 1 , n ) or through ( m , n - 1 )"}
{"code": "static int pathCount ( int mat [ ] [ ] , int k ) { return pathCountRec ( mat , R - 1 , C - 1 , k ) ; }", "nl": "A wrapper over pathCountRec ( )"}
{"code": "public static void main ( String [ ] args ) { int k = 12 ; int mat [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 6 , 5 } , { 3 , 2 , 1 } } ; System . out . println ( pathCount ( mat , k ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static final int R = 3 ; static final int C = 3 ; static final int MAX_K = 100 ; static int [ ] [ ] [ ] dp = new int [ R ] [ C ] [ MAX_K ] ; static int pathCountDPRecDP ( int [ ] [ ] mat , int m , int n , int k ) {", "nl": "A Dynamic Programming based JAVA program to count paths with exactly ' k ' coins"}
{"code": "if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ? 1 : 0 ) ;", "nl": "Base cases"}
{"code": "if ( dp [ m ] [ n ] [ k ] != - 1 ) return dp [ m ] [ n ] [ k ] ;", "nl": "If this subproblem is already solved"}
{"code": "dp [ m ] [ n ] [ k ] = pathCountDPRecDP ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountDPRecDP ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; return dp [ m ] [ n ] [ k ] ; }", "nl": "( m , n ) can be reached either through ( m - 1 , n ) or through ( m , n - 1 )"}
{"code": "static int pathCountDP ( int [ ] [ ] mat , int k ) { for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) for ( int l = 0 ; l < MAX_K ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; return pathCountDPRecDP ( mat , R - 1 , C - 1 , k ) ; }", "nl": "This function mainly initializes dp [ ] [ ] [ ] and calls pathCountDPRecDP ( )"}
{"code": "public static void main ( String [ ] args ) { int k = 12 ; int [ ] [ ] mat = new int [ ] [ ] { new int [ ] { 1 , 2 , 3 } , new int [ ] { 4 , 6 , 5 } , new int [ ] { 3 , 2 , 1 } } ; System . out . println ( pathCountDP ( mat , k ) ) ; } }", "nl": "Driver Program to test above functions"}
{"code": "import java . io . * ; import java . util . * ; class GFG { static int SIZE = 10 ;", "nl": "Java implementation to sort the given matrix"}
{"code": "static void sortMat ( int mat [ ] [ ] , int n ) {", "nl": "function to sort the given matrix"}
{"code": "int temp [ ] = new int [ n * n ] ; int k = 0 ;", "nl": "temporary matrix of size n ^ 2"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) temp [ k ++ ] = mat [ i ] [ j ] ;", "nl": "copy the elements of matrix one by one into temp [ ]"}
{"code": "Arrays . sort ( temp ) ;", "nl": "sort temp [ ]"}
{"code": "k = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) mat [ i ] [ j ] = temp [ k ++ ] ; }", "nl": "copy the elements of temp [ ] one by one in mat [ ] [ ]"}
{"code": "static void printMat ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) System . out . print ( mat [ i ] [ j ] + \" \u2581 \" ) ; System . out . println ( ) ; } }", "nl": "function to print the given matrix"}
{"code": "public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 5 , 4 , 7 } , { 1 , 3 , 8 } , { 2 , 9 , 6 } } ; int n = 3 ; System . out . println ( \" Original \u2581 Matrix : \" ) ; printMat ( mat , n ) ; sortMat ( mat , n ) ; System . out . println ( \" Matrix \u2581 After \u2581 Sorting : \" ) ; printMat ( mat , n ) ; } }", "nl": "Driver program to test above"}
{"code": "class SelectionSort {", "nl": "Java program for implementation of Selection Sort"}
{"code": "void sort ( int arr [ ] ) { int n = arr . length ;", "nl": "sort function"}
{"code": "for ( int i = 0 ; i < n - 1 ; i ++ ) {", "nl": "One by one move boundary of unsorted subarray"}
{"code": "int min_idx = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ;", "nl": "Find the minimum element in unsorted array"}
{"code": "int temp = arr [ min_idx ] ; arr [ min_idx ] = arr [ i ] ; arr [ i ] = temp ; } }", "nl": "Swap the found minimum element with the first element"}
{"code": "void printArray ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; System . out . println ( ) ; }", "nl": "Prints the array"}
{"code": "public static void main ( String args [ ] ) { SelectionSort ob = new SelectionSort ( ) ; int arr [ ] = { 64 , 25 , 12 , 22 , 11 } ; ob . sort ( arr ) ; System . out . println ( \" Sorted \u2581 array \" ) ; ob . printArray ( arr ) ; } }", "nl": "Driver code to test above"}
{"code": "import java . io . * ; class GFG {", "nl": "Optimized java implementation of Bubble sort"}
{"code": "static void bubbleSort ( int arr [ ] , int n ) { int i , j , temp ; boolean swapped ; for ( i = 0 ; i < n - 1 ; i ++ ) { swapped = false ; for ( j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) {", "nl": "An optimized version of Bubble Sort"}
{"code": "temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; swapped = true ; } }", "nl": "swap arr [ j ] and arr [ j + 1 ]"}
{"code": "if ( swapped == false ) break ; } }", "nl": "IF no two elements were swapped by inner loop , then break"}
{"code": "static void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; System . out . println ( ) ; }", "nl": "Function to print an array"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 64 , 34 , 25 , 12 , 22 , 11 , 90 } ; int n = arr . length ; bubbleSort ( arr , n ) ; System . out . println ( \" Sorted \u2581 array : \u2581 \" ) ; printArray ( arr , n ) ; } }", "nl": "Driver program"}
{"code": "class KClosest {", "nl": "Java program to find k closest elements to a given value"}
{"code": "int findCrossOver ( int arr [ ] , int low , int high , int x ) {", "nl": "Function to find the cross over point ( the point before which elements are smaller than or equal to x and after which greater than x )"}
{"code": "if ( arr [ high ] <= x ) return high ;", "nl": "Base cases x is greater than all"}
{"code": "if ( arr [ low ] > x ) return low ;", "nl": "x is smaller than all"}
{"code": "int mid = ( low + high ) / 2 ;", "nl": "Find the middle point"}
{"code": "if ( arr [ mid ] <= x && arr [ mid + 1 ] > x ) return mid ;", "nl": "If x is same as middle element , then return mid"}
{"code": "if ( arr [ mid ] < x ) return findCrossOver ( arr , mid + 1 , high , x ) ; return findCrossOver ( arr , low , mid - 1 , x ) ; }", "nl": "If x is greater than arr [ mid ] , then either arr [ mid + 1 ] is ceiling of x or ceiling lies in arr [ mid + 1. . . high ]"}
{"code": "void printKclosest ( int arr [ ] , int x , int k , int n ) {", "nl": "This function prints k closest elements to x in arr [ ] . n is the number of elements in arr [ ]"}
{"code": "int l = findCrossOver ( arr , 0 , n - 1 , x ) ;", "nl": "Find the crossover point"}
{"code": "int r = l + 1 ;", "nl": "Right index to search"}
{"code": "int count = 0 ;", "nl": "To keep track of count of elements already printed"}
{"code": "if ( arr [ l ] == x ) l -- ;", "nl": "If x is present in arr [ ] , then reduce left index Assumption : all elements in arr [ ] are distinct"}
{"code": "while ( l >= 0 && r < n && count < k ) { if ( x - arr [ l ] < arr [ r ] - x ) System . out . print ( arr [ l -- ] + \" \u2581 \" ) ; else System . out . print ( arr [ r ++ ] + \" \u2581 \" ) ; count ++ ; }", "nl": "Compare elements on left and right of crossover point to find the k closest elements"}
{"code": "while ( count < k && l >= 0 ) { System . out . print ( arr [ l -- ] + \" \u2581 \" ) ; count ++ ; }", "nl": "If there are no more elements on right side , then print left elements"}
{"code": "while ( count < k && r < n ) { System . out . print ( arr [ r ++ ] + \" \u2581 \" ) ; count ++ ; } }", "nl": "If there are no more elements on left side , then print right elements"}
{"code": "public static void main ( String args [ ] ) { KClosest ob = new KClosest ( ) ; int arr [ ] = { 12 , 16 , 22 , 30 , 35 , 39 , 42 , 45 , 48 , 50 , 53 , 55 , 56 } ; int n = arr . length ; int x = 35 , k = 4 ; ob . printKclosest ( arr , x , 4 , n ) ; } }", "nl": "Driver program to check above functions"}
{"code": "public class LinkedlistIS { node head ; node sorted ; class node { int val ; node next ; public node ( int val ) { this . val = val ; } }", "nl": "Java program to sort link list using insertion sort"}
{"code": "void push ( int val ) {", "nl": "A utility function to insert a node at the beginning of linked list"}
{"code": "node newnode = new node ( val ) ;", "nl": "allocate node"}
{"code": "newnode . next = head ;", "nl": "link the old list off the new node"}
{"code": "head = newnode ; }", "nl": "move the head to point to the new node"}
{"code": "void insertionSort ( node headref ) {", "nl": "function to sort a singly linked list using insertion sort"}
{"code": "sorted = null ; node current = headref ;", "nl": "Initialize sorted linked list"}
{"code": "while ( current != null ) {", "nl": "Traverse the given linked list and insert every node to sorted"}
{"code": "node next = current . next ;", "nl": "Store next for next iteration"}
{"code": "sortedInsert ( current ) ;", "nl": "insert current in sorted linked list"}
{"code": "current = next ; }", "nl": "Update current"}
{"code": "head = sorted ; }", "nl": "Update head_ref to point to sorted linked list"}
{"code": "void sortedInsert ( node newnode ) {", "nl": "* function to insert a new_node in a list . Note that * this function expects a pointer to head_ref as this * can modify the head of the input linked list * ( similar to push ( ) )"}
{"code": "if ( sorted == null sorted . val >= newnode . val ) { newnode . next = sorted ; sorted = newnode ; } else { node current = sorted ;", "nl": "Special case for the head end"}
{"code": "while ( current . next != null && current . next . val < newnode . val ) { current = current . next ; } newnode . next = current . next ; current . next = newnode ; } }", "nl": "Locate the node before the point of insertion"}
{"code": "void printlist ( node head ) { while ( head != null ) { System . out . print ( head . val + \" \u2581 \" ) ; head = head . next ; } }", "nl": "Function to print linked list"}
{"code": "public static void main ( String [ ] args ) { LinkedlistIS list = new LinkedlistIS ( ) ; list . push ( 5 ) ; list . push ( 20 ) ; list . push ( 4 ) ; list . push ( 3 ) ; list . push ( 30 ) ; System . out . println ( \" Linked \u2581 List \u2581 before \u2581 Sorting . . \" ) ; list . printlist ( list . head ) ; list . insertionSort ( list . head ) ; System . out . println ( \" LinkedList After sorting \"); list . printlist ( list . head ) ; } }", "nl": "Driver program to test above functions"}
{"code": "public static int count ( int S [ ] , int m , int n ) {", "nl": "Dynamic Programming Java implementation of Coin Change problem"}
{"code": "int table [ ] = new int [ n + 1 ] ;", "nl": "table [ i ] will be storing the number of solutions for value i . We need n + 1 rows as the table is constructed in bottom up manner using the base case ( n = 0 )"}
{"code": "table [ 0 ] = 1 ;", "nl": "Base case ( If given value is 0 )"}
{"code": "for ( int i = 0 ; i < m ; i ++ ) for ( int j = S [ i ] ; j <= n ; j ++ ) table [ j ] += table [ j - S [ i ] ] ; return table [ n ] ; }", "nl": "Pick all coins one by one and update the table [ ] values after the index greater than or equal to the value of the picked coin"}
{"code": "import java . io . * ; import java . util . * ; class GFG { static int [ ] [ ] dp = new int [ 100 ] [ 100 ] ;", "nl": "Java program using memoization"}
{"code": "static int matrixChainMemoised ( int [ ] p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != - 1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; } static int MatrixChainOrder ( int [ ] p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; }", "nl": "Function for matrix chain multiplication"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; for ( int [ ] row : dp ) Arrays . fill ( row , - 1 ) ; System . out . println ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \u2581 \" + MatrixChainOrder ( arr , n ) ) ; } }", "nl": "Driver Code"}
{"code": "class MatrixChainMultiplication {", "nl": "Dynamic Programming Java implementation of Matrix Chain Multiplication . See the Cormen book for details of the following algorithm"}
{"code": "static int MatrixChainOrder ( int p [ ] , int n ) {", "nl": "Matrix Ai has dimension p [ i - 1 ] x p [ i ] for i = 1. . n"}
{"code": "int m [ ] [ ] = new int [ n ] [ n ] ; int i , j , k , L , q ;", "nl": "For simplicity of the program , one extra row and one extra column are allocated in m [ ] [ ] . 0 th row and 0 th column of m [ ] [ ] are not used"}
{"code": "for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ;", "nl": "cost is zero when multiplying one matrix ."}
{"code": "for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) {", "nl": "L is chain length ."}
{"code": "q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }", "nl": "q = cost / scalar multiplications"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 } ; int size = arr . length ; System . out . println ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \u2581 \" + MatrixChainOrder ( arr , size ) ) ; } }", "nl": "Driver code"}
{"code": "class RodCutting {", "nl": "A Naive recursive solution for Rod cutting problem"}
{"code": "static int cutRod ( int price [ ] , int n ) { if ( n <= 0 ) return 0 ; int max_val = Integer . MIN_VALUE ;", "nl": "Returns the best obtainable price for a rod of length n and price [ ] as prices of different pieces"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) max_val = Math . max ( max_val , price [ i ] + cutRod ( price , n - i - 1 ) ) ; return max_val ; }", "nl": "Recursively cut the rod in different pieces and compare different configurations"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = arr . length ; System . out . println ( \" Maximum \u2581 Obtainable \u2581 Value \u2581 is \u2581 \" + cutRod ( arr , size ) ) ; } }", "nl": "Driver program to test above functions"}
{"code": "class RodCutting {", "nl": "A Dynamic Programming solution for Rod cutting problem"}
{"code": "static int cutRod ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; val [ 0 ] = 0 ;", "nl": "Returns the best obtainable price for a rod of length n and price [ ] as prices of different pieces"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) { int max_val = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }", "nl": "Build the table val [ ] in bottom up manner and return the last entry from the table"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = arr . length ; System . out . println ( \" Maximum \u2581 Obtainable \u2581 Value \u2581 is \u2581 \" + cutRod ( arr , size ) ) ; } }", "nl": "Driver program to test above functions"}
{"code": "static int multiply ( int x , int y ) {", "nl": "function to multiply two numbers x and y"}
{"code": "if ( y == 0 ) return 0 ;", "nl": "0 multiplied with anything gives 0"}
{"code": "if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ;", "nl": "Add x one by one"}
{"code": "if ( y < 0 ) return - multiply ( x , - y ) ; return - 1 ; }", "nl": "the case where y is negative"}
{"code": "public static void main ( String [ ] args ) { System . out . print ( \"NEW_LINE\" + multiply(5, -11)); } }", "nl": "Driver code"}
{"code": "class SieveOfEratosthenes { void sieveOfEratosthenes ( int n ) {", "nl": "Java program to print all primes smaller than or equal to n using Sieve of Eratosthenes"}
{"code": "boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) {", "nl": "Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true ."}
{"code": "if ( prime [ p ] == true ) {", "nl": "If prime [ p ] is not changed , then it is a prime"}
{"code": "for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } }", "nl": "Update all multiples of p"}
{"code": "for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) System . out . print ( i + \" \u2581 \" ) ; } }", "nl": "Print all prime numbers"}
{"code": "public static void main ( String args [ ] ) { int n = 30 ; System . out . print ( \" Following \u2581 are \u2581 the \u2581 prime \u2581 numbers \u2581 \" ) ; System . out . println ( \" smaller \u2581 than \u2581 or \u2581 equal \u2581 to \u2581 \" + n ) ; SieveOfEratosthenes g = new SieveOfEratosthenes ( ) ; g . sieveOfEratosthenes ( n ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java code for Pascal 's Triangle"}
{"code": "static int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }", "nl": "binomialCoeff"}
{"code": "static void printPascal ( int n ) {", "nl": "Function to print first n lines of Pascal 's Triangle"}
{"code": "for ( int line = 0 ; line < n ; line ++ ) {", "nl": "Iterate through every line and print entries in it"}
{"code": "for ( int i = 0 ; i <= line ; i ++ ) System . out . print ( binomialCoeff ( line , i ) + \" \u2581 \" ) ; System . out . println ( ) ; } }", "nl": "Every line has number of integers equal to line number"}
{"code": "public static void main ( String args [ ] ) { int n = 7 ; printPascal ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "java program for Pascal 's Triangle"}
{"code": "public static void printPascal ( int n ) {", "nl": "A O ( n ^ 2 ) time and O ( n ^ 2 ) extra space method for Pascal 's Triangle"}
{"code": "int [ ] [ ] arr = new int [ n ] [ n ] ;", "nl": "An auxiliary array to store generated pascal triangle values"}
{"code": "for ( int line = 0 ; line < n ; line ++ ) {", "nl": "Iterate through every line and print integer ( s ) in it"}
{"code": "for ( int i = 0 ; i <= line ; i ++ ) {", "nl": "Every line has number of integers equal to line number"}
{"code": "if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ;", "nl": "First and last values in every row are 1"}
{"code": "else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; System . out . print ( arr [ line ] [ i ] ) ; } System . out . println ( \" \" ) ; } } }", "nl": "Other values are sum of values just above and left of above"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; printPascal ( n ) ; }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { public static void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) {", "nl": "Java program for Pascal ' s \u2581 Triangle \u2581 A \u2581 O ( n ^ 2 ) \u2581 time \u2581 and \u2581 O ( 1 ) \u2581 extra \u2581 space \u2581 method \u2581 for \u2581 Pascal ' s Triangle"}
{"code": "int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) {", "nl": "used to represent C ( line , i )"}
{"code": "System . out . print ( C + \" \u2581 \" ) ; C = C * ( line - i ) / i ; } System . out . println ( ) ; } }", "nl": "The first value in a line is always 1"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; printPascal ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static int Add ( int x , int y ) {", "nl": "Java Program to add two numbers without using arithmetic operator"}
{"code": "while ( y != 0 ) {", "nl": "Iterate till there is no carry"}
{"code": "int carry = x & y ;", "nl": "carry now contains common set bits of x and y"}
{"code": "x = x ^ y ;", "nl": "Sum of bits of x and y where at least one of the bits is not set"}
{"code": "y = carry << 1 ; } return x ; }", "nl": "Carry is shifted by one so that adding it to x gives the required sum"}
{"code": "public static void main ( String arg [ ] ) { System . out . println ( Add ( 15 , 32 ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java code for Compute modulus division by a power - of - 2 - number"}
{"code": "static int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; }", "nl": "This function will return n % d . d must be one of : 1 , 2 , 4 , 8 , 16 , 32 ,"}
{"code": "public static void main ( String [ ] args ) { int n = 6 ;", "nl": "Driver Code"}
{"code": "int d = 4 ; System . out . println ( n + \" \u2581 moduo \u2581 \" + d + \" \u2581 is \u2581 \" + getModulo ( n , d ) ) ; } }", "nl": "d must be a power of 2"}
{"code": "import java . io . * ; class countSetBits {", "nl": "Java program to Count set bits in an integer"}
{"code": "static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }", "nl": "Function to get no of set bits in binary representation of positive integer n"}
{"code": "public static void main ( String args [ ] ) { int i = 9 ; System . out . println ( countSetBits ( i ) ) ; } }", "nl": "driver program"}
{"code": "import java . io . * ; class GFG {", "nl": "Java implementation for recursive approach to find the number of set bits using Brian Kernighan Algorithm"}
{"code": "public static int countSetBits ( int n ) {", "nl": "recursive function to count set bits"}
{"code": "if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }", "nl": "base case"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver function"}
{"code": "int n = 9 ;", "nl": "get value from user"}
{"code": "System . out . println ( countSetBits ( n ) ) ; } }", "nl": "function calling"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int [ ] BitsSetTable256 = new int [ 256 ] ;", "nl": "Lookup table"}
{"code": "public static void initialize ( ) {", "nl": "Function to initialise the lookup table"}
{"code": "BitsSetTable256 [ 0 ] = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i / 2 ] ; } }", "nl": "To initially generate the table algorithmically"}
{"code": "public static int countSetBits ( int n ) { return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) ; }", "nl": "Function to return the count of set bits in n"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "initialize ( ) ; int n = 9 ; System . out . print ( countSetBits ( n ) ) ; } }", "nl": "Initialise the lookup table"}
{"code": "import java . io . * ; class GFG {", "nl": "java program to demonstrate __builtin_popcount ( )"}
{"code": "public static void main ( String [ ] args ) { System . out . println ( Integer . bitCount ( 4 ) ) ; System . out . println ( Integer . bitCount ( 15 ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int [ ] num_to_bits = new int [ ] { 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 } ;", "nl": "Java program to count set bits by pre - storing count set bits in nibbles ."}
{"code": "static int countSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ;", "nl": "Recursively get nibble of a given number and map them in the array"}
{"code": "nibble = num & 0xf ;", "nl": "Find last nibble"}
{"code": "return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; }", "nl": "Use pre - stored values to find count in last nibble plus recursively add remaining nibbles ."}
{"code": "public static void main ( String [ ] args ) { int num = 31 ; System . out . println ( countSetBitsRec ( num ) ) ; } }", "nl": "Driver code"}
{"code": "static int countSetBits ( int N ) { int count = 0 ;", "nl": "Check each bit in a number is set or not and return the total count of the set bits ."}
{"code": "for ( int i = 0 ; i < 4 * 8 ; i ++ ) { if ( ( N & ( 1 << i ) ) != 0 ) count ++ ; } return count ; }", "nl": "( 1 << i ) = pow ( 2 , i )"}
{"code": "public static void main ( String [ ] args ) { int N = 15 ; System . out . println ( countSetBits ( N ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; import java . math . BigInteger ; class GFG {", "nl": "Java program to find parity of an integer"}
{"code": "static boolean getParity ( int n ) { boolean parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }", "nl": "Function to get parity of number n . It returns 1 if n has odd parity , and returns 0 if n has even parity"}
{"code": "public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( \" Parity \u2581 of \u2581 no \u2581 \" + n + \" \u2581 = \u2581 \" + ( getParity ( n ) ? \" odd \" : \" even \" ) ) ; } }", "nl": "Driver program to test getParity ( )"}
{"code": "class GFG {", "nl": "Java Program to find whether a no is power of two"}
{"code": "static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; return ( int ) ( Math . ceil ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ) == ( int ) ( Math . floor ( ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ) ) ; }", "nl": "Function to check if x is power of 2"}
{"code": "public static void main ( String [ ] args ) { if ( isPowerOfTwo ( 31 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; if ( isPowerOfTwo ( 64 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find whether a no is power of two"}
{"code": "static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n / 2 ; } return true ; }", "nl": "Function to check if x is power of 2"}
{"code": "public static void main ( String args [ ] ) { if ( isPowerOfTwo ( 31 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; if ( isPowerOfTwo ( 64 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver program"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static boolean powerOf2 ( int n ) {", "nl": "Function which checks whether a number is a power of 2"}
{"code": "if ( n == 1 ) return true ;", "nl": "base cases '1' is the only odd number which is a power of 2 ( 2 ^ 0 )"}
{"code": "else if ( n % 2 != 0 n == 0 ) return false ;", "nl": "all other odd numbers are not powers of 2"}
{"code": "return powerOf2 ( n / 2 ) ; }", "nl": "recursive function call"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int n = 64 ;", "nl": "True"}
{"code": "int m = 12 ; if ( powerOf2 ( n ) == true ) System . out . print ( \" True \" + \"NEW_LINE\"); else System . out . print ( \" False \" + \"NEW_LINE\"); if ( powerOf2 ( m ) == true ) System . out . print ( \" True \" + \"NEW_LINE\"); else System . out . print ( \" False \" + \"NEW_LINE\"); } }", "nl": "False"}
{"code": "class Test {", "nl": "Java program to efficiently check for power for 2"}
{"code": "static boolean isPowerOfTwo ( int x ) {", "nl": "Method to check if x is power of 2"}
{"code": "return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }", "nl": "First x in the below expression is for the case when x is 0"}
{"code": "public static void main ( String [ ] args ) { System . out . println ( isPowerOfTwo ( 31 ) ? \" Yes \" : \" No \" ) ; System . out . println ( isPowerOfTwo ( 64 ) ? \" Yes \" : \" No \" ) ; } }", "nl": "Driver method"}
{"code": "import java . io . * ; class MaxRepeating {", "nl": "Java program to find the maximum repeating number"}
{"code": "static int maxRepeating ( int arr [ ] , int n , int k ) {", "nl": "Returns maximum repeating element in arr [ 0. . n - 1 ] . The array elements are in range from 0 to k - 1"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) arr [ ( arr [ i ] % k ) ] += k ;", "nl": "Iterate though input array , for every element arr [ i ] , increment arr [ arr [ i ] % k ] by k"}
{"code": "int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } }", "nl": "Find index of the maximum repeating element"}
{"code": "return result ; }", "nl": "Return index of the maximum element"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 3 , 5 , 3 , 4 , 1 , 7 } ; int n = arr . length ; int k = 8 ; System . out . println ( \" Maximum \u2581 repeating \u2581 element \u2581 is : \u2581 \" + maxRepeating ( arr , n , k ) ) ; } }", "nl": "Driver function to check for above function"}
{"code": "import java . io . * ; class GFG {", "nl": "Java Program to solve range query on array whose each element is XOR of index value and previous element ."}
{"code": "static int fun ( int x ) { int y = ( x / 4 ) * 4 ;", "nl": "function return derived formula value ."}
{"code": "int ans = 0 ; for ( int i = y ; i <= x ; i ++ ) ans ^= i ; return ans ; }", "nl": "finding xor value of range [ y ... x ]"}
{"code": "static int query ( int x ) {", "nl": "function to solve query for l and r ."}
{"code": "if ( x == 0 ) return 0 ; int k = ( x + 1 ) / 2 ;", "nl": "if l or r is 0."}
{"code": "return ( ( x %= 2 ) != 0 ) ? 2 * fun ( k ) : ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) ; } static void allQueries ( int q , int l [ ] , int r [ ] ) { for ( int i = 0 ; i < q ; i ++ ) System . out . println ( ( query ( r [ i ] ) ^ query ( l [ i ] - 1 ) ) ) ; }", "nl": "finding x is divisible by 2 or not ."}
{"code": "public static void main ( String [ ] args ) { int q = 3 ; int [ ] l = { 2 , 2 , 5 } ; int [ ] r = { 4 , 8 , 9 } ; allQueries ( q , l , r ) ; } }", "nl": "Driven Program"}
{"code": "import java . io . * ; class GFG {", "nl": "Java code Queries on XOR of greatest odd divisor of the range"}
{"code": "static void prefixXOR ( int arr [ ] , int preXOR [ ] , int n ) {", "nl": "Precompute the prefix XOR of greatest odd divisor"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { while ( arr [ i ] % 2 != 1 ) arr [ i ] /= 2 ; preXOR [ i ] = arr [ i ] ; }", "nl": "Finding the Greatest Odd divisor"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) preXOR [ i ] = preXOR [ i - 1 ] ^ preXOR [ i ] ; }", "nl": "Finding prefix XOR"}
{"code": "static int query ( int preXOR [ ] , int l , int r ) { if ( l == 0 ) return preXOR [ r ] ; else return preXOR [ r ] ^ preXOR [ l - 1 ] ; }", "nl": "Return XOR of the range"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 3 , 4 , 5 } ; int n = arr . length ; int preXOR [ ] = new int [ n ] ; prefixXOR ( arr , preXOR , n ) ; System . out . println ( query ( preXOR , 0 , 2 ) ) ; System . out . println ( query ( preXOR , 1 , 2 ) ) ; } }", "nl": "Driven Program"}
{"code": "class gfg {", "nl": "Java code to find minimum number of swaps to sort a binary array"}
{"code": "static int findMinSwaps ( int arr [ ] , int n ) {", "nl": "Function to find minimum swaps to sort an array of 0 s and 1 s ."}
{"code": "int noOfZeroes [ ] = new int [ n ] ; int i , count = 0 ;", "nl": "Array to store count of zeroes"}
{"code": "noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOfZeroes [ i ] = noOfZeroes [ i + 1 ] ; if ( arr [ i ] == 0 ) noOfZeroes [ i ] ++ ; }", "nl": "Count number of zeroes on right side of every one ."}
{"code": "for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOfZeroes [ i ] ; } return count ; }", "nl": "Count total number of swaps by adding number of zeroes on right side of every one ."}
{"code": "public static void main ( String args [ ] ) { int ar [ ] = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; System . out . println ( findMinSwaps ( ar , ar . length ) ) ; } }", "nl": "Driver Code"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; System . out . println ( minswaps ( arr , 9 ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Recursive approach to check if an Array is sorted or not"}
{"code": "static boolean arraySortedOrNot ( int arr [ ] , int n ) {", "nl": "Function that returns true if array is sorted in non - decreasing order ."}
{"code": "if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ )", "nl": "Array has one or no element"}
{"code": "if ( arr [ i - 1 ] > arr [ i ] ) return false ;", "nl": "Unsorted pair found"}
{"code": "return true ; }", "nl": "No unsorted pair found"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 20 , 23 , 23 , 45 , 78 , 88 } ; int n = arr . length ; if ( arraySortedOrNot ( arr , n ) ) System . out . print ( \"YesNEW_LINE\"); else System . out . print ( \"NoNEW_LINE\"); } }", "nl": "driver code"}
{"code": "import java . util . * ; class Main {", "nl": "Java program to find two odd occurring elements"}
{"code": "static void printTwoOdd ( int arr [ ] , int size ) {", "nl": "Prints two numbers that occur odd number of times . The function assumes that the array size is at least 2 and there are exactly two numbers occurring odd number of times ."}
{"code": "int xor2 = arr [ 0 ] ;", "nl": "Will hold XOR of two odd occurring elements"}
{"code": "int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ;", "nl": "Will have only single set bit of xor2"}
{"code": "for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ;", "nl": "Get the xor of all elements in arr [ ] . The xor will basically be xor of two odd occurring elements"}
{"code": "set_bit_no = xor2 & ~ ( xor2 - 1 ) ;", "nl": "Get one set bit in the xor2 . We get rightmost set bit in the following line as it is easy to get"}
{"code": "for ( i = 0 ; i < size ; i ++ ) {", "nl": "Now divide elements in two sets : 1 ) The elements having the corresponding bit as 1. 2 ) The elements having the corresponding bit as 0."}
{"code": "if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ;", "nl": "XOR of first set is finally going to hold one odd occurring number x"}
{"code": "else y = y ^ arr [ i ] ; } System . out . println ( \" The \u2581 two \u2581 ODD \u2581 elements \u2581 are \u2581 \" + x + \" \u2581 & \u2581 \" + y ) ; }", "nl": "XOR of second set is finally going to hold the other odd occurring number y"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = arr . length ; printTwoOdd ( arr , arr_size ) ; } }", "nl": "main function"}
{"code": "import java . io . * ; class PairDifference {", "nl": "Java program to find a pair with the given difference"}
{"code": "static boolean findPair ( int arr [ ] , int n ) { int size = arr . length ;", "nl": "The function assumes that the array is sorted"}
{"code": "int i = 0 , j = 1 ;", "nl": "Initialize positions of two elements"}
{"code": "while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { System . out . print ( \" Pair \u2581 Found : \u2581 \" + \" ( \u2581 \" + arr [ i ] + \" , \u2581 \" + arr [ j ] + \" \u2581 ) \" ) ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } System . out . print ( \" No \u2581 such \u2581 pair \" ) ; return false ; }", "nl": "Search for a pair"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 8 , 30 , 40 , 100 } ; int n = 60 ; findPair ( arr , n ) ; } }", "nl": "Driver program to test above function"}
{"code": "import java . util . Arrays ; import java . util . Collections ; public class GfG {", "nl": "Java program to find k maximum elements of array in original order"}
{"code": "public static void printMax ( int arr [ ] , int k , int n ) {", "nl": "Function to print m Maximum elements"}
{"code": "Integer [ ] brr = new Integer [ n ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ;", "nl": "Array to store the copy of the original array"}
{"code": "Arrays . sort ( brr , Collections . reverseOrder ( ) ) ;", "nl": "Sorting the array in descending order"}
{"code": "for ( int i = 0 ; i < n ; ++ i ) if ( Arrays . binarySearch ( brr , arr [ i ] , Collections . reverseOrder ( ) ) >= 0 && Arrays . binarySearch ( brr , arr [ i ] , Collections . reverseOrder ( ) ) < k ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }", "nl": "Traversing through original array and printing all those elements that are in first k of sorted array . goo . gl / uj5RCD Please refer https : for details of Arrays . binarySearch ( )"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 50 , 8 , 45 , 12 , 25 , 40 , 84 } ; int n = arr . length ; int k = 3 ; printMax ( arr , k , n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java for printing smallest n number in order"}
{"code": "static void printSmall ( int arr [ ] , int asize , int n ) {", "nl": "Function to print smallest n numbers"}
{"code": "int [ ] copy_arr = Arrays . copyOf ( arr , asize ) ;", "nl": "Make copy of array"}
{"code": "Arrays . sort ( copy_arr ) ;", "nl": "Sort copy array"}
{"code": "for ( int i = 0 ; i < asize ; ++ i ) { if ( Arrays . binarySearch ( copy_arr , 0 , n , arr [ i ] ) > - 1 ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }", "nl": "For each arr [ i ] find whether it is a part of n - smallest with binary search"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int asize = arr . length ; int n = 5 ; printSmall ( arr , asize , n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Arrays ; class GFG {", "nl": "Java program to check if a given array can form arithmetic progression"}
{"code": "static boolean checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ;", "nl": "Returns true if a permutation of arr [ 0. . n - 1 ] can form arithmetic progression"}
{"code": "Arrays . sort ( arr ) ;", "nl": "Sort array"}
{"code": "int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }", "nl": "After sorting , difference between consecutive elements must be same ."}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 20 , 15 , 5 , 0 , 10 } ; int n = arr . length ; if ( checkIsAP ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "driver code"}
{"code": "import java . util . * ; class GFG { static int countPairs ( int a [ ] , int n ) {", "nl": "Java Code to find no . of Ways of choosing a pair with maximum difference"}
{"code": "int mn = Integer . MAX_VALUE ; int mx = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { mn = Math . min ( mn , a [ i ] ) ; mx = Math . max ( mx , a [ i ] ) ; }", "nl": "To find minimum and maximum of the array"}
{"code": "int c1 = 0 ;", "nl": "to find the count of minimum and maximum elements"}
{"code": "int c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == mn ) c1 ++ ; if ( a [ i ] == mx ) c2 ++ ; }", "nl": "Count variables"}
{"code": "if ( mn == mx ) return n * ( n - 1 ) / 2 ; else return c1 * c2 ; }", "nl": "condition for all elements equal"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 3 , 2 , 1 , 1 , 3 } ; int n = a . length ; System . out . print ( countPairs ( a , n ) ) ; } }", "nl": "Driver code"}
{"code": "class Geeks { static class Node { int data ; Node next ; }", "nl": "Java code to rearrange linked list in place"}
{"code": "static Node rearrange ( Node head ) {", "nl": "function for rearranging a linked list with high and low value ."}
{"code": "if ( head == null ) return null ;", "nl": "Base case ."}
{"code": "Node prev = head , curr = head . next ; while ( curr != null ) {", "nl": "two pointer variable ."}
{"code": "if ( prev . data > curr . data ) { int t = prev . data ; prev . data = curr . data ; curr . data = t ; }", "nl": "swap function for swapping data ."}
{"code": "if ( curr . next != null && curr . next . data > curr . data ) { int t = curr . next . data ; curr . next . data = curr . data ; curr . data = t ; } prev = curr . next ; if ( curr . next == null ) break ; curr = curr . next . next ; } return head ; }", "nl": "swap function for swapping data ."}
{"code": "static Node push ( Node head , int k ) { Node tem = new Node ( ) ; tem . data = k ; tem . next = head ; head = tem ; return head ; }", "nl": "function to insert a Node in the linked list at the beginning ."}
{"code": "static void display ( Node head ) { Node curr = head ; while ( curr != null ) { System . out . printf ( \" % d \u2581 \" , curr . data ) ; curr = curr . next ; } }", "nl": "function to display Node of linked list ."}
{"code": "public static void main ( String args [ ] ) { Node head = null ;", "nl": "Driver code"}
{"code": "head = push ( head , 7 ) ; head = push ( head , 3 ) ; head = push ( head , 8 ) ; head = push ( head , 6 ) ; head = push ( head , 9 ) ; head = rearrange ( head ) ; display ( head ) ; } }", "nl": "let create a linked list . 9 . 6 . 8 . 3 . 7"}
{"code": "import java . io . * ;", "nl": "Java implementation"}
{"code": "class Node { int data ; Node next ; Node ( int key ) { data = key ; next = null ; } }", "nl": "Creating the structure for node"}
{"code": "void printlist ( Node head ) { while ( head != null ) { System . out . print ( head . data + \" \u2581 \" ) ; if ( head . next != null ) { System . out . print ( \" - > \" ) ; } head = head . next ; } System . out . println ( ) ; }", "nl": "Function to print the list"}
{"code": "void rearrange ( Node head ) { if ( head != null ) { left = head ; reorderListUtil ( left ) ; } } void reorderListUtil ( Node right ) { if ( right == null ) { return ; } reorderListUtil ( right . next ) ;", "nl": "Function to rearrange"}
{"code": "if ( left == null ) { return ; }", "nl": "we set left = null , when we reach stop condition , so no processing required after that"}
{"code": "if ( left != right && left . next != right ) { Node temp = left . next ; left . next = right ; right . next = temp ; left = temp ; }", "nl": "Stop condition : odd case : left = right , even case : left . next = right"}
{"code": "else { if ( left . next == right ) {", "nl": "stop condition , set null to left nodes"}
{"code": "left . next . next = null ; left = null ; } else {", "nl": "even case"}
{"code": "left . next = null ; left = null ; } } }", "nl": "odd case"}
{"code": "public static void main ( String [ ] args ) { Node head = new Node ( 1 ) ; head . next = new Node ( 2 ) ; head . next . next = new Node ( 3 ) ; head . next . next . next = new Node ( 4 ) ; head . next . next . next . next = new Node ( 5 ) ; GFG gfg = new GFG ( ) ;", "nl": "Drivers Code"}
{"code": "gfg . printlist ( head ) ;", "nl": "Print original list"}
{"code": "gfg . rearrange ( head ) ;", "nl": "Modify the list"}
{"code": "gfg . printlist ( head ) ; } }", "nl": "Print modified list"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class LinkedList {", "nl": "Java program to subtract smaller valued list from larger valued list and return result as a list ."}
{"code": "static Node head ; boolean borrow ;", "nl": "head of list"}
{"code": "static class Node { int data ; Node next ; Node ( int d ) { data = d ; next = null ; } }", "nl": "Node Class"}
{"code": "int getLength ( Node node ) { int size = 0 ; while ( node != null ) { node = node . next ; size ++ ; } return size ; }", "nl": "A utility function to get length of linked list"}
{"code": "Node paddZeros ( Node sNode , int diff ) { if ( sNode == null ) return null ; Node zHead = new Node ( 0 ) ; diff -- ; Node temp = zHead ; while ( ( diff -- ) != 0 ) { temp . next = new Node ( 0 ) ; temp = temp . next ; } temp . next = sNode ; return zHead ; }", "nl": "A Utility that padds zeros in front of the Node , with the given diff"}
{"code": "Node subtractLinkedListHelper ( Node l1 , Node l2 ) { if ( l1 == null && l2 == null && borrow == false ) return null ; Node previous = subtractLinkedListHelper ( ( l1 != null ) ? l1 . next : null , ( l2 != null ) ? l2 . next : null ) ; int d1 = l1 . data ; int d2 = l2 . data ; int sub = 0 ;", "nl": "Subtract LinkedList Helper is a recursive function , move till the last Node , and subtract the digits and create the Node and return the Node . If d1 < d2 , we borrow the number from previous digit ."}
{"code": "if ( borrow ) { d1 -- ; borrow = false ; }", "nl": "if you have given the value value to next digit then reduce the d1 by 1"}
{"code": "if ( d1 < d2 ) { borrow = true ; d1 = d1 + 10 ; }", "nl": "If d1 < d2 , then borrow the number from previous digit . Add 10 to d1 and set borrow = true ;"}
{"code": "sub = d1 - d2 ;", "nl": "subtract the digits"}
{"code": "Node current = new Node ( sub ) ;", "nl": "Create a Node with sub value"}
{"code": "current . next = previous ; return current ; }", "nl": "Set the Next pointer as Previous"}
{"code": "Node subtractLinkedList ( Node l1 , Node l2 ) {", "nl": "This API subtracts two linked lists and returns the linked list which shall have the subtracted result ."}
{"code": "if ( l1 == null && l2 == null ) return null ;", "nl": "Base Case ."}
{"code": "int len1 = getLength ( l1 ) ; int len2 = getLength ( l2 ) ; Node lNode = null , sNode = null ; Node temp1 = l1 ; Node temp2 = l2 ;", "nl": "In either of the case , get the lengths of both Linked list ."}
{"code": "if ( len1 != len2 ) { lNode = len1 > len2 ? l1 : l2 ; sNode = len1 > len2 ? l2 : l1 ; sNode = paddZeros ( sNode , Math . abs ( len1 - len2 ) ) ; } else {", "nl": "If lengths differ , calculate the smaller Node and padd zeros for smaller Node and ensure both larger Node and smaller Node has equal length ."}
{"code": "while ( l1 != null && l2 != null ) { if ( l1 . data != l2 . data ) { lNode = l1 . data > l2 . data ? temp1 : temp2 ; sNode = l1 . data > l2 . data ? temp2 : temp1 ; break ; } l1 = l1 . next ; l2 = l2 . next ; } }", "nl": "If both list lengths are equal , then calculate the larger and smaller list . If 5 - 6 - 7 & 5 - 6 - 8 are linked list , then walk through linked list at last Node as 7 < 8 , larger Node is 5 - 6 - 8 and smaller Node is 5 - 6 - 7."}
{"code": "borrow = false ; return subtractLinkedListHelper ( lNode , sNode ) ; }", "nl": "After calculating larger and smaller Node , call subtractLinkedListHelper which returns the subtracted linked list ."}
{"code": "static void printList ( Node head ) { Node temp = head ; while ( temp != null ) { System . out . print ( temp . data + \" \u2581 \" ) ; temp = temp . next ; } }", "nl": "function to display the linked list"}
{"code": "public static void main ( String [ ] args ) { Node head = new Node ( 1 ) ; head . next = new Node ( 0 ) ; head . next . next = new Node ( 0 ) ; Node head2 = new Node ( 1 ) ; LinkedList ob = new LinkedList ( ) ; Node result = ob . subtractLinkedList ( head , head2 ) ; printList ( result ) ; } }", "nl": "Driver program to test above"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class LinkedList {", "nl": "Java implementation to insert node at the middle of the linked list"}
{"code": "static Node head ;", "nl": "head of list"}
{"code": "static class Node { int data ; Node next ;", "nl": "Node Class"}
{"code": "Node ( int d ) { data = d ; next = null ; } }", "nl": "Constructor to create a new node"}
{"code": "static void insertAtMid ( int x ) {", "nl": "function to insert node at the middle of the linked list"}
{"code": "if ( head == null ) head = new Node ( x ) ; else {", "nl": "if list is empty"}
{"code": "Node newNode = new Node ( x ) ; Node ptr = head ; int len = 0 ;", "nl": "get a new node"}
{"code": "while ( ptr != null ) { len ++ ; ptr = ptr . next ; }", "nl": "calculate length of the linked list , i . e , the number of nodes"}
{"code": "int count = ( ( len % 2 ) == 0 ) ? ( len / 2 ) : ( len + 1 ) / 2 ; ptr = head ;", "nl": "' count ' the number of nodes after which the new node is to be inserted"}
{"code": "while ( count -- > 1 ) ptr = ptr . next ;", "nl": "' ptr ' points to the node after which the new node is to be inserted"}
{"code": "newNode . next = ptr . next ; ptr . next = newNode ; } }", "nl": "insert the ' newNode ' and adjust the required links"}
{"code": "static void display ( ) { Node temp = head ; while ( temp != null ) { System . out . print ( temp . data + \" \u2581 \" ) ; temp = temp . next ; } }", "nl": "function to display the linked list"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver program to test above"}
{"code": "head = null ; head = new Node ( 1 ) ; head . next = new Node ( 2 ) ; head . next . next = new Node ( 4 ) ; head . next . next . next = new Node ( 5 ) ; System . out . println ( \" Linked \u2581 list \u2581 before \u2581 \" + \" insertion : \u2581 \" ) ; display ( ) ; int x = 3 ; insertAtMid ( x ) ; System . out . println ( \" Linked list after \" + \u2581 \" insertion : \"); display ( ) ; } }", "nl": "Creating the list 1.2 . 4.5"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class LinkedList {", "nl": "Java implementation to insert node at the middle of the linked list"}
{"code": "static Node head ;", "nl": "head of list"}
{"code": "static class Node { int data ; Node next ; Node ( int d ) { data = d ; next = null ; } }", "nl": "Node Class"}
{"code": "static void insertAtMid ( int x ) {", "nl": "function to insert node at the middle of the linked list"}
{"code": "if ( head == null ) head = new Node ( x ) ; else {", "nl": "if list is empty"}
{"code": "Node newNode = new Node ( x ) ;", "nl": "get a new node"}
{"code": "Node slow = head ; Node fast = head . next ; while ( fast != null && fast . next != null ) {", "nl": "assign values to the slow and fast pointers"}
{"code": "slow = slow . next ;", "nl": "move slow pointer to next node"}
{"code": "fast = fast . next . next ; }", "nl": "move fast pointer two nodes at a time"}
{"code": "newNode . next = slow . next ; slow . next = newNode ; } }", "nl": "insert the ' newNode ' and adjust the required links"}
{"code": "static void display ( ) { Node temp = head ; while ( temp != null ) { System . out . print ( temp . data + \" \u2581 \" ) ; temp = temp . next ; } }", "nl": "function to display the linked list"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver program to test above"}
{"code": "head = null ; head = new Node ( 1 ) ; head . next = new Node ( 2 ) ; head . next . next = new Node ( 4 ) ; head . next . next . next = new Node ( 5 ) ; System . out . println ( \" Linked \u2581 list \u2581 before \" + \" \u2581 insertion : \u2581 \" ) ; display ( ) ; int x = 3 ; insertAtMid ( x ) ; System . out . println ( \" Linked list after \" + \u2581 \" insertion : \"); display ( ) ; } }", "nl": "Creating the list 1.2 . 4.5"}
{"code": "class Solution {", "nl": "Java implementation for insertion Sort on a doubly linked list"}
{"code": "static class Node { int data ; Node prev , next ; } ;", "nl": "Node of a doubly linked list"}
{"code": "static Node getNode ( int data ) {", "nl": "function to create and return a new node of a doubly linked list"}
{"code": "Node newNode = new Node ( ) ;", "nl": "allocate node"}
{"code": "newNode . data = data ; newNode . prev = newNode . next = null ; return newNode ; }", "nl": "put in the data"}
{"code": "static Node sortedInsert ( Node head_ref , Node newNode ) { Node current ;", "nl": "function to insert a new node in sorted way in a sorted doubly linked list"}
{"code": "if ( head_ref == null ) head_ref = newNode ;", "nl": "if list is empty"}
{"code": "else if ( ( head_ref ) . data >= newNode . data ) { newNode . next = head_ref ; newNode . next . prev = newNode ; head_ref = newNode ; } else { current = head_ref ;", "nl": "if the node is to be inserted at the beginning of the doubly linked list"}
{"code": "while ( current . next != null && current . next . data < newNode . data ) current = current . next ;", "nl": "locate the node after which the new node is to be inserted"}
{"code": "newNode . next = current . next ;", "nl": "Make the appropriate links /"}
{"code": "if ( current . next != null ) newNode . next . prev = newNode ; current . next = newNode ; newNode . prev = current ; } return head_ref ; }", "nl": "if the new node is not inserted at the end of the list"}
{"code": "static Node insertionSort ( Node head_ref ) {", "nl": "function to sort a doubly linked list using insertion sort"}
{"code": "Node sorted = null ;", "nl": "Initialize ' sorted ' - a sorted doubly linked list"}
{"code": "Node current = head_ref ; while ( current != null ) {", "nl": "Traverse the given doubly linked list and insert every node to ' sorted '"}
{"code": "Node next = current . next ;", "nl": "Store next for next iteration"}
{"code": "current . prev = current . next = null ;", "nl": "removing all the links so as to create ' current ' as a new node for insertion"}
{"code": "sorted = sortedInsert ( sorted , current ) ;", "nl": "insert current in ' sorted ' doubly linked list"}
{"code": "current = next ; }", "nl": "Update current"}
{"code": "head_ref = sorted ; return head_ref ; }", "nl": "Update head_ref to point to sorted doubly linked list"}
{"code": "static void printList ( Node head ) { while ( head != null ) { System . out . print ( head . data + \" \u2581 \" ) ; head = head . next ; } }", "nl": "function to print the doubly linked list"}
{"code": "static Node push ( Node head_ref , int new_data ) {", "nl": "function to insert a node at the beginning of the doubly linked list"}
{"code": "Node new_node = new Node ( ) ;", "nl": "allocate node /"}
{"code": "new_node . data = new_data ;", "nl": "put in the data /"}
{"code": "new_node . next = ( head_ref ) ; new_node . prev = null ;", "nl": "Make next of new node as head and previous as null /"}
{"code": "if ( ( head_ref ) != null ) ( head_ref ) . prev = new_node ;", "nl": "change prev of head node to new node /"}
{"code": "( head_ref ) = new_node ; return head_ref ; }", "nl": "move the head to point to the new node /"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver code"}
{"code": "Node head = null ;", "nl": "start with the empty doubly linked list /"}
{"code": "head = push ( head , 9 ) ; head = push ( head , 3 ) ; head = push ( head , 5 ) ; head = push ( head , 10 ) ; head = push ( head , 12 ) ; head = push ( head , 8 ) ; System . out . println ( \"Doubly Linked List Before SortingNEW_LINE\"); printList ( head ) ; head = insertionSort ( head ) ; System . out . println ( \" Doubly Linked List After Sorting \"); printList ( head ) ; } }", "nl": "insert the following data"}
{"code": "class GFG {", "nl": "Java program to print all possible rotations of the given array"}
{"code": "static int arr [ ] = new int [ 10000 ] ;", "nl": "Global declaration of array"}
{"code": "public static void reverse ( int arr [ ] , int s , int e ) { while ( s < e ) { int tem = arr [ s ] ; arr [ s ] = arr [ e ] ; arr [ e ] = tem ; s = s + 1 ; e = e - 1 ; } }", "nl": "Function to reverse array between indices s and e"}
{"code": "public static void fun ( int arr [ ] , int k ) { int n = 4 - 1 ; int v = n - k ; if ( v >= 0 ) { reverse ( arr , 0 , v ) ; reverse ( arr , v + 1 , n ) ; reverse ( arr , 0 , n ) ; } }", "nl": "Function to generate all possible rotations of array"}
{"code": "public static void main ( String args [ ] ) { arr [ 0 ] = 1 ; arr [ 1 ] = 2 ; arr [ 2 ] = 3 ; arr [ 3 ] = 4 ; for ( int i = 0 ; i < 4 ; i ++ ) { fun ( arr , i ) ; System . out . print ( \" [ \" ) ; for ( int j = 0 ; j < 4 ; j ++ ) { System . out . print ( arr [ j ] + \" , \u2581 \" ) ; } System . out . print ( \" ] \" ) ; } } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static int MAX = 100005 ;", "nl": "Java program to find Bitwise OR of two equal halves of an array after performing K right circular shifts"}
{"code": "static int [ ] seg = new int [ 4 * MAX ] ;", "nl": "Array for storing the segment tree"}
{"code": "static void build ( int node , int l , int r , int a [ ] ) { if ( l == r ) seg [ node ] = a [ l ] ; else { int mid = ( l + r ) / 2 ; build ( 2 * node , l , mid , a ) ; build ( 2 * node + 1 , mid + 1 , r , a ) ; seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) ; } }", "nl": "Function to build the segment tree"}
{"code": "static int query ( int node , int l , int r , int start , int end , int a [ ] ) {", "nl": "Function to return the OR of elements in the range [ l , r ]"}
{"code": "if ( l > end r < start ) return 0 ; if ( start <= l && r <= end ) return seg [ node ] ;", "nl": "Check for out of bound condition"}
{"code": "int mid = ( l + r ) / 2 ;", "nl": "Find middle of the range"}
{"code": "return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) ; }", "nl": "Recurse for all the elements in array"}
{"code": "static void orsum ( int a [ ] , int n , int q , int k [ ] ) {", "nl": "Function to find the OR sum"}
{"code": "build ( 1 , 0 , n - 1 , a ) ;", "nl": "Function to build the segment Tree"}
{"code": "for ( int j = 0 ; j < q ; j ++ ) {", "nl": "Loop to handle q queries"}
{"code": "int i = k [ j ] % ( n / 2 ) ;", "nl": "Effective number of right circular shifts"}
{"code": "int sec = query ( 1 , 0 , n - 1 , n / 2 - i , n - i - 1 , a ) ;", "nl": "OR of second half of the array [ n / 2 - i , n - 1 - i ]"}
{"code": "int first = ( query ( 1 , 0 , n - 1 , 0 , n / 2 - 1 - i , a ) | query ( 1 , 0 , n - 1 , n - i , n - 1 , a ) ) ; int temp = sec + first ;", "nl": "OR of first half of the array [ n - i , n - 1 ] OR [ 0 , n / 2 - 1 - i ]"}
{"code": "System . out . print ( temp + \"NEW_LINE\"); } }", "nl": "Print final answer to the query"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 7 , 44 , 19 , 86 , 65 , 39 , 75 , 101 } ; int n = a . length ; int q = 2 ; int k [ ] = { 4 , 2 } ; orsum ( a , n , q , k ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program of the above approach"}
{"code": "static void maximumEqual ( int a [ ] , int b [ ] , int n ) {", "nl": "Function that prints maximum equal elements"}
{"code": "int store [ ] = new int [ ( int ) 1e5 ] ;", "nl": "Vector to store the index of elements of array b"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { store [ b [ i ] ] = i + 1 ; }", "nl": "Storing the positions of array B"}
{"code": "int ans [ ] = new int [ ( int ) 1e5 ] ;", "nl": "frequency array to keep count of elements with similar difference in distances"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Iterate through all element in arr1 [ ]"}
{"code": "int d = Math . abs ( store [ a [ i ] ] - ( i + 1 ) ) ;", "nl": "Calculate number of shift required to make current element equal"}
{"code": "if ( store [ a [ i ] ] < i + 1 ) { d = n - d ; }", "nl": "If d is less than 0"}
{"code": "ans [ d ] ++ ; } int finalans = 0 ;", "nl": "Store the frequency of current diff"}
{"code": "for ( int i = 0 ; i < 1e5 ; i ++ ) finalans = Math . max ( finalans , ans [ i ] ) ;", "nl": "Compute the maximum frequency stored"}
{"code": "System . out . print ( finalans + \"NEW_LINE\"); }", "nl": "Printing the maximum number of equal elements"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int A [ ] = { 6 , 7 , 3 , 9 , 5 } ; int B [ ] = { 7 , 3 , 9 , 5 , 6 } ; int size = A . length ;", "nl": "Given two arrays"}
{"code": "maximumEqual ( A , B , size ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class Array_Rotation {", "nl": "Java Implementation of Right Rotation of an Array K number of times"}
{"code": "static void RightRotate ( int a [ ] , int n , int k ) {", "nl": "Function to rightRotate array"}
{"code": "k = k % n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) {", "nl": "If rotation is greater than size of array"}
{"code": "System . out . print ( a [ n + i - k ] + \" \u2581 \" ) ; } else {", "nl": "Printing rightmost kth elements"}
{"code": "System . out . print ( a [ i - k ] + \" \u2581 \" ) ; } } System . out . println ( ) ; }", "nl": "Prints array after ' k ' elements"}
{"code": "public static void main ( String args [ ] ) { int Array [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = Array . length ; int K = 2 ; RightRotate ( Array , N , K ) ; } }", "nl": "Driver program"}
{"code": "class GFG {", "nl": "Java implementation for restoring original sort in rotated sorted array"}
{"code": "static void restoreSortedArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) {", "nl": "Function to restore the Original Sort"}
{"code": "reverse ( arr , 0 , i ) ; reverse ( arr , i + 1 , n ) ; reverse ( arr , 0 , n ) ; } } } static void reverse ( int [ ] arr , int i , int j ) { int temp ; while ( i < j ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; i ++ ; j -- ; } }", "nl": "In reverse ( ) , the first parameter is iterator to beginning element and second parameter is iterator to last element plus one ."}
{"code": "static void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }", "nl": "Function to print the Array"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n = arr . length ; restoreSortedArray ( arr , n - 1 ) ; printArray ( arr , n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation for restoring original sort in rotated sorted array using binary search"}
{"code": "static int findStartIndexOfArray ( int arr [ ] , int low , int high ) { if ( low > high ) { return - 1 ; } if ( low == high ) { return low ; } int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] ) { return mid + 1 ; } if ( arr [ mid - 1 ] > arr [ mid ] ) { return mid ; } if ( arr [ low ] > arr [ mid ] ) { return findStartIndexOfArray ( arr , low , mid - 1 ) ; } else { return findStartIndexOfArray ( arr , mid + 1 , high ) ; } }", "nl": "Function to find start index of array"}
{"code": "static void restoreSortedArray ( int arr [ ] , int n ) {", "nl": "Function to restore the Original Sort"}
{"code": "if ( arr [ 0 ] < arr [ n - 1 ] ) { return ; } int start = findStartIndexOfArray ( arr , 0 , n - 1 ) ;", "nl": "array is already sorted"}
{"code": "Arrays . sort ( arr , 0 , start ) ; Arrays . sort ( arr , start , n ) ; Arrays . sort ( arr ) ; }", "nl": "In reverse ( ) , the first parameter is iterator to beginning element and second parameter is iterator to last element plus one ."}
{"code": "static void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }", "nl": "Function to print the Array"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; restoreSortedArray ( arr , n ) ; printArray ( arr , n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; import java . io . * ; class GFG {", "nl": "Java program for Left Rotation and Right Rotation of a String"}
{"code": "static String leftrotate ( String str , int d ) { String ans = str . substring ( d ) + str . substring ( 0 , d ) ; return ans ; }", "nl": "function that rotates s towards left by d"}
{"code": "static String rightrotate ( String str , int d ) { return leftrotate ( str , str . length ( ) - d ) ; }", "nl": "function that rotates s towards right by d"}
{"code": "public static void main ( String args [ ] ) { String str1 = \" GeeksforGeeks \" ; System . out . println ( leftrotate ( str1 , 2 ) ) ; String str2 = \" GeeksforGeeks \" ; System . out . println ( rightrotate ( str2 , 2 ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to illustrate inserting a Node in a Cicular Doubly Linked list in begging , end and middle"}
{"code": "static class Node { int data ; Node next ; Node prev ; } ;", "nl": "Structure of a Node"}
{"code": "static Node insertNode ( Node start , int value ) {", "nl": "Function to insert a node at the end"}
{"code": "if ( start == null ) { Node new_node = new Node ( ) ; new_node . data = value ; new_node . next = new_node . prev = new_node ; start = new_node ; return new_node ; }", "nl": "If the list is empty , create a single node circular and doubly list"}
{"code": "Node last = ( start ) . prev ;", "nl": "Find last node /"}
{"code": "Node new_node = new Node ( ) ; new_node . data = value ;", "nl": "Create Node dynamically"}
{"code": "new_node . next = start ;", "nl": "Start is going to be next of new_node"}
{"code": "( start ) . prev = new_node ;", "nl": "Make new node previous of start"}
{"code": "new_node . prev = last ;", "nl": "Make last preivous of new node"}
{"code": "last . next = new_node ; return start ; }", "nl": "Make new node next of old last"}
{"code": "static void displayList ( Node start ) { Node temp = start ; while ( temp . next != start ) { System . out . printf ( \" % d \u2581 \" , temp . data ) ; temp = temp . next ; } System . out . printf ( \" % d \u2581 \" , temp . data ) ; }", "nl": "Function to display the circular doubly linked list"}
{"code": "static int searchList ( Node start , int search ) {", "nl": "Function to search the particular element from the list"}
{"code": "Node temp = start ;", "nl": "Declare the temp variable"}
{"code": "int count = 0 , flag = 0 , value ;", "nl": "Declare other control variable for the searching"}
{"code": "if ( temp == null ) return - 1 ; else {", "nl": "If start is null return - 1"}
{"code": "while ( temp . next != start ) {", "nl": "Move the temp pointer until , temp . next doesn 't move  start address (Circular Fashion)"}
{"code": "count ++ ;", "nl": "Increment count for location"}
{"code": "if ( temp . data == search ) { flag = 1 ; count -- ; break ; }", "nl": "If it is found raise the flag and break the loop"}
{"code": "temp = temp . next ; }", "nl": "Increment temp pointer"}
{"code": "if ( temp . data == search ) { count ++ ; flag = 1 ; }", "nl": "Check whether last element in the list content the value if contain , raise a flag and increment count"}
{"code": "if ( flag == 1 ) System . out . println ( \" \" + search \u2581 + \" found at location \"+ count); else System . out . println ( \" \" + search \u2581 + \" not found \"); } return - 1 ; }", "nl": "If flag is true , then element found , else not"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver code"}
{"code": "Node start = null ;", "nl": "Start with the empty list /"}
{"code": "start = insertNode ( start , 4 ) ;", "nl": "Insert 4. So linked list becomes 4. null"}
{"code": "start = insertNode ( start , 5 ) ;", "nl": "Insert 5. So linked list becomes 4.5"}
{"code": "start = insertNode ( start , 7 ) ;", "nl": "Insert 7. So linked list becomes 4.5 . 7"}
{"code": "start = insertNode ( start , 8 ) ;", "nl": "Insert 8. So linked list becomes 4.5 . 7.8"}
{"code": "start = insertNode ( start , 6 ) ; System . out . printf ( \" Created \u2581 circular \u2581 doubly \u2581 linked \u2581 list \u2581 is : \u2581 \" ) ; displayList ( start ) ; searchList ( start , 5 ) ; } }", "nl": "Insert 6. So linked list becomes 4.5 . 7.8 . 6"}
{"code": "class GFG {", "nl": "Java implementation to revesre a doubly circular linked list"}
{"code": "static class Node { int data ; Node next , prev ; } ;", "nl": "structure of a node of linked list"}
{"code": "static Node getNode ( int data ) { Node newNode = new Node ( ) ; newNode . data = data ; return newNode ; }", "nl": "function to create and return a new node"}
{"code": "static Node insertEnd ( Node head , Node new_node ) {", "nl": "Function to insert at the end"}
{"code": "if ( head == null ) { new_node . next = new_node . prev = new_node ; head = new_node ; return head ; }", "nl": "If the list is empty , create a single node circular and doubly list"}
{"code": "Node last = ( head ) . prev ;", "nl": "Find last node /"}
{"code": "new_node . next = head ;", "nl": "Start is going to be next of new_node"}
{"code": "( head ) . prev = new_node ;", "nl": "Make new node previous of start"}
{"code": "new_node . prev = last ;", "nl": "Make last preivous of new node"}
{"code": "last . next = new_node ; return head ; }", "nl": "Make new node next of old last"}
{"code": "static Node reverse ( Node head ) { if ( head == null ) return null ;", "nl": "Uitlity function to revesre a doubly circular linked list"}
{"code": "Node new_head = null ;", "nl": "Initialize a new head pointer"}
{"code": "Node last = head . prev ;", "nl": "get pointer to the the last node"}
{"code": "Node curr = last , prev ;", "nl": "set ' curr ' to last node"}
{"code": "while ( curr . prev != last ) { prev = curr . prev ;", "nl": "traverse list in backward direction"}
{"code": "new_head = insertEnd ( new_head , curr ) ; curr = prev ; } new_head = insertEnd ( new_head , curr ) ;", "nl": "insert ' curr ' at the end of the list starting with the ' new _ head ' pointer"}
{"code": "return new_head ; }", "nl": "head pointer of the reversed list"}
{"code": "static void display ( Node head ) { if ( head == null ) return ; Node temp = head ; System . out . print ( \" Forward \u2581 direction : \u2581 \" ) ; while ( temp . next != head ) { System . out . print ( temp . data + \" \u2581 \" ) ; temp = temp . next ; } System . out . print ( temp . data + \" \u2581 \" ) ; Node last = head . prev ; temp = last ; System . out . print ( \" Backward direction : \"); while ( temp . prev != last ) { System . out . print ( temp . data + \" \u2581 \" ) ; temp = temp . prev ; } System . out . print ( temp . data + \" \u2581 \" ) ; }", "nl": "function to display a doubly circular list in forward and backward direction"}
{"code": "public static void main ( String args [ ] ) { Node head = null ; head = insertEnd ( head , getNode ( 1 ) ) ; head = insertEnd ( head , getNode ( 2 ) ) ; head = insertEnd ( head , getNode ( 3 ) ) ; head = insertEnd ( head , getNode ( 4 ) ) ; head = insertEnd ( head , getNode ( 5 ) ) ; System . out . print ( \"Current list:NEW_LINE\"); display ( head ) ; head = reverse ( head ) ; System . out . print ( \" Reversed list : \"); display ( head ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG { static int MAXN = 1001 ;", "nl": "Naive Java implementation to find LCA in a tree ."}
{"code": "static int [ ] depth = new int [ MAXN ] ;", "nl": "stores depth for each node"}
{"code": "static int [ ] parent = new int [ MAXN ] ; @ SuppressWarnings ( \" unchecked \" ) static Vector < Integer > [ ] adj = new Vector [ MAXN ] ; static { for ( int i = 0 ; i < MAXN ; i ++ ) adj [ i ] = new Vector < > ( ) ; } static void addEdge ( int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; } static void dfs ( int cur , int prev ) {", "nl": "stores first parent for each node"}
{"code": "parent [ cur ] = prev ;", "nl": "marking parent for each node"}
{"code": "depth [ cur ] = depth [ prev ] + 1 ;", "nl": "marking depth for each node"}
{"code": "for ( int i = 0 ; i < adj [ cur ] . size ( ) ; i ++ ) if ( adj [ cur ] . elementAt ( i ) != prev ) dfs ( adj [ cur ] . elementAt ( i ) , cur ) ; } static void preprocess ( ) {", "nl": "propogating marking down the tree"}
{"code": "depth [ 0 ] = - 1 ;", "nl": "a dummy node"}
{"code": "dfs ( 1 , 0 ) ; }", "nl": "precalclating 1 ) depth . 2 ) parent . for each node"}
{"code": "static int LCANaive ( int u , int v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) { int temp = u ; u = v ; v = temp ; } v = parent [ v ] ; return LCANaive ( u , v ) ; }", "nl": "Time Complexity : O ( Height of tree ) recursively jumps one node above till both the nodes become equal"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 1 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 4 , 8 ) ; addEdge ( 4 , 9 ) ; addEdge ( 9 , 10 ) ; addEdge ( 9 , 11 ) ; addEdge ( 7 , 12 ) ; addEdge ( 7 , 13 ) ; preprocess ( ) ; System . out . println ( \" LCA ( 11,8 ) \u2581 : \u2581 \" + LCANaive ( 11 , 8 ) ) ; System . out . println ( \" LCA ( 3,13 ) \u2581 : \u2581 \" + LCANaive ( 3 , 13 ) ) ; } }", "nl": "adding edges to the tree"}
{"code": "import java . util . * ; class GFG { static final int MAXN = 1001 ;", "nl": "Java program to find LCA using Sqrt decomposition"}
{"code": "static int block_sz ;", "nl": "block size = Math . sqrt ( height )"}
{"code": "static int [ ] depth = new int [ MAXN ] ;", "nl": "stores depth for each node"}
{"code": "static int [ ] parent = new int [ MAXN ] ;", "nl": "stores first parent for each node"}
{"code": "static int [ ] jump_parent = new int [ MAXN ] ; static Vector < Integer > [ ] adj = new Vector [ MAXN ] ; static void addEdge ( int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; } static int LCANaive ( int u , int v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) { int t = u ; u = v ; v = t ; } v = parent [ v ] ; return LCANaive ( u , v ) ; }", "nl": "stores first ancestor in previous block"}
{"code": "static void dfs ( int cur , int prev ) {", "nl": "precalculating the required parameters associated with every node"}
{"code": "depth [ cur ] = depth [ prev ] + 1 ;", "nl": "marking depth of cur node"}
{"code": "parent [ cur ] = prev ;", "nl": "marking parent of cur node"}
{"code": "if ( depth [ cur ] % block_sz == 0 )", "nl": "making jump_parent of cur node"}
{"code": "jump_parent [ cur ] = parent [ cur ] ; else", "nl": "if it is first node of the block then its jump_parent is its cur parent"}
{"code": "jump_parent [ cur ] = jump_parent [ prev ] ;", "nl": "if it is not the first node of this block then its jump_parent is jump_parent of its parent"}
{"code": "for ( int i = 0 ; i < adj [ cur ] . size ( ) ; ++ i ) if ( adj [ cur ] . get ( i ) != prev ) dfs ( adj [ cur ] . get ( i ) , cur ) ; }", "nl": "propogating the marking down the subtree"}
{"code": "static int LCASQRT ( int u , int v ) { while ( jump_parent [ u ] != jump_parent [ v ] ) { if ( depth [ u ] > depth [ v ] ) {", "nl": "using sqrt decomposition trick"}
{"code": "int t = u ; u = v ; v = t ; }", "nl": "maintaining depth [ v ] > depth [ u ]"}
{"code": "v = jump_parent [ v ] ; }", "nl": "climb to its jump parent"}
{"code": "return LCANaive ( u , v ) ; } static void preprocess ( int height ) { block_sz = ( int ) Math . sqrt ( height ) ; depth [ 0 ] = - 1 ;", "nl": "u and v have same jump_parent"}
{"code": "dfs ( 1 , 0 ) ; }", "nl": "precalclating 1 ) depth . 2 ) parent . 3 ) jump_parent for each node"}
{"code": "public static void main ( String [ ] args ) { for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ;", "nl": "Driver code"}
{"code": "addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 1 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 4 , 8 ) ; addEdge ( 4 , 9 ) ; addEdge ( 9 , 10 ) ; addEdge ( 9 , 11 ) ; addEdge ( 7 , 12 ) ; addEdge ( 7 , 13 ) ;", "nl": "adding edges to the tree"}
{"code": "int height = 4 ; preprocess ( height ) ; System . out . print ( \" LCA ( 11,8 ) \u2581 : \u2581 \" + LCASQRT ( 11 , 8 ) + \"NEW_LINE\"); System . out . print ( \" LCA ( 3,13 ) \u2581 : \u2581 \" + LCASQRT ( 3 , 13 ) + \"NEW_LINE\"); } }", "nl": "here we are directly taking height = 4 according to the given tree but we can pre - calculate height = max depth in one more dfs"}
{"code": "class GFG {", "nl": "Java implementation of the above approach"}
{"code": "public static void main ( String [ ] args ) { int N = 3 ;", "nl": "Driver Code"}
{"code": "System . out . print ( Math . pow ( 2 , N + 1 ) - 2 ) ; } }", "nl": "Formula for number of trails for N consecutive heads"}
{"code": "import java . util . * ;", "nl": "Java implementation of the above approach"}
{"code": "class GFG { static int countOfNum ( int n , int a , int b ) { int cnt_of_a , cnt_of_b , cnt_of_ab , sum ;", "nl": "Function to return the count of numbers which are divisible by both A and B in the range [ 1 , N ] in constant time"}
{"code": "cnt_of_a = n / a ;", "nl": "Compute the count of numbers divisible by A in the range [ 1 , N ]"}
{"code": "cnt_of_b = n / b ;", "nl": "Compute the count of numbers divisible by B in the range [ 1 , N ]"}
{"code": "sum = cnt_of_b + cnt_of_a ;", "nl": "Adding the counts which are divisible by A and B"}
{"code": "cnt_of_ab = n / ( a * b ) ;", "nl": "The above value might contain repeated values which are divisible by both A and B . Therefore , the count of numbers which are divisible by both A and B are found"}
{"code": "sum = sum - cnt_of_ab ; return sum ; }", "nl": "The count computed above is subtracted to compute the final count"}
{"code": "static int sumOfNum ( int n , int a , int b ) { int i ; int sum = 0 ;", "nl": "Function to return the sum of numbers which are divisible by both A and B in the range [ 1 , N ]"}
{"code": "Set < Integer > ans = new HashSet < Integer > ( ) ;", "nl": "Set to store the numbers so that the numbers are not repeated"}
{"code": "for ( i = a ; i <= n ; i = i + a ) { ans . add ( i ) ; }", "nl": "For loop to find the numbers which are divisible by A and insert them into the set"}
{"code": "for ( i = b ; i <= n ; i = i + b ) { ans . add ( i ) ; }", "nl": "For loop to find the numbers which are divisible by A and insert them into the set"}
{"code": "for ( Integer it : ans ) { sum = sum + it ; } return sum ; }", "nl": "For loop to iterate through the set and find the sum"}
{"code": "public static void main ( String [ ] args ) { int N = 88 ; int A = 11 ; int B = 8 ; int count = countOfNum ( N , A , B ) ; int sumofnum = sumOfNum ( N , A , B ) ; System . out . print ( sumofnum % count ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static double get ( double L , double R ) {", "nl": "Function to return the value of the given expression"}
{"code": "double x = 1.0 / L ;", "nl": "Value of the first term"}
{"code": "double y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; }", "nl": "Value of the last term"}
{"code": "public static void main ( String [ ] args ) { int L = 6 , R = 12 ;", "nl": "Driver code"}
{"code": "double ans = get ( L , R ) ; System . out . printf ( \" % .2f \" , ans ) ; } }", "nl": "Get the result"}
{"code": "import java . io . * ; import java . util . * ; class GFG { static int MAX = 100000 ;", "nl": "Java implementation of the approach"}
{"code": "static ArrayList < Integer > v = new ArrayList < Integer > ( ) ; public static int upper_bound ( ArrayList < Integer > ar , int k ) { int s = 0 ; int e = ar . size ( ) ; while ( s != e ) { int mid = s + e >> 1 ; if ( ar . get ( mid ) <= k ) { s = mid + 1 ; } else { e = mid ; } } if ( s == ar . size ( ) ) { return - 1 ; } return s ; }", "nl": "To store the pre - computed integers"}
{"code": "static int consecutiveOnes ( int x ) {", "nl": "Function that returns true if the binary representation of x contains consecutive 1 s"}
{"code": "int p = 0 ; while ( x > 0 ) {", "nl": "To store the previous bit"}
{"code": "if ( x % 2 == 1 && p == 1 ) { return 1 ; }", "nl": "Check whether the previous bit and the current bit are both 1"}
{"code": "p = x % 2 ;", "nl": "Update previous bit"}
{"code": "x /= 2 ; } return 0 ; }", "nl": "Go to the next bit"}
{"code": "static void preCompute ( ) {", "nl": "Function to pre - compute the valid numbers from 0 to MAX"}
{"code": "for ( int i = 0 ; i <= MAX ; i ++ ) { if ( consecutiveOnes ( i ) == 0 ) { v . add ( i ) ; } } }", "nl": "Store all the numbers which do not have consecutive 1 s"}
{"code": "static int nextValid ( int n ) {", "nl": "Function to return the minimum number greater than n which does not contain consecutive 1 s"}
{"code": "int it = upper_bound ( v , n ) ; int val = v . get ( it ) ; return val ; }", "nl": "Search for the next greater element with no consecutive 1 s"}
{"code": "static void performQueries ( int queries [ ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) { System . out . println ( nextValid ( queries [ i ] ) ) ; } }", "nl": "Function to perform the queries"}
{"code": "public static void main ( String [ ] args ) { int queries [ ] = { 4 , 6 } ; int q = queries . length ;", "nl": "Driver code"}
{"code": "preCompute ( ) ;", "nl": "Pre - compute the numbers"}
{"code": "performQueries ( queries , q ) ; } }", "nl": "Perform the queries"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int changeToOnes ( String str ) {", "nl": "Function to return the number of operations required"}
{"code": "int i , l , ctr = 0 ; l = str . length ( ) ;", "nl": "ctr will store the number of consecutive ones at the end of the given binary string"}
{"code": "for ( i = l - 1 ; i >= 0 ; i -- ) {", "nl": "Loop to find number of 1 s at the end of the string"}
{"code": "if ( str . charAt ( i ) == '1' ) ctr ++ ;", "nl": "If the current character is 1"}
{"code": "else break ; }", "nl": "If we encounter the first 0 from the LSB position then we 'll break the loop"}
{"code": "return l - ctr ; }", "nl": "Number of operations required is ( l - ctr )"}
{"code": "static String removeZeroesFromFront ( String str ) { String s ; int i = 0 ;", "nl": "Function to remove leading zeroes from the string"}
{"code": "while ( i < str . length ( ) && str . charAt ( i ) == '0' ) i ++ ;", "nl": "Loop until s [ i ] becomes not equal to 1"}
{"code": "if ( i == str . length ( ) ) s = \"0\" ;", "nl": "If we reach the end of the string , it means that string contains only 0 's"}
{"code": "else s = str . substring ( i , str . length ( ) - i ) ; return s ; }", "nl": "Return the string without leading zeros"}
{"code": "public static void main ( String [ ] args ) { String str = \"10010111\" ;", "nl": "Driver code"}
{"code": "str = removeZeroesFromFront ( str ) ; System . out . println ( changeToOnes ( str ) ) ; } }", "nl": "Removing the leading zeroes"}
{"code": "import java . util . * ; class GFG {", "nl": "Java Implementation of above approach"}
{"code": "static int MinDeletion ( int a [ ] , int n ) {", "nl": "Function to return the minimum deletions required"}
{"code": "Map < Integer , Integer > mp = new HashMap < > ( ) ;", "nl": "To store the frequency of the array elements"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( a [ i ] ) ) { mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . put ( a [ i ] , 1 ) ; } }", "nl": "Store frequency of each element"}
{"code": "int ans = 0 ; for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) {", "nl": "To store the minimum deletions required"}
{"code": "int x = i . getKey ( ) ;", "nl": "Value"}
{"code": "int frequency = i . getValue ( ) ;", "nl": "It 's frequency"}
{"code": "if ( x <= frequency ) {", "nl": "If number less than or equal to it 's frequency"}
{"code": "ans += ( frequency - x ) ; }", "nl": "Delete extra occurrences"}
{"code": "else ans += frequency ; } return ans ; }", "nl": "Delete every occurrence of x"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 } ; int n = a . length ; System . out . println ( MinDeletion ( a , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of above approach"}
{"code": "static int maxCountAB ( String s [ ] , int n ) {", "nl": "Function to find maximum number of ABs"}
{"code": "int A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String S = s [ i ] ; int L = S . length ( ) ; for ( int j = 0 ; j < L - 1 ; j ++ ) {", "nl": "variable A , B , AB for count strings that end with ' A ' but not end with ' B ' , ' B ' but does not end with ' A ' and ' B ' and ends with ' A ' respectively ."}
{"code": "if ( S . charAt ( j ) == ' A ' && S . charAt ( j + 1 ) == ' B ' ) { ans ++ ; } }", "nl": "' AB ' is already present in string before concatenate them"}
{"code": "if ( S . charAt ( 0 ) == ' B ' && S . charAt ( L - 1 ) == ' A ' ) BA ++ ;", "nl": "count of strings that begins with ' B ' and ends with 'A"}
{"code": "else if ( S . charAt ( 0 ) == ' B ' ) B ++ ;", "nl": "count of strings that begins with ' B ' but does not end with ' A '"}
{"code": "else if ( S . charAt ( L - 1 ) == ' A ' ) A ++ ; }", "nl": "count of strings that ends with ' A ' but not end with ' B '"}
{"code": "if ( BA == 0 ) ans += Math . min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + Math . min ( B , A ) ; return ans ; }", "nl": "updating the value of ans and add extra count of ' AB '"}
{"code": "public static void main ( String [ ] args ) { String s [ ] = { \" ABCA \" , \" BOOK \" , \" BAND \" } ; int n = s . length ; System . out . println ( maxCountAB ( s , n ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int MinOperations ( int n , int x , int [ ] arr ) {", "nl": "Function to return the minimum number of operations required"}
{"code": "int total = 0 ; for ( int i = 0 ; i < n ; ++ i ) {", "nl": "To store total operations required"}
{"code": "if ( arr [ i ] > x ) { int difference = arr [ i ] - x ; total = total + difference ; arr [ i ] = x ; } }", "nl": "First make all elements equal to x which are currenctly greater"}
{"code": "for ( int i = 1 ; i < n ; ++ i ) { int LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] ;", "nl": "Left scan the array"}
{"code": "if ( LeftNeigbouringSum > x ) { int current_diff = LeftNeigbouringSum - x ; arr [ i ] = Math . max ( 0 , arr [ i ] - current_diff ) ; total = total + current_diff ; } } return total ; }", "nl": "Update the current element such that neighbouring sum is < x"}
{"code": "public static void main ( String args [ ] ) { int X = 1 ; int arr [ ] = { 1 , 6 , 1 , 2 , 0 , 4 } ; int N = arr . length ; System . out . println ( MinOperations ( N , X , arr ) ) ; } }", "nl": "Driver code"}
{"code": "public class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void findNumbers ( int arr [ ] , int n ) {", "nl": "Function to print the required numbers"}
{"code": "int sumN = ( n * ( n + 1 ) ) / 2 ;", "nl": "Sum of first n natural numbers"}
{"code": "int sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ;", "nl": "Sum of squares of first n natural numbers"}
{"code": "int sum = 0 , sumSq = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq += Math . pow ( arr [ i ] , 2 ) ; } int B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; int A = sum - sumN + B ; System . out . println ( \" A \u2581 = \u2581 \" + A + \" B = \" + B); }", "nl": "To store the sum and sum of squares of the array elements"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 } ; int n = arr . length ; findNumbers ( arr , n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Arrays ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static boolean is_prefix ( String temp , String str ) {", "nl": "Function to find the whether the string temp starts with str or not"}
{"code": "if ( temp . length ( ) < str . length ( ) ) return false ; else {", "nl": "Base Case"}
{"code": "for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) != temp . charAt ( i ) ) return false ; } return true ; } }", "nl": "Check for the corresponding characters in temp & str"}
{"code": "static String lexicographicallyString ( String [ ] input , int n , String str ) {", "nl": "Function to find lexicographic smallest string consisting of the string str as prefix"}
{"code": "Arrays . sort ( input ) ; for ( int i = 0 ; i < n ; i ++ ) { String temp = input [ i ] ;", "nl": "Sort the given array string arr [ ]"}
{"code": "if ( is_prefix ( temp , str ) ) { return temp ; } }", "nl": "If the i - th string contains given string as a prefix , then print the result"}
{"code": "return \" - 1\" ; }", "nl": "If no string exists then return \" - 1\""}
{"code": "public static void main ( String args [ ] ) { String [ ] arr = { \" apple \" , \" appe \" , \" apl \" , \" aapl \" , \" appax \" } ; String S = \" app \" ; int N = 5 ; System . out . println ( lexicographicallyString ( arr , N , S ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; public class GFG {", "nl": "Java program for the above approach"}
{"code": "static void Rearrange ( int arr [ ] , int K , int N ) {", "nl": "Function to rearrange the array"}
{"code": "int ans [ ] = new int [ N + 1 ] ;", "nl": "Stores the rearranged array"}
{"code": "int f = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { ans [ i ] = - 1 ; }", "nl": "Stores whether the arrangement is possible or not"}
{"code": "for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == K ) { K = i ; break ; } }", "nl": "Update K with the position of K"}
{"code": "Vector < Integer > smaller = new Vector < Integer > ( ) ; Vector < Integer > greater = new Vector < Integer > ( ) ;", "nl": "Stores all elements lesser than and greater than in vector smaller and greater respectively"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array arr [ ]"}
{"code": "if ( arr [ i ] < arr [ K ] ) smaller . add ( arr [ i ] ) ;", "nl": "If arr [ i ] is less than arr [ K ]"}
{"code": "else if ( arr [ i ] > arr [ K ] ) greater . add ( arr [ i ] ) ; } int low = 0 , high = N - 1 ;", "nl": "Else"}
{"code": "while ( low <= high ) {", "nl": "Iterate unil low is less than or equal to high"}
{"code": "int mid = ( low + high ) / 2 ;", "nl": "Stores mid point"}
{"code": "if ( mid == K ) { ans [ mid ] = arr [ K ] ; f = 1 ; break ; }", "nl": "If mid is equal to K"}
{"code": "else if ( mid < K ) { if ( smaller . size ( ) == 0 ) { break ; } ans [ mid ] = smaller . lastElement ( ) ; smaller . remove ( smaller . size ( ) - 1 ) ; low = mid + 1 ; }", "nl": "If mid is less than K"}
{"code": "else { if ( greater . size ( ) == 0 ) { break ; } ans [ mid ] = greater . lastElement ( ) ; greater . remove ( greater . size ( ) - 1 ) ; high = mid - 1 ; } }", "nl": "If mid is greater than K"}
{"code": "if ( f == - 1 ) { System . out . println ( - 1 ) ; return ; }", "nl": "If f is - 1"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Iterate in the range [ 1 , N ]"}
{"code": "if ( ans [ i ] == - 1 ) { if ( smaller . size ( ) > 0 ) { ans [ i ] = smaller . lastElement ( ) ; smaller . remove ( smaller . size ( ) - 1 ) ; } else if ( greater . size ( ) > 0 ) { ans [ i ] = greater . lastElement ( ) ; greater . remove ( greater . size ( ) - 1 ) ; } } }", "nl": "If ans [ i ] is equal to - 1"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) System . out . print ( ans [ i ] + \" \u2581 \" ) ; System . out . println ( ) ; }", "nl": "Print the rearranged array"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver code"}
{"code": "int arr [ ] = { 10 , 7 , 2 , 5 , 3 , 8 } ; int K = 7 ; int N = arr . length ;", "nl": "Input"}
{"code": "Rearrange ( arr , K , N ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void minimumK ( ArrayList < Integer > arr , int M , int N ) {", "nl": "Function to find minimum value of K such that the first person gets at least ( N / ( M + 1 ) ) candies"}
{"code": "int good = ( int ) ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) + 1 ;", "nl": "Find the minimum required value of candies for the first person"}
{"code": "for ( int i = 1 ; i <= N ; i ++ ) { int K = i ;", "nl": "Iterate K from [ 1 , n ]"}
{"code": "int candies = N ;", "nl": "Total number of candies"}
{"code": "int taken = 0 ; while ( candies > 0 ) {", "nl": "Candies taken by Person 1"}
{"code": "taken += Math . min ( K , candies ) ; candies -= Math . min ( K , candies ) ;", "nl": "Candies taken by 1 st person is minimum of K and candies left"}
{"code": "for ( int j = 0 ; j < M ; j ++ ) {", "nl": "Traverse the array arr [ ]"}
{"code": "int consume = ( arr . get ( j ) * candies ) / 100 ;", "nl": "Amount consumed by the person j"}
{"code": "candies -= consume ; } }", "nl": "Update the number of candies"}
{"code": "if ( taken >= good ) { System . out . print ( i ) ; return ; } } }", "nl": "Good share of candies achieved"}
{"code": "public static void main ( String [ ] args ) { int N = 13 , M = 1 ; ArrayList < Integer > arr = new ArrayList < Integer > ( ) ; arr . add ( 50 ) ; minimumK ( arr , M , N ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static boolean check ( int K , int n , int m , ArrayList < Integer > arr , int good_share ) { int candies = n , taken = 0 ; while ( candies > 0 ) {", "nl": "Function to check if the value of mid gives at least ( N / ( M + 1 ) ) candies or not"}
{"code": "taken += Math . min ( K , candies ) ; candies -= Math . min ( K , candies ) ;", "nl": "Candies taken by 1 st person is minimum of K and candies left"}
{"code": "for ( int j = 0 ; j < m ; j ++ ) {", "nl": "Traverse the given array"}
{"code": "int consume = ( arr . get ( j ) * candies ) / 100 ;", "nl": "Amount consumed by person j"}
{"code": "candies -= consume ; } }", "nl": "Update the count of candies"}
{"code": "return ( taken >= good_share ) ; }", "nl": "Check if person 1 gets the good share of candies"}
{"code": "static void minimumK ( ArrayList < Integer > arr , int N , int M ) {", "nl": "Function to find minimum value of K such that the first person gets at least ( N / ( M + 1 ) ) candies"}
{"code": "int good_share = ( int ) Math . ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) ; int lo = 1 , hi = N ;", "nl": "Find the minimum required value of candies for the first person"}
{"code": "while ( lo < hi ) {", "nl": "Iterate until low is less than or equal to mid"}
{"code": "int mid = ( lo + hi ) / 2 ;", "nl": "Find the value of mid"}
{"code": "if ( check ( mid , N , M , arr , good_share ) ) {", "nl": "Check for mid , whether it can be the possible value of K or not"}
{"code": "hi = mid ; }", "nl": "Update the value of hi"}
{"code": "else { lo = mid + 1 ; } }", "nl": "Otherwise , update the value of lo"}
{"code": "System . out . print ( hi ) ; }", "nl": "Print the resultant minimum value of K"}
{"code": "public static void main ( String [ ] args ) { int N = 13 , M = 1 ; ArrayList < Integer > arr = new ArrayList < Integer > ( ) ; arr . add ( 50 ) ; minimumK ( arr , N , M ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for above approach"}
{"code": "static void calcTotalTime ( String path ) {", "nl": "Function to calculate time taken to travel the path"}
{"code": "int time = 0 ;", "nl": "Stores total time"}
{"code": "int x = 0 , y = 0 ;", "nl": "Initial position"}
{"code": "Set < String > s = new HashSet < > ( ) ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { int p = x ; int q = y ; if ( path . charAt ( i ) == ' N ' ) y ++ ; else if ( path . charAt ( i ) == ' S ' ) y -- ; else if ( path . charAt ( i ) == ' E ' ) x ++ ; else if ( path . charAt ( i ) == ' W ' ) x -- ;", "nl": "Stores visited segments"}
{"code": "String o = ( p + x ) + \" \u2581 \" + ( q + y ) ; if ( ! s . contains ( o ) ) {", "nl": "Check whether segment is present in the set"}
{"code": "time += 2 ;", "nl": "Increment the value of time by 2"}
{"code": "s . add ( o ) ; } else time += 1 ; }", "nl": "Insert segment into the set"}
{"code": "System . out . println ( time ) ; }", "nl": "Print the value of time"}
{"code": "public static void main ( String [ ] args ) { String path = \" NSE \" ; calcTotalTime ( path ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static int findCost ( int [ ] A , int N ) {", "nl": "Function to calculate the cost required to make all array elements equal to 1"}
{"code": "int totalCost = 0 ;", "nl": "Stores the total cost"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array arr [ ]"}
{"code": "if ( A [ i ] == 0 ) {", "nl": "If current element is 0"}
{"code": "A [ i ] = 1 ;", "nl": "Convert 0 to 1"}
{"code": "totalCost += i ; } }", "nl": "Add the cost"}
{"code": "return totalCost ; }", "nl": "Return the total cost"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 1 , 0 , 1 , 0 , 1 , 0 } ; int N = arr . length ; System . out . println ( findCost ( arr , N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static int peakIndex ( int [ ] arr ) { int N = arr . length ;", "nl": "Function to find the peak index for the given array"}
{"code": "if ( arr . length < 3 ) return - 1 ; int i = 0 ;", "nl": "Base Case"}
{"code": "while ( i + 1 < N ) {", "nl": "Check for strictly increasing array"}
{"code": "if ( arr [ i + 1 ] < arr [ i ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == 0 i == N - 1 ) return - 1 ;", "nl": "If the strictly increasing condition is violated , then break"}
{"code": "int ans = i ;", "nl": "Stores the value of i , which is a potential peak index"}
{"code": "while ( i < N - 1 ) {", "nl": "Second traversal , for strictly decreasing array"}
{"code": "if ( arr [ i ] < arr [ i + 1 ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; }", "nl": "When the strictly decreasing condition is violated , then break"}
{"code": "if ( i == N - 1 ) return ans ;", "nl": "If i = N - 1 , it means that ans is the peak index"}
{"code": "return - 1 ; }", "nl": "Otherwise , peak index doesn 't exist"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 0 , 1 , 0 } ; System . out . println ( peakIndex ( arr ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void hasArrayTwoPairs ( int nums [ ] , int n , int target ) {", "nl": "Function to check if the array has 2 elements whose sum is equal to the given value"}
{"code": "Arrays . sort ( nums ) ;", "nl": "Sort the array in increasing order"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse the array , nums [ ]"}
{"code": "int x = target - nums [ i ] ;", "nl": "Store the required number to be found"}
{"code": "int low = 0 , high = n - 1 ; while ( low <= high ) {", "nl": "Perform binary search"}
{"code": "int mid = low + ( ( high - low ) / 2 ) ;", "nl": "Store the mid value"}
{"code": "if ( nums [ mid ] > x ) { high = mid - 1 ; }", "nl": "If nums [ mid ] is greater than x , then update high to mid - 1"}
{"code": "else if ( nums [ mid ] < x ) { low = mid + 1 ; }", "nl": "If nums [ mid ] is less than x , then update low to mid + 1"}
{"code": "else {", "nl": "Otherwise"}
{"code": "if ( mid == i ) { if ( ( mid - 1 >= 0 ) && nums [ mid - 1 ] == x ) { System . out . print ( nums [ i ] + \" , \u2581 \" ) ; System . out . print ( nums [ mid - 1 ] ) ; return ; } if ( ( mid + 1 < n ) && nums [ mid + 1 ] == x ) { System . out . print ( nums [ i ] + \" , \u2581 \" ) ; System . out . print ( nums [ mid + 1 ] ) ; return ; } break ; }", "nl": "If mid is equal i , check mid - 1 and mid + 1"}
{"code": "else { System . out . print ( nums [ i ] + \" , \u2581 \" ) ; System . out . print ( nums [ mid ] ) ; return ; } } } }", "nl": "Otherwise , print the pair and return"}
{"code": "System . out . print ( - 1 ) ; }", "nl": "If no such pair is found , then print - 1"}
{"code": "public static void main ( String [ ] args ) { int A [ ] = { 0 , - 1 , 2 , - 3 , 1 } ; int X = - 2 ; int N = A . length ;", "nl": "Driver Code"}
{"code": "hasArrayTwoPairs ( A , N , X ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void findClosest ( int N , int target ) { int closest = - 1 ; int diff = Integer . MAX_VALUE ;", "nl": "Function to find the divisor of N closest to the target"}
{"code": "for ( int i = 1 ; i <= ( int ) Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) {", "nl": "Iterate till square root of N"}
{"code": "if ( N / i == i ) {", "nl": "Check if divisors are equal"}
{"code": "if ( Math . abs ( target - i ) < diff ) { diff = Math . abs ( target - i ) ; closest = i ; } } else {", "nl": "Check if i is the closest"}
{"code": "if ( Math . abs ( target - i ) < diff ) { diff = Math . abs ( target - i ) ; closest = i ; }", "nl": "Check if i is the closest"}
{"code": "if ( Math . abs ( target - N / i ) < diff ) { diff = Math . abs ( target - N / i ) ; closest = N / i ; } } } }", "nl": "Check if n / i is the closest"}
{"code": "System . out . println ( closest ) ; }", "nl": "Print the closest value"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int N = 16 , X = 5 ;", "nl": "Given N & X"}
{"code": "findClosest ( N , X ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int power ( int A , int N ) {", "nl": "Function to calculate the minimum power of A and B greater than N"}
{"code": "int count = 0 ; if ( A == 1 ) return 0 ; while ( N > 0 ) {", "nl": "Stores the power of A which is greater than N"}
{"code": "count ++ ;", "nl": "Increment count by 1"}
{"code": "N /= A ; } return count ; }", "nl": "Divide N by A"}
{"code": "static void Pairs ( int N , int A , int B ) { int powerA , powerB ;", "nl": "Function to find a pair ( a , b ) such that A ^ a + B ^ b = N"}
{"code": "powerA = power ( A , N ) ;", "nl": "Calculate the minimum power of A greater than N"}
{"code": "powerB = power ( B , N ) ;", "nl": "Calculate the minimum power of B greater than N"}
{"code": "int intialB = B , intialA = A ;", "nl": "Make copy of A and B"}
{"code": "A = 1 ; for ( int i = 0 ; i <= powerA ; i ++ ) { B = 1 ; for ( int j = 0 ; j <= powerB ; j ++ ) {", "nl": "Traverse for every pair ( i , j )"}
{"code": "if ( B == N - A ) { System . out . println ( i + \" \u2581 \" + j ) ; return ; }", "nl": "Check if B ^ j + A ^ i = N To overcome the overflow problem use B = N - A rather than B + A = N"}
{"code": "B *= intialB ; }", "nl": "Increment power B by 1"}
{"code": "A *= intialA ; }", "nl": "Increment power A by 1"}
{"code": "System . out . println ( \" - 1\" ) ; return ; }", "nl": "Finally print - 1 if no pair is found"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "int N = 106 , A = 3 , B = 5 ;", "nl": "Given A , B and N"}
{"code": "Pairs ( N , A , B ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static int findNonMultiples ( int [ ] arr , int n , int k ) {", "nl": "Function to find the non - multiples till k"}
{"code": "Set < Integer > multiples = new HashSet < Integer > ( ) ;", "nl": "Stores all unique multiples"}
{"code": "for ( int i = 0 ; i < n ; ++ i ) {", "nl": "Iterate the array"}
{"code": "if ( ! multiples . contains ( arr [ i ] ) ) {", "nl": "For finding duplicates only once"}
{"code": "for ( int j = 1 ; j <= k / arr [ i ] ; j ++ ) { multiples . add ( arr [ i ] * j ) ; } } }", "nl": "Inserting all multiples into the set"}
{"code": "return k - multiples . size ( ) ; }", "nl": "Returning only the count of numbers that are not divisible by any of the array elements"}
{"code": "public static int countValues ( int [ ] arr , int N , int L , int R ) {", "nl": "Function to count the total values in the range [ L , R ]"}
{"code": "return findNonMultiples ( arr , N , R ) - findNonMultiples ( arr , N , L - 1 ) ; }", "nl": "Count all values in the range using exclusion principle"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 5 , 6 } ; int N = arr . length ; int L = 1 ; int R = 20 ;", "nl": "Driver code"}
{"code": "System . out . println ( countValues ( arr , N , L , R ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void minCollectingSpeed ( int [ ] piles , int H ) {", "nl": "Function to find the minimum number of coins to be collected per hour to empty N piles in H hours"}
{"code": "int ans = - 1 ; int low = 1 , high ;", "nl": "Stores the minimum coins to be removed per hour"}
{"code": "high = Arrays . stream ( piles ) . max ( ) . getAsInt ( ) ;", "nl": "Find the maximum array element"}
{"code": "while ( low <= high ) {", "nl": "Perform Binary Search"}
{"code": "int K = low + ( high - low ) / 2 ; int time = 0 ;", "nl": "Store the mid value of the range in K"}
{"code": "for ( int ai : piles ) { time += ( ai + K - 1 ) / K ; }", "nl": "Find the total time taken to empty N piles by removing K coins per hour"}
{"code": "if ( time <= H ) { ans = K ; high = K - 1 ; }", "nl": "If total time does not exceed H"}
{"code": "else { low = K + 1 ; } }", "nl": "Otherwise"}
{"code": "System . out . print ( ans ) ; }", "nl": "Print the required result"}
{"code": "static public void main ( String args [ ] ) { int [ ] arr = { 3 , 6 , 7 , 11 } ; int H = 8 ;", "nl": "Driver Code"}
{"code": "minCollectingSpeed ( arr , H ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int cntDisPairs ( int arr [ ] , int N , int K ) {", "nl": "Function to count distinct pairs in array whose sum equal to K"}
{"code": "int cntPairs = 0 ;", "nl": "Stores count of distinct pairs whose sum equal to K"}
{"code": "Arrays . sort ( arr ) ;", "nl": "Sort the array"}
{"code": "int i = 0 ;", "nl": "Stores index of the left pointer"}
{"code": "int j = N - 1 ;", "nl": "Stores index of the right pointer"}
{"code": "while ( i < j ) {", "nl": "Calculate count of distinct pairs whose sum equal to K"}
{"code": "if ( arr [ i ] + arr [ j ] == K ) {", "nl": "If sum of current pair is equal to K"}
{"code": "while ( i < j && arr [ i ] == arr [ i + 1 ] ) {", "nl": "Remove consecutive duplicate array elements"}
{"code": "i ++ ; }", "nl": "Update i"}
{"code": "while ( i < j && arr [ j ] == arr [ j - 1 ] ) {", "nl": "Remove consecutive duplicate array elements"}
{"code": "j -- ; }", "nl": "Update j"}
{"code": "cntPairs += 1 ;", "nl": "Update cntPairs"}
{"code": "i ++ ;", "nl": "Update i"}
{"code": "j -- ; }", "nl": "Update j"}
{"code": "else if ( arr [ i ] + arr [ j ] < K ) {", "nl": "if sum of current pair less than K"}
{"code": "i ++ ; } else {", "nl": "Update i"}
{"code": "j -- ; } } return cntPairs ; }", "nl": "Update j"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 5 , 7 , 7 , 8 } ; int N = arr . length ; int K = 13 ; System . out . print ( cntDisPairs ( arr , N , K ) ) ; }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int cntDisPairs ( int arr [ ] , int N , int K ) {", "nl": "Function to count distinct pairs in array whose sum equal to K"}
{"code": "int cntPairs = 0 ;", "nl": "Stores count of distinct pairs whose sum equal to K"}
{"code": "HashMap < Integer , Integer > cntFre = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Store frequency of each distinct element of the array"}
{"code": "if ( cntFre . containsKey ( arr [ i ] ) ) cntFre . put ( arr [ i ] , cntFre . get ( arr [ i ] ) + 1 ) ; else cntFre . put ( arr [ i ] , 1 ) ; }", "nl": "Update frequency of arr [ i ]"}
{"code": "for ( Map . Entry < Integer , Integer > it : cntFre . entrySet ( ) ) {", "nl": "Traverse the map"}
{"code": "int i = it . getKey ( ) ;", "nl": "Stores key value of the map"}
{"code": "if ( 2 * i == K ) {", "nl": "If i is the half of K"}
{"code": "if ( cntFre . get ( i ) > 1 ) cntPairs += 2 ; } else { if ( cntFre . containsKey ( K - i ) ) {", "nl": "If frequency of i greater than 1"}
{"code": "cntPairs += 1 ; } } }", "nl": "Update cntPairs"}
{"code": "cntPairs = cntPairs / 2 ; return cntPairs ; }", "nl": "Update cntPairs"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 5 , 7 , 7 , 8 } ; int N = arr . length ; int K = 13 ; System . out . print ( cntDisPairs ( arr , N , K ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ ] ) { for ( int i = 0 ; i < Q ; i ++ ) {", "nl": "Function to find the length of the longest subsequence such that no two adjacent elements are equal"}
{"code": "int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ;", "nl": "Replace element at index x with y"}
{"code": "arr [ x - 1 ] = y ;", "nl": "Since x is 1 - indexed , decrement x by 1"}
{"code": "int count = 1 ; for ( int j = 1 ; j < N ; j ++ ) {", "nl": "Keep track of number of elements in subsequence"}
{"code": "if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } }", "nl": "If previous element is not same as current element"}
{"code": "System . out . print ( count + \" \u2581 \" ) ; } }", "nl": "Print the desired count"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 5 , 2 } ; int N = arr . length ; int Q = 2 ; int Queries [ ] [ ] = { { 1 , 3 } , { 4 , 2 } } ;", "nl": "Driver Code"}
{"code": "longestSubsequence ( N , Q , arr , Queries ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG { static void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ ] ) { int count = 1 ;", "nl": "Java program for the above approach"}
{"code": "for ( int i = 1 ; i < N ; i ++ ) {", "nl": "Traverse the array arr [ ]"}
{"code": "if ( arr [ i ] != arr [ i - 1 ] ) { count += 1 ; } }", "nl": "If previous element is not same as current element"}
{"code": "for ( int i = 0 ; i < Q ; i ++ ) {", "nl": "Traverse the queries"}
{"code": "int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ;", "nl": "Replace element at index x with y"}
{"code": "if ( x > 1 ) {", "nl": "Recalculate for index x"}
{"code": "if ( arr [ x - 1 ] != arr [ x - 2 ] ) { count -= 1 ; }", "nl": "Subtract contribution of element at index x"}
{"code": "if ( arr [ x - 2 ] != y ) { count += 1 ; } }", "nl": "Add contribution of y"}
{"code": "if ( x < N ) {", "nl": "Recalculate for index x + 1"}
{"code": "if ( arr [ x ] != arr [ x - 1 ] ) { count -= 1 ; }", "nl": "Subtract contribution of element at index x + 1"}
{"code": "if ( y != arr [ x ] ) { count += 1 ; } } System . out . print ( count + \" \u2581 \" ) ;", "nl": "Adds contribution of y"}
{"code": "arr [ x - 1 ] = y ; } }", "nl": "Replace the element"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 1 , 1 , 2 , 5 , 2 } ; int N = arr . length ; int Q = 2 ; int Queries [ ] [ ] = { { 1 , 3 } , { 4 , 2 } } ;", "nl": "Driver Code"}
{"code": "longestSubsequence ( N , Q , arr , Queries ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void sum ( int arr [ ] , int n ) {", "nl": "Function to find sum of differences of indices of occurrences of each unique array element"}
{"code": "HashMap < Integer , Vector < Integer > > mp = new HashMap < > ( ) ;", "nl": "Stores indices of each array element"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { Vector < Integer > v = new Vector < > ( ) ; v . add ( i ) ; if ( mp . containsKey ( arr [ i ] ) ) v . addAll ( mp . get ( arr [ i ] ) ) ; mp . put ( arr [ i ] , v ) ; }", "nl": "Store the indices"}
{"code": "int [ ] ans = new int [ n ] ;", "nl": "Stores the sums"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse the array"}
{"code": "int sum = 0 ;", "nl": "Find sum for each element"}
{"code": "for ( int it : mp . get ( arr [ i ] ) ) {", "nl": "Iterate over the Map"}
{"code": "sum += Math . abs ( it - i ) ; }", "nl": "Calculate sum of occurrences of arr [ i ]"}
{"code": "ans [ i ] = sum ; }", "nl": "Store sum for current element"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + \" \u2581 \" ) ; } return ; }", "nl": "Print answer for each element"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 1 , 3 , 1 , 1 , 2 } ;", "nl": "Given array"}
{"code": "int n = arr . length ;", "nl": "Given size"}
{"code": "sum ( arr , n ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void conVowUpp ( char [ ] str ) {", "nl": "Function to convert vowels into uppercase"}
{"code": "int N = str . length ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' a ' str [ i ] == ' e ' str [ i ] == ' i ' str [ i ] == ' o ' str [ i ] == ' u ' ) { char c = Character . toUpperCase ( str [ i ] ) ; str [ i ] = c ; } } for ( char c : str ) System . out . print ( c ) ; }", "nl": "Stores the length of str"}
{"code": "public static void main ( String [ ] args ) { String str = \" eutopia \" ; conVowUpp ( str . toCharArray ( ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; static int N , P ;", "nl": "Stores the frequency of each type of chocolate"}
{"code": "static boolean helper ( int mid ) { int cnt = 0 ; for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) { int temp = i . getValue ( ) ; while ( temp >= mid ) { temp -= mid ; cnt ++ ; } }", "nl": "Function to check if chocolates can be eaten for ' mid ' no . of days"}
{"code": "return cnt >= N ; }", "nl": "If cnt exceeds N , return true"}
{"code": "static int findMaximumDays ( int arr [ ] ) {", "nl": "Function to find the maximum number of days for which chocolates can be eaten"}
{"code": "for ( int i = 0 ; i < P ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } }", "nl": "Store the frequency of each type of chocolate"}
{"code": "int start = 0 , end = P , ans = 0 ; while ( start <= end ) {", "nl": "Initialize start and end with 0 and P respectively"}
{"code": "int mid = start + ( ( end - start ) / 2 ) ;", "nl": "Calculate mid"}
{"code": "if ( mid != 0 && helper ( mid ) ) { ans = mid ;", "nl": "Check if chocolates can be distributed for mid days"}
{"code": "start = mid + 1 ; } else if ( mid == 0 ) { start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; }", "nl": "Check if chocolates can be distributed for more than mid consecutive days"}
{"code": "public static void main ( String [ ] args ) { N = 3 ; P = 10 ; int arr [ ] = { 1 , 2 , 2 , 1 , 1 , 3 , 3 , 3 , 2 , 4 } ;", "nl": "Driver code"}
{"code": "System . out . print ( findMaximumDays ( arr ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void countSubarrays ( int a [ ] , int n , int k ) {", "nl": "Function that counts the subarrays having sum modulo k equal to the length of subarray"}
{"code": "int ans = 0 ;", "nl": "Stores the count of subarrays"}
{"code": "ArrayList < Integer > pref = new ArrayList < > ( ) ; pref . add ( 0 ) ;", "nl": "Stores prefix sum of the array"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) pref . add ( ( a [ i ] + pref . get ( i ) ) % k ) ;", "nl": "Calculate prefix sum array"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) {", "nl": "Generate all the subarrays"}
{"code": "if ( ( pref . get ( j ) - pref . get ( i - 1 ) + k ) % k == j - i + 1 ) { ans ++ ; } } }", "nl": "Check if this subarray is a valid subarray or not"}
{"code": "System . out . println ( ans ) ; }", "nl": "Total count of subarrays"}
{"code": "public static void main ( String [ ] args ) throws java . lang . Exception {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 2 , 3 , 5 , 3 , 1 , 5 } ;", "nl": "Given arr [ ]"}
{"code": "int N = arr . length ;", "nl": "Size of the array"}
{"code": "int K = 4 ;", "nl": "Given K"}
{"code": "countSubarrays ( arr , N , K ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void countSubarrays ( int a [ ] , int n , int k ) {", "nl": "Function that counts the subarrays having sum modulo k equal to the length of subarray"}
{"code": "HashMap < Integer , Integer > cnt = new HashMap < > ( ) ;", "nl": "Stores the count of ( pref [ i ] - i ) % k"}
{"code": "long ans = 0 ;", "nl": "Stores the count of subarray"}
{"code": "ArrayList < Integer > pref = new ArrayList < > ( ) ; pref . add ( 0 ) ;", "nl": "Stores prefix sum of the array"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) pref . add ( ( a [ i ] + pref . get ( i ) ) % k ) ;", "nl": "Find prefix sum array"}
{"code": "cnt . put ( 0 , 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) {", "nl": "Base Condition"}
{"code": "int remIdx = i - k ; if ( remIdx >= 0 ) { if ( cnt . containsKey ( ( pref . get ( remIdx ) - remIdx % k + k ) % k ) ) cnt . put ( ( pref . get ( remIdx ) - remIdx % k + k ) % k , cnt . get ( ( pref . get ( remIdx ) - remIdx % k + k ) % k ) - 1 ) ; else cnt . put ( ( pref . get ( remIdx ) - remIdx % k + k ) % k , - 1 ) ; }", "nl": "Remove the index at present after K indices from the current index"}
{"code": "if ( cnt . containsKey ( ( pref . get ( i ) - i % k + k ) % k ) ) ans += cnt . get ( ( pref . get ( i ) - i % k + k ) % k ) ;", "nl": "Update the answer for subarrays ending at the i - th index"}
{"code": "if ( cnt . containsKey ( ( pref . get ( i ) - i % k + k ) % k ) ) cnt . put ( ( pref . get ( i ) - i % k + k ) % k , cnt . get ( ( pref . get ( i ) - i % k + k ) % k ) + 1 ) ; else cnt . put ( ( pref . get ( i ) - i % k + k ) % k , 1 ) ; }", "nl": "Add the calculated value of current index to count"}
{"code": "System . out . println ( ans ) ; }", "nl": "Print the count of subarrays"}
{"code": "public static void main ( String [ ] args ) throws java . lang . Exception {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 2 , 3 , 5 , 3 , 1 , 5 } ;", "nl": "Given arr [ ]"}
{"code": "int N = arr . length ;", "nl": "Size of the array"}
{"code": "int K = 4 ;", "nl": "Given K"}
{"code": "countSubarrays ( arr , N , K ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static boolean check ( String s , int k ) { int n = s . length ( ) ;", "nl": "Function to check if the substring of length K has equal 0 and 1"}
{"code": "for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) {", "nl": "Traverse the String"}
{"code": "if ( s . charAt ( i ) != s . charAt ( j ) ) return false ; } } int c = 0 ;", "nl": "Check if every K - th character is the same or not"}
{"code": "for ( int i = 0 ; i < k ; i ++ ) {", "nl": "Traverse subString of length K"}
{"code": "if ( s . charAt ( i ) == '0' )", "nl": "If current character is 0"}
{"code": "c ++ ;", "nl": "Increment count"}
{"code": "else", "nl": "Otherwise"}
{"code": "c -- ; }", "nl": "Decrement count"}
{"code": "if ( c == 0 ) return true ; else return false ; }", "nl": "Check for equal 0 s and 1 s"}
{"code": "public static void main ( String [ ] args ) { String s = \"101010\" ; int k = 2 ; if ( check ( s , k ) ) System . out . print ( \" Yes \" + \"NEW_LINE\"); else System . out . print ( \" No \" + \"NEW_LINE\"); } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static boolean isSame ( String str , int n ) {", "nl": "Function to check if the freq of any character is divisible by N"}
{"code": "HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( mp . containsKey ( str . charAt ( i ) - ' a ' ) ) { mp . put ( str . charAt ( i ) - ' a ' , mp . get ( str . charAt ( i ) - ' a ' ) + 1 ) ; } else { mp . put ( str . charAt ( i ) - ' a ' , 1 ) ; } } for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) {", "nl": "Stores the frequency of characters"}
{"code": "if ( ( it . getValue ( ) ) >= n ) { return true ; } }", "nl": "If frequency of a character is not divisible by n"}
{"code": "return false ; }", "nl": "If no character has frequency at least N"}
{"code": "public static void main ( String [ ] args ) { String str = \" ccabcba \" ; int n = 4 ;", "nl": "Driver Code"}
{"code": "if ( isSame ( str , n ) ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } } }", "nl": "Function Call"}
{"code": "import java . util . * ; import java . lang . * ; class GFG { static final double eps = 1e-6 ;", "nl": "Java program for the above approach"}
{"code": "static double func ( double a , double b , double c , double x ) { return a * x * x + b * x + c ; }", "nl": "Given function"}
{"code": "static double findRoot ( double a , double b , double c , double low , double high ) { double x = - 1 ;", "nl": "Function to find the root of the given non - decreasing Function"}
{"code": "while ( Math . abs ( high - low ) > eps ) {", "nl": "To get the minimum possible answer for the root"}
{"code": "x = ( low + high ) / 2 ;", "nl": "Find mid"}
{"code": "if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) { high = x ; }", "nl": "Search in [ low , x ]"}
{"code": "else { low = x ; } }", "nl": "Search in [ x , high ]"}
{"code": "return x ; }", "nl": "Return the required answer"}
{"code": "static void solve ( double a , double b , double c , double A , double B ) {", "nl": "Function to find the roots of the given equation within range [ a , b ]"}
{"code": "if ( func ( a , b , c , A ) * func ( a , b , c , B ) > 0 ) { System . out . println ( \" No \u2581 solution \" ) ; }", "nl": "If root doesn 't exists"}
{"code": "else { System . out . format ( \" % .4f \" , findRoot ( a , b , c , A , B ) ) ; } }", "nl": "Else find the root upto 4 decimal places"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "double a = 2 , b = - 3 , c = - 2 , A = 0 , B = 3 ;", "nl": "Given range"}
{"code": "solve ( a , b , c , A , B ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static boolean possible ( long mid , int [ ] a ) {", "nl": "Function check if mid can be median index of the difference array"}
{"code": "long n = a . length ;", "nl": "Size of the array"}
{"code": "long total = ( n * ( n - 1 ) ) / 2 ;", "nl": "Total possible no of pair possible"}
{"code": "long need = ( total + 1 ) / 2 ; long count = 0 ; long start = 0 , end = 1 ;", "nl": "The index of the element in the difference of all pairs from the array"}
{"code": "while ( end < n ) { if ( a [ ( int ) end ] - a [ ( int ) start ] <= mid ) { end ++ ; } else { count += ( end - start - 1 ) ; start ++ ; } }", "nl": "Count the number of pairs having difference <= mid"}
{"code": "if ( end == n && start < end && a [ ( int ) end - 1 ] - a [ ( int ) start ] <= mid ) { long t = end - start - 1 ; count += ( t * ( t + 1 ) / 2 ) ; }", "nl": "If the difference between end and first element is less then or equal to mid"}
{"code": "if ( count >= need ) return true ; else return false ; }", "nl": "Checking for the no of element less than or equal to mid is greater than median or not"}
{"code": "static long findMedian ( int [ ] a ) {", "nl": "Function to calculate the median of differences of all pairs from the array"}
{"code": "long n = a . length ;", "nl": "Size of the array"}
{"code": "long low = 0 , high = a [ ( int ) n - 1 ] - a [ 0 ] ;", "nl": "Initialising the low and high"}
{"code": "while ( low <= high ) {", "nl": "Binary search"}
{"code": "long mid = ( low + high ) / 2 ;", "nl": "Calculate mid"}
{"code": "if ( possible ( mid , a ) ) high = mid - 1 ; else low = mid + 1 ; }", "nl": "If mid can be the median of the array"}
{"code": "return high + 1 ; }", "nl": "Returning the median of the differences of pairs from the array"}
{"code": "public static void main ( String [ ] args ) { int [ ] a = { 1 , 7 , 5 , 2 } ; Arrays . sort ( a ) ; System . out . println ( findMedian ( a ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void UniversalSubset ( List < String > A , List < String > B ) {", "nl": "Function to find strings from A [ ] having all strings in B [ ] as subsequence"}
{"code": "int n1 = A . size ( ) ; int n2 = B . size ( ) ;", "nl": "Calculate respective sizes"}
{"code": "List < String > res = new ArrayList < > ( ) ;", "nl": "Stores the answer"}
{"code": "int [ ] [ ] A_fre = new int [ n1 ] [ 26 ] ; for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) A_fre [ i ] [ j ] = 0 ; }", "nl": "Stores the frequency of each character in strings of A [ ]"}
{"code": "for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < A . get ( i ) . length ( ) ; j ++ ) { A_fre [ i ] [ A . get ( i ) . charAt ( j ) - ' a ' ] ++ ; } }", "nl": "Compute the frequencies of characters of all strings"}
{"code": "int [ ] B_fre = new int [ 26 ] ; for ( int i = 0 ; i < n2 ; i ++ ) { int [ ] arr = new int [ 26 ] ; for ( int j = 0 ; j < B . get ( i ) . length ( ) ; j ++ ) { arr [ B . get ( i ) . charAt ( j ) - ' a ' ] ++ ; B_fre [ B . get ( i ) . charAt ( j ) - ' a ' ] = Math . max ( B_fre [ B . get ( i ) . charAt ( j ) - ' a ' ] , arr [ B . get ( i ) . charAt ( j ) - ' a ' ] ) ; } } for ( int i = 0 ; i < n1 ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) {", "nl": "Stores the frequency of each character in strings of B [ ] each character of a string in B [ ]"}
{"code": "if ( A_fre [ i ] [ j ] < B_fre [ j ] ) {", "nl": "If the frequency of a character in B [ ] exceeds that in A [ ]"}
{"code": "flag = 1 ; break ; } }", "nl": "A string exists in B [ ] which is not a proper subset of A [ i ]"}
{"code": "if ( flag == 0 )", "nl": "If all strings in B [ ] are proper subset of A [ ]"}
{"code": "res . add ( A . get ( i ) ) ; }", "nl": "Push the string in resultant vector"}
{"code": "if ( res . size ( ) != 0 ) {", "nl": "If any string is found"}
{"code": "for ( int i = 0 ; i < res . size ( ) ; i ++ ) { for ( int j = 0 ; j < res . get ( i ) . length ( ) ; j ++ ) System . out . print ( res . get ( i ) . charAt ( j ) ) ; } System . out . print ( \" \u2581 \" ) ; }", "nl": "Print those strings"}
{"code": "else System . out . print ( \" - 1\" ) ; }", "nl": "Otherwise"}
{"code": "public static void main ( String [ ] args ) { List < String > A = Arrays . asList ( \" geeksforgeeks \" , \" topcoder \" , \" leetcode \" ) ; List < String > B = Arrays . asList ( \" geek \" , \" ee \" ) ; UniversalSubset ( A , B ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static void findPair ( int a [ ] , int n ) {", "nl": "Function to find the minimum distance pair where one is the multiple of the other"}
{"code": "int min_dist = Integer . MAX_VALUE ; int index_a = - 1 , index_b = - 1 ;", "nl": "Initialize the variables"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Iterate for all the elements"}
{"code": "for ( int j = i + 1 ; j < n ; j ++ ) {", "nl": "Loop to make pairs"}
{"code": "if ( j - i < min_dist ) {", "nl": "Check for minimum distance"}
{"code": "if ( a [ i ] % a [ j ] == 0 a [ j ] % a [ i ] == 0 ) {", "nl": "Check if one is a multiple of other"}
{"code": "min_dist = j - i ;", "nl": "Update the distance"}
{"code": "index_a = i ; index_b = j ; } } } }", "nl": "Store indexes"}
{"code": "if ( index_a == - 1 ) { System . out . println ( \" - 1\" ) ; }", "nl": "If no such pair exists"}
{"code": "else { System . out . print ( \" ( \" + a [ index_a ] + \" , \u2581 \" + a [ index_b ] + \" ) \" ) ; } }", "nl": "Print the answer"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int a [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = a . length ;", "nl": "Given array arr [ ]"}
{"code": "findPair ( a , n ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void printNum ( int L , int R ) {", "nl": "Function to print all numbers in the range [ L , R ] having digits in strictly increasing order"}
{"code": "for ( int i = L ; i <= R ; i ++ ) { int temp = i ; int c = 10 ; int flag = 0 ;", "nl": "Iterate over the range"}
{"code": "while ( temp > 0 ) {", "nl": "Iterate over the digits"}
{"code": "if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; }", "nl": "Check if the current digit is >= the previous digit"}
{"code": "if ( flag == 0 ) System . out . print ( i + \" \u2581 \" ) ; } }", "nl": "If the digits are in ascending order"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int L = 10 , R = 15 ;", "nl": "Given range L and R"}
{"code": "printNum ( L , R ) ; } }", "nl": "Function call"}
{"code": "import java . util . Arrays ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int findMissing ( int arr [ ] , int left , int right , int diff ) {", "nl": "Function to find the missing element"}
{"code": "if ( right <= left ) return 0 ;", "nl": "Fix left and right boundary for binary search"}
{"code": "int mid = left + ( right - left ) / 2 ;", "nl": "Find index of middle element"}
{"code": "if ( arr [ mid + 1 ] - arr [ mid ] != diff ) return ( arr [ mid ] + diff ) ;", "nl": "Check if the element just after the middle element is missing"}
{"code": "if ( mid > 0 && arr [ mid ] - arr [ mid - 1 ] != diff ) return ( arr [ mid - 1 ] + diff ) ;", "nl": "Check if the element just before mid is missing"}
{"code": "if ( arr [ mid ] == arr [ 0 ] + mid * diff ) return findMissing ( arr , mid + 1 , right , diff ) ;", "nl": "Check if the elements till mid follow the AP , then recur for right half"}
{"code": "return findMissing ( arr , left , mid - 1 , diff ) ; }", "nl": "Else recur for left half"}
{"code": "static int missingElement ( int arr [ ] , int n ) {", "nl": "Function to find the missing element in AP series"}
{"code": "Arrays . sort ( arr ) ;", "nl": "Sort the array arr [ ]"}
{"code": "int diff = ( arr [ n - 1 ] - arr [ 0 ] ) / n ;", "nl": "Calculate Common Difference"}
{"code": "return findMissing ( arr , 0 , n - 1 , diff ) ; }", "nl": "Binary search for the missing"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int arr [ ] = new int [ ] { 2 , 8 , 6 , 10 } ; int n = arr . length ;", "nl": "Given array arr [ ]"}
{"code": "System . out . println ( missingElement ( arr , n ) ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static int power ( int x , int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }", "nl": "Function to calculate x raised to the power y in O ( logn )"}
{"code": "static int nthRootSearch ( int low , int high , int N , int K ) {", "nl": "Function to find the Kth root of the number N using BS"}
{"code": "if ( low <= high ) {", "nl": "If the range is still valid"}
{"code": "int mid = ( low + high ) / 2 ;", "nl": "Find the mid - value of range"}
{"code": "if ( ( power ( mid , K ) <= N ) && ( power ( mid + 1 , K ) > N ) ) { return mid ; }", "nl": "Base Case"}
{"code": "else if ( power ( mid , K ) < N ) { return nthRootSearch ( mid + 1 , high , N , K ) ; } else { return nthRootSearch ( low , mid - 1 , N , K ) ; } } return low ; }", "nl": "Condition to check if the left search space is useless"}
{"code": "public static void main ( String s [ ] ) {", "nl": "Driver Code"}
{"code": "int N = 16 , K = 4 ;", "nl": "Given N and K"}
{"code": "System . out . println ( nthRootSearch ( 0 , N , N , K ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to print count of subsets S such that Math . min ( S ) + Math . max ( S ) < K"}
{"code": "static int get_subset_count ( int arr [ ] , int K , int N ) {", "nl": "Function that return the count of subset such that Math . min ( S ) + Math . max ( S ) < K"}
{"code": "Arrays . sort ( arr ) ; int left , right ; left = 0 ; right = N - 1 ;", "nl": "Sorting the array"}
{"code": "int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) {", "nl": "ans stores total number of subsets"}
{"code": "ans += 1 << ( right - left ) ; left ++ ; } else {", "nl": "Add all possible subsets between i and j"}
{"code": "right -- ; } } return ans ; }", "nl": "Decrease the sum"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 5 , 7 } ; int K = 8 ; int N = arr . length ; System . out . print ( get_subset_count ( arr , K , N ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static int minMaxDiff ( int arr [ ] , int n , int k ) { int max_adj_dif = Integer . MIN_VALUE ;", "nl": "Java program to find the minimum of maximum difference between adjacent elements after at most K insertions"}
{"code": "for ( int i = 0 ; i < n - 1 ; i ++ ) max_adj_dif = Math . max ( max_adj_dif , Math . abs ( arr [ i ] - arr [ i + 1 ] ) ) ;", "nl": "Calculate the maximum adjacent difference"}
{"code": "if ( max_adj_dif == 0 ) return 0 ;", "nl": "If the maximum adjacent difference is already zero"}
{"code": "int best = 1 ; int worst = max_adj_dif ; int mid , required ; while ( best < worst ) { mid = ( best + worst ) / 2 ;", "nl": "best and worst specifies range of the maximum adjacent difference"}
{"code": "required = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { required += ( Math . abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) / mid ; }", "nl": "To store the no of insertions required for respective values of mid"}
{"code": "if ( required > k ) best = mid + 1 ;", "nl": "If the number of insertions required exceeds K"}
{"code": "else worst = mid ; } return worst ; }", "nl": "Otherwise"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 3 , 12 , 25 , 50 } ; int n = arr . length ; int k = 7 ; System . out . println ( minMaxDiff ( arr , n , k ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to check if the minimum element in the array is greater than or equal to half of every other elements"}
{"code": "static void checkMin ( int arr [ ] , int len ) {", "nl": "Function to Check if the minimum element in the array is greater than or equal to half of every other elements"}
{"code": "int smallest = Integer . MAX_VALUE ; int secondSmallest = Integer . MAX_VALUE ; for ( int i = 0 ; i < len ; i ++ ) {", "nl": "Initialise the variables to store smallest and second smallest"}
{"code": "if ( arr [ i ] < smallest ) { secondSmallest = smallest ; smallest = arr [ i ] ; }", "nl": "Check if current element is smaller than smallest , the current smallest will become secondSmallest and current element will be the new smallest"}
{"code": "else if ( arr [ i ] < secondSmallest ) { secondSmallest = arr [ i ] ; } } if ( 2 * smallest <= secondSmallest ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; }", "nl": "Check if current element is smaller than secondSmallest simply update the latter"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 5 } ; int len = arr . length ; checkMin ( arr , len ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find minimum and maximum fibonacci number in given array"}
{"code": "static void createHash ( HashSet < Integer > hash , int maxElement ) {", "nl": "Function to create hash table to check Fibonacci numbers"}
{"code": "int prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) {", "nl": "Insert initial two numbers in the hash table"}
{"code": "int temp = curr + prev ; hash . add ( temp ) ;", "nl": "Sum of previous two numbers"}
{"code": "prev = curr ; curr = temp ; } }", "nl": "Update the variable each time"}
{"code": "static void fibonacci ( int arr [ ] , int n ) {", "nl": "Function to find minimum and maximum fibonacci number in given array"}
{"code": "int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ;", "nl": "Find maximum value in the array"}
{"code": "HashSet < Integer > hash = new HashSet < Integer > ( ) ; createHash ( hash , max_val ) ;", "nl": "Creating a set containing all Fibonacci numbers up to maximum value in the array"}
{"code": "int minimum = Integer . MAX_VALUE ; int maximum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "For storing the Minimum and Maximum Fibonacci number"}
{"code": "if ( hash . contains ( arr [ i ] ) ) {", "nl": "Check if current element is a fibonacci number"}
{"code": "minimum = Math . min ( minimum , arr [ i ] ) ; maximum = Math . max ( maximum , arr [ i ] ) ; } } System . out . print ( minimum + \" , \u2581 \" + maximum + \"NEW_LINE\"); }", "nl": "Update the maximum and minimum accordingly"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = arr . length ; fibonacci ( arr , n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static boolean isValidLen ( String s , int len , int k ) {", "nl": "Function that returns true if there is a subString of length len with <= k unique characters"}
{"code": "int n = s . length ( ) ;", "nl": "Size of the String"}
{"code": "Map < Character , Integer > mp = new HashMap < Character , Integer > ( ) ; int right = 0 ;", "nl": "Map to store the characters and their frequency"}
{"code": "while ( right < len ) { if ( mp . containsKey ( s . charAt ( right ) ) ) { mp . put ( s . charAt ( right ) , mp . get ( s . charAt ( right ) ) + 1 ) ; } else { mp . put ( s . charAt ( right ) , 1 ) ; } right ++ ; } if ( mp . size ( ) <= k ) return true ;", "nl": "Update the map for the first subString"}
{"code": "while ( right < n ) {", "nl": "Check for the rest of the subStrings"}
{"code": "if ( mp . containsKey ( s . charAt ( right ) ) ) { mp . put ( s . charAt ( right ) , mp . get ( s . charAt ( right ) ) + 1 ) ; } else { mp . put ( s . charAt ( right ) , 1 ) ; }", "nl": "Add the new character"}
{"code": "if ( mp . containsKey ( s . charAt ( right - len ) ) ) { mp . put ( s . charAt ( right - len ) , mp . get ( s . charAt ( right - len ) ) - 1 ) ; }", "nl": "Remove the first character of the previous window"}
{"code": "if ( mp . get ( s . charAt ( right - len ) ) == 0 ) mp . remove ( s . charAt ( right - len ) ) ; if ( mp . size ( ) <= k ) return true ; right ++ ; } return mp . size ( ) <= k ; }", "nl": "Update the map"}
{"code": "static int maxLenSubStr ( String s , int k ) {", "nl": "Function to return the length of the longest subString which has K unique characters"}
{"code": "Set < Character > uni = new HashSet < Character > ( ) ; for ( Character x : s . toCharArray ( ) ) uni . add ( x ) ; if ( uni . size ( ) < k ) return - 1 ;", "nl": "Check if the complete String contains K unique characters"}
{"code": "int n = s . length ( ) ;", "nl": "Size of the String"}
{"code": "int lo = - 1 , hi = n + 1 ; while ( hi - lo > 1 ) { int mid = lo + hi >> 1 ; if ( isValidLen ( s , mid , k ) ) lo = mid ; else hi = mid ; } return lo ; }", "nl": "Apply binary search"}
{"code": "public static void main ( String [ ] args ) { String s = \" aabacbebebe \" ; int k = 3 ; System . out . print ( maxLenSubStr ( s , k ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static boolean isSquarePossible ( int arr [ ] , int n , int l ) {", "nl": "Function that returns true if it is possible to make a square with side equal to l"}
{"code": "int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "To store the count of elements greater than or equal to l"}
{"code": "if ( arr [ i ] >= l ) cnt ++ ;", "nl": "Increment the count"}
{"code": "if ( cnt >= l ) return true ; } return false ; }", "nl": "If the count becomes greater than or equal to l"}
{"code": "static int maxArea ( int arr [ ] , int n ) { int l = 0 , r = n ; int len = 0 ; while ( l <= r ) { int m = l + ( ( r - l ) / 2 ) ;", "nl": "Function to return the maximum area of the square that can be obtained"}
{"code": "if ( isSquarePossible ( arr , n , m ) ) { len = m ; l = m + 1 ; }", "nl": "If square is possible with side length m"}
{"code": "else r = m - 1 ; }", "nl": "Try to find a square with smaller side length"}
{"code": "return ( len * len ) ; }", "nl": "Return the area"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 } ; int n = arr . length ; System . out . println ( maxArea ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void insertNames ( String arr [ ] , int n ) {", "nl": "Function to insert the names and check whether they appear for the first time"}
{"code": "HashSet < String > set = new HashSet < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "To store the names of the employees"}
{"code": "if ( ! set . contains ( arr [ i ] ) ) { System . out . print ( \"NoNEW_LINE\"); set . add ( arr [ i ] ) ; } else { System . out . print ( \"YesNEW_LINE\"); } } }", "nl": "If current name is appearing for the first time"}
{"code": "public static void main ( String [ ] args ) { String arr [ ] = { \" geeks \" , \" for \" , \" geeks \" } ; int n = arr . length ; insertNames ( arr , n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int countLessThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = - 1 ;", "nl": "Function to return the count of elements in arr [ ] which are less than the given key"}
{"code": "while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] < key ) { l = m + 1 ; index = m ; } else { r = m - 1 ; } } return ( index + 1 ) ; }", "nl": "Modified binary search"}
{"code": "static int countGreaterThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = - 1 ;", "nl": "Function to return the count of elements in arr [ ] which are greater than the given key"}
{"code": "while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] <= key ) { l = m + 1 ; } else { r = m - 1 ; index = m ; } } if ( index == - 1 ) return 0 ; return ( n - index ) ; }", "nl": "Modified binary search"}
{"code": "static int countTriplets ( int n , int a [ ] , int b [ ] , int c [ ] ) {", "nl": "Function to return the count of the required triplets"}
{"code": "Arrays . sort ( a ) ; Arrays . sort ( b ) ; Arrays . sort ( c ) ; int count = 0 ;", "nl": "Sort all three arrays"}
{"code": "for ( int i = 0 ; i < n ; ++ i ) { int current = b [ i ] ;", "nl": "Iterate for all the elements of array B"}
{"code": "int low = countLessThan ( a , n , current ) ;", "nl": "Count of elements in A [ ] which are less than the chosen element from B [ ]"}
{"code": "int high = countGreaterThan ( c , n , current ) ;", "nl": "Count of elements in C [ ] which are greater than the chosen element from B [ ]"}
{"code": "count += ( low * high ) ; } return count ; }", "nl": "Update the count"}
{"code": "public static void main ( String args [ ] ) { int a [ ] = { 1 , 5 } ; int b [ ] = { 2 , 4 } ; int c [ ] = { 3 , 6 } ; int size = a . length ; System . out . println ( countTriplets ( size , a , b , c ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static int costToBalance ( String s ) { if ( s . length ( ) == 0 ) System . out . println ( 0 ) ;", "nl": "Java code to calculate the minimum cost to make the given parentheses balanced"}
{"code": "int ans = 0 ;", "nl": "To store absolute count of balanced and unbalanced parenthesis"}
{"code": "int o = 0 , c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) o ++ ; if ( s . charAt ( i ) == ' ) ' ) c ++ ; } if ( o != c ) return - 1 ; int [ ] a = new int [ s . length ( ) ] ; if ( s . charAt ( 0 ) == ' ( ' ) a [ 0 ] = 1 ; else a [ 0 ] = - 1 ; if ( a [ 0 ] < 0 ) ans += Math . abs ( a [ 0 ] ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += Math . abs ( a [ i ] ) ; } return ans ; }", "nl": "o ( open bracket ) stores count of ' ( ' and c ( close bracket ) stores count of ' ) '"}
{"code": "public static void main ( String args [ ] ) { String s ; s = \" ) ) ) ( ( ( \" ; System . out . println ( costToBalance ( s ) ) ; s = \" ) ) ( ( \" ; System . out . println ( costToBalance ( s ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class Middle {", "nl": "java program to find middle of three distinct numbers"}
{"code": "public static int middleOfThree ( int a , int b , int c ) {", "nl": "Function to find the middle of three number"}
{"code": "int x = a - b ;", "nl": "x is positive if a is greater than b . x is negative if b is greater than a ."}
{"code": "int y = b - c ;", "nl": "Similar to x"}
{"code": "int z = a - c ;", "nl": "Similar to x and y ."}
{"code": "if ( x * y > 0 ) return b ;", "nl": "Checking if b is middle ( x and y both are positive )"}
{"code": "else if ( x * z > 0 ) return c ; else return a ; }", "nl": "Checking if c is middle ( x and z both are positive )"}
{"code": "public static void main ( String [ ] args ) { int a = 20 , b = 30 , c = 40 ; System . out . println ( middleOfThree ( a , b , c ) ) ; } }", "nl": "driver code"}
{"code": "class Missing4 {", "nl": "Java program to find missing 4 elements in an array of size N where elements are in range from 1 to N + 4."}
{"code": "public static void missing4 ( int [ ] arr ) {", "nl": "Finds missing 4 numbers in O ( N ) time and O ( 1 ) auxiliary space ."}
{"code": "int [ ] helper = new int [ 4 ] ;", "nl": "To keep track of 4 possible numbers greater than length of input array In Java , helper is automatically initialized as 0."}
{"code": "for ( int i = 0 ; i < arr . length ; i ++ ) { int temp = Math . abs ( arr [ i ] ) ;", "nl": "Traverse the input array and mark visited elements either by marking them as negative in arr [ ] or in helper [ ] ."}
{"code": "if ( temp <= arr . length ) arr [ temp - 1 ] *= ( - 1 ) ;", "nl": "If element is smaller than or equal to length , mark its presence in arr [ ]"}
{"code": "else if ( temp > arr . length ) { if ( temp % arr . length != 0 ) helper [ temp % arr . length - 1 ] = - 1 ; else helper [ ( temp % arr . length ) + arr . length - 1 ] = - 1 ; } }", "nl": "Mark presence in helper [ ]"}
{"code": "for ( int i = 0 ; i < arr . length ; i ++ ) if ( arr [ i ] > 0 ) System . out . print ( i + 1 + \" \u2581 \" ) ; for ( int i = 0 ; i < helper . length ; i ++ ) if ( helper [ i ] >= 0 ) System . out . print ( arr . length + i + 1 + \" \u2581 \" ) ; return ; }", "nl": "Print all those elements whose presence is not marked ."}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 1 , 7 , 3 , 12 , 5 , 10 , 8 , 4 , 9 } ; missing4 ( arr ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void lexiMiddleSmallest ( int K , int N ) {", "nl": "Function that finds the middle the lexicographical smallest sequence"}
{"code": "if ( K % 2 == 0 ) {", "nl": "If K is even"}
{"code": "System . out . print ( K / 2 + \" \u2581 \" ) ;", "nl": "First element is K / 2"}
{"code": "for ( int i = 0 ; i < N - 1 ; ++ i ) { System . out . print ( K + \" \u2581 \" ) ; } System . out . println ( ) ; return ; }", "nl": "Remaining elements of the sequence are all integer K"}
{"code": "ArrayList < Integer > a = new ArrayList < Integer > ( ) ;", "nl": "Stores the sequence when K is odd"}
{"code": "for ( int i = 0 ; i < N / 2 ; ++ i ) {", "nl": "Iterate over the range [ 0 , N / 2 ]"}
{"code": "if ( a . get ( a . size ( ) - 1 ) == 1 ) {", "nl": "Check if the sequence ends with in 1 or not"}
{"code": "a . remove ( a . size ( ) - 1 ) ; }", "nl": "Remove the sequence ending in 1"}
{"code": "else {", "nl": "If it doesn 't end in 1"}
{"code": "int t = a . get ( a . size ( ) - 1 ) - 1 ; a . set ( a . get ( a . size ( ) - 1 ) , t ) ;", "nl": "Decrement by 1"}
{"code": "while ( a . size ( ) < N ) { a . add ( K ) ; } } }", "nl": "Insert K to the sequence till its size is N"}
{"code": "for ( int i : a ) { System . out . print ( i + \" \u2581 \" ) ; } System . out . println ( ) ; }", "nl": "Print the sequence stored in the vector"}
{"code": "public static void main ( String [ ] args ) { int K = 2 , N = 4 ; lexiMiddleSmallest ( K , N ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void findLastElement ( int arr [ ] , int N ) {", "nl": "Function to find the last remaining array element after repeatedly removing the smallest from pairs having absolute difference 2 or 0"}
{"code": "Arrays . sort ( arr ) ; int i = 0 ;", "nl": "Sort the given array in ascending order"}
{"code": "for ( i = 1 ; i < N ; i ++ ) {", "nl": "Traverse the array"}
{"code": "if ( arr [ i ] - arr [ i - 1 ] != 0 && arr [ i ] - arr [ i - 1 ] != 2 ) { System . out . println ( \" - 1\" ) ; return ; } }", "nl": "If difference between adjacent elements is not equal to 0 or 2"}
{"code": "System . out . println ( arr [ N - 1 ] ) ; }", "nl": "If operations can be performed"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 0 , 8 } ; int N = arr . length ; findLastElement ( arr , N ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void maxDivisions ( Integer arr [ ] , int N , int X ) {", "nl": "Function to count maximum subsets into which the given array can be split such that it satisfies the given condition"}
{"code": "Arrays . sort ( arr , Collections . reverseOrder ( ) ) ;", "nl": "Sort the array in decreasing order"}
{"code": "int maxSub = 0 ;", "nl": "Stores count of subsets possible"}
{"code": "int size = 0 ;", "nl": "Stores count of elements in current subset"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array arr [ ]"}
{"code": "size ++ ;", "nl": "Update size"}
{"code": "if ( arr [ i ] * size >= X ) {", "nl": "If product of the smallest element present in the current subset and size of current subset is >= K"}
{"code": "maxSub ++ ;", "nl": "Update maxSub"}
{"code": "size = 0 ; } } System . out . print ( maxSub + \"NEW_LINE\"); }", "nl": "Update size"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "Integer arr [ ] = { 1 , 3 , 3 , 7 } ;", "nl": "Given array"}
{"code": "int N = arr . length ;", "nl": "Size of the array"}
{"code": "int X = 3 ; maxDivisions ( arr , N , X ) ; } }", "nl": "Given value of X"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static void maxPossibleSum ( int [ ] arr , int N ) {", "nl": "Function to find maximum possible sum of second minimums in each quadruple"}
{"code": "Arrays . sort ( arr ) ; int sum = 0 ; int j = N - 3 ; while ( j >= 0 ) {", "nl": "Sort the array"}
{"code": "sum += arr [ j ] ; j -= 3 ; }", "nl": "Add the second minimum"}
{"code": "System . out . println ( sum ) ; }", "nl": "Print maximum possible sum"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int [ ] arr = { 7 , 4 , 5 , 2 , 3 , 1 , 5 , 9 } ;", "nl": "Given array"}
{"code": "int N = arr . length ; maxPossibleSum ( arr , N ) ; } }", "nl": "Size of the array"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void insertionSort ( int arr [ ] , int n ) { int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ;", "nl": "Function to sort an array using insertion sort"}
{"code": "while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } }", "nl": "Move elements of arr [ 0. . i - 1 ] , that are greater than key to one position ahead of their current position"}
{"code": "static void printArray ( int arr [ ] , int n ) { int i ;", "nl": "Function to print an array of size N"}
{"code": "for ( i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } System . out . println ( ) ; }", "nl": "Print the array"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; int N = arr . length ;", "nl": "Driver code"}
{"code": "insertionSort ( arr , N ) ; printArray ( arr , N ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static void getPairs ( int arr [ ] , int N , int K ) {", "nl": "Function to find the count required pairs"}
{"code": "int count = 0 ;", "nl": "Stores count of pairs"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) {", "nl": "Traverse the array"}
{"code": "if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } System . out . print ( count ) ; }", "nl": "Check if the condition is satisfied or not"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 2 , 1 } ; int N = arr . length ; int K = 2 ;", "nl": "Driver Code"}
{"code": "getPairs ( arr , N , K ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static int merge ( int arr [ ] , int temp [ ] , int l , int m , int r , int K ) {", "nl": "Function to merge two sorted arrays"}
{"code": "int i = l ;", "nl": "i : index to left subarray"}
{"code": "int j = m + 1 ;", "nl": "j : index to right subarray"}
{"code": "int cnt = 0 ; for ( i = l ; i <= m ; i ++ ) { boolean found = false ;", "nl": "Stores count of pairs that satisfy the given condition"}
{"code": "while ( j <= r ) {", "nl": "Traverse to check for the valid conditions"}
{"code": "if ( arr [ i ] >= K * arr [ j ] ) { found = true ; } else break ; j ++ ; }", "nl": "If condition satisfies"}
{"code": "if ( found == true ) { cnt += j - ( m + 1 ) ; j -- ; } }", "nl": "All elements in the right side of the left subarray also satisfies"}
{"code": "int k = l ; i = l ; j = m + 1 ; while ( i <= m && j <= r ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else temp [ k ++ ] = arr [ j ++ ] ; }", "nl": "Sort the two given arrays and store in the resultant array"}
{"code": "while ( i <= m ) temp [ k ++ ] = arr [ i ++ ] ;", "nl": "Elements which are left in the left subarray"}
{"code": "while ( j <= r ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = l ; i <= r ; i ++ ) arr [ i ] = temp [ i ] ;", "nl": "Elements which are left in the right subarray"}
{"code": "return cnt ; }", "nl": "Return the count obtained"}
{"code": "static int mergeSortUtil ( int arr [ ] , int temp [ ] , int l , int r , int K ) { int cnt = 0 ; if ( l < r ) {", "nl": "Function to partition array into two halves"}
{"code": "int m = ( l + r ) / 2 ;", "nl": "Same as ( l + r ) / 2 , but avoids overflow for large l and h"}
{"code": "cnt += mergeSortUtil ( arr , temp , l , m , K ) ; cnt += mergeSortUtil ( arr , temp , m + 1 , r , K ) ;", "nl": "Sort first and second halves"}
{"code": "cnt += merge ( arr , temp , l , m , r , K ) ; } return cnt ; }", "nl": "Call the merging function"}
{"code": "static void mergeSort ( int arr [ ] , int N , int K ) { int temp [ ] = new int [ N ] ; System . out . print ( mergeSortUtil ( arr , temp , 0 , N - 1 , K ) ) ; }", "nl": "Function to print the count of required pairs using Merge Sort"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 2 , 5 } ; int N = arr . length ; int K = 2 ;", "nl": "Driver code"}
{"code": "mergeSort ( arr , N , K ) ; } }", "nl": "Function Call"}
{"code": "import java . util . Arrays ; class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static void minRemovals ( int [ ] A , int N ) {", "nl": "Function to count minimum consecutive removals of elements of the same type"}
{"code": "Arrays . sort ( A ) ;", "nl": "Sort the array"}
{"code": "int mx = A [ N - 1 ] ;", "nl": "Stores the maximum element present in the array"}
{"code": "int sum = 1 ;", "nl": "Stores sum of the array"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; } if ( sum - mx >= mx ) { System . out . println ( 0 ) ; } else { System . out . println ( 2 * mx - sum ) ; } }", "nl": "Calculate sum of the array"}
{"code": "public static void main ( String [ ] args ) { int [ ] A = { 3 , 3 , 2 } ; int N = A . length ;", "nl": "Driver Code"}
{"code": "minRemovals ( A , N ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void rearrangeArray ( int a [ ] , int n ) {", "nl": "Function to rearrange the array a [ ] such that none of the array elements is same as its index"}
{"code": "Arrays . sort ( a ) ;", "nl": "Sort the array"}
{"code": "for ( int i = 0 ; i < n - 1 ; i ++ ) {", "nl": "Traverse the indices [ 0 , N - 2 ] of the given array"}
{"code": "if ( a [ i ] == i + 1 ) {", "nl": "Check if the current element is equal to its index"}
{"code": "int temp = a [ i ] ; a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = temp ; } }", "nl": "If found to be true , swap current element with the next element"}
{"code": "if ( a [ n - 1 ] == n ) {", "nl": "Check if the last element is same as its index"}
{"code": "int temp = a [ n - 1 ] ; a [ n - 1 ] = a [ n - 2 ] ; a [ n - 2 ] = temp ; }", "nl": "If found to be true , swap current element with the previous element"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( a [ i ] + \" \u2581 \" ) ; } }", "nl": "Print the modified array"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 1 , 5 , 3 , 2 , 4 } ; int N = arr . length ;", "nl": "Driver Code"}
{"code": "rearrangeArray ( arr , N ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; import java . io . * ; import java . lang . Math ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int minOperations ( int arr1 [ ] , int arr2 [ ] , int i , int j ) {", "nl": "Function that counts the minimum moves required to covert arr [ ] to brr [ ]"}
{"code": "if ( arr1 . equals ( arr2 ) ) return 0 ; if ( i >= arr1 . length j >= arr2 . length ) return 0 ;", "nl": "Base Case"}
{"code": "if ( arr1 [ i ] < arr2 [ j ] )", "nl": "If arr [ i ] < arr [ j ]"}
{"code": "return 1 + minOperations ( arr1 , arr2 , i + 1 , j + 1 ) ;", "nl": "Include the current element"}
{"code": "return Math . max ( minOperations ( arr1 , arr2 , i , j + 1 ) , minOperations ( arr1 , arr2 , i + 1 , j ) ) ; }", "nl": "Otherwise , excluding the current element"}
{"code": "static void minOperationsUtil ( int [ ] arr ) { int brr [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) brr [ i ] = arr [ i ] ; Arrays . sort ( brr ) ;", "nl": "Function that counts the minimum moves required to sort the array"}
{"code": "if ( arr . equals ( brr ) )", "nl": "If both the arrays are equal"}
{"code": "System . out . print ( \"0\" ) ;", "nl": "No moves required"}
{"code": "else", "nl": "Otherwise"}
{"code": "System . out . println ( minOperations ( arr , brr , 0 , 0 ) ) ; }", "nl": "Print minimum operations required"}
{"code": "public static void main ( final String [ ] args ) { int arr [ ] = { 4 , 7 , 2 , 3 , 9 } ; minOperationsUtil ( arr ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java Program to implement the above approach"}
{"code": "static void canTransform ( String s , String t ) { int n = s . length ( ) ;", "nl": "Function to check if str1 can be transformed to t by sorting subStrings"}
{"code": "Vector < Integer > occur [ ] = new Vector [ 26 ] ; for ( int i = 0 ; i < occur . length ; i ++ ) occur [ i ] = new Vector < Integer > ( ) ; for ( int x = 0 ; x < n ; x ++ ) { char ch = ( char ) ( s . charAt ( x ) - ' a ' ) ; occur [ ch ] . add ( x ) ; }", "nl": "Occur [ i ] stores the indices of char ( ' a ' + i ) in String s"}
{"code": "int [ ] idx = new int [ 26 ] ; boolean poss = true ; for ( int x = 0 ; x < n ; x ++ ) { char ch = ( char ) ( t . charAt ( x ) - ' a ' ) ;", "nl": "idx [ i ] stores the next available index of char ( ' a ' + i ) in occur [ i ]"}
{"code": "if ( idx [ ch ] >= occur [ ch ] . size ( ) ) {", "nl": "If this char is not available anymore"}
{"code": "poss = false ; break ; } for ( int small = 0 ; small < ch ; small ++ ) {", "nl": "Conversion not possible"}
{"code": "if ( idx [ small ] < occur [ small ] . size ( ) && occur [ small ] . get ( idx [ small ] ) < occur [ ch ] . get ( idx [ ch ] ) ) {", "nl": "If one of the smaller characters is available and occurs before"}
{"code": "poss = false ; break ; } } idx [ ch ] ++ ; }", "nl": "Conversion not possible"}
{"code": "if ( poss ) { System . out . print ( \" Yes \" + \"NEW_LINE\"); } else { System . out . print ( \" No \" + \"NEW_LINE\"); } }", "nl": "Print the answer"}
{"code": "public static void main ( String [ ] args ) { String s , t ; s = \" hdecb \" ; t = \" cdheb \" ; canTransform ( s , t ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int inversionCount ( String s ) {", "nl": "Function to count inversion count of the string"}
{"code": "int [ ] freq = new int [ 26 ] ; int inv = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int temp = 0 ;", "nl": "For storing frequency"}
{"code": "for ( int j = 0 ; j < ( int ) ( s . charAt ( i ) - ' a ' ) ; j ++ )", "nl": "Add all the characters which are less than the ith character before i ."}
{"code": "temp += freq [ j ] ; inv += ( i - temp ) ;", "nl": "Adding the count to inversion count"}
{"code": "freq [ s . charAt ( i ) - ' a ' ] ++ ; } return inv ; }", "nl": "Updating the character in the frequency array"}
{"code": "static boolean haveRepeated ( String S1 , String S2 ) { int [ ] freq = new int [ 26 ] ; for ( char i : S1 . toCharArray ( ) ) { if ( freq [ i - ' a ' ] > 0 ) return true ; freq [ i - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) freq [ i ] = 0 ; for ( char i : S2 . toCharArray ( ) ) { if ( freq [ i - ' a ' ] > 0 ) return true ; freq [ i - ' a ' ] ++ ; } return false ; }", "nl": "Function to check whether any of the string have a repeated character"}
{"code": "static void checkToMakeEqual ( String S1 , String S2 ) {", "nl": "Function to check whether the string S1 and S2 can be made equal by reversing sub strings of same size in both strings"}
{"code": "int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < S1 . length ( ) ; i ++ ) {", "nl": "Frequency array to check whether both string have same character or not"}
{"code": "freq [ S1 . charAt ( i ) - ' a ' ] ++ ; } boolean flag = false ; for ( int i = 0 ; i < S2 . length ( ) ; i ++ ) { if ( freq [ S2 . charAt ( i ) - ' a ' ] == 0 ) {", "nl": "Adding the frequency ;"}
{"code": "flag = true ; break ; }", "nl": "If the character is not in S1"}
{"code": "freq [ S2 . charAt ( i ) - ' a ' ] -- ; } if ( flag == true ) {", "nl": "Decrementing the frequency"}
{"code": "System . out . println ( \" No \" ) ; return ; }", "nl": "If both string doesnot have same characters or not"}
{"code": "int invCount1 = inversionCount ( S1 ) ; int invCount2 = inversionCount ( S2 ) ; if ( invCount1 == invCount2 || ( invCount1 & 1 ) == ( invCount2 & 1 ) || haveRepeated ( S1 , S2 ) ) {", "nl": "Finding inversion count of both strings"}
{"code": "System . out . println ( \" Yes \" ) ; } else System . out . println ( \" No \" ) ; }", "nl": "If inversion count is same , or have same parity or if any of the string have a repeated character then the answer is Yes else No"}
{"code": "public static void main ( String [ ] args ) { String S1 = \" abbca \" , S2 = \" acabb \" ; checkToMakeEqual ( S1 , S2 ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void sortArr ( int a [ ] , int n ) { int i , k ;", "nl": "Function to Sort a Bitonic array in constant space"}
{"code": "k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; k = ( int ) Math . pow ( 2 , k ) ;", "nl": "Initialize the value of k"}
{"code": "while ( k > 0 ) { for ( i = 0 ; i + k < n ; i ++ ) if ( a [ i ] > a [ i + k ] ) { int tmp = a [ i ] ; a [ i ] = a [ i + k ] ; a [ i + k ] = tmp ; }", "nl": "In each iteration compare elements k distance apart and swap if they are not in order"}
{"code": "k = k / 2 ; }", "nl": "k is reduced to half after every iteration"}
{"code": "for ( i = 0 ; i < n ; i ++ ) { System . out . print ( a [ i ] + \" \u2581 \" ) ; } }", "nl": "Print the array elements"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int arr [ ] = { 5 , 20 , 30 , 40 , 36 , 33 , 25 , 15 , 10 } ; int n = arr . length ;", "nl": "Given array arr [ ]"}
{"code": "sortArr ( arr , n ) ; } }", "nl": "Function call"}
{"code": "import java . util . Arrays ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void maximumSum ( int arr [ ] , int n , int k ) {", "nl": "Function that prints the maximum sum possible"}
{"code": "int elt = n / k ; int sum = 0 ;", "nl": "Find elements in each group"}
{"code": "Arrays . sort ( arr ) ; int count = 0 ; int i = n - 1 ;", "nl": "Sort all elements in non - descending order"}
{"code": "while ( count < k ) { sum += arr [ i ] ; i -- ; count ++ ; } count = 0 ; i = 0 ;", "nl": "Add K largest elements"}
{"code": "while ( count < k ) { sum += arr [ i ] ; i += elt - 1 ; count ++ ; }", "nl": "For sum of minimum elements from each subset"}
{"code": "System . out . println ( sum ) ; }", "nl": "Printing the maximum sum"}
{"code": "public static void main ( String [ ] args ) { int Arr [ ] = { 1 , 13 , 7 , 17 , 6 , 5 } ; int K = 2 ; int size = Arr . length ; maximumSum ( Arr , size , K ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Arrays ; class GFG {", "nl": "Java program to find the minimum possible sum of the smallest elements from K subsequences"}
{"code": "static int findMinSum ( int [ ] arr , int K , int L , int size ) { if ( K * L > size ) return - 1 ; int minsum = 0 ;", "nl": "Function to find the minimum sum"}
{"code": "Arrays . sort ( arr ) ;", "nl": "Sort the array"}
{"code": "for ( int i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ;", "nl": "Calculate sum of smallest K elements"}
{"code": "return minsum ; }", "nl": "Return the sum"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 2 , 15 , 5 , 1 , 35 , 16 , 67 , 10 } ; int K = 3 ; int L = 2 ; int length = arr . length ; System . out . print ( findMinSum ( arr , K , L , length ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int findKthSmallest ( int [ ] arr , int n , int k ) {", "nl": "Function to find the Kth smallest element in Unsorted Array"}
{"code": "int max = 0 ;", "nl": "Initialize the max Element as 0"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; }", "nl": "Iterate arr [ ] and find the maximum element in it"}
{"code": "int [ ] counter = new int [ max + 1 ] ;", "nl": "Frequency array to store the frequencies"}
{"code": "int smallest = 0 ;", "nl": "Counter variable"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { counter [ arr [ i ] ] ++ ; }", "nl": "Counting the frequencies"}
{"code": "for ( int num = 1 ; num <= max ; num ++ ) {", "nl": "Iterate through the freq [ ]"}
{"code": "if ( counter [ num ] > 0 ) {", "nl": "Check if num is present in the array"}
{"code": "smallest += counter [ num ] ; }", "nl": "Increment the counter with the frequency of num"}
{"code": "if ( smallest >= k ) {", "nl": "Checking if we have reached the Kth smallest element"}
{"code": "return num ; } } return - 1 ; }", "nl": "Return the Kth smallest element"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int [ ] arr = { 7 , 1 , 4 , 4 , 20 , 15 , 8 } ; int N = arr . length ; int K = 5 ;", "nl": "Given array"}
{"code": "System . out . print ( findKthSmallest ( arr , N , K ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java Program to implement the above approach"}
{"code": "static void lexNumbers ( int n ) { Vector < String > s = new Vector < String > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { s . add ( String . valueOf ( i ) ) ; } Collections . sort ( s ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) ans . add ( Integer . valueOf ( s . get ( i ) ) ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans . get ( i ) + \" \u2581 \" ) ; }", "nl": "Function to print all the numbers up to n in lexicographical order"}
{"code": "public static void main ( String [ ] args ) { int n = 15 ; lexNumbers ( n ) ; } }", "nl": "Driver Program"}
{"code": "class GFG { static int N = 4 ; static void func ( int a [ ] [ ] ) { int i , j , k ;", "nl": "Java implementation to print row of matrix in ascending or descending order alternatively"}
{"code": "for ( i = 0 ; i < N ; i ++ ) {", "nl": "Iterate matrix rowwise"}
{"code": "if ( i % 2 == 0 ) { for ( j = 0 ; j < N ; j ++ ) { for ( k = j + 1 ; k < N ; ++ k ) {", "nl": "Sort even rows in ascending order"}
{"code": "if ( a [ i ] [ j ] > a [ i ] [ k ] ) {", "nl": "Compare adjacent elements"}
{"code": "int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } }", "nl": "Swap adjacent element"}
{"code": "else { for ( j = 0 ; j < N ; j ++ ) { for ( k = j + 1 ; k < N ; ++ k ) {", "nl": "Sort even rows in descending order"}
{"code": "if ( a [ i ] [ j ] < a [ i ] [ k ] ) {", "nl": "Compare adjacent elements"}
{"code": "int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } }", "nl": "Swap adjacent element"}
{"code": "for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { System . out . print ( a [ i ] [ j ] + \" \u2581 \" ) ; } System . out . print ( \"NEW_LINE\"); } }", "nl": "Printing the final Output"}
{"code": "public static void main ( String [ ] args ) { int a [ ] [ ] = { { 5 , 7 , 3 , 4 } , { 9 , 5 , 8 , 2 } , { 6 , 3 , 8 , 1 } , { 5 , 8 , 9 , 3 } } ; func ( a ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java Program to find weight of minimum spanning tree in a complete graph where edges have weight either 0 or 1"}
{"code": "static HashMap < Integer , Integer > [ ] g = new HashMap [ 200005 ] ; static HashSet < Integer > s = new HashSet < > ( ) ; static HashSet < Integer > ns = new HashSet < > ( ) ;", "nl": "To store the edges of the given graph"}
{"code": "static void dfs ( int x ) { Vector < Integer > v = new Vector < > ( ) ; v . clear ( ) ; ns . clear ( ) ;", "nl": "A utility function to perform DFS Traversal"}
{"code": "for ( int it : s ) {", "nl": "Check those vertices which are stored in the set"}
{"code": "if ( g [ x ] . get ( it ) != null ) { v . add ( it ) ; } else { ns . add ( it ) ; } } s = ns ; for ( int i : v ) { dfs ( i ) ; } }", "nl": "Vertices are included if the weight of edge is 0"}
{"code": "static void weightOfMST ( int N ) {", "nl": "A utility function to find the weight of Minimum Spanning Tree"}
{"code": "int cnt = 0 ;", "nl": "To count the connected components"}
{"code": "for ( int i = 1 ; i <= N ; ++ i ) { s . add ( i ) ; } Vector < Integer > qt = new Vector < > ( ) ; for ( int t : s ) qt . add ( t ) ;", "nl": "Inserting the initial vertices in the set"}
{"code": "while ( ! qt . isEmpty ( ) ) {", "nl": "Traversing vertices stored in the set and Run DFS Traversal for each vertices"}
{"code": "++ cnt ; int t = qt . get ( 0 ) ; qt . remove ( 0 ) ;", "nl": "Incrementing the zero weight connected components"}
{"code": "dfs ( t ) ; } System . out . print ( cnt - 4 ) ; }", "nl": "DFS Traversal for every vertex remove"}
{"code": "public static void main ( String [ ] args ) { int N = 6 , M = 11 ; int edges [ ] [ ] = { { 1 , 3 } , { 1 , 4 } , { 1 , 5 } , { 1 , 6 } , { 2 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 4 } , { 3 , 5 } , { 3 , 6 } } ; for ( int i = 0 ; i < g . length ; i ++ ) g [ i ] = new HashMap < Integer , Integer > ( ) ;", "nl": "Driver 's Code"}
{"code": "for ( int i = 0 ; i < M ; ++ i ) { int u = edges [ i ] [ 0 ] ; int v = edges [ i ] [ 1 ] ; g [ u ] . put ( v , 1 ) ; g [ v ] . put ( u , 1 ) ; }", "nl": "Insert edges"}
{"code": "weightOfMST ( N ) ; } }", "nl": "Function call find the weight of Minimum Spanning Tree"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to count number of distinct pairs possible from the two arrays such that element selected from one array is always greater than the one selected from the other array"}
{"code": "static int countPairs ( int [ ] A , int [ ] B ) { int n = A . length ; int ans = 0 ; Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; }", "nl": "Function to return the count of pairs"}
{"code": "public static void main ( String [ ] args ) { int [ ] A = { 30 , 28 , 45 , 22 } ; int [ ] B = { 35 , 25 , 22 , 48 } ; System . out . print ( countPairs ( A , B ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int max_element ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < arr [ i ] ) max = arr [ i ] ; } return max ; }", "nl": "Java implementation of the approach"}
{"code": "static int maxMod ( int arr [ ] , int n ) { int maxVal = max_element ( arr , n ) ; int secondMax = 0 ;", "nl": "Function to return the maximum mod value for any pair from the array"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < maxVal && arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return secondMax ; }", "nl": "Find the second maximum element from the array"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 1 , 5 , 3 , 6 } ; int n = arr . length ; System . out . println ( maxMod ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static boolean isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) {", "nl": "Function to that returns true if it possible to choose the elements"}
{"code": "if ( x > n y > m ) return false ;", "nl": "If elements can 't be chosen"}
{"code": "Arrays . sort ( A ) ; Arrays . sort ( B ) ;", "nl": "Sort both the arrays"}
{"code": "if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }", "nl": "If xth smallest element of A [ ] is smaller than the yth greatest element of B [ ]"}
{"code": "public static void main ( String [ ] args ) { int A [ ] = { 1 , 1 , 1 , 1 , 1 } ; int B [ ] = { 2 , 2 } ; int n = A . length ; int m = B . length ; ; int x = 3 , y = 1 ; if ( isPossible ( A , B , n , m , x , y ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static int MAX = 100005 ;", "nl": "C # program to minimum changes required in an array for k distinct elements ."}
{"code": "static int Min_Replace ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ;", "nl": "Function to minimum changes required in an array for k distinct elements ."}
{"code": "Integer [ ] freq = new Integer [ MAX ] ; Arrays . fill ( freq , 0 ) ; int p = 0 ; freq [ p ] = 1 ;", "nl": "Store the frequency of each element"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; }", "nl": "Store the frequency of elements"}
{"code": "Arrays . sort ( freq , Collections . reverseOrder ( ) ) ;", "nl": "Sort frequencies in descending order"}
{"code": "int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ;", "nl": "To store the required answer"}
{"code": "return ans ; }", "nl": "Return the required answer"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 } ; int n = arr . length ; int k = 2 ; System . out . println ( Min_Replace ( arr , n , k ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find maximum number of elements without overlapping in a line"}
{"code": "static int Segment ( int x [ ] , int l [ ] , int n ) {", "nl": "Function to find maximum number of elements without overlapping in a line"}
{"code": "if ( n == 1 ) return 1 ;", "nl": "If n = 1 , then answer is one"}
{"code": "int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) {", "nl": "We can always make 1 st element to cover left segment and nth the right segment"}
{"code": "if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ;", "nl": "If left segment for ith element doesn 't overlap with i - 1 th  element then do left"}
{"code": "else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) {", "nl": "else try towards right if possible"}
{"code": "x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } }", "nl": "update x [ i ] to right endpoint of segment covered by it"}
{"code": "return ans ; }", "nl": "Return the required answer"}
{"code": "public static void main ( String [ ] args ) { int x [ ] = { 1 , 3 , 4 , 5 , 8 } , l [ ] = { 10 , 1 , 2 , 2 , 5 } ; int n = x . length ;", "nl": "Driver code"}
{"code": "System . out . println ( Segment ( x , l , n ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int MinimizeleftOverSum ( int a [ ] , int n ) { Vector < Integer > v1 = new Vector < Integer > ( ) , v2 = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) v1 . add ( a [ i ] ) ; else v2 . add ( a [ i ] ) ; }", "nl": "Function to find the minimized sum"}
{"code": "if ( v1 . size ( ) > v2 . size ( ) ) {", "nl": "If more odd elements"}
{"code": "Collections . sort ( v1 ) ; Collections . sort ( v2 ) ;", "nl": "Sort the elements"}
{"code": "int x = v1 . size ( ) - v2 . size ( ) - 1 ; int sum = 0 ; int i = 0 ;", "nl": "Left - over elements"}
{"code": "while ( i < x ) { sum += v1 . get ( i ++ ) ; }", "nl": "Find the sum of leftover elements"}
{"code": "return sum ; }", "nl": "Return the sum"}
{"code": "else if ( v2 . size ( ) > v1 . size ( ) ) {", "nl": "If more even elements"}
{"code": "Collections . sort ( v1 ) ; Collections . sort ( v2 ) ;", "nl": "Sort the elements"}
{"code": "int x = v2 . size ( ) - v1 . size ( ) - 1 ; int sum = 0 ; int i = 0 ;", "nl": "Left - over elements"}
{"code": "while ( i < x ) { sum += v2 . get ( i ++ ) ; }", "nl": "Find the sum of leftover elements"}
{"code": "return sum ; }", "nl": "Return the sum"}
{"code": "else return 0 ; }", "nl": "If same elements"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 2 , 2 , 2 , 2 } ; int n = a . length ; System . out . println ( MinimizeleftOverSum ( a , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "JAVA program to convert the given string"}
{"code": "static void minOperation ( String S , int N , int K ) {", "nl": "Function to find the minimum number of operations to convert the given string"}
{"code": "if ( N % K != 0 ) { System . out . println ( \" Not \u2581 Possible \" ) ; } else {", "nl": "Check if N is divisible by K"}
{"code": "int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < N ; i ++ ) { count [ ( S . charAt ( i ) - 97 ) ] ++ ; } int E = N / K ; Vector < Integer > greaterE = new Vector < > ( ) ; Vector < Integer > lessE = new Vector < > ( ) ; for ( int i = 0 ; i < 26 ; i ++ ) {", "nl": "Array to store frequency of characters in given string"}
{"code": "if ( count [ i ] < E ) lessE . add ( E - count [ i ] ) ; else greaterE . add ( count [ i ] - E ) ; } Collections . sort ( greaterE ) ; Collections . sort ( lessE ) ; int mi = Integer . MAX_VALUE ; for ( int i = 0 ; i <= K ; i ++ ) {", "nl": "Two arrays with number of operations required"}
{"code": "int set1 = i ; int set2 = K - i ; if ( greaterE . size ( ) >= set1 && lessE . size ( ) >= set2 ) { int step1 = 0 ; int step2 = 0 ; for ( int j = 0 ; j < set1 ; j ++ ) step1 += greaterE . get ( j ) ; for ( int j = 0 ; j < set2 ; j ++ ) step2 += lessE . get ( j ) ; mi = Math . min ( mi , Math . max ( step1 , step2 ) ) ; } } System . out . println ( mi ) ; } }", "nl": "Checking for all possibility"}
{"code": "public static void main ( String [ ] args ) { String S = \" accb \" ; int N = S . length ( ) ; int K = 2 ; minOperation ( S , N , K ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find minimum range increments to sort an array"}
{"code": "static int minMovesToSort ( int arr [ ] , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) {", "nl": "Function to find minimum range increments to sort an array"}
{"code": "if ( arr [ i ] > mn ) moves += arr [ i ] - mn ;", "nl": "If current element is found greater than last element Increment all terms in range i + 1 to n - 1"}
{"code": "} return moves ; }", "nl": "mn = arr [ i ] ; Minimum in range i to n - 1"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 2 , 8 , 4 } ; int n = arr . length ; System . out . println ( minMovesToSort ( arr , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static boolean prime [ ] = new boolean [ 100005 ] ; static void SieveOfEratosthenes ( int n ) { Arrays . fill ( prime , true ) ;", "nl": "Java implementation of the approach"}
{"code": "prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) {", "nl": "false here indicates that it is not prime"}
{"code": "if ( prime [ p ] ) {", "nl": "If prime [ p ] is not changed , then it is a prime"}
{"code": "for ( int i = p * 2 ; i < n ; i += p ) { prime [ i ] = false ; } } } }", "nl": "Update all multiples of p , set them to non - prime"}
{"code": "static void sortPrimes ( int arr [ ] , int n ) { SieveOfEratosthenes ( 100005 ) ;", "nl": "Function that sorts all the prime numbers from the array in descending"}
{"code": "Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "this vector will contain prime numbers to sort"}
{"code": "if ( prime [ arr [ i ] ] ) { v . add ( arr [ i ] ) ; } } Comparator comparator = Collections . reverseOrder ( ) ; Collections . sort ( v , comparator ) ; int j = 0 ;", "nl": "if the element is prime"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { arr [ i ] = v . get ( j ++ ) ; } } }", "nl": "update the array elements"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 4 , 3 , 2 , 6 , 100 , 17 } ; int n = arr . length ; sortPrimes ( arr , n ) ;", "nl": "Driver code"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } } }", "nl": "print the results ."}
{"code": "import java . io . * ; import java . util . Arrays ; class GFG { static void findOptimalPairs ( int arr [ ] , int N ) { Arrays . sort ( arr ) ;", "nl": "Java Program to divide the array into N pairs such that maximum pair is minimized"}
{"code": "for ( int i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) System . out . print ( \" ( \" + arr [ i ] + \" , \u2581 \" + arr [ j ] + \" ) \" + \" \u2581 \" ) ; }", "nl": "After Sorting Maintain two variables i and j pointing to start and end of array Such that smallest element of array pairs with largest element"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 9 , 6 , 5 , 1 } ; int N = arr . length ; findOptimalPairs ( arr , N ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to implement simple approach to sort an array according to count of set bits ."}
{"code": "static int countBits ( int a ) { int count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; }", "nl": "a utility function that returns total set bits count in an integer"}
{"code": "static void insertionSort ( int arr [ ] , int aux [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) {", "nl": "Function to simultaneously sort both arrays using insertion sort ( https : www . geeksforgeeks . org / insertion - sort / )"}
{"code": "int key1 = aux [ i ] ; int key2 = arr [ i ] ; int j = i - 1 ;", "nl": "use 2 keys because we need to sort both arrays simultaneously"}
{"code": "while ( j >= 0 && aux [ j ] < key1 ) { aux [ j + 1 ] = aux [ j ] ; arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } aux [ j + 1 ] = key1 ; arr [ j + 1 ] = key2 ; } }", "nl": "Move elements of arr [ 0. . i - 1 ] and aux [ 0. . i - 1 ] , such that elements of aux [ 0. . i - 1 ] are greater than key1 , to one position ahead of their current position"}
{"code": "static void sortBySetBitCount ( int arr [ ] , int n ) {", "nl": "Function to sort according to bit count using an auxiliary array"}
{"code": "int aux [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) aux [ i ] = countBits ( arr [ i ] ) ;", "nl": "Create an array and store count of set bits in it ."}
{"code": "insertionSort ( arr , aux , n ) ; }", "nl": "Sort arr [ ] according to values in aux [ ]"}
{"code": "static void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }", "nl": "Utility function to print an array"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; sortBySetBitCount ( arr , n ) ; printArr ( arr , n ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to sort an array according to count of set bits using std :: sort ( )"}
{"code": "static int countBits ( int a ) { int count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; }", "nl": "a utility function that returns total set bits count in an integer"}
{"code": "static void sortBySetBitCount ( int arr [ ] , int n ) { Vector < Integer > [ ] count = new Vector [ 32 ] ; for ( int i = 0 ; i < count . length ; i ++ ) count [ i ] = new Vector < Integer > ( ) ; int setbitcount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { setbitcount = countBits ( arr [ i ] ) ; count [ setbitcount ] . add ( arr [ i ] ) ; }", "nl": "Function to sort according to bit count . This function assumes that there are 32 bits in an integer ."}
{"code": "int j = 0 ;", "nl": "Used as an index in final sorted array"}
{"code": "for ( int i = 31 ; i >= 0 ; i -- ) { Vector < Integer > v1 = count [ i ] ; for ( int p = 0 ; p < v1 . size ( ) ; p ++ ) arr [ j ++ ] = v1 . get ( p ) ; } }", "nl": "Traverse through all bit counts ( Note that we sort array in decreasing order )"}
{"code": "static void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; }", "nl": "Utility function to print an array"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; sortBySetBitCount ( arr , n ) ; printArr ( arr , n ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void generateString ( int k1 , int k2 , char [ ] s ) {", "nl": "Function to find lexicographically smallest String having number of 1 s greater than number of 0 s"}
{"code": "int C1s = 0 , C0s = 0 ; int flag = 0 ; Vector < Integer > pos = new Vector < Integer > ( ) ;", "nl": "C1s And C0s stores the count of 1 s and 0 s at every position"}
{"code": "for ( int i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == '0' ) { C0s ++ ;", "nl": "Traverse the String S"}
{"code": "if ( ( i + 1 ) % k1 != 0 && ( i + 1 ) % k2 != 0 ) { pos . add ( i ) ; } } else { C1s ++ ; } if ( C0s >= C1s ) {", "nl": "If the position is not divisible by k1 and k2"}
{"code": "if ( pos . size ( ) == 0 ) { System . out . print ( - 1 ) ; flag = 1 ; break ; }", "nl": "If C0s >= C1s and pos [ ] is empty then the String can 't  be formed"}
{"code": "else { int k = pos . get ( pos . size ( ) - 1 ) ; s [ k ] = '1' ; C0s -- ; C1s ++ ; pos . remove ( pos . size ( ) - 1 ) ; } } }", "nl": "If pos [ ] is not empty then flip the bit of last position present in pos [ ]"}
{"code": "if ( flag == 0 ) { System . out . print ( s ) ; } }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { int K1 = 2 , K2 = 4 ; String S = \"11000100\" ; generateString ( K1 , K2 , S . toCharArray ( ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void maximizeProduct ( int N ) {", "nl": "Function to find the pair ( X , Y ) such that X xor Y = N and the count of set bits in X and Y is less than count of set bit in N"}
{"code": "int MSB = ( int ) ( Math . log ( N ) / Math . log ( 2 ) ) ;", "nl": "Stores MSB ( Most Significant Bit )"}
{"code": "int X = 1 << MSB ;", "nl": "Stores the value of X"}
{"code": "int Y = N - ( 1 << MSB ) ;", "nl": "Stores the value of Y"}
{"code": "for ( int i = 0 ; i < MSB ; i ++ ) {", "nl": "Traversing over all bits of N"}
{"code": "if ( ( N & ( 1 << i ) ) == 0 ) {", "nl": "If ith bit of N is 0"}
{"code": "X += 1 << i ;", "nl": "Set ith bit of X to 1"}
{"code": "Y += 1 << i ; } }", "nl": "Set ith bit of Y to 1"}
{"code": "System . out . println ( X + \" \u2581 \" + Y ) ; }", "nl": "Print Answer"}
{"code": "public static void main ( String [ ] args ) { int N = 45 ; maximizeProduct ( N ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static boolean check ( int num ) {", "nl": "Function to check if the number is valid"}
{"code": "int sm = 0 ;", "nl": "Sum of digits of num"}
{"code": "int num2 = num * num ; while ( num > 0 ) { sm += num % 10 ; num /= 10 ; }", "nl": "Squared number"}
{"code": "int sm2 = 0 ; while ( num2 > 0 ) { sm2 += num2 % 10 ; num2 /= 10 ; } return ( ( sm * sm ) == sm2 ) ; }", "nl": "Sum of digits of ( num * num )"}
{"code": "static int convert ( String s ) { int val = 0 ; s = reverse ( s ) ; int cur = 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { val += ( s . charAt ( i ) - '0' ) * cur ; cur *= 10 ; } return val ; }", "nl": "Function to convert a String to an integer"}
{"code": "static void generate ( String s , int len , HashSet < Integer > uniq ) {", "nl": "Function to generate all possible Strings of length len"}
{"code": "if ( s . length ( ) == len ) {", "nl": "Desired String"}
{"code": "if ( check ( convert ( s ) ) ) { uniq . add ( convert ( s ) ) ; } return ; }", "nl": "Take only valid numbers"}
{"code": "for ( int i = 0 ; i <= 3 ; i ++ ) { generate ( s + ( char ) ( i + '0' ) , len , uniq ) ; } } static String reverse ( String input ) { char [ ] a = input . toCharArray ( ) ; int l , r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . valueOf ( a ) ; }", "nl": "Recurse for all possible digits"}
{"code": "static int totalNumbers ( int L , int R ) {", "nl": "Function to calculate unique numbers in range [ L , R ]"}
{"code": "int ans = 0 ;", "nl": "Initialize a variable to store the answer"}
{"code": "int max_len = ( int ) ( Math . log10 ( R ) + 1 ) ;", "nl": "Calculate the maximum possible length"}
{"code": "HashSet < Integer > uniq = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= max_len ; i ++ ) {", "nl": "Set to store distinct valid numbers"}
{"code": "generate ( \" \" , i , uniq ) ; }", "nl": "Generate all possible Strings of length i"}
{"code": "for ( int x : uniq ) { if ( x >= L && x <= R ) { ans ++ ; } } return ans ; }", "nl": "Iterate the set to get the count of valid numbers in the range [ L , R ]"}
{"code": "public static void main ( String [ ] args ) { int L = 22 , R = 22 ; System . out . print ( totalNumbers ( L , R ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void convertXintoY ( int X , int Y ) {", "nl": "Function to check if X can be converted to Y by multiplying X by 2 or appending 1 at the end"}
{"code": "while ( Y > X ) {", "nl": "Iterate until Y is at least X"}
{"code": "if ( Y % 2 == 0 ) Y /= 2 ;", "nl": "If Y is even"}
{"code": "else if ( Y % 10 == 1 ) Y /= 10 ;", "nl": "If the last digit of Y is 1"}
{"code": "else break ; }", "nl": "Otherwise"}
{"code": "if ( X == Y ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; }", "nl": "Check if X is equal to Y"}
{"code": "public static void main ( String [ ] args ) { int X = 100 , Y = 40021 ; convertXintoY ( X , Y ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void generateString ( int K ) {", "nl": "Function to find the lexicographically smallest string of the first K lower case alphabets having unique substrings"}
{"code": "String s = \" \" ;", "nl": "Stores the resultant string"}
{"code": "for ( int i = 97 ; i < 97 + K ; i ++ ) { s = s + ( char ) ( i ) ;", "nl": "Iterate through all the characters"}
{"code": "for ( int j = i + 1 ; j < 97 + K ; j ++ ) { s += ( char ) ( i ) ; s += ( char ) ( j ) ; } }", "nl": "Inner Loop for making pairs and adding them into string"}
{"code": "s += ( char ) ( 97 ) ;", "nl": "Adding first character so that substring consisting of the last the first alphabet is present"}
{"code": "System . out . println ( s ) ; }", "nl": "Print the resultant string"}
{"code": "public static void main ( String [ ] args ) { int K = 4 ; generateString ( K ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static void findEquation ( int S , int M ) {", "nl": "Function to find the quadratic equation from the given sum and products of roots"}
{"code": "System . out . println ( \"1 \u2581 \" + ( ( - 1 ) * S ) + \" \u2581 \" + M ) ; }", "nl": "Print the coefficients"}
{"code": "public static void main ( String [ ] args ) { int S = 5 , M = 6 ; findEquation ( S , M ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int minSteps ( ArrayList < Integer > a , int n ) {", "nl": "Function to count the minimum number of pairs of adjacent elements required to be replaced by their sum to make all array elements equal"}
{"code": "int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = a . get ( 0 ) ;", "nl": "Stores the prefix sum of the array"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] + a . get ( i ) ;", "nl": "Calculate the prefix sum array"}
{"code": "int mx = - 1 ;", "nl": "Stores the maximum number of subarrays into which the array can be split"}
{"code": "for ( int subgroupsum : prefix_sum ) { int sum = 0 ; int i = 0 ; int grp_count = 0 ;", "nl": "Iterate over all possible sums"}
{"code": "while ( i < n ) { sum += a . get ( i ) ;", "nl": "Traverse the array"}
{"code": "if ( sum == subgroupsum ) {", "nl": "If the sum is equal to the current prefix sum"}
{"code": "grp_count += 1 ; sum = 0 ; }", "nl": "Increment count of groups by 1"}
{"code": "else if ( sum > subgroupsum ) { grp_count = - 1 ; break ; } i += 1 ; }", "nl": "Otherwise discard this subgroup sum"}
{"code": "if ( grp_count > mx ) mx = grp_count ; }", "nl": "Update the maximum this of subarrays"}
{"code": "return n - mx ; }", "nl": "Return the minimum number of operations"}
{"code": "public static void main ( String [ ] args ) { ArrayList < Integer > A = new ArrayList < Integer > ( ) ; A . add ( 1 ) ; A . add ( 2 ) ; A . add ( 3 ) ; A . add ( 2 ) ; A . add ( 1 ) ; A . add ( 3 ) ; int N = A . size ( ) ;", "nl": "Driver Code"}
{"code": "System . out . print ( minSteps ( A , N ) ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static void maxOccuringCharacter ( String s ) {", "nl": "Function to find the most frequent character after replacing X with either '0' or '1' according as per the given conditions"}
{"code": "int count0 = 0 , count1 = 0 ;", "nl": "Store the count of 0 s and 1 s in the string S"}
{"code": "for ( int i = 0 ; i < s . length ( ) ; i ++ ) {", "nl": "Count the frequency of 0 and 1"}
{"code": "if ( s . charAt ( i ) == '1' ) { count1 ++ ; }", "nl": "If the character is 1"}
{"code": "else if ( s . charAt ( i ) == '0' ) { count0 ++ ; } }", "nl": "If the character is 0"}
{"code": "int prev = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' ) { prev = i ; break ; } }", "nl": "Stores first occurence of 1"}
{"code": "for ( int i = prev + 1 ; i < s . length ( ) ; i ++ ) {", "nl": "Traverse the string to count the number of X between two consecutive 1 s"}
{"code": "if ( s . charAt ( i ) != ' X ' ) {", "nl": "If the current character is not X"}
{"code": "if ( s . charAt ( i ) == '1' ) { count1 += i - prev - 1 ; prev = i ; }", "nl": "If the current character is 1 , add the number of Xs to count1 and set prev to i"}
{"code": "else {", "nl": "Otherwise"}
{"code": "boolean flag = true ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) == '1' ) { flag = false ; prev = j ; break ; } }", "nl": "Find next occurence of 1 in the string"}
{"code": "if ( ! flag ) { i = prev ; }", "nl": "If it is found , set i to prev"}
{"code": "else { i = s . length ( ) ; } } } }", "nl": "Otherwise , break out of the loop"}
{"code": "prev = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '0' ) { prev = i ; break ; } }", "nl": "Store the first occurence of 0"}
{"code": "for ( int i = prev + 1 ; i < s . length ( ) ; i ++ ) {", "nl": "Repeat the same procedure to count the number of X between two consecutive 0 s"}
{"code": "if ( s . charAt ( i ) != ' X ' ) {", "nl": "If the current character is not X"}
{"code": "if ( s . charAt ( i ) == '0' ) {", "nl": "If the current character is 0"}
{"code": "count0 += i - prev - 1 ;", "nl": "Add the count of Xs to count0"}
{"code": "prev = i ; }", "nl": "Set prev to i"}
{"code": "else {", "nl": "Otherwise"}
{"code": "boolean flag = true ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) == '0' ) { prev = j ; flag = false ; break ; } }", "nl": "Find the next occurence of 0 in the string"}
{"code": "if ( ! flag ) { i = prev ; }", "nl": "If it is found , set i to prev"}
{"code": "else { i = s . length ( ) ; } } } }", "nl": "Otherwise , break out of the loop"}
{"code": "if ( s . charAt ( 0 ) == ' X ' ) {", "nl": "Count number of X present in the starting of the string as XXXX1 ..."}
{"code": "int count = 0 ; int i = 0 ; while ( s . charAt ( i ) == ' X ' ) { count ++ ; i ++ ; }", "nl": "Store the count of X"}
{"code": "if ( s . charAt ( i ) == '1' ) { count1 += count ; } }", "nl": "Increment count1 by count if the condition is satisfied"}
{"code": "if ( s . charAt ( s . length ( ) - 1 ) == ' X ' ) {", "nl": "Count the number of X present in the ending of the string as ... XXXX0"}
{"code": "int count = 0 ; int i = s . length ( ) - 1 ; while ( s . charAt ( i ) == ' X ' ) { count ++ ; i -- ; }", "nl": "Store the count of X"}
{"code": "if ( s . charAt ( i ) == '0' ) { count0 += count ; } }", "nl": "Increment count0 by count if the condition is satisfied"}
{"code": "if ( count0 == count1 ) { System . out . println ( \" X \" ) ; }", "nl": "If count of 1 is equal to count of 0 , print X"}
{"code": "else if ( count0 > count1 ) { System . out . println ( 0 ) ; }", "nl": "Otherwise , if count of 1 is greater than count of 0"}
{"code": "else System . out . println ( 1 ) ; }", "nl": "Otherwise , print 0"}
{"code": "public static void main ( String [ ] args ) { String S = \" XX10XX10XXX1XX \" ; maxOccuringCharacter ( S ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int maxSheets ( int A , int B ) { int area = A * B ;", "nl": "Function to calculate the maximum number of sheets possible by given operations"}
{"code": "int count = 1 ;", "nl": "Initial count of sheets"}
{"code": "while ( area % 2 == 0 ) {", "nl": "Keep dividing the sheets into half"}
{"code": "area /= 2 ;", "nl": "Reduce area by half"}
{"code": "count *= 2 ; } return count ; }", "nl": "Increase count by twice"}
{"code": "public static void main ( String args [ ] ) { int A = 5 , B = 10 ; System . out . println ( maxSheets ( A , B ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void findMinMoves ( int a , int b ) {", "nl": "Function to find the minimum moves required to reach origin from ( a , b )"}
{"code": "int ans = 0 ;", "nl": "Stores the minimum number of moves"}
{"code": "if ( a == b || Math . abs ( a - b ) == 1 ) { ans = a + b ; } else {", "nl": "Check if the absolute difference is 1 or 0"}
{"code": "int k = Math . min ( a , b ) ;", "nl": "Store the minimum of a , b"}
{"code": "int j = Math . max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; }", "nl": "Store the maximum of a , b"}
{"code": "System . out . print ( ans ) ; }", "nl": "Print the answer"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int a = 3 , b = 5 ;", "nl": "Given co - ordinates"}
{"code": "findMinMoves ( a , b ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static long cntEvenSumPairs ( long X , long Y ) {", "nl": "Function to count maximum even sum pairs in the given range"}
{"code": "long cntXEvenNums = X / 2 ;", "nl": "Stores the count of even numbers between 1 to X"}
{"code": "long cntXOddNums = ( X + 1 ) / 2 ;", "nl": "Stores the count of odd numbers between 1 to X"}
{"code": "long cntYEvenNums = Y / 2 ;", "nl": "Stores the count of even numbers between 1 to Y"}
{"code": "long cntYOddNums = ( Y + 1 ) / 2 ;", "nl": "Stores the count of odd numbers between 1 to Y"}
{"code": "long cntPairs = ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ;", "nl": "Stores the count of pairs having even sum"}
{"code": "return cntPairs ; }", "nl": "Retuens the count of pairs having even sum"}
{"code": "public static void main ( String [ ] args ) { long X = 2 ; long Y = 3 ; System . out . println ( cntEvenSumPairs ( X , Y ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int minMoves ( int [ ] arr ) { int N = arr . length ;", "nl": "Function to calculate minimum number of moves to make the sequence a Fibonacci series"}
{"code": "if ( N <= 2 ) return 0 ;", "nl": "If number of elements is less than 3"}
{"code": "int ans = Integer . MAX_VALUE ;", "nl": "Initialize the value of the result"}
{"code": "for ( int i = - 1 ; i <= 1 ; i ++ ) { for ( int j = - 1 ; j <= 1 ; j ++ ) {", "nl": "Try all permutations of the first two elements"}
{"code": "int num1 = arr [ 0 ] + i ;", "nl": "Value of first element after operation"}
{"code": "int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = Math . abs ( i ) + Math . abs ( j ) ;", "nl": "Value of second element after operation"}
{"code": "for ( int idx = 2 ; idx < N ; idx ++ ) {", "nl": "Calculate number of moves for rest of the elements of the array"}
{"code": "int num = num1 + num2 ;", "nl": "Element at idx index"}
{"code": "if ( Math . abs ( arr [ idx ] - num ) > 1 ) flag = 0 ;", "nl": "If it is not possible to change the element in atmost one move"}
{"code": "else moves += Math . abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; }", "nl": "Otherwise"}
{"code": "if ( flag > 0 ) ans = Math . min ( ans , moves ) ; } }", "nl": "Update the answer"}
{"code": "if ( ans == Integer . MAX_VALUE ) return - 1 ; return ans ; }", "nl": "Return the answer"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 4 , 8 , 9 , 17 , 27 } ; System . out . print ( minMoves ( arr ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void querySum ( int arr [ ] , int N , int Q [ ] [ ] , int M ) {", "nl": "Function to Find the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all queries"}
{"code": "for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ;", "nl": "Iterate over each query"}
{"code": "int sum = 0 ;", "nl": "Stores the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ..."}
{"code": "while ( x < N ) {", "nl": "Traverse the array and calculate the sum of the expression"}
{"code": "sum += arr [ x ] ;", "nl": "Update sum"}
{"code": "x += y ; } System . out . print ( sum + \" \u2581 \" ) ; } }", "nl": "Update x"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 7 , 5 , 4 } ; int Q [ ] [ ] = { { 2 , 1 } , { 3 , 2 } } ; int N = arr . length ; int M = Q . length ; querySum ( arr , N , Q , M ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; }", "nl": "Function to calculate Bitwise OR from given bitwise XOR and bitwise AND values"}
{"code": "public static void main ( String [ ] args ) { int X = 5 , Y = 2 ; System . out . print ( findBitwiseORGivenXORAND ( X , Y ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class solution {", "nl": "Java program for the above approach"}
{"code": "static int GCD ( int a , int b ) {", "nl": "Function to return GCD of two numbers a and b"}
{"code": "if ( b == 0 ) return a ;", "nl": "Base Case"}
{"code": "return GCD ( b , a % b ) ; }", "nl": "Recursively Find the GCD"}
{"code": "static void canReach ( int N , int A , int B , int K ) {", "nl": "Function to check of B can be reaced from A with a jump of K elements in the circular queue"}
{"code": "int gcd = GCD ( N , K ) ;", "nl": "Find GCD of N and K"}
{"code": "if ( Math . abs ( A - B ) % gcd == 0 ) { System . out . println ( \" Yes \" ) ; }", "nl": "If A - B is divisible by gcd then print Yes"}
{"code": "else { System . out . println ( \" No \" ) ; } }", "nl": "Otherwise"}
{"code": "public static void main ( String args [ ] ) { int N = 5 , A = 2 , B = 1 , K = 2 ;", "nl": "Driver Code"}
{"code": "canReach ( N , A , B , K ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void countOfSubarray ( int arr [ ] , int N ) {", "nl": "Function that counts the subarrays with sum of its elements as its length"}
{"code": "Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;", "nl": "Store count of elements upto current element with length i"}
{"code": "int answer = 0 ;", "nl": "Stores the final count of subarray"}
{"code": "int sum = 0 ;", "nl": "Stores the prefix sum"}
{"code": "if ( mp . get ( 1 ) != null ) mp . put ( 1 , mp . get ( 1 ) + 1 ) ; else mp . put ( 1 , 1 ) ;", "nl": "If size of subarray is 1"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Iterate the array"}
{"code": "sum += arr [ i ] ; if ( mp . get ( sum - i ) != null ) answer += mp . get ( sum - i ) ;", "nl": "Find the sum"}
{"code": "if ( mp . get ( sum - i ) != null ) mp . put ( sum - i , mp . get ( sum - i ) + 1 ) ; else mp . put ( sum - i , 1 ) ; }", "nl": "Update frequency in map"}
{"code": "System . out . print ( answer ) ; }", "nl": "Print the total count"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 1 , 0 , 2 , 1 , 2 , - 2 , 2 , 4 } ;", "nl": "Given array arr [ ]"}
{"code": "int N = arr . length ;", "nl": "Size of array"}
{"code": "countOfSubarray ( arr , N ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int minAbsDiff ( int N ) {", "nl": "Function to split the first N natural numbers into two sets having minimum absolute difference of their sums"}
{"code": "int sumSet1 = 0 ;", "nl": "Stores the sum of elements of set1"}
{"code": "int sumSet2 = 0 ;", "nl": "Stores the sum of elements of set2"}
{"code": "for ( int i = N ; i > 0 ; i -- ) {", "nl": "Traverse first N natural numbers"}
{"code": "if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return Math . abs ( sumSet1 - sumSet2 ) ; }", "nl": "Check if sum of elements of set1 is less than or equal to sum of elements of set2"}
{"code": "public static void main ( String [ ] args ) { int N = 6 ; System . out . println ( minAbsDiff ( N ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static boolean checkDigits ( int n ) {", "nl": "Function to check if N contains digits 0 , 1 , 2 , 5 , 8 only"}
{"code": "do { int r = n % 10 ;", "nl": "Extract digits of N"}
{"code": "if ( r == 3 r == 4 r == 6 r == 7 r == 9 ) return false ; n /= 10 ; } while ( n != 0 ) ; return true ; }", "nl": "Return false if any of these digits are present"}
{"code": "static boolean isPrime ( int n ) { if ( n <= 1 ) return false ;", "nl": "Function to check if N is prime or not"}
{"code": "for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }", "nl": "Check for all factors"}
{"code": "static boolean isAllPrime ( int n ) { return isPrime ( n ) && checkDigits ( n ) ; }", "nl": "Function to check if n is prime in all the desired forms"}
{"code": "public static void main ( String [ ] args ) { int N = 101 ; if ( isAllPrime ( N ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void minCost ( String str , int a , int b ) {", "nl": "Function to calculate the minimum cost required to generate a balanced bracket sequence"}
{"code": "int openUnbalanced = 0 ;", "nl": "Stores the count of unbalanced open brackets"}
{"code": "int closedUnbalanced = 0 ;", "nl": "Stores the count of unbalanced closed brackets"}
{"code": "int openCount = 0 ;", "nl": "Stores the count of open brackets"}
{"code": "int closedCount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) {", "nl": "Stores the count of closed brackets"}
{"code": "if ( str . charAt ( i ) == ' ( ' ) { openUnbalanced ++ ; openCount ++ ; }", "nl": "If open brace is encountered"}
{"code": "else {", "nl": "Otherwise"}
{"code": "if ( openUnbalanced == 0 )", "nl": "If no unbalanced open brackets are present"}
{"code": "closedUnbalanced ++ ;", "nl": "Increase count of unbalanced closed brackets"}
{"code": "else", "nl": "Otherwise"}
{"code": "openUnbalanced -- ;", "nl": "Reduce count of unbalanced open brackets"}
{"code": "closedCount ++ ; } }", "nl": "Increase count of closed brackets"}
{"code": "int result = a * ( Math . abs ( openCount - closedCount ) ) ;", "nl": "Calculate lower bound of minimum cost"}
{"code": "if ( closedCount > openCount ) closedUnbalanced -= ( closedCount - openCount ) ; if ( openCount > closedCount ) openUnbalanced -= ( openCount - closedCount ) ;", "nl": "Reduce excess open or closed brackets to prevent counting them twice"}
{"code": "result += Math . min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ;", "nl": "Update answer by adding minimum of removing both unbalanced open and closed brackets or inserting closed unbalanced brackets to end of String"}
{"code": "System . out . print ( result + \"NEW_LINE\"); }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { String str = \" ) ) ( ) ( ( ) ( ) ( \" ; int A = 1 , B = 3 ; minCost ( str , A , B ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static void countEvenSum ( int low , int high , int k ) {", "nl": "Function to return the number of all permutations such that sum of K numbers in range is even"}
{"code": "int even_count = high / 2 - ( low - 1 ) / 2 ; int odd_count = ( high + 1 ) / 2 - low / 2 ; long even_sum = 1 ; long odd_sum = 0 ;", "nl": "Find total count of even and odd number in given range"}
{"code": "for ( int i = 0 ; i < k ; i ++ ) {", "nl": "Iterate loop k times and update even_sum & odd_sum using previous values"}
{"code": "long prev_even = even_sum ; long prev_odd = odd_sum ;", "nl": "Update the prev_even and odd_sum"}
{"code": "even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ;", "nl": "Even sum"}
{"code": "odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; }", "nl": "Odd sum"}
{"code": "System . out . println ( even_sum ) ; }", "nl": "Return even_sum"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int low = 4 ; int high = 5 ;", "nl": "Given ranges"}
{"code": "int K = 3 ;", "nl": "Length of permutation"}
{"code": "countEvenSum ( low , high , K ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java Program to implement the above approach"}
{"code": "public static void count ( int n , int k ) { long count = ( long ) ( Math . pow ( 10 , k ) - Math . pow ( 10 , k - 1 ) ) ;", "nl": "Function to count the number of N - digit numbers such that sum of every K consecutive digits are equal"}
{"code": "System . out . print ( count ) ; }", "nl": "Print the answer"}
{"code": "public static void main ( String [ ] args ) { int n = 2 , k = 1 ; count ( n , k ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static int func ( int N , int P ) {", "nl": "Function to find the sum of largest divisors of numbers in range 1 to N not divisible by prime number P"}
{"code": "int sumUptoN = ( N * ( N + 1 ) / 2 ) ; int sumOfMultiplesOfP ;", "nl": "Total sum upto N"}
{"code": "if ( N < P ) { return sumUptoN ; }", "nl": "If no multiple of P exist up to N"}
{"code": "else if ( ( N / P ) == 1 ) { return sumUptoN - P + 1 ; }", "nl": "If only P itself is in the range from 1 to N"}
{"code": "sumOfMultiplesOfP = ( ( N / P ) * ( 2 * P + ( N / P - 1 ) * P ) ) / 2 ;", "nl": "Sum of those that are divisible by P"}
{"code": "return ( sumUptoN + func ( N / P , P ) - sumOfMultiplesOfP ) ; }", "nl": "Recursively function call to find the sum for N / P"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 10 , P = 5 ;", "nl": "Given N and P"}
{"code": "System . out . println ( func ( N , P ) ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java program to implement the approach"}
{"code": "public static void findShifts ( int [ ] A , int N ) {", "nl": "Function to find the right shifts required for each element to reach its sorted array position in A [ ]"}
{"code": "int [ ] shift = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Stores required number of shifts for each element"}
{"code": "if ( i == A [ i ] - 1 ) shift [ i ] = 0 ;", "nl": "If the element is at sorted position"}
{"code": "else", "nl": "Otherwise"}
{"code": "shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; }", "nl": "Calculate right shift"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) System . out . print ( shift [ i ] + \" \u2581 \" ) ; }", "nl": "Print the respective shifts"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 4 , 3 , 2 , 5 } ; int N = arr . length ; findShifts ( arr , N ) ; } }", "nl": "Driver code"}
{"code": "public class Main {", "nl": "Java program to implement the above approach"}
{"code": "public static void constructmatrix ( int N ) { boolean check = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) {", "nl": "Function to construct matrix with diagonal sum equal to matrix sum"}
{"code": "if ( i == j ) { System . out . print ( \"1 \u2581 \" ) ; } else if ( check ) {", "nl": "If diagonal position"}
{"code": "System . out . print ( \"2 \u2581 \" ) ; check = false ; } else {", "nl": "Positive element"}
{"code": "System . out . print ( \" - 2 \u2581 \" ) ; check = true ; } } System . out . println ( ) ; } }", "nl": "Negative element"}
{"code": "public static void main ( String [ ] args ) { int N = 5 ; constructmatrix ( 5 ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java Program to implement the above approach"}
{"code": "static int check ( int unit_digit , int X ) { int times , digit ;", "nl": "Function to calculate and return the minimum number of times a number with unit digit X needs to be added to get a sum N"}
{"code": "for ( times = 1 ; times <= 10 ; times ++ ) { digit = ( X * times ) % 10 ; if ( digit == unit_digit ) return times ; }", "nl": "Calculate the number of additions required to get unit digit of N"}
{"code": "return - 1 ; }", "nl": "If unit digit of N cannot be obtained"}
{"code": "static int getNum ( int N , int X ) { int unit_digit ;", "nl": "Function to return the minimum number required to represent N"}
{"code": "unit_digit = N % 10 ;", "nl": "Stores unit digit of N"}
{"code": "int times = check ( unit_digit , X ) ;", "nl": "Stores minimum addition of X required to obtain unit digit of N"}
{"code": "if ( times == - 1 ) return times ;", "nl": "If unit digit of N cannot be obtained"}
{"code": "else {", "nl": "Otherwise"}
{"code": "if ( N >= ( times * X ) )", "nl": "If N is greater than or equal to ( X * times )"}
{"code": "return times ;", "nl": "Minimum count of numbers that needed to represent N"}
{"code": "else return - 1 ; } }", "nl": "Representation not possible"}
{"code": "public static void main ( String [ ] args ) { int N = 58 , X = 7 ; System . out . println ( getNum ( N , X ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static int minPoints ( int n , int m ) { int ans = 0 ;", "nl": "Function to find the minimum number of Points required to cover a grid"}
{"code": "if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = ( ( n * m ) / 2 ) + 1 ; } else { ans = ( n * m ) / 2 ; }", "nl": "If number of block is even"}
{"code": "return ans ; }", "nl": "Return the minimum points"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 5 , M = 7 ;", "nl": "Given size of grid"}
{"code": "System . out . print ( minPoints ( N , M ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java code for the above approach"}
{"code": "static String getLargestString ( String s , int k ) {", "nl": "Function to find the largest lexicographical String with given constraints ."}
{"code": "int [ ] frequency_array = new int [ 26 ] ;", "nl": "Vector containing frequency of each character ."}
{"code": "for ( int i = 0 ; i < s . length ( ) ; i ++ ) { frequency_array [ s . charAt ( i ) - ' a ' ] ++ ; }", "nl": "Assigning frequency"}
{"code": "String ans = \" \" ;", "nl": "Empty String of String class type"}
{"code": "for ( int i = 25 ; i >= 0 {", "nl": "Loop to iterate over maximum priority first ."}
{"code": "if ( frequency_array [ i ] > k ) {", "nl": "If frequency is greater than or equal to k ."}
{"code": "int temp = k ; String st = String . valueOf ( ( char ) ( i + ' a ' ) ) ; while ( temp > 0 ) {", "nl": "Temporary variable to operate in - place of k ."}
{"code": "ans += st ; temp -- ; } frequency_array [ i ] -= k ;", "nl": "Concatenating with the resultant String ans ."}
{"code": "int j = i - 1 ; while ( frequency_array [ j ] <= 0 && j >= 0 ) { j -- ; }", "nl": "Handling k case by adjusting with just smaller priority element ."}
{"code": "if ( frequency_array [ j ] > 0 && j >= 0 ) { String str = String . valueOf ( ( char ) ( j + ' a ' ) ) ; ans += str ; frequency_array [ j ] -= 1 ; } else {", "nl": "Condition to verify if index j does have frequency greater than 0 ;"}
{"code": "break ; } }", "nl": "If no such element is found than String can not be processed further ."}
{"code": "else if ( frequency_array [ i ] > 0 ) {", "nl": "If frequency is greater than 0 and less than k ."}
{"code": "int temp = frequency_array [ i ] ; frequency_array [ i ] -= temp ; String st = String . valueOf ( ( char ) ( i + ' a ' ) ) ; while ( temp > 0 ) { ans += st ; temp -- ; } }", "nl": "Here we don 't need to fix K  consecutive element criteria."}
{"code": "else { i -- ; } } return ans ; }", "nl": "Otherwise check for next possible element ."}
{"code": "public static void main ( String [ ] args ) { String S = \" xxxxzza \" ; int k = 3 ; System . out . print ( getLargestString ( S , k ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to find the minimum operations make all elements equal using the second array"}
{"code": "static int minOperations ( int a [ ] , int b [ ] , int n ) {", "nl": "Function to find the minimum operations required to make all elements of the array equal"}
{"code": "int minA = Arrays . stream ( a ) . min ( ) . getAsInt ( ) ;", "nl": "Minimum element of A [ ]"}
{"code": "for ( int x = minA ; x >= 0 ; x -- ) {", "nl": "Traverse through all final values"}
{"code": "boolean check = true ;", "nl": "Variable indicating whether all elements can be converted to x or not"}
{"code": "int operations = 0 ;", "nl": "Total operations"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; }", "nl": "Traverse through all array elements"}
{"code": "else { check = false ; break ; } } if ( check ) return operations ; } return - 1 ; }", "nl": "All elements can 't  be converted to x"}
{"code": "public static void main ( String [ ] args ) { int N = 5 ; int A [ ] = { 5 , 7 , 10 , 5 , 15 } ; int B [ ] = { 2 , 2 , 1 , 3 , 5 } ; System . out . print ( minOperations ( A , B , N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to find the largest value of a + b satisfying the given condition"}
{"code": "static int getLargestSum ( int N ) {", "nl": "Function to return the maximum sum of a + b satisfying the given condition"}
{"code": "int max_sum = 0 ;", "nl": "Initialize max_sum"}
{"code": "for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) {", "nl": "Consider all the possible pairs"}
{"code": "if ( i * j % ( i + j ) == 0 )", "nl": "Check if the product is divisible by the sum"}
{"code": "max_sum = Math . max ( max_sum , i + j ) ; } }", "nl": "Storing the maximum sum in the max_sum variable"}
{"code": "return max_sum ; }", "nl": "Return the max_sum value"}
{"code": "public static void main ( String [ ] args ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; System . out . print ( max_sum ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation to find the maximum sum of the array by multiplying the prefix and suffix of the array by - 1"}
{"code": "static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ;", "nl": "Kadane 's algorithm to find  the maximum subarray sum"}
{"code": "for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; }", "nl": "Loop to find the maximum subarray array sum in the given array"}
{"code": "static int maxSum ( int a [ ] , int n ) {", "nl": "Function to find the maximum sum of the array by multiplying the prefix and suffix by - 1"}
{"code": "int S = 0 ; int i ;", "nl": "Total intital sum"}
{"code": "for ( i = 0 ; i < n ; i ++ ) S += a [ i ] ; int X = maxSubArraySum ( a , n ) ;", "nl": "Loop to find the maximum sum of the array"}
{"code": "return 2 * X - S ; }", "nl": "Maximum value"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { - 1 , - 2 , - 3 } ; int n = a . length ; int max_sum = maxSum ( a , n ) ; System . out . print ( max_sum ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to find the number of interesting primes up to N"}
{"code": "static boolean isPrime ( int n ) { int flag = 1 ;", "nl": "Function to check if a number is prime or not"}
{"code": "for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { flag = 0 ; break ; } } return ( flag == 1 ? true : false ) ; }", "nl": "If n is divisible by any number between 2 and Math . sqrt ( n ) , it is not prime"}
{"code": "static boolean isPerfectSquare ( int x ) {", "nl": "Function to check if a number is perfect square or not"}
{"code": "double sr = Math . sqrt ( x ) ;", "nl": "Find floating point value of square root of x ."}
{"code": "return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }", "nl": "If square root is an integer"}
{"code": "static int countInterestingPrimes ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) {", "nl": "Function to find the number of interesting primes less than equal to N ."}
{"code": "if ( isPrime ( i ) ) {", "nl": "Check whether the number is prime or not"}
{"code": "for ( int j = 1 ; j * j * j * j <= i ; j ++ ) {", "nl": "Iterate for values of b"}
{"code": "if ( isPerfectSquare ( i - j * j * j * j ) ) { answer ++ ; break ; } } } }", "nl": "Check condition for a"}
{"code": "return answer ; }", "nl": "Return the required answer"}
{"code": "public static void main ( String [ ] args ) { int N = 10 ; System . out . print ( countInterestingPrimes ( N ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void decBinary ( int arr [ ] , int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } }", "nl": "Function to convert decimal number n to its binary representation stored as an array arr [ ]"}
{"code": "static int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; }", "nl": "Function to convert the number represented as a binary array arr [ ] into its decimal equivalent"}
{"code": "static int maxNum ( int n , int k ) {", "nl": "Function to return the maximized number by flipping atmost k bits"}
{"code": "int l = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ;", "nl": "Number of bits in n"}
{"code": "int a [ ] = new int [ l ] ; decBinary ( a , n ) ;", "nl": "Find the binary representation of n"}
{"code": "int cn = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == 0 && cn < k ) { a [ i ] = 1 ; cn ++ ; } }", "nl": "To count the number of 0 s flipped"}
{"code": "return binaryDec ( a , l ) ; }", "nl": "Return the decimal equivalent of the maximized number"}
{"code": "public static void main ( String [ ] args ) { int n = 4 , k = 1 ; System . out . println ( maxNum ( n , k ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void findSubSeq ( int arr [ ] , int n , int sum ) { for ( int i = n - 1 ; i >= 0 ; i -- ) {", "nl": "Function to find the required subsequence"}
{"code": "if ( sum < arr [ i ] ) arr [ i ] = - 1 ;", "nl": "Current element cannot be a part of the required subsequence"}
{"code": "else sum -= arr [ i ] ; }", "nl": "Include current element in the required subsequence So update the sum"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Print the elements of the required subsequence"}
{"code": "if ( arr [ i ] != - 1 ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }", "nl": "If the current element was included in the subsequence"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 17 , 25 , 46 , 94 , 201 , 400 } ; int n = arr . length ; int sum = 272 ; findSubSeq ( arr , n , sum ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int MAX = 26 ;", "nl": "Java implementation of the approach"}
{"code": "static char maxAlpha ( String str , int len ) {", "nl": "Function to return the maximum valued alphabet"}
{"code": "int [ ] first = new int [ MAX ] ; int [ ] last = new int [ MAX ] ;", "nl": "To store the first and the last occurrence of all the characters"}
{"code": "for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; }", "nl": "Set the first and the last occurrence of all the characters to - 1"}
{"code": "for ( int i = 0 ; i < len ; i ++ ) { int index = ( str . charAt ( i ) - ' a ' ) ;", "nl": "Update the occurrences of the characters"}
{"code": "if ( first [ index ] == - 1 ) first [ index ] = i ; last [ index ] = i ; }", "nl": "Only set the first occurrence if it hasn 't already been set"}
{"code": "int ans = - 1 , maxVal = - 1 ;", "nl": "To store the result"}
{"code": "for ( int i = 0 ; i < MAX ; i ++ ) {", "nl": "For every alphabet"}
{"code": "if ( first [ i ] == - 1 ) continue ;", "nl": "If current alphabet doesn 't appear  in the given String"}
{"code": "if ( ( last [ i ] - first [ i ] ) > maxVal ) { maxVal = last [ i ] - first [ i ] ; ans = i ; } } return ( char ) ( ans + ' a ' ) ; }", "nl": "If the current character has the highest value so far"}
{"code": "public static void main ( String [ ] args ) { String str = \" abbba \" ; int len = str . length ( ) ; System . out . print ( maxAlpha ( str , len ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static int MAX = 100001 ;", "nl": "Java implementation of the approach"}
{"code": "static void find_distinct ( int a [ ] , int n , int q , int queries [ ] ) { int [ ] check = new int [ MAX ] ; int [ ] idx = new int [ MAX ] ; int cnt = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) {", "nl": "Function to perform queries to find number of distinct elements from a given index till last index in an array"}
{"code": "if ( check [ a [ i ] ] == 0 ) {", "nl": "Check if current element already visited or not"}
{"code": "idx [ i ] = cnt ; check [ a [ i ] ] = 1 ; cnt ++ ; } else {", "nl": "If not visited store current counter and increment it and mark check as 1"}
{"code": "idx [ i ] = cnt - 1 ; } }", "nl": "Otherwise if visited simply store current counter"}
{"code": "for ( int i = 0 ; i < q ; i ++ ) { int m = queries [ i ] ; System . out . print ( idx [ m ] + \" \u2581 \" ) ; } }", "nl": "Perform queries"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 } ; int n = a . length ; int queries [ ] = { 0 , 3 , 5 , 7 } ; int q = queries . length ; find_distinct ( a , n , q , queries ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static int MAX = 24 ;", "nl": "Java implementation of the approach"}
{"code": "static int countOp ( int x ) {", "nl": "Function to return the count of operations required"}
{"code": "int arr [ ] = new int [ MAX ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] * 2 ;", "nl": "To store the powers of 2"}
{"code": "int temp = x ; boolean flag = true ;", "nl": "Temporary variable to store x"}
{"code": "int ans = 0 ;", "nl": "To store the index of smaller number larger than x"}
{"code": "int operations = 0 ; boolean flag2 = false ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( arr [ i ] - 1 == x ) flag2 = true ;", "nl": "To store the count of operations"}
{"code": "if ( arr [ i ] > x ) { ans = i ; break ; } }", "nl": "Stores the index of number in the form of 2 ^ n - 1"}
{"code": "if ( flag2 ) return 0 ; while ( flag ) {", "nl": "If x is already in the form 2 ^ n - 1 then no operation is required"}
{"code": "if ( arr [ ans ] < x ) ans ++ ; operations ++ ;", "nl": "If number is less than x increase the index"}
{"code": "for ( int i = 0 ; i < MAX ; i ++ ) { int take = x ^ ( arr [ i ] - 1 ) ; if ( take <= arr [ ans ] - 1 ) {", "nl": "Calculate all the values ( x xor 2 ^ n - 1 ) for all possible n"}
{"code": "if ( take > temp ) temp = take ; } }", "nl": "Only take value which is closer to the number"}
{"code": "if ( temp == arr [ ans ] - 1 ) { flag = false ; break ; } temp ++ ; operations ++ ; x = temp ; if ( x == arr [ ans ] - 1 ) flag = false ; }", "nl": "If number is in the form of 2 ^ n - 1 then break"}
{"code": "return operations ; }", "nl": "Return the count of operations required to obtain the number"}
{"code": "public static void main ( String [ ] args ) { int x = 39 ; System . out . println ( countOp ( x ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Arrays ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int minOperations ( int [ ] arr , int n ) { int maxi , result = 0 ;", "nl": "Function to return the minimum operations required"}
{"code": "int [ ] freq = new int [ 1000001 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x ] ++ ; }", "nl": "Count the frequency of each element"}
{"code": "maxi = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) {", "nl": "Maximum element from the array"}
{"code": "for ( int j = i * 2 ; j <= maxi ; j = j + i ) {", "nl": "Find all the multiples of i"}
{"code": "freq [ j ] = 0 ; }", "nl": "Delete the multiples"}
{"code": "result ++ ; } } return result ; }", "nl": "Increment the operations"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 2 , 4 , 4 , 4 } ; int n = arr . length ; System . out . println ( minOperations ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int __gcd ( int a , int b ) { if ( a == 0 ) return b ; return __gcd ( b % a , a ) ; } static int minGCD ( int arr [ ] , int n ) { int minGCD = 0 ;", "nl": "Function to return minimum GCD among all subarrays"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) minGCD = __gcd ( minGCD , arr [ i ] ) ; return minGCD ; }", "nl": "Minimum GCD among all sub - arrays will be the GCD of all the elements of the array"}
{"code": "static int minLCM ( int arr [ ] , int n ) { int minLCM = arr [ 0 ] ;", "nl": "Function to return minimum LCM among all subarrays"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) minLCM = Math . min ( minLCM , arr [ i ] ) ; return minLCM ; }", "nl": "Minimum LCM among all sub - arrays will be the minimum element from the array"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 66 , 14 , 521 } ; int n = arr . length ; System . out . println ( \" LCM \u2581 = \u2581 \" + minLCM ( arr , n ) + \" \u2581 GCD \u2581 = \u2581 \" + minGCD ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static String formStringMinOperations ( char [ ] s ) {", "nl": "Function that returns the modified lexicographically smallest String after performing minimum number of given operations"}
{"code": "int count [ ] = new int [ 3 ] ; for ( char c : s ) { count [ ( int ) c - 48 ] += 1 ; }", "nl": "Stores the initial frequencies of characters 0 s , 1 s and 2 s"}
{"code": "int processed [ ] = new int [ 3 ] ;", "nl": "Stores number of processed characters upto that point of each type"}
{"code": "int reqd = ( int ) s . length / 3 ; for ( int i = 0 ; i < s . length ; i ++ ) {", "nl": "Required number of characters of each type"}
{"code": "if ( count [ s [ i ] - '0' ] == reqd ) { continue ; }", "nl": "If the current type has already reqd number of characters , no need to perform any operation"}
{"code": "if ( s [ i ] == '0' && count [ 0 ] > reqd && processed [ 0 ] >= reqd ) {", "nl": "Process all 3 cases"}
{"code": "if ( count [ 1 ] < reqd ) { s [ i ] = '1' ; count [ 1 ] ++ ; count [ 0 ] -- ; }", "nl": "Check for 1 first"}
{"code": "else if ( count [ 2 ] < reqd ) { s [ i ] = '2' ; count [ 2 ] ++ ; count [ 0 ] -- ; } }", "nl": "Else 2"}
{"code": "if ( s [ i ] == '1' && count [ 1 ] > reqd ) { if ( count [ 0 ] < reqd ) { s [ i ] = '0' ; count [ 0 ] ++ ; count [ 1 ] -- ; } else if ( count [ 2 ] < reqd && processed [ 1 ] >= reqd ) { s [ i ] = '2' ; count [ 2 ] ++ ; count [ 1 ] -- ; } }", "nl": "Here we need to check processed [ 1 ] only for 2 since 0 is less than 1 and we can replace it anytime"}
{"code": "if ( s [ i ] == '2' && count [ 2 ] > reqd ) { if ( count [ 0 ] < reqd ) { s [ i ] = '0' ; count [ 0 ] ++ ; count [ 2 ] -- ; } else if ( count [ 1 ] < reqd ) { s [ i ] = '1' ; count [ 1 ] ++ ; count [ 2 ] -- ; } }", "nl": "Here we can replace 2 with 0 and 1 anytime"}
{"code": "processed [ s [ i ] - '0' ] ++ ; } return String . valueOf ( s ) ; }", "nl": "keep count of processed characters of each type"}
{"code": "public static void main ( String [ ] args ) { String s = \"011200\" ; System . out . println ( formStringMinOperations ( s . toCharArray ( ) ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class solution {", "nl": "Java Program to find the minimum number of adjacent swaps to arrange similar items together"}
{"code": "static int findMinimumAdjacentSwaps ( int arr [ ] , int N ) {", "nl": "Function to find minimum swaps"}
{"code": "boolean [ ] visited = new boolean [ N + 1 ] ; int minimumSwaps = 0 ; Arrays . fill ( visited , false ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) {", "nl": "visited array to check if value is seen already"}
{"code": "if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ;", "nl": "If the arr [ i ] is seen first time"}
{"code": "int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) {", "nl": "stores the number of swaps required to find the correct position of current element 's partner"}
{"code": "if ( visited [ arr [ j ] ] == false ) count ++ ;", "nl": "Increment count only if the current element has not been visited yet ( if is visited , means it has already been placed at its correct position )"}
{"code": "else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; }", "nl": "If current element 's partner is found"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 3 , 1 , 2 } ; int N = arr . length ; N /= 2 ; System . out . println ( findMinimumAdjacentSwaps ( arr , N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "JAVA program to print the largest palindromic number by permuting digits of a number"}
{"code": "static boolean possibility ( HashMap < Integer , Integer > m , int length , String s ) {", "nl": "Function to check if a number can be permuted to form a palindrome number"}
{"code": "int countodd = 0 ; for ( int i = 0 ; i < length ; i ++ ) {", "nl": "counts the occurrence of number which is odd"}
{"code": "if ( m . get ( s . charAt ( i ) - '0' ) % 2 == 1 ) countodd ++ ;", "nl": "if occurrence is odd"}
{"code": "if ( countodd > 1 ) return false ; } return true ; }", "nl": "if number exceeds 1"}
{"code": "static void largestPalindrome ( String s ) {", "nl": "function to print the largest palindromic number by permuting digits of a number"}
{"code": "int l = s . length ( ) ;", "nl": "String length"}
{"code": "HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < l ; i ++ ) if ( m . containsKey ( s . charAt ( i ) - '0' ) ) m . put ( s . charAt ( i ) - '0' , m . get ( s . charAt ( i ) - '0' ) + 1 ) ; else m . put ( s . charAt ( i ) - '0' , 1 ) ;", "nl": "map that marks the occurrence of a number"}
{"code": "if ( possibility ( m , l , s ) == false ) { System . out . print ( \" Palindrome \u2581 cannot \u2581 be \u2581 formed \" ) ; return ; }", "nl": "check the possibility of a palindromic number"}
{"code": "char [ ] largest = new char [ l ] ;", "nl": "String array that stores the largest permuted palindromic number"}
{"code": "int front = 0 ;", "nl": "pointer of front"}
{"code": "for ( int i = 9 ; i >= 0 ; i -- ) {", "nl": "greedily start from 9 to 0 and place the greater number in front and odd in the middle"}
{"code": "if ( m . containsKey ( i ) && m . get ( i ) % 2 == 1 ) {", "nl": "if the occurrence of number is odd"}
{"code": "largest [ l / 2 ] = ( char ) ( i + 48 ) ;", "nl": "place one odd occurring number in the middle"}
{"code": "m . put ( i , m . get ( i ) - 1 ) ;", "nl": "decrease the count"}
{"code": "while ( m . get ( i ) > 0 ) { largest [ front ] = ( char ) ( i + 48 ) ; largest [ l - front - 1 ] = ( char ) ( i + 48 ) ; m . put ( i , m . get ( i ) - 2 ) ; front ++ ; } } else {", "nl": "place the rest of numbers greedily"}
{"code": "while ( m . containsKey ( i ) && m . get ( i ) > 0 ) {", "nl": "if all numbers occur even times , then place greedily"}
{"code": "largest [ front ] = ( char ) ( i + 48 ) ; largest [ l - front - 1 ] = ( char ) ( i + 48 ) ;", "nl": "place greedily at front"}
{"code": "m . put ( i , m . get ( i ) - 2 ) ;", "nl": "2 numbers are placed , so decrease the count"}
{"code": "front ++ ; } } }", "nl": "increase placing position"}
{"code": "for ( int i = 0 ; i < l ; i ++ ) System . out . print ( largest [ i ] ) ; }", "nl": "print the largest String thus formed"}
{"code": "public static void main ( String [ ] args ) { String s = \"313551\" ; largestPalindrome ( s ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to count swaps required to balance string"}
{"code": "public static long swapCount ( String s ) {", "nl": "Function to calculate swaps required"}
{"code": "Vector < Integer > pos = new Vector < Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( s . charAt ( i ) == ' [ ' ) pos . add ( i ) ;", "nl": "Keep track of ' [ '"}
{"code": "int count = 0 ;", "nl": "To count number of encountered ' [ '"}
{"code": "int p = 0 ;", "nl": "To track position of next ' [ ' in pos"}
{"code": "long sum = 0 ; char [ ] S = s . toCharArray ( ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) {", "nl": "To store result"}
{"code": "if ( S [ i ] == ' [ ' ) { ++ count ; ++ p ; } else if ( S [ i ] == ' ] ' ) -- count ;", "nl": "Increment count and move p to next position"}
{"code": "if ( count < 0 ) {", "nl": "We have encountered an unbalanced part of string"}
{"code": "sum += pos . get ( p ) - i ; char temp = S [ i ] ; S [ i ] = S [ pos . get ( p ) ] ; S [ pos . get ( p ) ] = temp ; ++ p ;", "nl": "Increment sum by number of swaps required i . e . position of next ' [ ' - current position"}
{"code": "count = 1 ; } } return sum ; }", "nl": "Reset count to 1"}
{"code": "public static void main ( String [ ] args ) { String s = \" [ ] ] [ ] [ \" ; System . out . println ( swapCount ( s ) ) ; s = \" [ [ ] [ ] ] \" ; System . out . println ( swapCount ( s ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Arrays ; import java . util . Collections ; class GFG {", "nl": "Java program to divide a board into m * n squares"}
{"code": "static int minimumCostOfBreaking ( Integer X [ ] , Integer Y [ ] , int m , int n ) { int res = 0 ;", "nl": "method returns minimum cost to break board into m * n squares"}
{"code": "Arrays . sort ( X , Collections . reverseOrder ( ) ) ;", "nl": "sort the horizontal cost in reverse order"}
{"code": "Arrays . sort ( Y , Collections . reverseOrder ( ) ) ;", "nl": "sort the vertical cost in reverse order"}
{"code": "int hzntl = 1 , vert = 1 ;", "nl": "initialize current width as 1"}
{"code": "int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ;", "nl": "loop until one or both cost array are processed"}
{"code": "hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ;", "nl": "increase current horizontal part count by 1"}
{"code": "vert ++ ; j ++ ; } }", "nl": "increase current vertical part count by 1"}
{"code": "int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ;", "nl": "loop for horizontal array , if remains"}
{"code": "total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; }", "nl": "loop for vertical array , if remains"}
{"code": "public static void main ( String arg [ ] ) { int m = 6 , n = 4 ; Integer X [ ] = { 2 , 1 , 3 , 1 , 4 } ; Integer Y [ ] = { 4 , 1 , 2 } ; System . out . print ( minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ) ; } }", "nl": "Driver program"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static int getMin ( int x , int y , int z ) { return Math . min ( Math . min ( x , y ) , z ) ; }", "nl": "Function to find the minimum of the three numbers"}
{"code": "static int editDistance ( String str1 , String str2 , int m , int n ) {", "nl": "Function to find the minimum number operations required to convert String str1 to str2 using the operations"}
{"code": "int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;", "nl": "Stores the results of subproblems"}
{"code": "for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) {", "nl": "Fill dp [ ] [ ] in bottom up manner"}
{"code": "if ( i == 0 )", "nl": "If str1 is empty , then insert all characters of String str2"}
{"code": "dp [ i ] [ j ] = j ;", "nl": "Minimum operations is j"}
{"code": "else if ( j == 0 )", "nl": "If str2 is empty , then remove all characters of String str2"}
{"code": "dp [ i ] [ j ] = i ;", "nl": "Minimum operations is i"}
{"code": "else if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;", "nl": "If the last characters are same , then ignore last character"}
{"code": "else {", "nl": "If the last character is different , then find the minimum"}
{"code": "dp [ i ] [ j ] = 1 + getMin ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } }", "nl": "Perform one of the insert , remove and the replace"}
{"code": "return dp [ m ] [ n ] ; }", "nl": "Return the minimum number of steps required"}
{"code": "static void minimumSteps ( String S , int N ) {", "nl": "Function to find the minimum number of steps to modify the String such that first half and second half becomes the same"}
{"code": "int ans = Integer . MAX_VALUE ;", "nl": "Stores the minimum number of operations required"}
{"code": "for ( int i = 1 ; i < N ; i ++ ) { String S1 = S . substring ( 0 , i ) ; String S2 = S . substring ( i ) ;", "nl": "Traverse the given String S"}
{"code": "int count = editDistance ( S1 , S2 , S1 . length ( ) , S2 . length ( ) ) ;", "nl": "Find the minimum operations"}
{"code": "ans = Math . min ( ans , count ) ; }", "nl": "Update the ans"}
{"code": "System . out . print ( ans ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { String S = \" aabb \" ; int N = S . length ( ) ; minimumSteps ( S , N ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int minimumOperations ( int N ) {", "nl": "Function to find the minimum number of operations to reduce N to 2 by dividing N by 5 or decrementing by 3"}
{"code": "int [ ] dp = new int [ N + 1 ] ; int i ;", "nl": "Initialize the dp array"}
{"code": "for ( i = 0 ; i <= N ; i ++ ) { dp [ i ] = ( int ) 1e9 ; }", "nl": "Initialize the array dp [ ]"}
{"code": "dp [ 2 ] = 0 ;", "nl": "For N = 2 number of operations needed is zero"}
{"code": "for ( i = 2 ; i <= N ; i ++ ) {", "nl": "Iterating over the range [ 1 , N ]"}
{"code": "if ( dp [ i ] == ( int ) 1e9 ) continue ;", "nl": "If it 's not possible to  create current N"}
{"code": "if ( i * 5 <= N ) { dp [ i * 5 ] = Math . min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; }", "nl": "Multiply with 5"}
{"code": "if ( i + 3 <= N ) { dp [ i + 3 ] = Math . min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } }", "nl": "Adding the value 3"}
{"code": "if ( dp [ N ] == 1e9 ) return - 1 ;", "nl": "Checking if not possible to make the number as 2"}
{"code": "return dp [ N ] ; }", "nl": "Return the minimum number of operations"}
{"code": "public static void main ( String [ ] args ) { int N = 25 ; System . out . println ( minimumOperations ( N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int MaxProfit ( int arr [ ] , int n , int transactionFee ) { int buy = - arr [ 0 ] ; int sell = 0 ;", "nl": "Function to find the maximum profit with transaction fee"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) { int temp = buy ;", "nl": "Traversing the stocks for each day"}
{"code": "buy = Math . max ( buy , sell - arr [ i ] ) ; sell = Math . max ( sell , temp + arr [ i ] - transactionFee ) ; }", "nl": "Update buy and sell"}
{"code": "return Math . max ( sell , buy ) ; }", "nl": "Return the maximum profit"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int arr [ ] = { 6 , 1 , 7 , 2 , 8 , 4 } ; int n = arr . length ; int transactionFee = 2 ;", "nl": "Given Input"}
{"code": "System . out . println ( MaxProfit ( arr , n , transactionFee ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for tha above approach"}
{"code": "static int start [ ] [ ] = new int [ 3 ] [ 3 ] ;", "nl": "Stores the maximum path sum from the cell ( 1 , 1 ) to ( N , M )"}
{"code": "static int ending [ ] [ ] = new int [ 3 ] [ 3 ] ;", "nl": "Stores the maximum path sum from the cell ( j , j ) to ( N , M )"}
{"code": "static void calculateStart ( int n , int m ) {", "nl": "Function to find the maximum path sum from the cell ( 1 , 1 ) to ( N , M )"}
{"code": "for ( int i = 1 ; i < m ; ++ i ) { start [ 0 ] [ i ] += start [ 0 ] [ i - 1 ] ; }", "nl": "Traverse the first row"}
{"code": "for ( int i = 1 ; i < n ; ++ i ) { start [ i ] [ 0 ] += start [ i - 1 ] [ 0 ] ; }", "nl": "Traverse the first column"}
{"code": "for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 1 ; j < m ; ++ j ) {", "nl": "Traverse the matrix"}
{"code": "start [ i ] [ j ] += Math . max ( start [ i - 1 ] [ j ] , start [ i ] [ j - 1 ] ) ; } } }", "nl": "Update the value of start [ i ] [ j ]"}
{"code": "static void calculateEnd ( int n , int m ) {", "nl": "Function to find the maximum path sum from the cell ( j , j ) to ( N , M )"}
{"code": "for ( int i = n - 2 ; i >= 0 ; -- i ) { ending [ i ] [ m - 1 ] += ending [ i + 1 ] [ m - 1 ] ; }", "nl": "Traverse the last row"}
{"code": "for ( int i = m - 2 ; i >= 0 ; -- i ) { ending [ n - 1 ] [ i ] += ending [ n - 1 ] [ i + 1 ] ; }", "nl": "Traverse the last column"}
{"code": "for ( int i = n - 2 ; i >= 0 ; -- i ) { for ( int j = m - 2 ; j >= 0 ; -- j ) {", "nl": "Traverse the matrix"}
{"code": "ending [ i ] [ j ] += Math . max ( ending [ i + 1 ] [ j ] , ending [ i ] [ j + 1 ] ) ; } } }", "nl": "Update the value of ending [ i ] [ j ]"}
{"code": "static void maximumPathSum ( int mat [ ] [ ] , int n , int m , int q , int coordinates [ ] [ ] ) {", "nl": "Function to find the maximum path sum from the top - left to the bottom right cell such that path contains one of the cells in the array coordinates [ ] [ ]"}
{"code": "for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { start [ i ] [ j ] = mat [ i ] [ j ] ; ending [ i ] [ j ] = mat [ i ] [ j ] ; } }", "nl": "Initialize the start and the end matrices"}
{"code": "calculateStart ( n , m ) ;", "nl": "Calculate the start matrix"}
{"code": "calculateEnd ( n , m ) ;", "nl": "Calculate the end matrix"}
{"code": "int ans = 0 ;", "nl": "Stores the maximum path sum"}
{"code": "for ( int i = 0 ; i < q ; ++ i ) { int X = coordinates [ i ] [ 0 ] - 1 ; int Y = coordinates [ i ] [ 1 ] - 1 ;", "nl": "Traverse the coordinates"}
{"code": "ans = Math . max ( ans , start [ X ] [ Y ] + ending [ X ] [ Y ] - mat [ X ] [ Y ] ) ; }", "nl": "Update the value of ans"}
{"code": "System . out . print ( ans ) ; }", "nl": "Print the resultant maximum sum path value"}
{"code": "public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int N = 3 ; int M = 3 ; int Q = 2 ; int coordinates [ ] [ ] = { { 1 , 2 } , { 2 , 2 } } ; maximumPathSum ( mat , N , M , Q , coordinates ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; import java . lang . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int MaxSubsetlength ( String arr [ ] , int A , int B ) {", "nl": "Function to find the length of the longest subset of an array of strings with at most A 0 s and B 1 s"}
{"code": "int dp [ ] [ ] = new int [ A + 1 ] [ B + 1 ] ;", "nl": "Initialize a 2D array with its entries as 0"}
{"code": "for ( String str : arr ) {", "nl": "Traverse the given array"}
{"code": "int zeros = 0 , ones = 0 ; for ( char ch : str . toCharArray ( ) ) { if ( ch == '0' ) zeros ++ ; else ones ++ ; }", "nl": "Store the count of 0 s and 1 s in the current string"}
{"code": "for ( int i = A ; i >= zeros ; i -- )", "nl": "Iterate in the range [ A , zeros ]"}
{"code": "for ( int j = B ; j >= ones ; j -- )", "nl": "Iterate in the range [ B , ones ]"}
{"code": "dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) ; }", "nl": "Update the value of dp [ i ] [ j ]"}
{"code": "return dp [ A ] [ B ] ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { String arr [ ] = { \"1\" , \"0\" , \"0001\" , \"10\" , \"111001\" } ; int A = 5 , B = 3 ; System . out . println ( MaxSubsetlength ( arr , A , B ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; import java . lang . * ; import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int numOfWays ( int a [ ] [ ] , int n , int i , HashSet < Integer > blue ) {", "nl": "Function to count ways to select N distinct pairs of candies with different colours"}
{"code": "if ( i == n ) return 1 ;", "nl": "If n pairs are selected"}
{"code": "int count = 0 ;", "nl": "Stores count of ways to select the i - th pair"}
{"code": "for ( int j = 0 ; j < n ; j ++ ) {", "nl": "Iterate over the range [ 0 , n ]"}
{"code": "if ( a [ i ] [ j ] == 1 && ! blue . contains ( j ) ) { blue . add ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . remove ( j ) ; } } return count ; }", "nl": "If pair ( i , j ) is not included"}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; int mat [ ] [ ] = { { 0 , 1 , 1 } , { 1 , 0 , 1 } , { 1 , 1 , 1 } } ; HashSet < Integer > mpp = new HashSet < > ( ) ; System . out . println ( ( numOfWays ( mat , n , 0 , mpp ) ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java Program to implement the above approach"}
{"code": "static void minCost ( int arr [ ] , int n ) {", "nl": "Function to find the minimum cost to reach the end of an array"}
{"code": "if ( n < 3 ) { System . out . println ( arr [ 0 ] ) ; return ; }", "nl": "Base Case : When N < 3"}
{"code": "int dp [ ] = new int [ n ] ;", "nl": "Store the results in table"}
{"code": "dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ;", "nl": "Initialize base cases"}
{"code": "for ( int i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = Math . min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ;", "nl": "Iterate over the range [ 2 , N - 2 ] to construct the dp array"}
{"code": "dp [ n - 1 ] = Math . min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ;", "nl": "Handle case for the last index , i . e . N - 1"}
{"code": "System . out . println ( dp [ n - 1 ] ) ; }", "nl": "Print the answer"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 9 , 4 , 6 , 8 , 5 } ; int N = arr . length ; minCost ( arr , N ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static int M = 1000000007 ;", "nl": "Java program to implement the above approach"}
{"code": "static int power ( int X , int Y ) {", "nl": "Function to find the value of power ( X , Y ) in O ( log Y )"}
{"code": "int res = 1 ;", "nl": "Stores power ( X , Y )"}
{"code": "X = X % M ;", "nl": "Update X"}
{"code": "if ( X == 0 ) return 0 ;", "nl": "Base Case"}
{"code": "while ( Y > 0 ) {", "nl": "Calculate power ( X , Y )"}
{"code": "if ( ( Y & 1 ) != 0 ) {", "nl": "If Y is an odd number"}
{"code": "res = ( res * X ) % M ; }", "nl": "Update res"}
{"code": "Y = Y >> 1 ;", "nl": "Update Y"}
{"code": "X = ( X * X ) % M ; } return res ; }", "nl": "Update X"}
{"code": "static int findValue ( int n ) {", "nl": "Function to calculate ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 )"}
{"code": "int X = 0 ;", "nl": "Stores binary representation of n"}
{"code": "int pow_10 = 1 ;", "nl": "Stores power of 10"}
{"code": "while ( n != 0 ) {", "nl": "Calculate the binary representation of n"}
{"code": "if ( ( n & 1 ) != 0 ) {", "nl": "If n is an odd number"}
{"code": "X += pow_10 ; }", "nl": "Update X"}
{"code": "pow_10 *= 10 ;", "nl": "Update pow_10"}
{"code": "n /= 2 ; }", "nl": "Update n"}
{"code": "X = ( X * 2 ) % M ;", "nl": "Double the value of X"}
{"code": "int res = power ( 2 , X ) ; return res ; }", "nl": "Stores the value of ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 )"}
{"code": "public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( findValue ( n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static final long M = 1000000007 ;", "nl": "Java program to implement the above approach"}
{"code": "static long power ( long X , long Y ) {", "nl": "Function to find the value of power ( X , Y ) in O ( log Y )"}
{"code": "long res = 1 ;", "nl": "Stores power ( X , Y )"}
{"code": "X = X % M ;", "nl": "Update X"}
{"code": "if ( X == 0 ) return 0 ;", "nl": "Base Case"}
{"code": "while ( Y > 0 ) {", "nl": "Calculate power ( X , Y )"}
{"code": "if ( Y % 2 == 1 ) {", "nl": "If Y is an odd number"}
{"code": "res = ( res * X ) % M ; }", "nl": "Update res"}
{"code": "Y = Y >> 1 ;", "nl": "Update Y"}
{"code": "X = ( X * X ) % M ; } return res ; }", "nl": "Update X"}
{"code": "static long findValue ( int N ) {", "nl": "Function to calculate ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 )"}
{"code": "long [ ] dp = new long [ N + 1 ] ;", "nl": "dp [ N ] * dp [ N ] : Stores value of ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 )"}
{"code": "dp [ 1 ] = 2 ; dp [ 2 ] = 1024 ;", "nl": "Base Case"}
{"code": "for ( int i = 3 ; i <= N ; i ++ ) {", "nl": "Iterate over the range [ 3 , N ]"}
{"code": "int y = ( i & ( - i ) ) ;", "nl": "Stores rightmost bit of i"}
{"code": "int x = i - y ;", "nl": "Stores the value of ( i - y )"}
{"code": "if ( x == 0 ) {", "nl": "If x is power of 2"}
{"code": "dp [ i ] = power ( dp [ i / 2 ] , 10 ) ; } else {", "nl": "Update dp [ i ]"}
{"code": "dp [ i ] = ( dp [ x ] * dp [ y ] ) % M ; } } return ( dp [ N ] * dp [ N ] ) % M ; }", "nl": "Update dp [ i ]"}
{"code": "public static void main ( String [ ] args ) { int n = 150 ; System . out . print ( findValue ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int findWays ( int N ) {", "nl": "Function to find the number of ways to get the sum N with throw of dice"}
{"code": "if ( N == 0 ) { return 1 ; }", "nl": "Base Case"}
{"code": "int cnt = 0 ;", "nl": "Stores the count of total number of ways to get sum N"}
{"code": "for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i ) ; } }", "nl": "Recur for all 6 states"}
{"code": "return cnt ; }", "nl": "Return answer"}
{"code": "public static void main ( String [ ] args ) { int N = 4 ;", "nl": "Driver Code"}
{"code": "System . out . print ( findWays ( N ) ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) {", "nl": "Utility function to check array can be partition to 3 subsequences of equal sum or not"}
{"code": "if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } else {", "nl": "Base Case"}
{"code": "int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ;", "nl": "When element at index j is added to sm1"}
{"code": "int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ;", "nl": "When element at index j is added to sm2"}
{"code": "int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ;", "nl": "When element at index j is added to sm3"}
{"code": "return Math . max ( Math . max ( l , m ) , r ) ; } }", "nl": "Return maximum value among all above 3 recursive call"}
{"code": "static void checkEqualSum ( int arr [ ] , int N ) {", "nl": "Function to check array can be partition to 3 subsequences of equal sum or not"}
{"code": "int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ;", "nl": "Initialise 3 sums to 0"}
{"code": "if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } }", "nl": "Function Call"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = arr . length ;", "nl": "Given array arr [ ]"}
{"code": "checkEqualSum ( arr , N ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG { static HashMap < String , Integer > dp = new HashMap < String , Integer > ( ) ;", "nl": "Java program for the above approach"}
{"code": "static int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) { String s = String . valueOf ( sm1 ) + \" _ \" + String . valueOf ( sm2 ) + String . valueOf ( j ) ;", "nl": "Function to check array can be partition into sum of 3 equal"}
{"code": "if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; }", "nl": "Base Case"}
{"code": "if ( dp . containsKey ( s ) ) return dp . get ( s ) ; else {", "nl": "If value at particular index is not - 1 then return value at that index which ensure no more further calls"}
{"code": "int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ;", "nl": "When element at index j is added to sm1"}
{"code": "int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ;", "nl": "When element at index j is added to sm2"}
{"code": "int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ;", "nl": "When element at index j is added to sm3"}
{"code": "dp . put ( s , Math . max ( Math . max ( l , m ) , r ) ) ; return dp . get ( s ) ; } }", "nl": "Update the current state and return that value"}
{"code": "static void checkEqualSum ( int arr [ ] , int N ) {", "nl": "Function to check array can be partition to 3 subsequences of equal sum or not"}
{"code": "int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ;", "nl": "Initialise 3 sums to 0"}
{"code": "if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } }", "nl": "Function Call"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = arr . length ;", "nl": "Given array arr [ ]"}
{"code": "checkEqualSum ( arr , N ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java program to find the smallest index in the array in the range [ L , R ] which does not contain X"}
{"code": "static void precompute ( int nextpos [ ] , int arr [ ] , int N ) {", "nl": "Precompute the index of next different element in the array for every array element"}
{"code": "nextpos [ N - 1 ] = N ; for ( int i = N - 2 ; i >= 0 ; i -- ) {", "nl": "Default value"}
{"code": "if ( arr [ i ] == arr [ i + 1 ] ) nextpos [ i ] = nextpos [ i + 1 ] ; else nextpos [ i ] = i + 1 ; } }", "nl": "Compute nextpos [ i ] using nextpos [ i + 1 ]"}
{"code": "static void findIndex ( int query [ ] [ ] , int arr [ ] , int N , int Q ) {", "nl": "Function to return the smallest index"}
{"code": "int [ ] nextpos = new int [ N ] ; precompute ( nextpos , arr , N ) ; for ( int i = 0 ; i < Q ; i ++ ) { int l , r , x ; l = query [ i ] [ 0 ] ; r = query [ i ] [ 1 ] ; x = query [ i ] [ 2 ] ; int ans = - 1 ;", "nl": "nextpos [ i ] will store the next position p where arr [ p ] != arr [ i ]"}
{"code": "if ( arr [ l ] != x ) ans = l ;", "nl": "If X is not present at l"}
{"code": "else {", "nl": "Otherwise"}
{"code": "int d = nextpos [ l ] ;", "nl": "Find the index which stores a value different from X"}
{"code": "if ( d <= r ) ans = d ; } System . out . print ( ans + \"NEW_LINE\"); } }", "nl": "If that index is within the range"}
{"code": "public static void main ( String [ ] args ) { int N , Q ; N = 6 ; Q = 3 ; int arr [ ] = { 1 , 2 , 1 , 1 , 3 , 5 } ; int query [ ] [ ] = { { 0 , 3 , 1 } , { 1 , 5 , 2 } , { 2 , 3 , 1 } } ; findIndex ( query , arr , N , Q ) ; } }", "nl": "Driver Code"}
{"code": "class GFG { static long mod = 10000000007L ;", "nl": "Java program for above approach"}
{"code": "static long countWays ( String s , String t , int k ) {", "nl": "Function to count number of ways to convert string S to string T by performing K cyclic shifts"}
{"code": "int n = s . length ( ) ;", "nl": "Calculate length of string"}
{"code": "int a = 0 , b = 0 ;", "nl": "' a ' is no of good cyclic shifts ' b ' is no of bad cyclic shifts"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { String p = s . substring ( i , n - i ) + s . substring ( 0 , i ) ;", "nl": "Iterate in the string"}
{"code": "if ( p == t ) a ++ ; else b ++ ; }", "nl": "Precompute the number of good and bad cyclic shifts"}
{"code": "long dp1 [ ] = new long [ k + 1 ] ; long dp2 [ ] = new long [ k + 1 ] ; if ( s == t ) { dp1 [ 0 ] = 1 ; dp2 [ 0 ] = 0 ; } else { dp1 [ 0 ] = 0 ; dp2 [ 0 ] = 1 ; }", "nl": "dp2 [ i ] to store the no of ways to get to a bad shift in i moves"}
{"code": "for ( int i = 1 ; i <= k ; i ++ ) { dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod ; dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod ; }", "nl": "Calculate good and bad shifts"}
{"code": "return dp1 [ k ] ; }", "nl": "Return the required number of ways"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "String S = \" ab \" , T = \" ab \" ;", "nl": "Given Strings"}
{"code": "int K = 2 ;", "nl": "Given K shifts required"}
{"code": "System . out . print ( countWays ( S , T , K ) ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int minOperation ( int k ) {", "nl": "Function to find minimum operations"}
{"code": "int dp [ ] = new int [ k + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ;", "nl": "dp is initialised to store the steps"}
{"code": "if ( i % 2 == 0 ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; }", "nl": "For all even numbers"}
{"code": "public static void main ( String [ ] args ) { int K = 12 ; System . out . print ( minOperation ( K ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation for the above mentioned recursive approach"}
{"code": "static int maxSum ( int p0 , int p1 , int a [ ] , int pos , int n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; }", "nl": "Function to find the maximum subset sum"}
{"code": "int ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ;", "nl": "Ignore the current element"}
{"code": "ans = Math . max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ;", "nl": "including element in partition 1"}
{"code": "ans = Math . max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; }", "nl": "including element in partition 2"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int n = 4 ; int a [ ] = { 1 , 2 , 3 , 6 } ; System . out . println ( maxSum ( 0 , 0 , a , 0 , n ) ) ; } }", "nl": "size of the array"}
{"code": "class GFG { final static int INT_MIN = Integer . MIN_VALUE ;", "nl": "Java implementation for the above mentioned Dynamic Programming approach"}
{"code": "static int maxSum ( int a [ ] , int n ) {", "nl": "Function to find the maximum subset sum"}
{"code": "int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int limit = 2 * sum + 1 ;", "nl": "sum of all elements"}
{"code": "int dp [ ] [ ] = new int [ n + 1 ] [ limit ] ;", "nl": "bottom up lookup table ;"}
{"code": "for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) dp [ i ] [ j ] = INT_MIN ; }", "nl": "initialising dp table with INT_MIN where , INT_MIN means no solution"}
{"code": "dp [ 0 ] [ sum ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) {", "nl": "Case when diff is 0"}
{"code": "if ( ( j - a [ i - 1 ] ) >= 0 && dp [ i - 1 ] [ j - a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) ;", "nl": "Putting ith element in g0"}
{"code": "if ( ( j + a [ i - 1 ] ) < limit && dp [ i - 1 ] [ j + a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) ;", "nl": "Putting ith element in g1"}
{"code": "if ( dp [ i - 1 ] [ j ] != INT_MIN ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ sum ] ; }", "nl": "Ignoring ith element"}
{"code": "public static void main ( String [ ] args ) { int n = 4 ; int [ ] a = { 1 , 2 , 3 , 6 } ; System . out . println ( maxSum ( a , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to count the different possible string form by replacing two same characters with one"}
{"code": "static int fib [ ] = new int [ 100005 ] ;", "nl": "Array to find the fibonacci sequence"}
{"code": "static void computeFibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 100005 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } }", "nl": "Function to find the fibonacci sequence"}
{"code": "static int countString ( String str ) {", "nl": "Function to count all possible strings"}
{"code": "int ans = 1 ; int cnt = 1 ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) {", "nl": "Initialize ans = 1"}
{"code": "if ( str . charAt ( i ) == str . charAt ( i - 1 ) ) { cnt ++ ; }", "nl": "If two consecutive char are same increase cnt"}
{"code": "else { ans = ans * fib [ cnt ] ; cnt = 1 ; } }", "nl": "Else multiply the fib [ cnt ] to ans and initialize ans to 1"}
{"code": "ans = ans * fib [ cnt ] ;", "nl": "If str = abcdeeee , then for last \" eeee \" the count munst be updated"}
{"code": "return ans ; }", "nl": "Return the total count"}
{"code": "public static void main ( String [ ] args ) { String str = \" abdllldefkkkk \" ;", "nl": "Driver 's Code"}
{"code": "computeFibonacci ( ) ;", "nl": "Function to precompute all the fibonacci number"}
{"code": "System . out . println ( countString ( str ) ) ; } }", "nl": "Function call to find the count"}
{"code": "import java . util . * ; class GFG { static int MAX = 1000 ;", "nl": "Java program to find the first N terms of Golomb Sequence"}
{"code": "static void printGolombSequence ( int N ) {", "nl": "Function to print the Golomb Sequence"}
{"code": "int [ ] arr = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) arr [ i ] = 0 ;", "nl": "Initialise the array"}
{"code": "int cnt = 0 ;", "nl": "Initialise the cnt to 0"}
{"code": "arr [ 0 ] = 0 ; arr [ 1 ] = 1 ;", "nl": "First and second element of Golomb Sequence is 0 , 1"}
{"code": "Map < Integer , Integer > M = new HashMap < Integer , Integer > ( ) ;", "nl": "Map to store the count of current element in Golomb Sequence"}
{"code": "M . put ( 2 , 2 ) ;", "nl": "Store the count of 2"}
{"code": "for ( int i = 2 ; i <= N ; i ++ ) {", "nl": "Iterate over 2 to N"}
{"code": "if ( cnt == 0 ) { arr [ i ] = 1 + arr [ i - 1 ] ; cnt = M . get ( arr [ i ] ) ; cnt -- ; }", "nl": "If cnt is equals to 0 then we have new number for Golomb Sequence 1 2 2 3 3 4 4 4 5 5 5 which is 1 + previous element"}
{"code": "else { arr [ i ] = arr [ i - 1 ] ; cnt -- ; }", "nl": "Else the current element is the previous element in this Sequence"}
{"code": "M . put ( i , arr [ i ] ) ; }", "nl": "Map the current index to current value in arr [ ]"}
{"code": "for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }", "nl": "Print the Golomb Sequence"}
{"code": "public static void main ( String args [ ] ) { int N = 11 ; printGolombSequence ( N ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation to find the number the number of ways to reach Nth stair by taking 1 , 2 step at a time and 3 Steps at a time exactly once ."}
{"code": "static int number_of_ways ( int n ) {", "nl": "Function to find the number the number of ways to reach Nth stair"}
{"code": "int [ ] includes_3 = new int [ n + 1 ] ;", "nl": "Array including number of ways that includes 3"}
{"code": "int [ ] not_includes_3 = new int [ n + 1 ] ;", "nl": "Array including number of ways that doesn 't includes 3"}
{"code": "includes_3 [ 3 ] = 1 ; not_includes_3 [ 1 ] = 1 ; not_includes_3 [ 2 ] = 2 ; not_includes_3 [ 3 ] = 3 ;", "nl": "Initially to reach 3 stairs by taking 3 steps can be reached by 1 way"}
{"code": "for ( int i = 4 ; i <= n ; i ++ ) { includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] ; not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] ; } return includes_3 [ n ] ; }", "nl": "Loop to find the number the number of ways to reach Nth stair"}
{"code": "public static void main ( String [ ] args ) { int n = 7 ; System . out . print ( number_of_ways ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static int MAX = 100000 ;", "nl": "Java implementation of the approach"}
{"code": "static int [ ] divisors = new int [ MAX ] ;", "nl": "Map to store the divisor count"}
{"code": "static void generateDivisors ( int n ) { for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { divisors [ i ] ++ ; } else { divisors [ i ] ++ ; divisors [ n / i ] ++ ; } } } }", "nl": "Function to generate the divisors of all the array elements"}
{"code": "static int findMaxMultiples ( int [ ] arr , int n ) {", "nl": "Function to find the maximum number of multiples in an array before it"}
{"code": "int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "To store the maximum divisor count"}
{"code": "ans = Math . max ( divisors [ arr [ i ] ] , ans ) ;", "nl": "Update ans if more number of divisors are found"}
{"code": "generateDivisors ( arr [ i ] ) ; } return ans ; }", "nl": "Generating all the divisors of the next element of the array"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 8 , 1 , 28 , 4 , 2 , 6 , 7 } ; int n = arr . length ; System . out . print ( findMaxMultiples ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int n = 3 ; static int maxV = 20 ;", "nl": "Java implementation of the approach"}
{"code": "static int [ ] [ ] [ ] dp = new int [ n ] [ n ] [ maxV ] ;", "nl": "3d array to store states of dp"}
{"code": "static int [ ] [ ] [ ] v = new int [ n ] [ n ] [ maxV ] ;", "nl": "Array to determine whether a state has been solved before"}
{"code": "static int countWays ( int i , int j , int x , int arr [ ] [ ] ) {", "nl": "Function to return the count of required paths"}
{"code": "if ( i == n j == n ) { return 0 ; } x = ( x & arr [ i ] [ j ] ) ; if ( x == 0 ) { return 0 ; } if ( i == n - 1 && j == n - 1 ) { return 1 ; }", "nl": "Base cases"}
{"code": "if ( v [ i ] [ j ] [ x ] == 1 ) { return dp [ i ] [ j ] [ x ] ; } v [ i ] [ j ] [ x ] = 1 ;", "nl": "If a state has been solved before it won 't be evaluated again"}
{"code": "dp [ i ] [ j ] [ x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) ; return dp [ i ] [ j ] [ x ] ; }", "nl": "Recurrence relation"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 2 , 1 } , { 1 , 1 , 0 } , { 2 , 1 , 1 } } ; System . out . println ( countWays ( 0 , 0 , arr [ 0 ] [ 0 ] , arr ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int N = 3 ;", "nl": "Java program for the above approach"}
{"code": "static int FindMaximumSum ( int ind , int kon , int a [ ] , int b [ ] , int c [ ] , int n , int dp [ ] [ ] ) {", "nl": "Function to return the maximum sum"}
{"code": "if ( ind == n ) return 0 ;", "nl": "Base case"}
{"code": "if ( dp [ ind ] [ kon ] != - 1 ) return dp [ ind ] [ kon ] ; int ans = ( int ) ( - 1e9 + 5 ) ;", "nl": "Already visited"}
{"code": "if ( kon == 0 ) { ans = Math . max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; }", "nl": "If the element has been taken from first array in previous step"}
{"code": "else if ( kon == 1 ) { ans = Math . max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; }", "nl": "If the element has been taken from second array in previous step"}
{"code": "else if ( kon == 2 ) { ans = Math . max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; } return dp [ ind ] [ kon ] = ans ; }", "nl": "If the element has been taken from third array in previous step"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 6 , 8 , 2 , 7 , 4 , 2 , 7 } ; int b [ ] = { 7 , 8 , 5 , 8 , 6 , 3 , 5 } ; int c [ ] = { 8 , 3 , 2 , 6 , 8 , 4 , 1 } ; int n = a . length ; int dp [ ] [ ] = new int [ n ] [ N ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = - 1 ; } }", "nl": "Driver code"}
{"code": "int x = FindMaximumSum ( 0 , 0 , a , b , c , n , dp ) ;", "nl": "Pick element from first array"}
{"code": "int y = FindMaximumSum ( 0 , 1 , a , b , c , n , dp ) ;", "nl": "Pick element from second array"}
{"code": "int z = FindMaximumSum ( 0 , 2 , a , b , c , n , dp ) ;", "nl": "Pick element from third array"}
{"code": "System . out . println ( Math . max ( x , Math . max ( y , z ) ) ) ; } }", "nl": "Print the maximum of them"}
{"code": "import java . util . * ; class GFG { static int mod = 1000000007 ;", "nl": "Java implementation of the approach"}
{"code": "static int noOfBinaryStrings ( int N , int k ) { int dp [ ] = new int [ 100002 ] ; for ( int i = 1 ; i <= k - 1 ; i ++ ) { dp [ i ] = 1 ; } dp [ k ] = 2 ; for ( int i = k + 1 ; i <= N ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; } return dp [ N ] ; }", "nl": "Function to return no of ways to build a binary string of length N such that 0 s always occur in groups of size K"}
{"code": "public static void main ( String [ ] args ) { int N = 4 ; int K = 2 ; System . out . println ( noOfBinaryStrings ( N , K ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to find number of ways to pair people in party"}
{"code": "static int findWaysToPair ( int p ) {", "nl": "Function to find number of ways to pair people in party"}
{"code": "int dp [ ] = new int [ p + 1 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ;", "nl": "To store count of number of ways ."}
{"code": "for ( int i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; }", "nl": "Using the recurrence defined find count for different values of p ."}
{"code": "public static void main ( String args [ ] ) { int p = 3 ; System . out . println ( findWaysToPair ( p ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static int CountWays ( int n ) {", "nl": "A simple recursive implementation for counting ways to reach a score using 1 and 2 with consecutive 2 allowed"}
{"code": "if ( n == 0 ) { return 1 ; } if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 1 + 1 ; }", "nl": "base cases"}
{"code": "return CountWays ( n - 1 ) + CountWays ( n - 3 ) ; }", "nl": "For cases n > 2"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( CountWays ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to check if the number is weird or not"}
{"code": "static ArrayList < Integer > factors ( int n ) {", "nl": "code to find all the factors of the number excluding the number itself"}
{"code": "ArrayList < Integer > v = new ArrayList < Integer > ( ) ; v . add ( 1 ) ;", "nl": "ArrayList to store the factors"}
{"code": "for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) {", "nl": "note that this loop runs till sqrt ( n )"}
{"code": "if ( n % i == 0 ) { v . add ( i ) ;", "nl": "if the value of i is a factor"}
{"code": "if ( n / i != i ) { v . add ( n / i ) ; } } }", "nl": "condition to check the divisor is not the number itself"}
{"code": "return v ; }", "nl": "return the ArrayList"}
{"code": "static boolean checkAbundant ( int n ) { ArrayList < Integer > v ; int sum = 0 ;", "nl": "Function to check if the number is abundant or not"}
{"code": "v = factors ( n ) ;", "nl": "find the divisors using function"}
{"code": "for ( int i = 0 ; i < v . size ( ) ; i ++ ) { sum += v . get ( i ) ; }", "nl": "sum all the factors"}
{"code": "if ( sum > n ) return true ; else return false ; }", "nl": "check for abundant or not"}
{"code": "static boolean checkSemiPerfect ( int n ) { ArrayList < Integer > v ;", "nl": "Function to check if the number is semi - perfect or not"}
{"code": "v = factors ( n ) ;", "nl": "find the divisors"}
{"code": "Collections . sort ( v ) ; int r = v . size ( ) ;", "nl": "sorting the ArrayList"}
{"code": "boolean subset [ ] [ ] = new boolean [ r + 1 ] [ n + 1 ] ;", "nl": "subset to check if no is semiperfect"}
{"code": "for ( int i = 0 ; i <= r ; i ++ ) subset [ i ] [ 0 ] = true ;", "nl": "initialising 1 st column to true"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = false ;", "nl": "initialing 1 st row except zero position to 0"}
{"code": "for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) {", "nl": "loop to find whether the number is semiperfect"}
{"code": "if ( j < v . get ( i - 1 ) ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; else { subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - v . get ( i - 1 ) ] ; } } }", "nl": "calculation to check if the number can be made by summation of divisors"}
{"code": "if ( ( subset [ r ] [ n ] ) == false ) return false ; else return true ; }", "nl": "if not possible to make the number by any combination of divisors"}
{"code": "static boolean checkweird ( int n ) { if ( checkAbundant ( n ) == true && checkSemiPerfect ( n ) == false ) return true ; else return false ; }", "nl": "Function to check for weird or not"}
{"code": "public static void main ( String args [ ] ) { int n = 70 ; if ( checkweird ( n ) ) System . out . println ( \" Weird \u2581 Number \" ) ; else System . out . println ( \" Not \u2581 Weird \u2581 Number \" ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to print largest contiguous array sum when array is created after concatenating a small array k times ."}
{"code": "static int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = 0 ; int INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) {", "nl": "Returns sum of maximum sum subarray created after concatenating a [ 0. . n - 1 ] k times ."}
{"code": "max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }", "nl": "This is where it differs from Kadane 's algorithm. We use modular  arithmetic to find next element."}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 10 , 20 , - 30 , - 1 } ; int n = a . length ; int k = 3 ; System . out . println ( \" Maximum \u2581 contiguous \u2581 sum \u2581 is \u2581 \" + maxSubArraySumRepeated ( a , n , k ) ) ; } }", "nl": "Driver program to test maxSubArraySum"}
{"code": "import java . util . * ; import java . lang . * ; public class GfG {", "nl": "Java implementation to find the longest increasing odd even subsequence"}
{"code": "public static int longOddEvenIncSeq ( int arr [ ] , int n ) {", "nl": "function to find the longest increasing odd even subsequence"}
{"code": "int [ ] lioes = new int [ n ] ;", "nl": "lioes [ i ] stores longest increasing odd even subsequence ending at arr [ i ]"}
{"code": "int maxLen = 0 ;", "nl": "to store the length of longest increasing odd even subsequence"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ;", "nl": "Initialize LIOES values for all indexes"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ;", "nl": "Compute optimized LIOES values in bottom up manner"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ;", "nl": "Pick maximum of all LIOES values"}
{"code": "return maxLen ; }", "nl": "required maximum length"}
{"code": "public static void main ( String argc [ ] ) { int [ ] arr = new int [ ] { 1 , 12 , 2 , 22 , 5 , 30 , 31 , 14 , 17 , 11 } ; int n = 10 ; System . out . println ( \" Longest \u2581 Increasing \u2581 Odd \" + \" \u2581 Even \u2581 Subsequence : \u2581 \" + longOddEvenIncSeq ( arr , n ) ) ; } }", "nl": "driver function"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program to get maximum and minimum values of an expression"}
{"code": "static boolean isOperator ( char op ) { return ( op == ' + ' op == ' * ' ) ; }", "nl": "Utility method to check whether a character is operator or not"}
{"code": "static void printMinAndMaxValueOfExp ( String exp ) { Vector < Integer > num = new Vector < Integer > ( ) ; Vector < Character > opr = new Vector < Character > ( ) ; String tmp = \" \" ;", "nl": "method prints minimum and maximum value obtainable from an expression"}
{"code": "for ( int i = 0 ; i < exp . length ( ) ; i ++ ) { if ( isOperator ( exp . charAt ( i ) ) ) { opr . add ( exp . charAt ( i ) ) ; num . add ( Integer . parseInt ( tmp ) ) ; tmp = \" \" ; } else { tmp += exp . charAt ( i ) ; } }", "nl": "store operator and numbers in different vectors"}
{"code": "num . add ( Integer . parseInt ( tmp ) ) ; int len = num . size ( ) ; int [ ] [ ] minVal = new int [ len ] [ len ] ; int [ ] [ ] maxVal = new int [ len ] [ len ] ;", "nl": "storing last number in vector"}
{"code": "for ( int i = 0 ; i < len ; i ++ ) { for ( int j = 0 ; j < len ; j ++ ) { minVal [ i ] [ j ] = Integer . MAX_VALUE ; maxVal [ i ] [ j ] = 0 ;", "nl": "initializing minval and maxval 2D array"}
{"code": "if ( i == j ) minVal [ i ] [ j ] = maxVal [ i ] [ j ] = num . get ( i ) ; } }", "nl": "initializing main diagonal by num values"}
{"code": "for ( int L = 2 ; L <= len ; L ++ ) { for ( int i = 0 ; i < len - L + 1 ; i ++ ) { int j = i + L - 1 ; for ( int k = i ; k < j ; k ++ ) { int minTmp = 0 , maxTmp = 0 ;", "nl": "looping similar to matrix chain multiplication and updating both 2D arrays"}
{"code": "if ( opr . get ( k ) == ' + ' ) { minTmp = minVal [ i ] [ k ] + minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] + maxVal [ k + 1 ] [ j ] ; }", "nl": "if current operator is ' + ' , updating tmp variable by addition"}
{"code": "else if ( opr . get ( k ) == ' * ' ) { minTmp = minVal [ i ] [ k ] * minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] * maxVal [ k + 1 ] [ j ] ; }", "nl": "if current operator is ' * ' , updating tmp variable by multiplication"}
{"code": "if ( minTmp < minVal [ i ] [ j ] ) minVal [ i ] [ j ] = minTmp ; if ( maxTmp > maxVal [ i ] [ j ] ) maxVal [ i ] [ j ] = maxTmp ; } } }", "nl": "updating array values by tmp variables"}
{"code": "System . out . print ( \" Minimum \u2581 value \u2581 : \u2581 \" + minVal [ 0 ] [ len - 1 ] + \" , \u2581 Maximum \u2581 value \u2581 : \u2581 \" + maxVal [ 0 ] [ len - 1 ] ) ; }", "nl": "last element of first row will store the result"}
{"code": "public static void main ( String [ ] args ) { String expression = \"1 + 2*3 + 4*5\" ; printMinAndMaxValueOfExp ( expression ) ; } }", "nl": "Driver code to test above methods"}
{"code": "class MatrixChainMultiplication {", "nl": "A naive recursive implementation that simply follows the above optimal substructure property"}
{"code": "static int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int min = Integer . MAX_VALUE ;", "nl": "Matrix Ai has dimension p [ i - 1 ] x p [ i ] for i = 1. . n"}
{"code": "for ( int k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; }", "nl": "place parenthesis at different places between first and last matrix , recursively calculate count of multiplications for each parenthesis placement and return the minimum count"}
{"code": "return min ; }", "nl": "Return minimum count"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 , 3 } ; int n = arr . length ; System . out . println ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \u2581 \" + MatrixChainOrder ( arr , 1 , n - 1 ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG { static int [ ] [ ] dp = new int [ 100 ] [ 100 ] ;", "nl": "Java program using memoization"}
{"code": "static int matrixChainMemoised ( int [ ] p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != - 1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; } static int MatrixChainOrder ( int [ ] p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; }", "nl": "Function for matrix chain multiplication"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; for ( int [ ] row : dp ) Arrays . fill ( row , - 1 ) ; System . out . println ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \u2581 \" + MatrixChainOrder ( arr , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void flipBitsOfAandB ( int A , int B ) {", "nl": "Function to flip bits of A and B which are set in both of them"}
{"code": "A = A ^ ( A & B ) ;", "nl": "Clear the bits of A which are set in both A and B"}
{"code": "B = B ^ ( A & B ) ;", "nl": "Clear the bits of B which are set in both A and B"}
{"code": "System . out . print ( A + \" \u2581 \" + B ) ; }", "nl": "Print updated A and B"}
{"code": "public static void main ( String [ ] args ) { int A = 10 , B = 20 ; flipBitsOfAandB ( A , B ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int TotalHammingDistance ( int n ) { int i = 1 , sum = 0 ; while ( n / i > 0 ) { sum = sum + n / i ; i = i * 2 ; } return sum ; }", "nl": "Function to calculate and return the hamming distance between all consecutive numbers from 0 to N"}
{"code": "public static void main ( String [ ] args ) { int N = 9 ; System . out . println ( TotalHammingDistance ( N ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static final int m = 1000000007 ;", "nl": "Java Program to implement the above approach"}
{"code": "static void solve ( long n ) {", "nl": "Function to find the sum of all divisors of all numbers from 1 to N"}
{"code": "long s = 0 ; for ( int l = 1 ; l <= n ; ) {", "nl": "Stores the sum"}
{"code": "int r = ( int ) ( n / Math . floor ( n / l ) ) ; int x = ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ; int y = ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ; int p = ( int ) ( ( n / l ) % m ) ;", "nl": "Marks the last point of occurence with same count"}
{"code": "s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; }", "nl": "Calculate the sum"}
{"code": "System . out . print ( ( s + m ) % m ) ; }", "nl": "Return the result"}
{"code": "public static void main ( String [ ] args ) { long n = 12 ; solve ( n ) ; } }", "nl": "Driver Code"}
{"code": "import java . lang . * ; class GFG {", "nl": "Java program to find minimum time required to split a stick of N length into unit pieces"}
{"code": "static int min_time_to_cut ( int N ) { if ( N == 0 ) return 0 ;", "nl": "Function to return the minimum time required to split stick of N into length into unit pieces"}
{"code": "return ( int ) Math . ceil ( Math . log ( N ) / Math . log ( 2 ) ) ; }", "nl": "Return the minimum unit of time required"}
{"code": "public static void main ( String [ ] args ) { int N = 100 ; System . out . print ( min_time_to_cut ( N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to count of distinct pair sum between two Array with values 1 to N"}
{"code": "static int findDistinctSums ( int n ) {", "nl": "Function to find the distinct sums"}
{"code": "HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) {", "nl": "Set to store distinct sums"}
{"code": "s . add ( i + j ) ; } }", "nl": "Inserting every sum"}
{"code": "return s . size ( ) ; }", "nl": "Returning distinct sums"}
{"code": "public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( findDistinctSums ( N ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to print the triangle separated pattern using star and slash character"}
{"code": "static int printPattern ( int i , int j , int n ) {", "nl": "Function to print pattern recursively"}
{"code": "if ( j >= n ) { return 0 ; } if ( i >= n ) { return 1 ; }", "nl": "Base Case"}
{"code": "if ( j == i j == n - 1 - i ) {", "nl": "Conditions to print slash"}
{"code": "if ( i == n - 1 - j ) { System . out . print ( \" / \" ) ; }", "nl": "Condition to print forword slash"}
{"code": "else { System . out . print ( \" \\ \\\" ) ; } }", "nl": "Condition to print backward slash"}
{"code": "else { System . out . print ( \" * \" ) ; }", "nl": "Else print ' * '"}
{"code": "if ( printPattern ( i , j + 1 , n ) == 1 ) { return 1 ; } System . out . println ( ) ;", "nl": "Recursive call for rows"}
{"code": "return printPattern ( i + 1 , 0 , n ) ; }", "nl": "Recursive call for changing the rows"}
{"code": "public static void main ( String [ ] args ) { int N = 9 ;", "nl": "Driver Code"}
{"code": "printPattern ( 0 , 0 , N ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; import java . util . * ; class GfG {", "nl": "Java implementation for pattern searching in an array using Z - Algorithm"}
{"code": "private static int [ ] zArray ( int arr [ ] ) { int z [ ] ; int n = arr . length ; z = new int [ n ] ; int r = 0 , l = 0 ;", "nl": "Function to calculate Z - Array"}
{"code": "for ( int k = 1 ; k < n ; k ++ ) {", "nl": "Loop to calculate Z - Array"}
{"code": "if ( k > r ) { r = l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; }", "nl": "Outside the Z - box"}
{"code": "else { int k1 = k - l ; if ( z [ k1 ] < r - k + 1 ) z [ k ] = z [ k1 ] ; else { l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } } } return z ; }", "nl": "Inside Z - box"}
{"code": "private static int [ ] mergeArray ( int A [ ] , int B [ ] ) { int n = A . length ; int m = B . length ; int z [ ] ;", "nl": "Helper function to merge two arrays and create a single array"}
{"code": "int c [ ] = new int [ n + m + 1 ] ;", "nl": "Array to store merged array"}
{"code": "for ( int i = 0 ; i < m ; i ++ ) c [ i ] = B [ i ] ;", "nl": "Copying array B"}
{"code": "c [ m ] = Integer . MAX_VALUE ;", "nl": "Adding a separator"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) c [ m + i + 1 ] = A [ i ] ;", "nl": "Copying array A"}
{"code": "z = zArray ( c ) ; return z ; }", "nl": "Calling Z - function"}
{"code": "private static void findZArray ( int A [ ] , int B [ ] , int n ) { int flag = 0 ; int z [ ] ; z = mergeArray ( A , B ) ;", "nl": "Function to help compute the Z array"}
{"code": "for ( int i = 0 ; i < z . length ; i ++ ) { if ( z [ i ] == n ) { System . out . print ( ( i - n - 1 ) + \" \u2581 \" ) ; flag = 1 ; } } if ( flag == 0 ) { System . out . println ( \" Not \u2581 Found \" ) ; } }", "nl": "Printing indexes where array B occur"}
{"code": "public static void main ( String args [ ] ) { int A [ ] = { 1 , 2 , 3 , 2 , 3 , 2 } ; int B [ ] = { 2 , 3 } ; int n = B . length ; findZArray ( A , B , n ) ; } }", "nl": "Driver Code"}
{"code": "class GfG {", "nl": "Java implementation of the approach"}
{"code": "static int getCount ( String a , String b ) {", "nl": "Function to return the count of repetitions of string a to generate string b"}
{"code": "if ( b . length ( ) % a . length ( ) != 0 ) return - 1 ; int count = b . length ( ) / a . length ( ) ;", "nl": "If b cannot be generated by repeating a"}
{"code": "String str = \" \" ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str . equals ( b ) ) return count ; return - 1 ; }", "nl": "Repeat a count number of times"}
{"code": "public static void main ( String [ ] args ) { String a = \" geeks \" ; String b = \" geeksgeeks \" ; System . out . println ( getCount ( a , b ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "JAVA program to Check if a given String can be formed from another String using given constraints"}
{"code": "static boolean check ( String S1 , String S2 ) {", "nl": "Function to check if S2 can be formed of S1"}
{"code": "int n1 = S1 . length ( ) ; int n2 = S2 . length ( ) ;", "nl": "length of Strings"}
{"code": "HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;", "nl": "hash - table to store count"}
{"code": "for ( int i = 0 ; i < n1 ; i ++ ) { if ( mp . containsKey ( ( int ) S1 . charAt ( i ) ) ) { mp . put ( ( int ) S1 . charAt ( i ) , mp . get ( ( int ) S1 . charAt ( i ) ) + 1 ) ; } else { mp . put ( ( int ) S1 . charAt ( i ) , 1 ) ; } }", "nl": "store count of each character"}
{"code": "for ( int i = 0 ; i < n2 ; i ++ ) {", "nl": "traverse and check for every character"}
{"code": "if ( mp . containsKey ( ( int ) S2 . charAt ( i ) ) ) { mp . put ( ( int ) S2 . charAt ( i ) , mp . get ( ( int ) S2 . charAt ( i ) ) - 1 ) ; }", "nl": "if the character of s2 is present in s1"}
{"code": "else if ( mp . containsKey ( S2 . charAt ( i ) - 1 ) && mp . containsKey ( S2 . charAt ( i ) - 2 ) ) { mp . put ( ( S2 . charAt ( i ) - 1 ) , mp . get ( S2 . charAt ( i ) - 1 ) - 1 ) ; mp . put ( ( S2 . charAt ( i ) - 2 ) , mp . get ( S2 . charAt ( i ) - 2 ) - 1 ) ; } else { return false ; } } return true ; }", "nl": "if the character of s2 is not present in S1 , then check if previous two ASCII characters are present in S1"}
{"code": "public static void main ( String [ ] args ) { String S1 = \" abbat \" ; String S2 = \" cat \" ;", "nl": "Driver Code"}
{"code": "if ( check ( S1 , S2 ) ) System . out . print ( \" YES \" ) ; else System . out . print ( \" NO \" ) ; } }", "nl": "Calling function to check"}
{"code": "public class GFG {", "nl": "Java program to calculate number of times the pattern occurred in given string"}
{"code": "static int countPattern ( String str ) { int len = str . length ( ) ; boolean oneSeen = false ;", "nl": "Returns count of occurrences of \"1(0 + ) 1\" int str ."}
{"code": "for ( int i = 0 ; i < len ; i ++ ) { char getChar = str . charAt ( i ) ;", "nl": "int count = 0 ; Initialize result"}
{"code": "if ( getChar == '1' && oneSeen == true ) { if ( str . charAt ( i - 1 ) == '0' ) count ++ ; }", "nl": "Check if encountered '1' forms a valid pattern as specified"}
{"code": "if ( getChar == '1' && oneSeen == false ) oneSeen = true ;", "nl": "if 1 encountered for first time set oneSeen to 1"}
{"code": "if ( getChar != '0' && str . charAt ( i ) != '1' ) oneSeen = false ; } return count ; }", "nl": "Check if there is any other character other than '0' or '1' . If so then set oneSeen to 0 to search again for new pattern"}
{"code": "public static void main ( String [ ] args ) { String str = \"100001abc101\" ; System . out . println ( countPattern ( str ) ) ; } }", "nl": "Driver program to test above function"}
{"code": "public class GFG {", "nl": "Java program for the above approach"}
{"code": "static String checkIfPossible ( int N , String [ ] arr , String T ) {", "nl": "Function to check if it possible to make all the strings equal to the string T"}
{"code": "int [ ] freqS = new int [ 256 ] ;", "nl": "Stores the frequency of all the strings in the array arr [ ]"}
{"code": "int [ ] freqT = new int [ 256 ] ;", "nl": "Stores the frequency of the string T"}
{"code": "for ( char ch : T . toCharArray ( ) ) { freqT [ ch - ' a ' ] ++ ; }", "nl": "Iterate over the characters of the string T"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Iterate in the range [ 0 , N - 1 ]"}
{"code": "for ( char ch : arr [ i ] . toCharArray ( ) ) { freqS [ ch - ' a ' ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) {", "nl": "Iterate over the characters of the string arr [ i ]"}
{"code": "if ( freqT [ i ] == 0 && freqS [ i ] != 0 ) { return \" No \" ; }", "nl": "If freqT [ i ] is 0 and freqS [ i ] is not 0"}
{"code": "else if ( freqS [ i ] == 0 && freqT [ i ] != 0 ) { return \" No \" ; }", "nl": "If freqS [ i ] is 0 and freqT [ i ] is not 0"}
{"code": "else if ( freqT [ i ] != 0 && freqS [ i ] != ( freqT [ i ] * N ) ) { return \" No \" ; } }", "nl": "If freqS [ i ] is not freqT [ i ] * N"}
{"code": "return \" Yes \" ; }", "nl": "Otherwise , return \" Yes \""}
{"code": "public static void main ( String [ ] args ) { String [ ] arr = { \" abc \" , \" abb \" , \" acc \" } ; String T = \" abc \" ; int N = arr . length ; System . out . println ( checkIfPossible ( N , arr , T ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . Stack ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int groupsOfOnes ( String S , int N ) {", "nl": "Function to find the number of the groups of 1 s only in the binary string"}
{"code": "int count = 0 ;", "nl": "Stores number of groups of 1 s"}
{"code": "Stack < Integer > st = new Stack < > ( ) ;", "nl": "Initialization of the stack"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the string S"}
{"code": "if ( S . charAt ( i ) == '1' ) st . push ( 1 ) ;", "nl": "If S [ i ] is '1'"}
{"code": "else {", "nl": "Otherwise"}
{"code": "if ( ! st . empty ( ) ) { count ++ ; while ( ! st . empty ( ) ) { st . pop ( ) ; } } } }", "nl": "If st is empty"}
{"code": "if ( ! st . empty ( ) ) count ++ ;", "nl": "If st is not empty"}
{"code": "return count ; }", "nl": "Return answer"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "String S = \"100110111\" ; int N = S . length ( ) ;", "nl": "Input"}
{"code": "System . out . println ( groupsOfOnes ( S , N ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; public class Main {", "nl": "Java program for the above approach"}
{"code": "static void generatePalindrome ( String S ) {", "nl": "Function to print all palindromic strings of length 3 that can be formed using characters of string S"}
{"code": "HashMap < Character , Integer > Hash = new HashMap < > ( ) ;", "nl": "Stores the count of character"}
{"code": "for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( Hash . containsKey ( S . charAt ( i ) ) ) Hash . put ( S . charAt ( i ) , Hash . get ( S . charAt ( i ) ) + 1 ) ; else Hash . put ( S . charAt ( i ) , 1 ) ; }", "nl": "Traverse the string S"}
{"code": "TreeSet < String > st = new TreeSet < String > ( ) ;", "nl": "Stores all palindromic strings"}
{"code": "for ( char i = ' a ' ; i <= ' z ' ; i ++ ) {", "nl": "Iterate over the charchaters over the range [ ' a ' , ' z ' ]"}
{"code": "if ( Hash . containsKey ( i ) && Hash . get ( i ) == 2 ) {", "nl": "If Hash [ ch ] is equal to 2"}
{"code": "for ( char j = ' a ' ; j <= ' z ' ; j ++ ) {", "nl": "Iterate over the characters over the range [ ' a ' , ' z ' ]"}
{"code": "String s = \" \" ; if ( Hash . containsKey ( j ) && i != j ) { s += i ; s += j ; s += i ;", "nl": "Stores all the palindromic string"}
{"code": "st . add ( s ) ; } } }", "nl": "Push the s into the set st"}
{"code": "if ( Hash . containsKey ( i ) && Hash . get ( i ) >= 3 ) {", "nl": "If Hash [ i ] is greater than or equal to 3"}
{"code": "for ( char j = ' a ' ; j <= ' z ' ; j ++ ) {", "nl": "Iterate over charchaters over the range [ ' a ' , ' z ' ]"}
{"code": "String s = \" \" ;", "nl": "Stores all the palindromic string"}
{"code": "if ( Hash . containsKey ( j ) ) { s += i ; s += j ; s += i ;", "nl": "If Hash [ j ] is positive"}
{"code": "st . add ( s ) ; } } } }", "nl": "Push s into the set st"}
{"code": "for ( String ans : st ) { System . out . println ( ans ) ; } }", "nl": "Iterate over the set"}
{"code": "public static void main ( String [ ] args ) { String S = \" ddabdac \" ; generatePalindrome ( S ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG {", "nl": "Java program for the above approach"}
{"code": "static void countOccurrences ( String S , String X , String Y ) {", "nl": "Function to count occurrences of the string Y in the string S for every occurrence of X in S"}
{"code": "int count = 0 ;", "nl": "Stores the count of occurrences of X"}
{"code": "int N = S . length ( ) , A = X . length ( ) ; int B = Y . length ( ) ;", "nl": "Stores the lengths of the three strings"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the string S"}
{"code": "if ( S . substring ( i , Math . min ( N , i + B ) ) . equals ( Y ) ) count ++ ;", "nl": "If the current substring is Y , then increment the value of count by 1"}
{"code": "if ( S . substring ( i , Math . min ( N , i + A ) ) . equals ( X ) ) System . out . print ( count + \" \u2581 \" ) ; } }", "nl": "If the current substring is X , then print the count"}
{"code": "public static void main ( String [ ] args ) { String S = \" abcdefdefabc \" ; String X = \" abc \" ; String Y = \" def \" ; countOccurrences ( S , X , Y ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void DFA ( String str , int N ) {", "nl": "Function to find whether the given String is Accepted by the DFA"}
{"code": "if ( N <= 1 ) { System . out . print ( \" No \" ) ; return ; }", "nl": "If n <= 1 , then print No"}
{"code": "int count = 0 ;", "nl": "To count the matched characters"}
{"code": "if ( str . charAt ( 0 ) == ' C ' ) { count ++ ;", "nl": "Check if the first character is C"}
{"code": "for ( int i = 1 ; i < N ; i ++ ) {", "nl": "Traverse the rest of String"}
{"code": "if ( str . charAt ( i ) == ' A ' || str . charAt ( i ) == ' B ' ) count ++ ; else break ; } } else {", "nl": "If character is A or B , increment count by 1"}
{"code": "System . out . print ( \" No \" ) ; return ; }", "nl": "If the first character is not C , print - 1"}
{"code": "if ( count == N ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; }", "nl": "If all characters matches"}
{"code": "public static void main ( String [ ] args ) { String str = \" CAABBAAB \" ; int N = str . length ( ) ; DFA ( str , N ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static void minMaxDigits ( String str , int N ) {", "nl": "Function to find the maximum and minimum number of digits to be removed to make str divisible by 3"}
{"code": "int arr [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = ( str . charAt ( i ) - '0' ) % 3 ;", "nl": "Convert the string into array of digits"}
{"code": "int zero = 0 , one = 0 , two = 0 ;", "nl": "Count of 0 s , 1 s , and 2 s"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero ++ ; if ( arr [ i ] == 1 ) one ++ ; if ( arr [ i ] == 2 ) two ++ ; }", "nl": "Traverse the array"}
{"code": "int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum = ( sum + arr [ i ] ) % 3 ; }", "nl": "Find the sum of digits % 3"}
{"code": "if ( sum == 0 ) { System . out . print ( 0 + \" \u2581 \" ) ; } if ( sum == 1 ) { if ( ( one != 0 ) && ( N > 1 ) ) System . out . print ( 1 + \" \u2581 \" ) ; else if ( two > 1 && N > 2 ) System . out . print ( 2 + \" \u2581 \" ) ; else System . out . print ( - 1 + \" \u2581 \" ) ; } if ( sum == 2 ) { if ( two != 0 && N > 1 ) System . out . print ( 1 + \" \u2581 \" ) ; else if ( one > 1 && N > 2 ) System . out . print ( 2 + \" \u2581 \" ) ; else System . out . print ( - 1 + \" \u2581 \" ) ; }", "nl": "Cases to find minimum number of digits to be removed"}
{"code": "if ( zero > 0 ) System . out . print ( N - 1 + \" \u2581 \" ) ; else if ( one > 0 && two > 0 ) System . out . print ( N - 2 + \" \u2581 \" ) ; else if ( one > 2 two > 2 ) System . out . print ( N - 3 + \" \u2581 \" ) ; else System . out . print ( - 1 + \" \u2581 \" ) ; }", "nl": "Cases to find maximum number of digits to be removed"}
{"code": "public static void main ( String [ ] args ) { String str = \"12345\" ; int N = str . length ( ) ;", "nl": "Driver code"}
{"code": "minMaxDigits ( str , N ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int findMinimumChanges ( int N , int K , char [ ] S ) {", "nl": "Function to find the minimum number of changes to make the String K - periodic and palindrome"}
{"code": "int ans = 0 ;", "nl": "Initialize ans with 0"}
{"code": "for ( int i = 0 ; i < ( K + 1 ) / 2 ; i ++ ) {", "nl": "Iterate from 0 to ( K + 1 ) / 2"}
{"code": "HashMap < Character , Integer > mp = new HashMap < > ( ) ;", "nl": "Store frequency of character"}
{"code": "for ( int j = i ; j < N ; j += K ) {", "nl": "Iterate through all indices , i , i + K , i + 2 k ... . and store the frequency of character"}
{"code": "if ( mp . containsKey ( S [ j ] ) ) { mp . put ( S [ j ] , mp . get ( S [ j ] ) + 1 ) ; } else { mp . put ( S [ j ] , 1 ) ; } }", "nl": "Increase the frequency of current character"}
{"code": "for ( int j = N - i - 1 ; j >= 0 ; j -= K ) {", "nl": "Iterate through all indices K - i , 2 K - i , 3 K - i ... . and store the frequency of character"}
{"code": "if ( K % 2 == 1 && i == K / 2 ) break ;", "nl": "If K is odd & i is samw as K / 2 , break the loop"}
{"code": "if ( mp . containsKey ( S [ j ] ) ) { mp . put ( S [ j ] , mp . get ( S [ j ] ) + 1 ) ; } else { mp . put ( S [ j ] , 1 ) ; } }", "nl": "Increase the frequency of current character"}
{"code": "int curr_max = Integer . MIN_VALUE ; for ( Map . Entry < Character , Integer > p : mp . entrySet ( ) ) { curr_max = Math . max ( curr_max , p . getValue ( ) ) ; }", "nl": "Find the maximum frequency of a character among all visited characters"}
{"code": "if ( ( K % 2 == 1 ) && i == K / 2 ) ans += ( N / K - curr_max ) ;", "nl": "If K is odd and i is same as K / 2 then , only N / K characters is visited"}
{"code": "else ans += ( N / K * 2 - curr_max ) ; }", "nl": "Otherwise N / K * 2 characters has visited"}
{"code": "return ans ; }", "nl": "Return the result"}
{"code": "public static void main ( String [ ] args ) { String S = \" aabbcbbcb \" ; int N = S . length ( ) ; int K = 3 ;", "nl": "Driver Code"}
{"code": "System . out . print ( findMinimumChanges ( N , K , S . toCharArray ( ) ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static String checkString ( String s , int K ) { int n = s . length ( ) ;", "nl": "Function to check if any index contains more than K active characters"}
{"code": "Map < Character , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . put ( s . charAt ( i ) , i ) ; } int cnt = 0 , f = 0 ;", "nl": "Store the last occurrence of each character in the map ."}
{"code": "Set < Character > st = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Stores the active characters"}
{"code": "st . add ( s . charAt ( i ) ) ;", "nl": "Insert the character"}
{"code": "if ( st . size ( ) > K ) { f = 1 ; break ; }", "nl": "If the size of set exceeds K"}
{"code": "if ( mp . get ( s . charAt ( i ) ) == i ) st . remove ( s . charAt ( i ) ) ; } return ( f == 1 ? \" Yes \" : \" No \" ) ; }", "nl": "Remove the character from set if i is the last index of the current character"}
{"code": "public static void main ( String [ ] args ) { String s = \" aabbcdca \" ; int k = 2 ; System . out . println ( checkString ( s , k ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to count the number of strings in the array whose distinct characters is less than or equal to M"}
{"code": "public static void distinct ( String [ ] S , int M ) { int count = 0 ;", "nl": "Function to count the strings whose distinct characters count is less than M"}
{"code": "for ( int i = 0 ; i < S . length ; i ++ ) {", "nl": "Loop to iterate over all the strings of the array"}
{"code": "Set < Character > set = new HashSet < > ( ) ; for ( int j = 0 ; j < S [ i ] . length ( ) ; j ++ ) { if ( ! set . contains ( S [ i ] . charAt ( j ) ) ) set . add ( S [ i ] . charAt ( j ) ) ; } int c = set . size ( ) ;", "nl": "Distinct characters in the String with the help of set"}
{"code": "if ( c <= M ) count += 1 ; } System . out . println ( count ) ; }", "nl": "Checking if its less than or equal to M"}
{"code": "public static void main ( String [ ] args ) { String S [ ] = { \" HERBIVORES \" , \" AEROPLANE \" , \" GEEKSFORGEEKS \" } ; int M = 7 ; distinct ( S , M ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to remove the characters having odd frequencies in the string"}
{"code": "static String removeOddFrequencyCharacters ( String s ) {", "nl": "Function to remove the characters which have odd frequencies in the string"}
{"code": "HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char p = s . charAt ( i ) ; Integer count = m . get ( p ) ; if ( count == null ) { count = 0 ; m . put ( p , 1 ) ; } else m . put ( p , count + 1 ) ; }", "nl": "Create a map to store the frequency of each character"}
{"code": "String new_string = \" \" ;", "nl": "To store the new string"}
{"code": "for ( int i = 0 ; i < s . length ( ) ; i ++ ) {", "nl": "Remove the characters which have odd frequencies"}
{"code": "if ( ( m . get ( s . charAt ( i ) ) & 1 ) == 1 ) continue ;", "nl": "If the character has odd frequency then skip"}
{"code": "new_string += s . charAt ( i ) ; }", "nl": "Else concatenate the character to the new string"}
{"code": "return new_string ; }", "nl": "Return the modified string"}
{"code": "public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ;", "nl": "Driver code"}
{"code": "str = removeOddFrequencyCharacters ( str ) ; System . out . print ( str ) ; } }", "nl": "Remove the characters which have odd frequencies"}
{"code": "class GFG { static int i ;", "nl": "Java implementation to find product of elements at k - th level"}
{"code": "static int productAtKthLevel ( String tree , int k , int level ) { if ( tree . charAt ( i ++ ) == ' ( ' ) {", "nl": "Recursive Function to find product of elements at k - th level"}
{"code": "if ( tree . charAt ( i ) == ' ) ' ) return 1 ; int product = 1 ;", "nl": "if subtree is null , just like if root == null"}
{"code": "if ( level == k ) product = tree . charAt ( i ) - '0' ;", "nl": "Consider only level k node to be part of the product"}
{"code": "++ i ; int leftproduct = productAtKthLevel ( tree , k , level + 1 ) ;", "nl": "Recur for Left Subtree"}
{"code": "++ i ; int rightproduct = productAtKthLevel ( tree , k , level + 1 ) ;", "nl": "Recur for Right Subtree"}
{"code": "++ i ; return product * leftproduct * rightproduct ; } return Integer . MIN_VALUE ; }", "nl": "Taking care of ' ) ' after left and right subtree"}
{"code": "public static void main ( String [ ] args ) { String tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) \" + \" ( 9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" ; int k = 2 ; i = 0 ; System . out . print ( productAtKthLevel ( tree , k , 0 ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to print the most occurring character in an array of Strings"}
{"code": "static void findMostOccurringChar ( Vector < String > str ) {", "nl": "Function to print the most occurring character"}
{"code": "int [ ] hash = new int [ 26 ] ;", "nl": "Creating a hash of size 26"}
{"code": "for ( int i = 0 ; i < str . size ( ) ; i ++ ) {", "nl": "For loop to iterate through every String of the array"}
{"code": "for ( int j = 0 ; j < str . get ( i ) . length ( ) ; j ++ ) {", "nl": "For loop to iterate through every character of the String"}
{"code": "hash [ str . get ( i ) . charAt ( j ) - 97 ] ++ ; } }", "nl": "Incrementing the count of the character in the hash"}
{"code": "int max = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { max = hash [ i ] > hash [ max ] ? i : max ; } System . out . print ( ( char ) ( max + 97 ) + \"NEW_LINE\"); }", "nl": "Finding the character with the maximum count"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "Vector < String > str = new Vector < String > ( ) ; str . add ( \" animal \" ) ; str . add ( \" zebra \" ) ; str . add ( \" lion \" ) ; str . add ( \" giraffe \" ) ; findMostOccurringChar ( str ) ; } }", "nl": "Declaring Vector of String type"}
{"code": "public class GFG {", "nl": "Java implementation of the approach"}
{"code": "public static boolean isPalindrome ( float num ) {", "nl": "Function that returns true if num is palindrome"}
{"code": "String s = String . valueOf ( num ) ;", "nl": "Convert the given floating point number into a string"}
{"code": "int low = 0 ; int high = s . length ( ) - 1 ; while ( low < high ) {", "nl": "Pointers pointing to the first and the last character of the string"}
{"code": "if ( s . charAt ( low ) != s . charAt ( high ) ) return false ;", "nl": "Not a palindrome"}
{"code": "low ++ ; high -- ; } return true ; }", "nl": "Update the pointers"}
{"code": "public static void main ( String args [ ] ) { float n = 123.321f ; if ( isPalindrome ( n ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "class GFG { final static int MAX = 26 ;", "nl": "Java implementation of the approach"}
{"code": "static int maxSubStr ( char [ ] str1 , int len1 , char [ ] str2 , int len2 ) {", "nl": "Function to return the maximum number of times str1 can appear as a non - overlapping substring in str2"}
{"code": "if ( len1 > len2 ) return 0 ;", "nl": "str1 cannot never be substring of str2"}
{"code": "int freq1 [ ] = new int [ MAX ] ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ i ] = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ;", "nl": "Store the frequency of the characters of str1"}
{"code": "int freq2 [ ] = new int [ MAX ] ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ i ] = 0 ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ;", "nl": "Store the frequency of the characters of str2"}
{"code": "int minPoss = Integer . MAX_VALUE ; for ( int i = 0 ; i < MAX ; i ++ ) {", "nl": "To store the required count of substrings"}
{"code": "if ( freq1 [ i ] == 0 ) continue ;", "nl": "Current character doesn 't appear in str1"}
{"code": "if ( freq1 [ i ] > freq2 [ i ] ) return 0 ;", "nl": "Frequency of the current character in str1 is greater than its frequency in str2"}
{"code": "minPoss = Math . min ( minPoss , freq2 [ i ] / freq1 [ i ] ) ; } return minPoss ; }", "nl": "Update the count of possible substrings"}
{"code": "public static void main ( String [ ] args ) { String str1 = \" geeks \" , str2 = \" gskefrgoekees \" ; int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; System . out . println ( maxSubStr ( str1 . toCharArray ( ) , len1 , str2 . toCharArray ( ) , len2 ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int cntWays ( String str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; }", "nl": "Function to return the number of ways to insert the bracket pairs"}
{"code": "public static void main ( String [ ] args ) { String str = \" ab \" ; int n = str . length ( ) ; System . out . println ( cntWays ( str , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of above approach"}
{"code": "static Set < String > uSet = new HashSet < String > ( ) ;", "nl": "Set to store all the Strings from the given array"}
{"code": "static int minCnt = Integer . MAX_VALUE ;", "nl": "To store the required count"}
{"code": "static void findSubStr ( String str , int cnt , int start ) {", "nl": "Recursive function to find the count of subStrings that can be splitted starting from the index start such that all the subStrings are present in the map"}
{"code": "if ( start == str . length ( ) ) {", "nl": "All the chosen subStrings are present in the map"}
{"code": "minCnt = Math . min ( cnt , minCnt ) ; }", "nl": "Update the minimum count of subStrings"}
{"code": "for ( int len = 1 ; len <= ( str . length ( ) - start ) ; len ++ ) {", "nl": "Starting from the subStrings of length 1 that start with the given index"}
{"code": "String subStr = str . substring ( start , start + len ) ;", "nl": "Get the subString"}
{"code": "if ( uSet . contains ( subStr ) ) {", "nl": "If the subString is present in the set"}
{"code": "findSubStr ( str , cnt + 1 , start + len ) ; } } }", "nl": "Recursive call for the rest of the String"}
{"code": "static void findMinSubStr ( String arr [ ] , int n , String str ) {", "nl": "Function that inserts all the Strings from the given array in a set and calls the recursive function to find the minimum count of subStrings str can be splitted into that satisfy the given condition"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) uSet . add ( arr [ i ] ) ;", "nl": "Insert all the Strings from the given array in a set"}
{"code": "findSubStr ( str , 0 , 0 ) ; }", "nl": "Find the required count"}
{"code": "public static void main ( String args [ ] ) { String str = \"123456\" ; String arr [ ] = { \"1\" , \"12345\" , \"2345\" , \"56\" , \"23\" , \"456\" } ; int n = arr . length ; findMinSubStr ( arr , n , str ) ; System . out . print ( minCnt ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int countSubStr ( String s , int n ) { int c1 = 0 , c2 = 0 ;", "nl": "Function to return the count of required substrings"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "For every index of the string"}
{"code": "if ( i < n - 5 && \" geeks \" . equals ( s . substring ( i , i + 5 ) ) ) { c1 ++ ; }", "nl": "If the substring starting at the current index is \" geeks \""}
{"code": "if ( i < n - 3 && \" for \" . equals ( s . substring ( i , i + 3 ) ) ) { c2 = c2 + c1 ; } } return c2 ; }", "nl": "If the substring is \" for \""}
{"code": "public static void main ( String [ ] args ) { String s = \" geeksforgeeksisforgeeks \" ; int n = s . length ( ) ; System . out . println ( countSubStr ( s , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; public class Main { public static void main ( String [ ] args ) {", "nl": "Java implementation of the approach"}
{"code": "String string = \" { [ ( ) ] } [ ] \" ;", "nl": "Defining the string"}
{"code": "char [ ] lst1 = { ' { ' , ' ( ' , ' [ ' } ;", "nl": "Storing opening braces in list lst1"}
{"code": "char [ ] lst2 = { ' } ' , ' ) ' , ' ] ' } ;", "nl": "Storing closing braces in list lst2"}
{"code": "Vector < Character > lst = new Vector < Character > ( ) ;", "nl": "Creating an empty list lst"}
{"code": "HashMap < Character , Character > Dict = new HashMap < > ( ) ; Dict . put ( ' ) ' , ' ( ' ) ; Dict . put ( ' } ' , ' { ' ) ; Dict . put ( ' ] ' , ' [ ' ) ; int a = 0 , b = 0 , c = 0 ;", "nl": "Creating dictionary to map closing braces to opening ones"}
{"code": "if ( Arrays . asList ( lst2 ) . contains ( string . charAt ( 0 ) ) ) { System . out . println ( 1 ) ; } else { int k = 0 ;", "nl": "If first position of string contain any closing braces return 1"}
{"code": "for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( Arrays . asList ( lst1 ) . contains ( string . charAt ( i ) ) ) { lst . add ( string . charAt ( i ) ) ; k = i + 2 ; } else {", "nl": "If characters of string are opening braces then append them in a list"}
{"code": "if ( lst . size ( ) == 0 && Arrays . asList ( lst2 ) . contains ( string . charAt ( i ) ) ) { System . out . println ( ( i + 1 ) ) ; c = 1 ; break ; } else {", "nl": "When size of list is 0 and new closing braces is encountered then print its index starting from 1"}
{"code": "if ( lst . size ( ) > 0 && Dict . get ( string . charAt ( i ) ) == lst . get ( lst . size ( ) - 1 ) ) { lst . remove ( lst . size ( ) - 1 ) ; } else {", "nl": "As we encounter closing braces we map them with theircorresponding opening braces using dictionary and check if it is same as last opened braces ( last element in list ) if yes then we delete that elememt from list"}
{"code": "a = 1 ; break ; } } } }", "nl": "Otherwise we return the index ( starting from 1 ) at which nesting is found wrong"}
{"code": "if ( lst . size ( ) == 0 && c == 0 ) { System . out . println ( 0 ) ; b = 1 ; } if ( a == 0 && b == 0 && c == 0 ) { System . out . println ( k ) ; } } } }", "nl": "At end if the list is empty it means the string is perfectly nested"}
{"code": "public class GFG { static final int MAX = 26 ;", "nl": "Java implementation of the above approach :"}
{"code": "static String encryptStr ( String str , int n , int x ) {", "nl": "Function to return the encrypted string"}
{"code": "x = x % MAX ; char arr [ ] = str . toCharArray ( ) ;", "nl": "Reduce x because rotation of length 26 is unnecessary"}
{"code": "int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "calculate the frequency of characters"}
{"code": "if ( freq [ arr [ i ] - ' a ' ] % 2 == 0 ) { int pos = ( arr [ i ] - ' a ' + x ) % MAX ; arr [ i ] = ( char ) ( pos + ' a ' ) ; }", "nl": "If the frequency of current character is even then increment it by x"}
{"code": "else { int pos = ( arr [ i ] - ' a ' - x ) ; if ( pos < 0 ) pos += MAX ; arr [ i ] = ( char ) ( pos + ' a ' ) ; } }", "nl": "Else decrement it by x"}
{"code": "return String . valueOf ( arr ) ; }", "nl": "Return the count"}
{"code": "public static void main ( String [ ] args ) { String s = \" abcda \" ; int n = s . length ( ) ; int x = 3 ; System . out . println ( encryptStr ( s , n , x ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static boolean isPossible ( char [ ] str ) {", "nl": "Function that returns true if it is possible to rearrange the characters of the string such that no two consecutive characters are same"}
{"code": "Map < Character , Integer > freq = new HashMap < > ( ) ;", "nl": "To store the frequency of each of the character"}
{"code": "int max_freq = 0 ; for ( int j = 0 ; j < ( str . length ) ; j ++ ) { if ( freq . containsKey ( str [ j ] ) ) { freq . put ( str [ j ] , freq . get ( str [ j ] ) + 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } else { freq . put ( str [ j ] , 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } }", "nl": "To store the maximum frequency so far"}
{"code": "if ( max_freq <= ( str . length - max_freq + 1 ) ) return true ; return false ; }", "nl": "If possible"}
{"code": "public static void main ( String [ ] args ) { String str = \" geeksforgeeks \" ; if ( isPossible ( str . toCharArray ( ) ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void printUncommon ( String str1 , String str2 ) { int a1 = 0 , a2 = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) {", "nl": "Function to print the uncommon characters in the given string in sorted order"}
{"code": "int ch = ( str1 . charAt ( i ) ) - ' a ' ;", "nl": "Converting character to ASCII code"}
{"code": "a1 = a1 | ( 1 << ch ) ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) {", "nl": "Bit operation"}
{"code": "int ch = ( str2 . charAt ( i ) ) - ' a ' ;", "nl": "Converting character to ASCII code"}
{"code": "a2 = a2 | ( 1 << ch ) ; }", "nl": "Bit operation"}
{"code": "int ans = a1 ^ a2 ; int i = 0 ; while ( i < 26 ) { if ( ans % 2 == 1 ) { System . out . print ( ( char ) ( ' a ' + i ) ) ; } ans = ans / 2 ; i ++ ; } }", "nl": "XOR operation leaves only uncommon characters in the ans variable"}
{"code": "public static void main ( String [ ] args ) { String str1 = \" geeksforgeeks \" ; String str2 = \" geeksquiz \" ; printUncommon ( str1 , str2 ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find minimum number of reversals required to balance an expression"}
{"code": "static int countMinReversals ( String expr ) { int len = expr . length ( ) ;", "nl": "Returns count of minimum reversals for making expr balanced . Returns - 1 if expr cannot be balanced ."}
{"code": "if ( len % 2 != 0 ) return - 1 ;", "nl": "length of expression must be even to make it balanced by using reversals ."}
{"code": "int ans = 0 ; int i ;", "nl": "To store number of reversals required ."}
{"code": "int open = 0 ;", "nl": "To store number of unbalanced opening brackets ."}
{"code": "int close = 0 ; for ( i = 0 ; i < len ; i ++ ) {", "nl": "To store number of unbalanced closing brackets ."}
{"code": "if ( expr . charAt ( i ) == ' { ' ) open ++ ;", "nl": "If current bracket is open then increment open count ."}
{"code": "else { if ( open == 0 ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ;", "nl": "If current bracket is close , check if it balances opening bracket . If yes then decrement count of unbalanced opening bracket else increment count of closing bracket ."}
{"code": "close %= 2 ; open %= 2 ; if ( close != 0 ) ans += 2 ; return ans ; }", "nl": "For the case : \" } { \" or when one closing and one opening bracket remains for pairing , then both need to be reversed ."}
{"code": "public static void main ( String args [ ] ) { String expr = \" } } { { \" ; System . out . println ( countMinReversals ( expr ) ) ; } }", "nl": "Driver Code"}
{"code": "class GfG {", "nl": "Java implementation of the approach"}
{"code": "static int totalPairs ( String s1 , String s2 ) { int a1 = 0 , b1 = 0 ;", "nl": "Function to return the total number of valid pairs"}
{"code": "for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( ( int ) s1 . charAt ( i ) % 2 != 0 ) a1 ++ ; else b1 ++ ; } int a2 = 0 , b2 = 0 ;", "nl": "Count total number of even and odd ascii values for string s1"}
{"code": "for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( ( int ) s2 . charAt ( i ) % 2 != 0 ) a2 ++ ; else b2 ++ ; }", "nl": "Count total number of even and odd ascii values for string s2"}
{"code": "return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; }", "nl": "Return total valid pairs"}
{"code": "public static void main ( String [ ] args ) { String s1 = \" geeks \" , s2 = \" for \" ; System . out . println ( totalPairs ( s1 , s2 ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find the number of occurrences of prefix which occurs maximum no . of time"}
{"code": "static int prefixOccurrences ( String str ) { char c = str . charAt ( 0 ) ; int countc = 0 ;", "nl": "Function to return the count of the required prefix"}
{"code": "for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == c ) countc ++ ; } return countc ; }", "nl": "Find the frequency of first character of string"}
{"code": "public static void main ( String args [ ] ) { String str = \" abbcdabbcd \" ; System . out . println ( prefixOccurrences ( str ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int minOperations ( String s , String t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Function to return the minimum operations of the given type required to convert string s to string t"}
{"code": "if ( s . charAt ( i ) == t . charAt ( i ) ) continue ;", "nl": "Characters are already equal"}
{"code": "if ( s . charAt ( i ) == '0' ) ct0 ++ ;", "nl": "Increment count of 0 s"}
{"code": "else ct1 ++ ; } return Math . max ( ct0 , ct1 ) ; }", "nl": "Increment count of 1 s"}
{"code": "public static void main ( String args [ ] ) { String s = \"010\" , t = \"101\" ; int n = s . length ( ) ; System . out . println ( minOperations ( s , t , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static String decryptString ( String str , int n ) {", "nl": "Function to return the decrypted string"}
{"code": "int i = 0 , jump = 1 ; String decryptedStr = \" \" ; while ( i < n ) { decryptedStr += str . charAt ( i ) ; i += jump ;", "nl": "Initial jump will be 1"}
{"code": "jump ++ ; } return decryptedStr ; }", "nl": "Increment jump by 1 with every character"}
{"code": "public static void main ( String [ ] args ) { String str = \" geeeeekkkksssss \" ; int n = str . length ( ) ; System . out . println ( decryptString ( str , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GfG {", "nl": "Java program to find which bit sequence to be flipped"}
{"code": "static char bitToBeFlipped ( String s ) {", "nl": "Function to check which bit is to be flipped"}
{"code": "char last = s . charAt ( s . length ( ) - 1 ) ; char first = s . charAt ( 0 ) ;", "nl": "variable to store first and last character of string"}
{"code": "if ( last == first ) { if ( last == '0' ) { return '1' ; } else { return '0' ; } }", "nl": "Check if first and last characters are equal , if yes , then return the character which is not at last"}
{"code": "else if ( last != first ) { return last ; } return last ; }", "nl": "else return last"}
{"code": "public static void main ( String [ ] args ) { String s = \"1101011000\" ; System . out . println ( bitToBeFlipped ( s ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find Sum and product of Prime Frequencies of Characters in a String"}
{"code": "static void SieveOfEratosthenes ( boolean prime [ ] , int p_size ) {", "nl": "Function to create Sieve to check primes"}
{"code": "prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) {", "nl": "false here indicates that it is not prime"}
{"code": "if ( prime [ p ] ) {", "nl": "If prime [ p ] is not changed , then it is a prime"}
{"code": "for ( int i = p * 2 ; i < p_size ; i += p ) { prime [ i ] = false ; } } } }", "nl": "Update all multiples of p , set them to non - prime"}
{"code": "static void sumProdOfPrimeFreq ( char [ ] s ) { boolean [ ] prime = new boolean [ s . length + 1 ] ; Arrays . fill ( prime , true ) ; SieveOfEratosthenes ( prime , s . length + 1 ) ; int i , j ;", "nl": "Function to find the sum of prime frequencies of the characters of the given string"}
{"code": "Map < Character , Integer > mp = new HashMap < > ( ) ; for ( i = 0 ; i < s . length ; i ++ ) { mp . put ( s [ i ] , mp . get ( s [ i ] ) == null ? 1 : mp . get ( s [ i ] ) + 1 ) ; } int sum = 0 , product = 1 ;", "nl": "map is used to store character frequencies"}
{"code": "for ( Map . Entry < Character , Integer > it : mp . entrySet ( ) ) {", "nl": "Traverse the map"}
{"code": "if ( prime [ it . getValue ( ) ] ) { sum += it . getValue ( ) ; product *= it . getValue ( ) ; } } System . out . print ( \" Sum \u2581 = \u2581 \" + sum ) ; System . out . println ( \" Product = \" + product); }", "nl": "If the frequency is prime"}
{"code": "public static void main ( String [ ] args ) { String s = \" geeksforgeeks \" ; sumProdOfPrimeFreq ( s . toCharArray ( ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . HashMap ; class GFG {", "nl": "Java implementation of above approach"}
{"code": "public static boolean multipleOrFactor ( String s1 , String s2 ) {", "nl": "Function that checks if the frequency of character are a factor or multiple of each other"}
{"code": "HashMap < Character , Integer > m1 = new HashMap < > ( ) ; HashMap < Character , Integer > m2 = new HashMap < > ( ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( m1 . containsKey ( s1 . charAt ( i ) ) ) { int x = m1 . get ( s1 . charAt ( i ) ) ; m1 . put ( s1 . charAt ( i ) , ++ x ) ; } else m1 . put ( s1 . charAt ( i ) , 1 ) ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( m2 . containsKey ( s2 . charAt ( i ) ) ) { int x = m2 . get ( s2 . charAt ( i ) ) ; m2 . put ( s2 . charAt ( i ) , ++ x ) ; } else m2 . put ( s2 . charAt ( i ) , 1 ) ; } for ( HashMap . Entry < Character , Integer > entry : m1 . entrySet ( ) ) {", "nl": "map store frequency of each character"}
{"code": "if ( ! m2 . containsKey ( entry . getKey ( ) ) ) continue ;", "nl": "if any frequency is 0 , then continue as condition is satisfied"}
{"code": "if ( m2 . get ( entry . getKey ( ) ) != null && ( m2 . get ( entry . getKey ( ) ) % entry . getValue ( ) == 0 || entry . getValue ( ) % m2 . get ( entry . getKey ( ) ) == 0 ) ) continue ;", "nl": "if factor or multiple , then condition satisfied"}
{"code": "else return false ; } return true ; }", "nl": "if condition not satisfied"}
{"code": "public static void main ( String [ ] args ) { String s1 = \" geeksforgeeks \" , s2 = \" geeks \" ; if ( multipleOrFactor ( s1 , s2 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void solve ( String s ) {", "nl": "Function that removes the characters which have even frequencies in the string"}
{"code": "HashMap < Character , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m . containsKey ( s . charAt ( i ) ) ) m . put ( s . charAt ( i ) , m . get ( s . charAt ( i ) ) + 1 ) ; else m . put ( s . charAt ( i ) , 1 ) ; }", "nl": "create a map to store the frequency of each character"}
{"code": "String new_string = \" \" ;", "nl": "to store the new string"}
{"code": "for ( int i = 0 ; i < s . length ( ) ; i ++ ) {", "nl": "remove the characters which have even frequencies"}
{"code": "if ( m . get ( s . charAt ( i ) ) % 2 == 0 ) continue ;", "nl": "if the character has even frequency then skip"}
{"code": "new_string = new_string + s . charAt ( i ) ; }", "nl": "else concatenate the character to the new string"}
{"code": "System . out . println ( new_string ) ; }", "nl": "display the modified string"}
{"code": "public static void main ( String [ ] args ) { String s = \" aabbbddeeecc \" ;", "nl": "Driver code"}
{"code": "solve ( s ) ; } }", "nl": "remove the characters which have even frequencies"}
{"code": "class GFG {", "nl": "Java implementation to remove all the palindromic words from the given sentence"}
{"code": "static boolean isPalindrome ( String str ) { int i = 0 , j = str . length ( ) - 1 ;", "nl": "function to check if ' str ' is palindrome"}
{"code": "while ( i < j ) {", "nl": "traversing from both the ends"}
{"code": "if ( str . charAt ( i ++ ) != str . charAt ( j -- ) ) return false ; }", "nl": "not palindrome"}
{"code": "return true ; }", "nl": "palindrome"}
{"code": "static String removePalinWords ( String str ) {", "nl": "function to remove all the palindromic words from the given sentence"}
{"code": "String final_str = \" \" , word = \" \" ;", "nl": "' final _ str ' to store the final string and ' word ' to one by one store each word of ' str '"}
{"code": "str = str + \" \u2581 \" ; int n = str . length ( ) ;", "nl": "add space at the end of ' str '"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "traversing ' str '"}
{"code": "if ( str . charAt ( i ) != ' \u2581 ' ) word = word + str . charAt ( i ) ; else {", "nl": "accumulating characters of the current word"}
{"code": "if ( ! ( isPalindrome ( word ) ) ) final_str += word + \" \u2581 \" ;", "nl": "if ' word ' is not palindrome then a add it to ' final _ str '"}
{"code": "word = \" \" ; } }", "nl": "reset"}
{"code": "return final_str ; }", "nl": "required final string"}
{"code": "public static void main ( String [ ] args ) { String str = \" Text \u2581 contains \u2581 malayalam \u2581 and \u2581 level \u2581 words \" ; System . out . print ( removePalinWords ( str ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find the sum of elements present in all subsequences"}
{"code": "static int findSubSequence ( String s , int num ) {", "nl": "Returns numeric value of a subsequence of s . The subsequence to be picked is decided using bit pattern of num ( We pick all those digits for which there is a set bit in num )"}
{"code": "int res = 0 ;", "nl": "Initialize the result"}
{"code": "int i = 0 ; while ( num > 0 ) {", "nl": "till n != 0"}
{"code": "if ( ( num & 1 ) == 1 ) res += s . charAt ( i ) - '0' ; i ++ ;", "nl": "if i - th bit is set then add this number"}
{"code": "num = num >> 1 ; } return res ; }", "nl": "right shift i"}
{"code": "static int combinedSum ( String s ) {", "nl": "function to find combined sum of all individual subsequence sum"}
{"code": "int n = s . length ( ) ;", "nl": "length of String"}
{"code": "int c_sum = 0 ;", "nl": "stores the combined"}
{"code": "int range = ( 1 << n ) - 1 ;", "nl": "2 ^ n - 1 subsequences"}
{"code": "for ( int i = 0 ; i <= range ; i ++ ) c_sum += findSubSequence ( s , i ) ;", "nl": "loop for all subsequences"}
{"code": "return c_sum ; }", "nl": "returns the combined sum"}
{"code": "public static void main ( String [ ] args ) { String s = \"123\" ; System . out . println ( combinedSum ( s ) ) ; } }", "nl": "Driver function"}
{"code": "class GFG { static final int MAX_CHAR = 26 ;", "nl": "Java Program to find the subsequence with each character occurring at least k times in string s"}
{"code": "static void findSubsequence ( String str , int k ) {", "nl": "Function to find the subsequence"}
{"code": "int a [ ] = new int [ MAX_CHAR ] ;", "nl": "Taking an extra array to keep record for character count in s"}
{"code": "for ( int i = 0 ; i < str . length ( ) ; i ++ ) a [ str . charAt ( i ) - ' a ' ] ++ ;", "nl": "Counting occurrences of all characters in str [ ]"}
{"code": "for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( a [ str . charAt ( i ) - ' a ' ] >= k ) System . out . print ( str . charAt ( i ) ) ; }", "nl": "Printing characters with count >= k in same order as they appear in str ."}
{"code": "public static void main ( String [ ] args ) { int k = 2 ; findSubsequence ( \" geeksforgeeks \" , k ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static String convert ( String str ) {", "nl": "Java program to convert a sentence to gOOGLE cASE ."}
{"code": "String w = \" \" , z = \" \" ;", "nl": "empty strings"}
{"code": "str = str . toUpperCase ( ) + \" \u2581 \" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) {", "nl": "convert input string to upper case"}
{"code": "char ch = str . charAt ( i ) ; if ( ch != ' \u2581 ' ) w = w + ch ; else {", "nl": "checki if character is not a space and adding it to string w"}
{"code": "z = z + ( Character . toLowerCase ( w . charAt ( 0 ) ) ) + w . substring ( 1 ) + \" \u2581 \" ; w = \" \" ; } } return z ; }", "nl": "converting first character to lower case and subsequent initial letter of another word to lower case"}
{"code": "public static void main ( String [ ] args ) { String str = \" I \u2581 got \u2581 intern \u2581 at \u2581 geeksforgeeks \" ; System . out . println ( convert ( str ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "JAVA Program to Encrypt String with product of number of vowels and consonants in subString of size k"}
{"code": "static boolean isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; }", "nl": "isVowel ( ) is a function that returns true for a vowel and false otherwise ."}
{"code": "static String encryptString ( char [ ] s , int n , int k ) {", "nl": "function to Encrypt the String"}
{"code": "int [ ] cv = new int [ n ] ; int [ ] cc = new int [ n ] ; if ( isVowel ( s [ 0 ] ) ) cv [ 0 ] = 1 ; else cc [ 0 ] = 1 ;", "nl": "cv to count vowel cc to count consonants"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) { cv [ i ] = cv [ i - 1 ] + ( isVowel ( s [ i ] ) == true ? 1 : 0 ) ; cc [ i ] = cc [ i - 1 ] + ( isVowel ( s [ i ] ) == true ? 0 : 1 ) ; } String ans = \" \" ; int prod = 0 ; prod = cc [ k - 1 ] * cv [ k - 1 ] ; ans += String . valueOf ( prod ) ;", "nl": "Counting prefix count of vowel and prefix count of consonants"}
{"code": "for ( int i = k ; i < s . length ; i ++ ) { prod = ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) ; ans += String . valueOf ( prod ) ; } return ans ; }", "nl": "generating the encrypted String ."}
{"code": "public static void main ( String [ ] args ) { String s = \" hello \" ; int n = s . length ( ) ; int k = 2 ; System . out . print ( encryptString ( s . toCharArray ( ) , n , k ) + \"NEW_LINE\"); } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG { static int countOccurrences ( String str , String word ) {", "nl": "Java program to count the number of occurrence of a word in the given string"}
{"code": "String a [ ] = str . split ( \" \u2581 \" ) ;", "nl": "split the string by spaces in a"}
{"code": "int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) {", "nl": "search for pattern in a"}
{"code": "if ( word . equals ( a [ i ] ) ) count ++ ; } return count ; }", "nl": "if match found increase count"}
{"code": "public static void main ( String args [ ] ) { String str = \" GeeksforGeeks \u2581 A \u2581 computer \u2581 science \u2581 portal \u2581 for \u2581 geeks \u2581 \" ; String word = \" portal \" ; System . out . println ( countOccurrences ( str , word ) ) ; } }", "nl": "Driver code"}
{"code": "class initials { static void printInitials ( String name ) { if ( name . length ( ) == 0 ) return ;", "nl": "Java program to print initials of a name"}
{"code": "String words [ ] = name . split ( \" \u2581 \" ) ; for ( String word : words ) { System . out . print ( Character . toUpperCase ( word . charAt ( 0 ) ) + \" \u2581 \" ) ; } }", "nl": "split the string using ' space ' and print the first character of every word"}
{"code": "public static void main ( String args [ ] ) { String name = \" prabhat \u2581 kumar \u2581 singh \" ; printInitials ( name ) ; } }", "nl": "Driver code"}
{"code": "public class PermuteString {", "nl": "Java program to print all permutations with respect to cases"}
{"code": "static void permute ( String input ) { int n = input . length ( ) ;", "nl": "Function to generate permutations"}
{"code": "int max = 1 << n ;", "nl": "Number of permutations is 2 ^ n"}
{"code": "input = input . toLowerCase ( ) ;", "nl": "Converting string to lower case"}
{"code": "for ( int i = 0 ; i < max ; i ++ ) { char combination [ ] = input . toCharArray ( ) ;", "nl": "Using all subsequences and permuting them"}
{"code": "for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = ( char ) ( combination [ j ] - 32 ) ; }", "nl": "If j - th bit is set , we convert it to upper case"}
{"code": "System . out . print ( combination ) ; System . out . print ( \" \u2581 \" ) ; } }", "nl": "Printing current combination"}
{"code": "public static void main ( String [ ] args ) { permute ( \" ABC \" ) ; } }", "nl": "Driver Program to test above function"}
{"code": "public class GFG {", "nl": "Java program for above implementation"}
{"code": "static void printString ( String str , char ch , int count ) { int occ = 0 , i ;", "nl": "Method to print the string"}
{"code": "if ( count == 0 ) { System . out . println ( str ) ; return ; }", "nl": "If given count is 0 print the given string and return"}
{"code": "for ( i = 0 ; i < str . length ( ) ; i ++ ) {", "nl": "Start traversing the string"}
{"code": "if ( str . charAt ( i ) == ch ) occ ++ ;", "nl": "Increment occ if current char is equal to given character"}
{"code": "if ( occ == count ) break ; }", "nl": "Break the loop if given character has been occurred given no . of times"}
{"code": "if ( i < str . length ( ) - 1 ) System . out . println ( str . substring ( i + 1 ) ) ;", "nl": "Print the string after the occurrence of given character given no . of times"}
{"code": "else System . out . println ( \" Empty \u2581 string \" ) ; }", "nl": "Otherwise string is empty"}
{"code": "public static void main ( String [ ] args ) { String str = \" geeks \u2581 for \u2581 geeks \" ; printString ( str , ' e ' , 2 ) ; } }", "nl": "Driver Method"}
{"code": "class GFG {", "nl": "Java program to reverse order of vowels"}
{"code": "static boolean isVowel ( char c ) { return ( c == ' a ' c == ' A ' c == ' e ' c == ' E ' c == ' i ' c == ' I ' c == ' o ' c == ' O ' c == ' u ' c == ' U ' ) ; }", "nl": "utility function to check for vowel"}
{"code": "static String reverseVowel ( String str ) {", "nl": "Function to reverse order of vowels"}
{"code": "int i = 0 ; int j = str . length ( ) - 1 ; char [ ] str1 = str . toCharArray ( ) ; while ( i < j ) { if ( ! isVowel ( str1 [ i ] ) ) { i ++ ; continue ; } if ( ! isVowel ( str1 [ j ] ) ) { j -- ; continue ; }", "nl": "Start two indexes from two corners and move toward each other"}
{"code": "char t = str1 [ i ] ; str1 [ i ] = str1 [ j ] ; str1 [ j ] = t ; i ++ ; j -- ; } String str2 = String . copyValueOf ( str1 ) ; return str2 ; }", "nl": "swapping"}
{"code": "public static void main ( String [ ] args ) { String str = \" hello \u2581 world \" ; System . out . println ( reverseVowel ( str ) ) ; } }", "nl": "Driver function"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to count minimum palindromic subsequences to be removed to make an string empty ."}
{"code": "static boolean isPalindrome ( String str ) {", "nl": "A function to check if a string str is palindrome"}
{"code": "int l = 0 ; int h = str . length ( ) - 1 ;", "nl": "Start from leftmost and rightmost corners of str"}
{"code": "while ( h > l ) if ( str . charAt ( l ++ ) != str . charAt ( h -- ) ) return false ; return true ; }", "nl": "Keep comparing characters while they are same"}
{"code": "static int minRemovals ( String str ) {", "nl": "Returns count of minimum palindromic subseuqnces to be removed to make string empty"}
{"code": "if ( str . charAt ( 0 ) == '') return 0 ;", "nl": "If string is empty"}
{"code": "if ( isPalindrome ( str ) ) return 1 ;", "nl": "If string is palindrome"}
{"code": "return 2 ; }", "nl": "If string is not palindrome"}
{"code": "public static void main ( String [ ] args ) { System . out . println ( minRemovals ( \"010010\" ) ) ; System . out . println ( minRemovals ( \"0100101\" ) ) ; } }", "nl": "Driver code to test above"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int power ( int x , int y , int p ) {", "nl": "Iterative function to calculate ( x ^ y ) % p in O ( log y )"}
{"code": "int res = 1 ;", "nl": "Initialize result"}
{"code": "x = x % p ; while ( y > 0 ) {", "nl": "Update x if it is >= p"}
{"code": "if ( y % 2 == 1 ) res = ( res * x ) % p ;", "nl": "If y is odd , multiply x with result"}
{"code": "y = y >> 1 ; x = ( x * x ) % p ; } return res ; }", "nl": "y must be even now y = y / 2"}
{"code": "static int findModuloByM ( int X , int N , int M ) {", "nl": "Function to return XXX ... . . ( N times ) % M"}
{"code": "if ( N < 6 ) {", "nl": "Return the mod by M of smaller numbers"}
{"code": "String temp = \" \" ; for ( int i = 0 ; i < N ; i ++ ) temp = temp + ( char ) ( X + 48 ) ;", "nl": "Creating a string of N X 's"}
{"code": "int res = Integer . parseInt ( temp ) % M ; return res ; }", "nl": "Converting the string to int and calculating the modulo"}
{"code": "if ( N % 2 == 0 ) {", "nl": "Checking the parity of N"}
{"code": "int half = findModuloByM ( X , N / 2 , M ) % M ;", "nl": "Dividing the number into equal half"}
{"code": "int res = ( half * power ( 10 , N / 2 , M ) + half ) % M ; return res ; } else {", "nl": "Utilizing the formula for even N"}
{"code": "int half = findModuloByM ( X , N / 2 , M ) % M ;", "nl": "Dividing the number into equal half"}
{"code": "int res = ( half * power ( 10 , N / 2 + 1 , M ) + half * 10 + X ) % M ; return res ; } }", "nl": "Utilizing the formula for odd N"}
{"code": "public static void main ( String [ ] args ) { int X = 6 , N = 14 , M = 9 ;", "nl": "Driver code"}
{"code": "System . out . println ( findModuloByM ( X , N , M ) ) ; } }", "nl": "Print XXX ... ( N times ) % M"}
{"code": "class GFG {", "nl": "Java approach for the above approach"}
{"code": "static class circle { double x ; double y ; double r ; public circle ( int x , int y , int r ) { this . x = x ; this . y = y ; this . r = r ; } }", "nl": "Structure of the circle"}
{"code": "static boolean check ( circle C [ ] ) {", "nl": "Utility function to check if given circles satisfy required criteria"}
{"code": "double C1C2 = Math . sqrt ( ( C [ 1 ] . x - C [ 0 ] . x ) * ( C [ 1 ] . x - C [ 0 ] . x ) + ( C [ 1 ] . y - C [ 0 ] . y ) * ( C [ 1 ] . y - C [ 0 ] . y ) ) ;", "nl": "Stores the distance between the centres of C1 and C2"}
{"code": "boolean flag = false ;", "nl": "Stores the status if the given given criteria is satisfied or not"}
{"code": "if ( C1C2 < ( C [ 0 ] . r + C [ 1 ] . r ) ) {", "nl": "If C1C2 is less than the sum of the radii of the first 2 circles"}
{"code": "if ( ( C [ 0 ] . x + C [ 1 ] . x ) == 2 * C [ 2 ] . x && ( C [ 0 ] . y + C [ 1 ] . y ) == 2 * C [ 2 ] . y ) {", "nl": "If C3 is the midpoint of the centres at C1 and C2"}
{"code": "flag = true ; } }", "nl": "Mark flag true"}
{"code": "return flag ; }", "nl": "Return flag"}
{"code": "static boolean IsFairTriplet ( circle c [ ] ) { boolean f = false ;", "nl": "Function to check if the given circles satisfy required criteria"}
{"code": "f |= check ( c ) ; for ( int i = 0 ; i < 2 ; i ++ ) { swap ( c [ 0 ] , c [ 2 ] ) ;", "nl": "Check for the current combination of circles"}
{"code": "f |= check ( c ) ; } return f ; } static void swap ( circle circle1 , circle circle2 ) { circle temp = circle1 ; circle1 = circle2 ; circle2 = temp ; }", "nl": "Check for the next combination"}
{"code": "public static void main ( String [ ] args ) { circle C [ ] = new circle [ 3 ] ; C [ 0 ] = new circle ( 0 , 0 , 8 ) ; C [ 1 ] = new circle ( 0 , 10 , 6 ) ; C [ 2 ] = new circle ( 0 , 5 , 5 ) ; if ( IsFairTriplet ( C ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static double eccHyperbola ( double A , double B ) {", "nl": "Function to find the eccentricity of a hyperbola"}
{"code": "double r = ( double ) B * B / A * A ;", "nl": "Stores the squared ratio of major axis to minor axis"}
{"code": "r += 1 ;", "nl": "Increment r by 1"}
{"code": "return Math . sqrt ( r ) ; }", "nl": "Return the square root of r"}
{"code": "public static void main ( String [ ] args ) { double A = 3.0 , B = 2.0 ; System . out . print ( eccHyperbola ( A , B ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static float calculateArea ( float A , float B , float C , float D ) {", "nl": "Function to find the area of cyclic quadrilateral"}
{"code": "float S = ( A + B + C + D ) / 2 ;", "nl": "Stores the value of half of the perimeter"}
{"code": "float area = ( float ) Math . sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ;", "nl": "Stores area of cyclic quadrilateral"}
{"code": "return area ; }", "nl": "Return the resultant area"}
{"code": "public static void main ( String [ ] args ) { float A = 10 ; float B = 15 ; float C = 20 ; float D = 25 ; System . out . println ( calculateArea ( A , B , C , D ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static void triangleArea ( int a , int b ) {", "nl": "Function to calculate ratio of a triangle inscribed in an ellipse to the triangle on the auxiliary circle"}
{"code": "double ratio = ( double ) b / a ;", "nl": "Stores the ratio of the semi - major to semi - minor axes"}
{"code": "System . out . println ( ratio ) ; }", "nl": "Print the ratio"}
{"code": "public static void main ( String args [ ] ) { int a = 1 , b = 2 ; triangleArea ( a , b ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static class pair { float first , second ; pair ( float first , float second ) { this . first = first ; this . second = second ; } }", "nl": "Java program for the above approach"}
{"code": "static float distance ( int m , int n , int p , int q ) { return ( float ) Math . sqrt ( Math . pow ( n - m , 2 ) + Math . pow ( q - p , 2 ) * 1.0 ) ; }", "nl": "Function to calculate the distance between a pair of points"}
{"code": "static void Excenters ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) {", "nl": "Function to calculate the coordinates of the excenters of a triangle"}
{"code": "float a = distance ( x2 , x3 , y2 , y3 ) ; float b = distance ( x3 , x1 , y3 , y1 ) ; float c = distance ( x1 , x2 , y1 , y2 ) ;", "nl": "Length of the sides of the triangle"}
{"code": "pair [ ] excenter = new pair [ 4 ] ;", "nl": "Stores the coordinates of the excenters of the triangle"}
{"code": "excenter [ 1 ] = new pair ( ( - ( a * x1 ) + ( b * x2 ) + ( c * x3 ) ) / ( - a + b + c ) , ( - ( a * y1 ) + ( b * y2 ) + ( c * y3 ) ) / ( - a + b + c ) ) ;", "nl": "For I1"}
{"code": "excenter [ 2 ] = new pair ( ( ( a * x1 ) - ( b * x2 ) + ( c * x3 ) ) / ( a - b + c ) , ( ( a * y1 ) - ( b * y2 ) + ( c * y3 ) ) / ( a - b + c ) ) ;", "nl": "For I2"}
{"code": "excenter [ 3 ] = new pair ( ( ( a * x1 ) + ( b * x2 ) - ( c * x3 ) ) / ( a + b - c ) , ( ( a * y1 ) + ( b * y2 ) - ( c * y3 ) ) / ( a + b - c ) ) ;", "nl": "For I3"}
{"code": "for ( int i = 1 ; i <= 3 ; i ++ ) { System . out . println ( ( int ) excenter [ i ] . first + \" \u2581 \" + ( int ) excenter [ i ] . second ) ; } }", "nl": "Print the excenters of the triangle"}
{"code": "public static void main ( String [ ] args ) { int x1 , x2 , x3 , y1 , y2 , y3 ; x1 = 0 ; x2 = 3 ; x3 = 0 ; y1 = 0 ; y2 = 0 ; y3 = 4 ; Excenters ( x1 , y1 , x2 , y2 , x3 , y3 ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void findHeight ( float p1 , float p2 , float b , float c ) { float a = Math . max ( p1 , p2 ) - Math . min ( p1 , p2 ) ;", "nl": "Function to calculate height of the trapezoid"}
{"code": "float s = ( a + b + c ) / 2 ;", "nl": "Apply Heron 's formula"}
{"code": "float area = ( int ) Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ;", "nl": "Calculate the area"}
{"code": "float height = ( area * 2 ) / a ;", "nl": "Calculate height of trapezoid"}
{"code": "System . out . print ( \" Height \u2581 is : \u2581 \" + height ) ; }", "nl": "Print the height"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "float p1 = 25 , p2 = 10 ; float a = 14 , b = 13 ; findHeight ( p1 , p2 , a , b ) ; } }", "nl": "Given a , b , p1 and p2"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find nth icositetragonal number"}
{"code": "static int Icositetragonal_num ( int n ) {", "nl": "Function to find icositetragonal number"}
{"code": "return ( 22 * n * n - 20 * n ) / 2 ; }", "nl": "Formula to calculate nth icositetragonal number"}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( Icositetragonal_num ( n ) ) ; n = 10 ; System . out . println ( Icositetragonal_num ( n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java Program to find the rea of the circle inscribed in a trapezoid having non - parallel sides m , n"}
{"code": "static double area_of_circle ( int m , int n ) {", "nl": "Function to find area of circle inscribed in a trapezoid having non - parallel sides m , n"}
{"code": "int square_of_radius = ( m * n ) / 4 ; double area = ( 3.141 * square_of_radius ) ; return area ; }", "nl": "radius of circle by the formula i . e . root ( m * n ) / 2 area of circle = ( 3.141 ) * ( R * * 2 )"}
{"code": "public static void main ( String [ ] args ) { int n = 10 ; int m = 30 ; System . out . println ( area_of_circle ( m , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation to find the area of the equilateral triangle inscribed in a circle of radius R"}
{"code": "static double area ( int R ) {", "nl": "Function to find the area of equilateral triangle inscribed in a circle of radius R"}
{"code": "double base = 1.732 * R ; double height = ( 1.5 ) * R ;", "nl": "Base and Height of equilateral triangle"}
{"code": "double area = 0.5 * base * height ; return area ; }", "nl": "Area using Base and Height"}
{"code": "public static void main ( String [ ] args ) { int R = 7 ; System . out . println ( area ( R ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java Program to find the biggest circle which can be inscribed within the semicircle"}
{"code": "static float circlearea ( float R ) {", "nl": "Function to find the area of the circle"}
{"code": "if ( R < 0 ) return - 1 ;", "nl": "Radius cannot be negative"}
{"code": "float a = ( float ) ( ( 3.14 * R * R ) / 4 ) ; return a ; }", "nl": "Area of the largest circle"}
{"code": "public static void main ( String [ ] args ) { float R = 2 ; System . out . println ( circlearea ( R ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to Number of pairs of lines having integer intersection points"}
{"code": "static int countPairs ( int [ ] P , int [ ] Q , int N , int M ) {", "nl": "Count number of pairs of lines having integer intersection point"}
{"code": "int [ ] A = new int [ 2 ] , B = new int [ 2 ] ;", "nl": "Initialize arrays to store counts"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ;", "nl": "Count number of odd and even Pi"}
{"code": "for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ;", "nl": "Count number of odd and even Qi"}
{"code": "return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; }", "nl": "Return the count of pairs"}
{"code": "public static void main ( String [ ] args ) { int [ ] P = { 1 , 3 , 2 } ; int [ ] Q = { 3 , 0 } ; int N = P . length ; int M = Q . length ; System . out . print ( countPairs ( P , Q , N , M ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; }", "nl": "Function to count maximum number of intersections possible"}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countIntersections ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "public class GFG { static double PI = 3.14159 ;", "nl": "Java implementation of above approach"}
{"code": "static double areaOfTriangle ( float d ) {", "nl": "Function to return the area of triangle BCD"}
{"code": "float c = ( float ) ( 1.618 * d ) ; float s = ( d + c + c ) / 2 ;", "nl": "Using Golden ratio"}
{"code": "double area = Math . sqrt ( s * ( s - c ) * ( s - c ) * ( s - d ) ) ;", "nl": "Calculate area of triangle BCD"}
{"code": "return 5 * area ; }", "nl": "Return area of all 5 triangle are same"}
{"code": "static double areaOfRegPentagon ( float d ) {", "nl": "Function to return the area of regular pentagon"}
{"code": "double cal = 4 * Math . tan ( PI / 5 ) ; double area = ( 5 * d * d ) / cal ;", "nl": "Calculate the area of regular pentagon using above formula"}
{"code": "return area ; }", "nl": "Return area of regular pentagon"}
{"code": "static double areaOfPentagram ( float d ) {", "nl": "Function to return the area of pentagram"}
{"code": "return areaOfRegPentagon ( d ) + areaOfTriangle ( d ) ; }", "nl": "Area of a pentagram is equal to the area of regular pentagon and five times the area of Triangle"}
{"code": "public static void main ( String [ ] args ) { float d = 5 ; System . out . println ( areaOfPentagram ( d ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static void anglequichord ( int z ) { System . out . println ( \" The \u2581 angle \u2581 is \u2581 \" + z + \" \u2581 degrees \" ) ; }", "nl": "Java program to find the angle subtended by the chord to the centre of the circle when the angle subtended by another equal chord of a congruent circle is given"}
{"code": "public static void main ( String [ ] args ) { int z = 48 ; anglequichord ( z ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to convert the digits of a number to its ASCII values"}
{"code": "static void convertToASCII ( int N ) { String num = Integer . toString ( N ) ; for ( char ch : num . toCharArray ( ) ) { System . out . print ( ch + \" \u2581 ( \" + ( int ) ch + \")NEW_LINE\"); } }", "nl": "Function to convert digits of N to respective ASCII values"}
{"code": "public static void main ( String [ ] args ) { int N = 36 ; convertToASCII ( N ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void productExceptSelf ( int arr [ ] , int N ) {", "nl": "Function to form product array with O ( n ) time and O ( 1 ) space"}
{"code": "int product = 1 ;", "nl": "Stores the product of array"}
{"code": "int z = 0 ;", "nl": "Stores the count of zeros"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array"}
{"code": "if ( arr [ i ] != 0 ) product *= arr [ i ] ;", "nl": "If arr [ i ] is not zero"}
{"code": "if ( arr [ i ] == 0 ) z += 1 ; }", "nl": "If arr [ i ] is zero then increment count of z by 1"}
{"code": "int a = Math . abs ( product ) ; for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Stores the absolute value of the product"}
{"code": "if ( z == 1 ) {", "nl": "If Z is equal to 1"}
{"code": "if ( arr [ i ] != 0 ) arr [ i ] = 0 ;", "nl": "If arr [ i ] is not zero"}
{"code": "else arr [ i ] = product ; continue ; }", "nl": "Else"}
{"code": "else if ( z > 1 ) {", "nl": "If count of 0 s at least 2"}
{"code": "arr [ i ] = 0 ; continue ; }", "nl": "Assign arr [ i ] = 0"}
{"code": "int b = Math . abs ( arr [ i ] ) ;", "nl": "Store absolute value of arr [ i ]"}
{"code": "int curr = ( int ) Math . round ( Math . exp ( Math . log ( a ) - Math . log ( b ) ) ) ;", "nl": "Find the value of a / b"}
{"code": "if ( arr [ i ] < 0 && product < 0 ) arr [ i ] = curr ;", "nl": "If arr [ i ] and product both are less than zero"}
{"code": "else if ( arr [ i ] > 0 && product > 0 ) arr [ i ] = curr ;", "nl": "If arr [ i ] and product both are greater than zero"}
{"code": "else arr [ i ] = - 1 * curr ; }", "nl": "Else"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }", "nl": "Traverse the array arr [ ]"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 10 , 3 , 5 , 6 , 2 } ; int N = arr . length ;", "nl": "Driver Code"}
{"code": "productExceptSelf ( arr , N ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static void singleDigitSubarrayCount ( int arr [ ] , int N ) {", "nl": "Function to count of subarrays made up of single digit integers only"}
{"code": "int res = 0 ;", "nl": "Stores count of subarrays"}
{"code": "int count = 0 ;", "nl": "Stores the count of consecutive single digit numbers in the array"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) {", "nl": "Traverse the array"}
{"code": "count ++ ;", "nl": "Increment size of block by 1"}
{"code": "res += count ; } else {", "nl": "Increment res by count"}
{"code": "count = 0 ; } } System . out . print ( res ) ; }", "nl": "Assign count = 0"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 0 , 1 , 14 , 2 , 5 } ;", "nl": "Given array"}
{"code": "int N = arr . length ; singleDigitSubarrayCount ( arr , N ) ; } }", "nl": "Size of the array"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program of the above approach"}
{"code": "static int isPossible ( int N ) { return ( ( ( N & ( N - 1 ) ) & N ) ) ; }", "nl": "Function to check if the number N can be expressed as sum of 2 or more consecutive numbers or not"}
{"code": "static void countElements ( int N ) {", "nl": "Function to count integers in the range [ 1 , N ] that can be expressed as sum of 2 or more consecutive numbers"}
{"code": "int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isPossible ( i ) != 0 ) count ++ ; } System . out . println ( count ) ; }", "nl": "Stores the required count"}
{"code": "public static void main ( String [ ] args ) { int N = 15 ; countElements ( N ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static void countElements ( int N ) { int Cur_Ele = 1 ; int Count = 0 ;", "nl": "Function to count integers in the range [ 1 , N ] that can be expressed as sum of 2 or more consecutive numbers"}
{"code": "while ( Cur_Ele <= N ) {", "nl": "Count powers of 2 up to N"}
{"code": "Count ++ ;", "nl": "Increment count"}
{"code": "Cur_Ele = Cur_Ele * 2 ; } System . out . print ( N - Count ) ; }", "nl": "Update current power of 2"}
{"code": "public static void main ( String [ ] args ) { int N = 15 ; countElements ( N ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void maxAdjacent ( int [ ] arr , int N ) { Vector < Integer > res = new Vector < Integer > ( ) ; int arr_max = Integer . MIN_VALUE ;", "nl": "Function to calculate maximum difference between adjacent elements excluding every array element once"}
{"code": "for ( int i = 1 ; i < N ; i ++ ) { arr_max = Math . max ( arr_max , Math . abs ( arr [ i - 1 ] - arr [ i ] ) ) ; } for ( int i = 1 ; i < N - 1 ; i ++ ) { int curr_max = Math . abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ;", "nl": "Compute maximum adjacent difference for whole array"}
{"code": "int ans = Math . max ( curr_max , arr_max ) ;", "nl": "Store the maximum between arr_max and curr_max"}
{"code": "res . add ( ans ) ; }", "nl": "Append the result into a vector"}
{"code": "for ( int x : res ) System . out . print ( x + \" \u2581 \" ) ; System . out . println ( ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 7 , 8 } ; int N = arr . length ; maxAdjacent ( arr , N ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; import java . lang . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int minimumIncrement ( int arr [ ] , int N ) {", "nl": "Function to find min operations to make even and odd count equal"}
{"code": "if ( N % 2 != 0 ) { System . out . println ( \" - 1\" ) ; System . exit ( 0 ) ; }", "nl": "Odd size will never make odd and even counts equal"}
{"code": "int cntEven = 0 ;", "nl": "Stores the count of even numbers in the array arr [ ]"}
{"code": "int cntOdd = 0 ;", "nl": "Stores count of odd numbers in the array arr [ ]"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array arr [ ]"}
{"code": "if ( arr [ i ] % 2 == 0 ) {", "nl": "If arr [ i ] is an even number"}
{"code": "cntEven += 1 ; } }", "nl": "Update cntEven"}
{"code": "cntOdd = N - cntEven ;", "nl": "Odd numbers in arr [ ]"}
{"code": "return Math . abs ( cntEven - cntOdd ) / 2 ; }", "nl": "Return absolute difference divided by 2"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 9 } ; int N = arr . length ;", "nl": "Driver code"}
{"code": "System . out . println ( minimumIncrement ( arr , N ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java Program to implement the above approach"}
{"code": "static void cntWaysConsArray ( int A [ ] , int N ) {", "nl": "Function to find count the ways to construct an array , B [ ] such that abs ( A [ i ] - B [ i ] ) <= 1 and product of elements of B [ ] is even"}
{"code": "int total = 1 ;", "nl": "Stores count of arrays B [ ] such that abs ( A [ i ] - B [ i ] ) <= 1"}
{"code": "int oddArray = 1 ;", "nl": "Stores count of arrays B [ ] whose product of elements is not even"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array"}
{"code": "total = total * 3 ;", "nl": "Update total"}
{"code": "if ( A [ i ] % 2 == 0 ) {", "nl": "If A [ i ] is an even number"}
{"code": "oddArray *= 2 ; } }", "nl": "Update oddArray"}
{"code": "System . out . println ( total - oddArray ) ; }", "nl": "Print 3 ^ N - 2 ^ X"}
{"code": "public static void main ( String [ ] args ) { int A [ ] = { 2 , 4 } ; int N = A . length ; cntWaysConsArray ( A , N ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . Arrays ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void countNumberHavingKthBitSet ( int N , int K ) {", "nl": "Function to count the numbers in the range [ 1 , N ] whose rightmost set bit is K"}
{"code": "int numbers_rightmost_setbit_K = 0 ; for ( int i = 1 ; i <= K ; i ++ ) {", "nl": "Stores the number whose rightmost set bit is K"}
{"code": "int numbers_rightmost_bit_i = ( N + 1 ) / 2 ;", "nl": "Numbers whose rightmost set bit is i"}
{"code": "N -= numbers_rightmost_bit_i ;", "nl": "Subtracting the number whose rightmost set bit is i , from N"}
{"code": "if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } System . out . println ( numbers_rightmost_setbit_K ) ; }", "nl": "Since i = k , then the number whose rightmost set bit is K is stored"}
{"code": "static public void main ( String args [ ] ) { int N = 15 ; int K = 2 ; countNumberHavingKthBitSet ( N , K ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int countSetBits ( int N ) { int count = 0 ;", "nl": "Function to count set bits in binary representation of number N"}
{"code": "while ( N != 0 ) { N = N & ( N - 1 ) ; count ++ ; }", "nl": "Count set bits in N"}
{"code": "return count ; }", "nl": "Return the final count"}
{"code": "public static void main ( String [ ] args ) { int N = 4 ; int bits = countSetBits ( N ) ;", "nl": "Driver code"}
{"code": "System . out . println ( \" Odd \u2581 \" + \" : \u2581 \" + ( int ) ( Math . pow ( 2 , bits ) ) ) ;", "nl": "Print odd Binomial coefficients"}
{"code": "System . out . println ( \" Even \u2581 \" + \" : \u2581 \" + ( N + 1 - ( int ) ( Math . pow ( 2 , bits ) ) ) ) ; } }", "nl": "Print even Binomial coefficients"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void minMoves ( int arr [ ] , int N ) {", "nl": "Function to find the minimum number of replacements required to make all array elements even"}
{"code": "int odd_element_cnt = 0 ;", "nl": "Stores the count of odd elements"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array"}
{"code": "if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } }", "nl": "Increase count of odd elements"}
{"code": "int moves = ( odd_element_cnt ) / 2 ;", "nl": "Store number of replacements required"}
{"code": "if ( odd_element_cnt % 2 != 0 ) moves += 2 ;", "nl": "Two extra moves will be required to make the last odd element even"}
{"code": "System . out . print ( moves ) ; }", "nl": "Print the minimum replacements"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 3 , 7 , 20 } ; int N = arr . length ;", "nl": "Driver Code"}
{"code": "minMoves ( arr , N ) ; } }", "nl": "Function call"}
{"code": "import java . util . Arrays ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void minimumSubsetDifference ( int N ) {", "nl": "Function to partition squares of N natural number in two subset"}
{"code": "int blockOfSize8 = N / 8 ;", "nl": "Store the count of blocks of size 8"}
{"code": "String str = \" ABBABAAB \" ;", "nl": "Partition of block of 8 element"}
{"code": "int subsetDifference = 0 ;", "nl": "Store the minimum subset difference"}
{"code": "String partition = \" \" ; while ( blockOfSize8 -- > 0 ) { partition += str ; }", "nl": "Partition of N elements to minimize their subset sum difference"}
{"code": "int A [ ] = new int [ N ] ; int B [ ] = new int [ N ] ; int x = 0 , y = 0 ; for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Store elements of subset A and B"}
{"code": "if ( partition . charAt ( i ) == ' A ' ) { A [ x ++ ] = ( ( i + 1 ) * ( i + 1 ) ) ; }", "nl": "If element is of type A"}
{"code": "else { B [ y ++ ] = ( ( i + 1 ) * ( i + 1 ) ) ; } }", "nl": "If the element is of type B"}
{"code": "System . out . println ( subsetDifference ) ;", "nl": "Print the minimum subset difference"}
{"code": "for ( int i = 0 ; i < x ; i ++ ) System . out . print ( A [ i ] + \" \u2581 \" ) ; System . out . println ( ) ;", "nl": "Print the first subset"}
{"code": "for ( int i = 0 ; i < y ; i ++ ) System . out . print ( B [ i ] + \" \u2581 \" ) ; }", "nl": "Print the second subset"}
{"code": "public static void main ( String [ ] args ) { int N = 8 ;", "nl": "Driver Code"}
{"code": "minimumSubsetDifference ( N ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static void findTheGreatestX ( int P , int Q ) {", "nl": "Function to find the largest number X such that it divides P but is not divisible by Q"}
{"code": "HashMap < Integer , Integer > divisiors = new HashMap < > ( ) ; for ( int i = 2 ; i * i <= Q ; i ++ ) { while ( Q % i == 0 && Q > 1 ) { Q /= i ;", "nl": "Stores the frequency count of of all Prime Factors"}
{"code": "if ( divisiors . containsKey ( i ) ) { divisiors . put ( i , divisiors . get ( i ) + 1 ) ; } else { divisiors . put ( i , 1 ) ; } } }", "nl": "Increment the frequency of the current prime factor"}
{"code": "if ( Q > 1 ) if ( divisiors . containsKey ( Q ) ) { divisiors . put ( Q , divisiors . get ( Q ) + 1 ) ; } else { divisiors . put ( Q , 1 ) ; }", "nl": "If Q is a prime factor"}
{"code": "int ans = 0 ;", "nl": "Stores the desired result"}
{"code": "for ( Map . Entry < Integer , Integer > i : divisiors . entrySet ( ) ) { int frequency = i . getValue ( ) ; int temp = P ;", "nl": "Iterate through all divisors of Q"}
{"code": "int cur = 0 ; while ( temp % i . getKey ( ) == 0 ) { temp /= i . getKey ( ) ;", "nl": "Stores the frequency count of current prime divisor on dividing P"}
{"code": "cur ++ ; }", "nl": "Count the frequency of the current prime factor"}
{"code": "if ( cur < frequency ) { ans = P ; break ; } temp = P ;", "nl": "If cur is less than frequency then P is the final result"}
{"code": "for ( int j = cur ; j >= frequency ; j -- ) { temp /= i . getKey ( ) ; }", "nl": "Iterate to get temporary answer"}
{"code": "ans = Math . max ( temp , ans ) ; }", "nl": "Update current answer"}
{"code": "System . out . print ( ans ) ; }", "nl": "Print the desired result"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int P = 10 , Q = 4 ;", "nl": "Given P and Q"}
{"code": "findTheGreatestX ( P , Q ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static String checkRearrangements ( int [ ] [ ] mat , int N , int M ) {", "nl": "Function to check if there is any row where number of unique elements are greater than 1"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( mat [ i ] [ 0 ] != mat [ i ] [ j ] ) { return \" Yes \" ; } } } return \" No \" ; }", "nl": "Iterate over the matrix"}
{"code": "static String nonZeroXor ( int [ ] [ ] mat , int N , int M ) { int res = 0 ;", "nl": "Function to check if it is possible to rearrange mat [ ] [ ] such that XOR of its first column is non - zero"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { res = res ^ mat [ i ] [ 0 ] ; }", "nl": "Find bitwise XOR of the first column of mat [ ] [ ]"}
{"code": "if ( res != 0 ) return \" Yes \" ;", "nl": "If bitwise XOR of the first column of mat [ ] [ ] is non - zero"}
{"code": "else return checkRearrangements ( mat , N , M ) ; }", "nl": "Otherwise check rearrangements"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int [ ] [ ] mat = { { 1 , 1 , 2 } , { 2 , 2 , 2 } , { 3 , 3 , 3 } } ; int N = mat . length ; int M = mat [ 0 ] . length ;", "nl": "Given Matrix mat [ ] [ ]"}
{"code": "System . out . print ( nonZeroXor ( mat , N , M ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG { static final int size_int = 32 ;", "nl": "Java Program to implement the above approach"}
{"code": "static int functionMax ( int arr [ ] , int n ) {", "nl": "Function to maximize the value for the given function and the array elements"}
{"code": "Vector < Integer > [ ] setBit = new Vector [ 32 + 1 ] ; for ( int i = 0 ; i < setBit . length ; i ++ ) setBit [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < size_int ; j ++ ) {", "nl": "Vector array to maintain which bit is set for which integer in the given array by saving index of that integer"}
{"code": "if ( ( arr [ i ] & ( 1 << j ) ) > 0 )", "nl": "Check if j - th bit is set for i - th integer"}
{"code": "setBit [ j ] . add ( i ) ; } }", "nl": "Push the index of that integer in setBit [ j ]"}
{"code": "for ( int i = size_int ; i >= 0 ; i -- ) { if ( setBit [ i ] . size ( ) == 1 ) {", "nl": "Find the element having highest significant set bit unset in other elements"}
{"code": "swap ( arr , 0 , setBit [ i ] . get ( 0 ) ) ; break ; } }", "nl": "Place that integer at 0 - th index"}
{"code": "int maxAnd = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { maxAnd = maxAnd & ( ~ arr [ i ] ) ; }", "nl": "Store the maximum AND value"}
{"code": "return maxAnd ; } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; }", "nl": "Return the answer"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 } ; int n = arr . length ;", "nl": "Driver Code"}
{"code": "System . out . print ( functionMax ( arr , n ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static int nCr ( int n , int r ) {", "nl": "Function returns nCr i . e . Binomial Coefficient"}
{"code": "int res = 1 ;", "nl": "Initialize res with 1"}
{"code": "if ( r > n - r ) r = n - r ;", "nl": "Since C ( n , r ) = C ( n , n - r )"}
{"code": "for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }", "nl": "Evaluating expression"}
{"code": "static int solve ( int n , int m , int k ) {", "nl": "Function to calculate and return the sum of the products"}
{"code": "int sum = 0 ;", "nl": "Initialize sum to 0"}
{"code": "for ( int i = 0 ; i <= k ; i ++ ) sum += nCr ( n , i ) * nCr ( m , k - i ) ; return sum ; }", "nl": "Traverse from 0 to k"}
{"code": "public static void main ( String [ ] args ) { int n = 3 , m = 2 , k = 2 ; System . out . print ( solve ( n , m , k ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int powerOptimised ( int a , int n ) {", "nl": "Function to return a ^ n"}
{"code": "int ans = 1 ; while ( n > 0 ) { int last_bit = ( n & 1 ) ;", "nl": "Stores final answer"}
{"code": "if ( last_bit > 0 ) { ans = ans * a ; } a = a * a ;", "nl": "Check if current LSB is set"}
{"code": "n = n >> 1 ; } return ans ; }", "nl": "Right shift"}
{"code": "public static void main ( String [ ] args ) { int a = 3 , n = 5 ; System . out . print ( powerOptimised ( a , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int findMaximumGcd ( int n ) {", "nl": "Function to find the integer M such that gcd ( N , M ) is maximum"}
{"code": "int max_gcd = 1 ;", "nl": "Initialize a variable"}
{"code": "for ( int i = 1 ; i * i <= n ; i ++ ) {", "nl": "Find all the divisors of N and return the maximum divisor"}
{"code": "if ( n % i == 0 ) {", "nl": "Check if i is divisible by N"}
{"code": "if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } }", "nl": "Update max_gcd"}
{"code": "return max_gcd ; }", "nl": "Return the maximum value"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 10 ;", "nl": "Given Number"}
{"code": "System . out . print ( findMaximumGcd ( N ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG { static final int x = 2000021 ;", "nl": "Java program for the above approach"}
{"code": "static int [ ] v = new int [ x ] ;", "nl": "For storing smallest prime factor"}
{"code": "static void sieve ( ) { v [ 1 ] = 1 ;", "nl": "Function consmallest prime factor array"}
{"code": "for ( int i = 2 ; i < x ; i ++ ) v [ i ] = i ;", "nl": "Mark smallest prime factor for every number to be itself ."}
{"code": "for ( int i = 4 ; i < x ; i += 2 ) v [ i ] = 2 ; for ( int i = 3 ; i * i < x ; i ++ ) {", "nl": "Separately mark spf for every even number as 2"}
{"code": "if ( v [ i ] == i ) {", "nl": "Check if i is prime"}
{"code": "for ( int j = i * i ; j < x ; j += i ) {", "nl": "Mark SPF for all numbers divisible by i"}
{"code": "if ( v [ j ] == j ) { v [ j ] = i ; } } } } }", "nl": "Mark spf [ j ] if it is not previously marked"}
{"code": "static int prime_factors ( int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; while ( n != 1 ) { s . add ( v [ n ] ) ; n = n / v [ n ] ; } return s . size ( ) ; }", "nl": "Function for counts total number of prime factors"}
{"code": "static void distinctPrimes ( int m , int k ) {", "nl": "Function to print elements of sets of K consecutive elements having K prime factors"}
{"code": "Vector < Integer > result = new Vector < Integer > ( ) ; for ( int i = 14 ; i < m + k ; i ++ ) {", "nl": "To store the result"}
{"code": "long count = prime_factors ( i ) ;", "nl": "Count number of prime factors of number"}
{"code": "if ( count == k ) { result . add ( i ) ; } } int p = result . size ( ) ; for ( int index = 0 ; index < p - 1 ; index ++ ) { long element = result . get ( index ) ; int count = 1 , z = index ;", "nl": "If number has exactly K factors push in result [ ]"}
{"code": "while ( z < p - 1 && count <= k && result . get ( z ) + 1 == result . get ( z + 1 ) ) {", "nl": "Iterate till we get K consecutive elements in result [ ]"}
{"code": "count ++ ; z ++ ; }", "nl": "Count sequence until K"}
{"code": "if ( count >= k ) System . out . print ( element + \" \u2581 \" ) ; } }", "nl": "Print the element if count >= K"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "sieve ( ) ;", "nl": "To construct spf [ ]"}
{"code": "int N = 1000 , K = 3 ;", "nl": "Given N and K"}
{"code": "distinctPrimes ( N , K ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static void print_product ( int a , int b , int c , int d ) {", "nl": "Function to multiply Complex Numbers with just three multiplications"}
{"code": "int prod1 = a * c ; int prod2 = b * d ; int prod3 = ( a + b ) * ( c + d ) ;", "nl": "Find value of prod1 , prod2 and prod3"}
{"code": "int real = prod1 - prod2 ;", "nl": "Real Part"}
{"code": "int imag = prod3 - ( prod1 + prod2 ) ;", "nl": "Imaginary Part"}
{"code": "System . out . println ( real + \" \u2581 + \u2581 \" + imag + \" i \" ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int a = 2 ; int b = 3 ; int c = 4 ; int d = 5 ;", "nl": "Given four numbers"}
{"code": "print_product ( a , b , c , d ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java implementation for the above approach"}
{"code": "static boolean isInsolite ( int n ) { int N = n ;", "nl": "Function to check if a number is an Insolite numbers"}
{"code": "int sum = 0 ;", "nl": "To store sum of squares of digits"}
{"code": "int product = 1 ; while ( n != 0 ) {", "nl": "To store product of squares of digits"}
{"code": "int r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = n / 10 ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; }", "nl": "extracting digit"}
{"code": "public static void main ( String [ ] args ) { int N = 111 ;", "nl": "Driver Code"}
{"code": "if ( isInsolite ( N ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java implementation to check if a number is Superabundant"}
{"code": "static int sigma ( int n ) { if ( n == 1 ) return 1 ;", "nl": "Function to calculate the sum of all divisors of a given number"}
{"code": "int result = 0 ;", "nl": "Sum of divisors"}
{"code": "for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) {", "nl": "Find all divisors which divides ' num '"}
{"code": "if ( n % i == 0 ) {", "nl": "If ' i ' is divisor of ' n '"}
{"code": "if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } }", "nl": "If both divisors are same then add it once else add both"}
{"code": "return ( result + n + 1 ) ; }", "nl": "Add 1 and n to result as above loop considers proper divisors greater than 1."}
{"code": "static boolean isSuperabundant ( int N ) {", "nl": "Function to check if N is a superabundant number"}
{"code": "for ( double i = 1 ; i < N ; i ++ ) { double x = sigma ( ( int ) ( i ) ) / i ; double y = sigma ( ( int ) ( N ) ) / ( N * 1.0 ) ; if ( x > y ) return false ; } return true ; }", "nl": "To check all numbers from 1 to N"}
{"code": "public static void main ( String [ ] args ) { int N = 4 ; if ( isSuperabundant ( N ) ) System . out . print ( \"YesNEW_LINE\"); else System . out . print ( \"NoNEW_LINE\"); } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation for the above approach"}
{"code": "static boolean isDNum ( int n ) {", "nl": "Function to find the N - th icosikaipentagon number"}
{"code": "if ( n < 4 ) return false ; int numerator = 0 , hcf = 0 ;", "nl": "Number should be greater than 3"}
{"code": "for ( int k = 2 ; k <= n ; k ++ ) { numerator = ( int ) ( Math . pow ( k , n - 2 ) - k ) ; hcf = __gcd ( n , k ) ; }", "nl": "Check every k in range 2 to n - 1"}
{"code": "if ( hcf == 1 && ( numerator % n ) != 0 ) return false ; return true ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; }", "nl": "Condition for D - Number"}
{"code": "public static void main ( String [ ] args ) { int n = 15 ; boolean a = isDNum ( n ) ; if ( a ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static int Sum ( int N ) { int SumOfPrimeDivisors [ ] = new int [ N + 1 ] ; for ( int i = 2 ; i <= N ; ++ i ) {", "nl": "Function to find prime divisors of all numbers from 1 to N"}
{"code": "if ( SumOfPrimeDivisors [ i ] == 1 ) {", "nl": "if the number is prime"}
{"code": "for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; }", "nl": "add this prime to all it 's multiples"}
{"code": "static boolean RuthAaronNumber ( int n ) { if ( Sum ( n ) == Sum ( n + 1 ) ) return true ; else return false ; }", "nl": "Function to check Ruth - Aaron number"}
{"code": "public static void main ( String [ ] args ) { int N = 714 ; if ( RuthAaronNumber ( N ) ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to maximize the sum of absolute differences between adjacent elements"}
{"code": "static int maxAdjacentDifference ( int N , int K ) {", "nl": "Function for maximising the sum"}
{"code": "if ( N == 1 ) { return 0 ; }", "nl": "Difference is 0 when only one element is present in array"}
{"code": "if ( N == 2 ) { return K ; }", "nl": "Difference is K when two elements are present in array"}
{"code": "return 2 * K ; }", "nl": "Otherwise"}
{"code": "public static void main ( String [ ] args ) { int N = 6 ; int K = 11 ; System . out . print ( maxAdjacentDifference ( N , K ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static final int mod = 1000000007 ;", "nl": "Java program for the above approach"}
{"code": "public static int linearSum ( int n ) { return ( n * ( n + 1 ) / 2 ) % mod ; }", "nl": "Functions returns sum of numbers from 1 to n"}
{"code": "public static int rangeSum ( int b , int a ) { return ( linearSum ( b ) - linearSum ( a ) ) % mod ; }", "nl": "Functions returns sum of numbers from a + 1 to b"}
{"code": "public static int totalSum ( int n ) {", "nl": "Function returns total sum of divisors"}
{"code": "int result = 0 ; int i = 1 ;", "nl": "Stores total sum"}
{"code": "while ( true ) {", "nl": "Finding numbers and its occurence"}
{"code": "result += rangeSum ( n / i , n / ( i + 1 ) ) * ( i % mod ) % mod ; result %= mod ; if ( i == n ) break ; i = n / ( n / ( i + 1 ) ) ; } return result ; }", "nl": "Sum of product of each number and its occurence"}
{"code": "public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( totalSum ( N ) ) ; N = 12 ; System . out . println ( totalSum ( N ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation to check if N is a Nontrivial undulant number"}
{"code": "static boolean isDouble ( int num ) { String s = Integer . toString ( num ) ; int l = s . length ( ) ;", "nl": "Function to check if a string is double string or not"}
{"code": "if ( s . charAt ( 0 ) == s . charAt ( 1 ) ) return false ;", "nl": "a and b should not be equal"}
{"code": "if ( l % 2 == 1 ) { s = s + s . charAt ( 1 ) ; l ++ ; }", "nl": "Condition to check if length is odd make length even"}
{"code": "String s1 = s . substring ( 0 , l / 2 ) ;", "nl": "First half of s"}
{"code": "String s2 = s . substring ( l / 2 ) ;", "nl": "Second half of s"}
{"code": "return s1 . equals ( s2 ) ; }", "nl": "Double string if first and last half are equal"}
{"code": "static boolean isNontrivialUndulant ( int N ) { return N > 100 && isDouble ( N ) ; }", "nl": "Function to check if N is an Nontrivial undulant number"}
{"code": "public static void main ( String [ ] args ) { int n = 121 ; if ( isNontrivialUndulant ( n ) ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; }", "nl": "Function to find the nth Megagon Number"}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( MegagonNum ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static final int mod = 1000000007 ;", "nl": "Java implementation to find the product of all the pairs from the given array"}
{"code": "static int productPairs ( int arr [ ] , int n ) {", "nl": "Function to return the product of the elements of all possible pairs from the array"}
{"code": "int product = 1 ;", "nl": "To store the required product"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) {", "nl": "Nested loop to calculate all possible pairs"}
{"code": "product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } }", "nl": "Multiply the product of the elements of the current pair"}
{"code": "return product % mod ; }", "nl": "Return the final result"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . print ( productPairs ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static final int mod = 1000000007 ;", "nl": "Java implementation to Find the product of all the pairs from the given array"}
{"code": "static int power ( int x , int y ) { int p = 1000000007 ;", "nl": "Function to calculate ( x ^ y ) % 1000000007"}
{"code": "int res = 1 ;", "nl": "Initialize result"}
{"code": "x = x % p ; while ( y > 0 ) {", "nl": "Update x if it is more than or equal to p"}
{"code": "if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; }", "nl": "If y is odd , multiply x with result"}
{"code": "return res ; }", "nl": "Return the final result"}
{"code": "static int productPairs ( int arr [ ] , int n ) {", "nl": "Function to return the product of the elements of all possible pairs from the array"}
{"code": "int product = 1 ;", "nl": "To store the required product"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Iterate for every element of the array"}
{"code": "product = ( product % mod * ( int ) power ( arr [ i ] , ( 2 * n ) ) % mod ) % mod ; } return product % mod ; }", "nl": "Each element appears ( 2 * n ) times"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . print ( productPairs ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to construct array that cube sum of all element is a perfect square"}
{"code": "static void constructArray ( int N ) { int arr [ ] = new int [ N ] ;", "nl": "Function to create and print the array"}
{"code": "for ( int i = 1 ; i <= N ; i ++ ) { arr [ i - 1 ] = i ; }", "nl": "Initialise the array of size N"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + \" , \u2581 \" ) ; } }", "nl": "Print the array"}
{"code": "public static void main ( String [ ] args ) { int N = 6 ; constructArray ( N ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to count all subsequence whose product is Composite number"}
{"code": "static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }", "nl": "Function to check whether a number is prime or not"}
{"code": "static int countSubsequences ( int arr [ ] , int n ) {", "nl": "Function to find number of subsequences whose product is a composite number"}
{"code": "int totalSubsequence = ( int ) ( Math . pow ( 2 , n ) - 1 ) ; int countPrime = 0 , countOnes = 0 ;", "nl": "Find total non empty subsequence"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) countOnes ++ ; else if ( isPrime ( arr [ i ] ) ) countPrime ++ ; } int compositeSubsequence ;", "nl": "Find count of prime number and ones"}
{"code": "int onesSequence = ( int ) ( Math . pow ( 2 , countOnes ) - 1 ) ;", "nl": "Calculate the non empty one subsequence"}
{"code": "compositeSubsequence = totalSubsequence - countPrime - onesSequence - onesSequence * countPrime ; return compositeSubsequence ; }", "nl": "Find count of composite subsequence"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 2 } ; int n = arr . length ; System . out . print ( countSubsequences ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation to check if a number can be expressed as sum of K consecutive integer"}
{"code": "static void checksum ( int n , int k ) {", "nl": "Function to check if a number can be expressed as the sum of k consecutive"}
{"code": "float first_term = ( float ) ( ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ) ;", "nl": "Finding the first term of AP"}
{"code": "if ( first_term - ( int ) ( first_term ) == 0 ) {", "nl": "Checking if first term is an integer"}
{"code": "for ( int i = ( int ) first_term ; i <= first_term + k - 1 ; i ++ ) { System . out . print ( i + \" \u2581 \" ) ; } } else System . out . print ( \" - 1\" ) ; }", "nl": "Loop to print the K consecutive integers"}
{"code": "public static void main ( String [ ] args ) { int n = 33 , k = 6 ; checksum ( n , k ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to represent N as sum of K even numbers"}
{"code": "static void sumEvenNumbers ( int N , int K ) { int check = N - 2 * ( K - 1 ) ;", "nl": "Function to print the representation"}
{"code": "if ( check > 0 && check % 2 == 0 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { System . out . print ( \"2 \u2581 \" ) ; } System . out . println ( check ) ; } else { System . out . println ( \" - 1\" ) ; } }", "nl": "N must be greater than equal to 2 * K and must be even"}
{"code": "public static void main ( String args [ ] ) { int N = 8 ; int K = 2 ; sumEvenNumbers ( N , K ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . Scanner ; class contiguous_subarrays {", "nl": "Java program to find the number of contiguous subarrays including the element at every index of the array of size N"}
{"code": "public static int [ ] calculateWays ( int n ) { int x = 0 ;", "nl": "Function to find the number of subarrays including the element at every index of the array"}
{"code": "int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = 0 ;", "nl": "Creating an array of size N"}
{"code": "for ( int i = 0 ; i < n / 2 ; i ++ ) {", "nl": "The loop is iterated till half the length of the array"}
{"code": "if ( n % 2 == 0 && i == n / 2 ) break ;", "nl": "Condition to avoid overwriting the middle element for the array with even length ."}
{"code": "x = n * ( i + 1 ) - ( i + 1 ) * i ;", "nl": "Computing the number of subarrays"}
{"code": "v [ i ] = x ; v [ n - i - 1 ] = x ; } return v ; }", "nl": "The ith element from the beginning and the ending have the same number of possible subarray"}
{"code": "public static void printArray ( int [ ] v ) { for ( int i = 0 ; i < v . length ; i ++ ) System . out . print ( v [ i ] + \" \u2581 \" ) ; }", "nl": "Function to print the vector"}
{"code": "public static void main ( String args [ ] ) { int [ ] v ; v = calculateWays ( 4 ) ; printArray ( v ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static final int MAXN = 10000000 ;", "nl": "Java program to find the smallest number greater than or equal to X and divisible by Y"}
{"code": "static int sumOfDigits ( int n ) {", "nl": "Function that returns the sum of digits of a number"}
{"code": "int sum = 0 ; while ( n > 0 ) {", "nl": "Initialize variable to store the sum"}
{"code": "sum += n % 10 ;", "nl": "Add the last digit of the number"}
{"code": "n /= 10 ; } return sum ; }", "nl": "Remove the last digit from the number"}
{"code": "static int smallestNum ( int X , int Y ) {", "nl": "Function that returns the smallest number greater than or equal to X and divisible by Y"}
{"code": "int res = - 1 ;", "nl": "Initialize result variable"}
{"code": "for ( int i = X ; i < MAXN ; i ++ ) {", "nl": "Loop through numbers greater than equal to X"}
{"code": "int sum_of_digit = sumOfDigits ( i ) ;", "nl": "Calculate sum of digits"}
{"code": "if ( sum_of_digit % Y == 0 ) { res = i ; break ; } } return res ; }", "nl": "Check if sum of digits is divisible by Y"}
{"code": "public static void main ( String [ ] args ) { int X = 5923 , Y = 13 ; System . out . print ( smallestNum ( X , Y ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to count the numbers which can convert N to 1 using the given operation"}
{"code": "static int countValues ( int N ) { Vector < Integer > div = new Vector < > ( ) ;", "nl": "Function to count the numbers which can convert N to 1 using the given operation"}
{"code": "for ( int i = 2 ; i * i <= N ; i ++ ) {", "nl": "Store all the divisors of N"}
{"code": "if ( N % i == 0 ) { div . add ( i ) ;", "nl": "If i is a divisor"}
{"code": "if ( N != i * i ) { div . add ( N / i ) ; } } } int answer = 0 ;", "nl": "If i is not equal to N / i"}
{"code": "for ( int i = 1 ; i * i <= N - 1 ; i ++ ) {", "nl": "Iterate through all the divisors of N - 1 and count them in answer"}
{"code": "if ( ( N - 1 ) % i == 0 ) { if ( i * i == N - 1 ) answer ++ ; else answer += 2 ; } }", "nl": "Check if N - 1 is a divisor or not"}
{"code": "for ( int d : div ) { int K = N ; while ( K % d == 0 ) K /= d ; if ( ( K - 1 ) % d == 0 ) answer ++ ; } return answer ; }", "nl": "Iterate through all divisors and check for N mod d = 1 or ( N - 1 ) mod d = 0"}
{"code": "public static void main ( String [ ] args ) { int N = 6 ; System . out . print ( countValues ( N ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to find the maximum possible prime divisor of a number can have N divisors"}
{"code": "static void findMaxPrimeDivisor ( int n ) { int max_possible_prime = 0 ;", "nl": "Function to find the maximum possible prime divisors of a number can have with N divisors"}
{"code": "while ( n % 2 == 0 ) { max_possible_prime ++ ; n = n / 2 ; }", "nl": "Number of time number divided by 2"}
{"code": "for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { max_possible_prime ++ ; n = n / i ; } }", "nl": "Divide by other prime numbers"}
{"code": "if ( n > 2 ) { max_possible_prime ++ ; } System . out . print ( max_possible_prime + \"NEW_LINE\"); }", "nl": "If the last number of also prime then also include it"}
{"code": "public static void main ( String [ ] args ) { int n = 4 ;", "nl": "Driver Code"}
{"code": "findMaxPrimeDivisor ( n ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java program to count ways to express a number as sum of two numbers ."}
{"code": "static int CountWays ( int n ) { int ans = ( n - 1 ) / 2 ; return ans ; }", "nl": "Function returns the count of ways express a number as sum of two numbers ."}
{"code": "public static void main ( String [ ] args ) { int N = 8 ; System . out . print ( CountWays ( N ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . lang . * ; import java . util . * ; class GFG {", "nl": "Java program to find the max - size to which an array can be divided into 2 equal parts such that one part contains unique elements while another contains similar elements"}
{"code": "static void Solve ( int arr [ ] , int size , int n ) { int [ ] v = new int [ n + 1 ] ;", "nl": "Function to find the max - size to which an array can be divided into 2 equal parts"}
{"code": "for ( int i = 0 ; i < size ; i ++ ) v [ arr [ i ] ] ++ ;", "nl": "Array to find the frequency of each element of array"}
{"code": "int max1 = - 1 , mx = - 1 ; for ( int i = 0 ; i < v . length ; i ++ ) { if ( v [ i ] > mx ) { mx = v [ i ] ; max1 = i ; } }", "nl": "Find the index maximum frequency element present in array arr [ ]"}
{"code": "int cnt = 0 ; for ( int i : v ) { if ( i == 0 ) ++ cnt ; } int diff1 = n + 1 - cnt ;", "nl": "Find total unique elements present in array arr [ ]"}
{"code": "int max_size = Math . max ( Math . min ( v [ max1 ] - 1 , diff1 ) , Math . min ( v [ max1 ] , diff1 - 1 ) ) ; System . out . println ( \" Maximum \u2581 size \u2581 is : \u2581 \" + max_size ) ;", "nl": "Find the Max - Size to which an array arr [ ] can be splitted"}
{"code": "System . out . println ( \" First \u2581 Array \u2581 is \" ) ; for ( int i = 0 ; i < max_size ; i ++ ) { System . out . print ( max1 + \" \u2581 \" ) ; v [ max1 ] -= 1 ; } System . out . println ( ) ;", "nl": "Find the first array containing same elements"}
{"code": "System . out . println ( \" The \u2581 Second \u2581 Array \u2581 Is \u2581 : \" ) ; for ( int i = 0 ; i < ( n + 1 ) ; i ++ ) { if ( v [ i ] > 0 ) { System . out . print ( i + \" \u2581 \" ) ; max_size -- ; } if ( max_size < 1 ) break ; } System . out . println ( ) ; }", "nl": "Find the second array containing unique elements"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int n = 7 ;", "nl": "initialise n"}
{"code": "int arr [ ] = new int [ ] { 1 , 2 , 1 , 5 , 1 , 6 , 7 , 2 } ;", "nl": "array declaration"}
{"code": "int size = arr . length ; Solve ( arr , size , n ) ; } }", "nl": "size of array"}
{"code": "class GFG {", "nl": "Java program to find sum of xor of all unordered triplets of the array"}
{"code": "static int power ( int x , int y , int p ) {", "nl": "Iterative Function to calculate ( x ^ y ) % p in O ( log y )"}
{"code": "int res = 1 ;", "nl": "Initialize result"}
{"code": "x = x % p ; while ( y > 0 ) {", "nl": "Update x if it is more than or equal to p"}
{"code": "if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ;", "nl": "If y is odd , multiply x with result"}
{"code": "x = ( x * x ) % p ; } return res ; }", "nl": "y must be even now y = y >> 1 ; y = y / 2"}
{"code": "static int modInverse ( int n , int p ) { return power ( n , p - 2 , p ) ; }", "nl": "Returns n ^ ( - 1 ) mod p"}
{"code": "static int nCrModPFermat ( int n , int r , int p ) {", "nl": "Returns nCr % p using Fermat 's little theorem."}
{"code": "if ( r == 0 ) return 1 ; if ( n < r ) return 0 ;", "nl": "Base case"}
{"code": "int fac [ ] = new int [ n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; }", "nl": "Fill factorial array so that we can find all factorial of r , n and n - r"}
{"code": "static int SumOfXor ( int a [ ] , int n ) { int mod = 10037 ; int answer = 0 ;", "nl": "Function returns sum of xor of all unordered triplets of the array"}
{"code": "for ( int k = 0 ; k < 32 ; k ++ ) {", "nl": "Iterating over the bits"}
{"code": "int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Number of elements whith k 'th bit  1 and 0 respectively"}
{"code": "if ( ( a [ i ] & ( 1 << k ) ) != 0 ) x ++ ; else y ++ ; }", "nl": "Checking if k 'th bit is 1"}
{"code": "answer += ( ( 1 << k ) % mod * ( nCrModPFermat ( x , 3 , mod ) + x * nCrModPFermat ( y , 2 , mod ) ) % mod ) % mod ; } return answer ; }", "nl": "Adding this bit 's part to the answer"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; int A [ ] = { 3 , 5 , 2 , 18 , 7 } ; System . out . println ( SumOfXor ( A , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { public static float round ( float var , int digit ) { float value = ( int ) ( var * Math . pow ( 10 , digit ) + .5 ) ; return ( float ) value / ( float ) Math . pow ( 10 , digit ) ; }", "nl": "Java implementation to find the probability of not getting two consecutive heads together when N coins are tossed"}
{"code": "public static int probability ( int N ) {", "nl": "Function to compute the N - th Fibonacci number in the sequence where a = 2 and b = 3"}
{"code": "int a = 2 ; int b = 3 ;", "nl": "The first two numbers in the sequence are initialized"}
{"code": "if ( N == 1 ) { return a ; } else if ( N == 2 ) { return b ; } else {", "nl": "Base cases"}
{"code": "for ( int i = 3 ; i <= N ; i ++ ) { int c = a + b ; a = b ; b = c ; } return b ; } }", "nl": "Loop to compute the fibonacci sequence based on the first two initialized numbers"}
{"code": "public static float operations ( int N ) {", "nl": "Function to find the probability of not getting two consecutive heads when N coins are tossed"}
{"code": "int x = probability ( N ) ;", "nl": "Computing the number of favourable cases"}
{"code": "int y = ( int ) Math . pow ( 2 , N ) ; return round ( ( float ) x / ( float ) y , 2 ) ; }", "nl": "Computing the number of all possible outcomes for N tosses"}
{"code": "public static void main ( String [ ] args ) { int N = 10 ; System . out . println ( ( operations ( N ) ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to check if the concatenation of two numbers is a perfect cube or not"}
{"code": "static boolean isPerfectCube ( int x ) { long cr = Math . round ( Math . cbrt ( x ) ) ; return ( cr * cr * cr == x ) ; }", "nl": "Function to check if a number is a perfect Cube or not"}
{"code": "static void checkCube ( int a , int b ) {", "nl": "Function to check if concatenation of two numbers is a perfect cube or not"}
{"code": "String s1 = Integer . toString ( a ) ; String s2 = Integer . toString ( b ) ;", "nl": "Convert numbers to string using to_string ( )"}
{"code": "int c = Integer . parseInt ( s1 + s2 ) ;", "nl": "Concatenate the numbers and convert it into integer"}
{"code": "if ( isPerfectCube ( c ) ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } }", "nl": "Check if concatenated value is perfect cube or not"}
{"code": "public static void main ( String [ ] args ) { int a = 6 ; int b = 4 ; checkCube ( a , b ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static int largest_sum ( int arr [ ] , int n ) {", "nl": "Function to return the largest sum"}
{"code": "int maximum = - 1 ;", "nl": "Variable to store the largest sum"}
{"code": "HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ;", "nl": "Map to store the frequencies of each element"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } }", "nl": "Store the Frequencies"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Loop to combine duplicate elements and update the sum in the map"}
{"code": "if ( m . get ( arr [ i ] ) > 1 ) { if ( m . containsKey ( 2 * arr [ i ] ) ) {", "nl": "If j is a duplicate element"}
{"code": "m . put ( 2 * arr [ i ] , m . get ( 2 * arr [ i ] ) + m . get ( arr [ i ] ) / 2 ) ; } else { m . put ( 2 * arr [ i ] , m . get ( arr [ i ] ) / 2 ) ; }", "nl": "Update the frequency of 2 * j"}
{"code": "if ( 2 * arr [ i ] > maximum ) maximum = 2 * arr [ i ] ; } }", "nl": "If the new sum is greater than maximum value , Update the maximum"}
{"code": "return maximum ; }", "nl": "Returns the largest sum"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 4 , 7 , 8 } ; int n = arr . length ;", "nl": "Driver Code"}
{"code": "System . out . println ( largest_sum ( arr , n ) ) ; } }", "nl": "Function Calling"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program of the above approach"}
{"code": "static void canBeReduced ( int x , int y ) { int maxi = Math . max ( x , y ) ; int mini = Math . min ( x , y ) ;", "nl": "Function to check if it is possible to make x and y can become 0 at same time"}
{"code": "if ( ( ( x + y ) % 3 ) == 0 && maxi <= 2 * mini ) System . out . print ( \" YES \" + \"NEW_LINE\"); else System . out . print ( \" NO \" + \"NEW_LINE\"); }", "nl": "Check the given conditions"}
{"code": "public static void main ( String [ ] args ) { int x = 6 , y = 9 ;", "nl": "Driver Code"}
{"code": "canBeReduced ( x , y ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to check if the given number is prime using Wheel Factorization Method"}
{"code": "static void isPrime ( int N ) { boolean isPrime = true ;", "nl": "Function to check if a given number x is prime or not"}
{"code": "int [ ] arr = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 } ;", "nl": "The Wheel for checking prime number"}
{"code": "if ( N < 2 ) { isPrime = false ; }", "nl": "Base Case"}
{"code": "if ( N % 2 == 0 N % 3 == 0 N % 5 == 0 ) { isPrime = false ; }", "nl": "Check for the number taken as basis"}
{"code": "for ( int i = 0 ; i < Math . sqrt ( N ) ; i += 30 ) {", "nl": "Check for Wheel Here i , acts as the layer of the wheel"}
{"code": "for ( int c : arr ) {", "nl": "Check for the list of Sieve in arr [ ]"}
{"code": "if ( c > Math . sqrt ( N ) ) { break ; }", "nl": "If number is greater than sqrt ( N ) break"}
{"code": "else { if ( N % ( c + i ) == 0 ) { isPrime = false ; break ; } }", "nl": "Check if N is a multiple of prime number in the wheel"}
{"code": "if ( ! isPrime ) break ; } } if ( isPrime ) System . out . println ( \" Prime \u2581 Number \" ) ; else System . out . println ( \" Not \u2581 a \u2581 Prime \u2581 Number \" ) ; }", "nl": "If at any iteration isPrime is false , break from the loop"}
{"code": "public static void main ( String args [ ] ) { int N = 121 ;", "nl": "Driver 's Code"}
{"code": "isPrime ( N ) ; } }", "nl": "Function call for primality check"}
{"code": "class GFG {", "nl": "Java implementation to find all Pairs possible from the given Array"}
{"code": "static void printPairs ( int arr [ ] , int n ) {", "nl": "Function to print all possible pairs from the array"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( \" ( \" + arr [ i ] + \" , \u2581 \" + arr [ j ] + \" ) \" + \" , \u2581 \" ) ; } } }", "nl": "Nested loop for all possible pairs"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 } ; int n = arr . length ; printPairs ( arr , n ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int nearest ( int n ) {", "nl": "Function to return the Least number"}
{"code": "int prevCube = ( int ) Math . cbrt ( n ) ; int nextCube = prevCube + 1 ; prevCube = prevCube * prevCube * prevCube ; nextCube = nextCube * nextCube * nextCube ;", "nl": "Get the perfect cube before and after N"}
{"code": "int ans = ( n - prevCube ) < ( nextCube - n ) ? ( prevCube - n ) : ( nextCube - n ) ;", "nl": "Check which is nearest to N"}
{"code": "return ans ; }", "nl": "return the result"}
{"code": "public static void main ( String [ ] args ) { int n = 25 ; System . out . println ( nearest ( n ) ) ; n = 27 ; System . out . println ( nearest ( n ) ) ; n = 40 ; System . out . println ( nearest ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static void circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( int ) Math . sqrt ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ; if ( distSq + r2 == r1 ) { System . out . println ( \" The \u2581 smaller \u2581 circle \u2581 lies \u2581 completely \" + \" \u2581 inside \u2581 the \u2581 bigger \u2581 circle \u2581 with \u2581 \" + \" touching \u2581 each \u2581 other \u2581 \" + \" at \u2581 a \u2581 point \u2581 of \u2581 circumference . \u2581 \" ) ; } else if ( distSq + r2 < r1 ) { System . out . println ( \" The \u2581 smaller \u2581 circle \u2581 lies \u2581 completely \" + \" \u2581 inside \u2581 the \u2581 bigger \u2581 circle \u2581 without \" + \" \u2581 touching \u2581 each \u2581 other \u2581 \" + \" at \u2581 a \u2581 point \u2581 of \u2581 circumference . \" ) ; } else { System . out . println ( \" The \u2581 smaller \u2581 does \u2581 not \u2581 lies \u2581 inside \" + \" \u2581 the \u2581 bigger \u2581 circle \u2581 completely . \" ) ; } }", "nl": "Java program to check if one circle lies inside another circle or not ."}
{"code": "public static void main ( String [ ] args ) { int x1 = 10 , y1 = 8 ; int x2 = 1 , y2 = 2 ; int r1 = 30 , r2 = 10 ; circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find the length of the direct common tangent between two circles which intersect each other"}
{"code": "static void lengtang ( double r1 , double r2 , double d ) { System . out . println ( \" The \u2581 length \u2581 of \u2581 the \u2581 direct \" + \" \u2581 common \u2581 tangent \u2581 is \u2581 \" + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) ) ; }", "nl": "Function to find the length of the direct common tangent"}
{"code": "public static void main ( String [ ] args ) { double r1 = 4 , r2 = 6 , d = 3 ; lengtang ( r1 , r2 , d ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find radius of the circle when the width and height of an arc is given"}
{"code": "static void rad ( double d , double h ) { System . out . println ( \" The \u2581 radius \u2581 of \u2581 the \u2581 circle \u2581 is \u2581 \" + ( ( d * d ) / ( 8 * h ) + h / 2 ) ) ; }", "nl": "Function to find the radius"}
{"code": "public static void main ( String [ ] args ) { double d = 4 , h = 1 ; rad ( d , h ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find the shortest distance from chord to the centre of circle"}
{"code": "static void shortdis ( double r , double d ) { System . out . println ( \" The \u2581 shortest \u2581 distance \u2581 \" + \" from \u2581 the \u2581 chord \u2581 to \u2581 centre \u2581 \" + ( Math . sqrt ( ( r * r ) - ( ( d * d ) / 4 ) ) ) ) ; }", "nl": "Function to find the shortest distance"}
{"code": "public static void main ( String [ ] args ) { double r = 4 , d = 3 ; shortdis ( r , d ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find the length of the direct common tangent between two circles which donot touch each other"}
{"code": "static void lengtang ( double r1 , double r2 , double d ) { System . out . println ( \" The \u2581 length \u2581 of \u2581 the \u2581 direct \" + \" \u2581 common \u2581 tangent \u2581 is \u2581 \" + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) ) ; }", "nl": "Function to find the length of the direct common tangent"}
{"code": "public static void main ( String [ ] args ) { double r1 = 4 , r2 = 6 , d = 12 ; lengtang ( r1 , r2 , d ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java Program to find the the biggest square which can be inscribed within the equilateral triangle"}
{"code": "static double square ( double a ) {", "nl": "Function to find the side of the square"}
{"code": "if ( a < 0 ) return - 1 ;", "nl": "the side cannot be negative"}
{"code": "double x = 0.464 * a ; return x ; }", "nl": "side of the square"}
{"code": "public static void main ( String [ ] args ) { double a = 5 ; System . out . println ( square ( a ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java Program to find the apothem of a regular polygon with given side length"}
{"code": "double polyapothem ( double n , double a ) {", "nl": "Function to find the apothem of a regular polygon"}
{"code": "if ( a < 0 && n < 0 ) return - 1 ;", "nl": "Side and side length cannot be negative"}
{"code": "return ( a / ( 2 * java . lang . Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; }", "nl": "Degree converted to radians"}
{"code": "public static void main ( String args [ ] ) { double a = 9 , n = 6 ; GFG g = new GFG ( ) ; System . out . println ( g . polyapothem ( n , a ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java Program to find the area of a regular polygon with given side length"}
{"code": "static float polyarea ( float n , float a ) {", "nl": "Function to find the area of a regular polygon"}
{"code": "if ( a < 0 && n < 0 ) return - 1 ;", "nl": "Side and side length cannot be negative"}
{"code": "float A = ( a * a * n ) / ( float ) ( 4 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; }", "nl": "Area degree converted to radians"}
{"code": "public static void main ( String [ ] args ) { float a = 9 , n = 6 ; System . out . println ( polyarea ( n , a ) ) ; } }", "nl": "Driver code"}
{"code": "import java . lang . Math ; import java . io . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static double calculateSide ( double n , double r ) { double theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * Math . sin ( theta_in_radians / 2 ) ; }", "nl": "Function to calculate the side of the polygon circumscribed in a circle"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "double n = 3 ;", "nl": "Total sides of the polygon"}
{"code": "double r = 5 ; System . out . println ( calculateSide ( n , r ) ) ; } }", "nl": "Radius of the circumscribing circle"}
{"code": "import java . io . * ; class GFG {", "nl": "Java Program to find the biggest right circular cylinder that can be fit within a frustum"}
{"code": "static float cyl ( float r , float R , float h ) {", "nl": "Function to find the biggest right circular cylinder"}
{"code": "if ( h < 0 && r < 0 && R < 0 ) return - 1 ;", "nl": "radii and height cannot be negative"}
{"code": "float r1 = r ;", "nl": "radius of right circular cylinder"}
{"code": "float h1 = h ;", "nl": "height of right circular cylinder"}
{"code": "float V = ( float ) ( 3.14 * Math . pow ( r1 , 2 ) * h1 ) ; return V ; }", "nl": "volume of right circular cylinder"}
{"code": "public static void main ( String [ ] args ) { float r = 7 , R = 11 , h = 6 ; System . out . print ( cyl ( r , R , h ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find the perimeter of a regular polygon"}
{"code": "static double Perimeter ( double s , int n ) { double perimeter = 1 ;", "nl": "Function to calculate the perimeter"}
{"code": "perimeter = n * s ; return perimeter ; }", "nl": "Calculate Perimeter"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver method"}
{"code": "int n = 5 ;", "nl": "Get the number of sides"}
{"code": "double s = 2.5 , peri ;", "nl": "Get the length of side"}
{"code": "peri = Perimeter ( s , n ) ; System . out . println ( \" Perimeter \u2581 of \u2581 Regular \u2581 Polygon \" + \" \u2581 with \u2581 \" + n + \" \u2581 sides \u2581 of \u2581 length \u2581 \" + s + \" \u2581 = \u2581 \" + peri ) ; } }", "nl": "find perimeter"}
{"code": "import java . io . * ; class GFG {", "nl": "Java Program to find the biggest rhombus which can be inscribed within the rectangle"}
{"code": "static float rhombusarea ( float l , float b ) {", "nl": "Function to find the area of the biggest rhombus"}
{"code": "if ( l < 0 b < 0 ) return - 1 ;", "nl": "the length and breadth cannot be negative"}
{"code": "return ( l * b ) / 2 ; }", "nl": "area of the rhombus"}
{"code": "public static void main ( String [ ] args ) { float l = 16 , b = 6 ; System . out . println ( rhombusarea ( l , b ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to Check if a point lies on or inside a rectangle | Set - 2"}
{"code": "static boolean FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; }", "nl": "function to find if given point lies inside a given rectangle or not ."}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ;", "nl": "bottom - left and top - right corners of rectangle"}
{"code": "int x = 1 , y = 5 ;", "nl": "given point"}
{"code": "if ( FindPoint ( x1 , y1 , x2 , y2 , x , y ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "function call"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find the Perpendicular ( shortest ) distance between a point and a Plane in 3 D ."}
{"code": "static void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = Math . abs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = ( float ) Math . sqrt ( a * a + b * b + c * c ) ; System . out . println ( \" Perpendicular \u2581 distance \u2581 \" + \" is \u2581 \" + d / e ) ; }", "nl": "Function to find distance"}
{"code": "public static void main ( String [ ] args ) { float x1 = 4 ; float y1 = - 4 ; float z1 = 3 ; float a = 2 ; float b = - 2 ; float c = 5 ; float d = 8 ;", "nl": "Driver code"}
{"code": "shortest_distance ( x1 , y1 , z1 , a , b , c , d ) ; } }", "nl": "Function call"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find the volume of the triangular prism"}
{"code": "static float findVolume ( float l , float b , float h ) {", "nl": "function to find the Volume of triangular prism"}
{"code": "float volume = ( l * b * h ) / 2 ; return volume ; }", "nl": "formula to find Volume"}
{"code": "public static void main ( String [ ] args ) { float l = 18 , b = 12 , h = 9 ;", "nl": "Driver code"}
{"code": "System . out . println ( \" Volume \u2581 of \u2581 triangular \u2581 prism : \u2581 \" + findVolume ( l , b , h ) ) ; } }", "nl": "function calling"}
{"code": "class GFG {", "nl": "A simple program to find if given 4 values can represent 4 sides of rectangle"}
{"code": "static boolean isRectangle ( int a , int b , int c , int d ) {", "nl": "Function to check if the given integers value make a rectangle"}
{"code": "if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; }", "nl": "Square is also a rectangle"}
{"code": "public static void main ( String [ ] args ) { int a = 1 , b = 2 , c = 3 , d = 4 ; if ( isRectangle ( a , b , c , d ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find the midpoint of a line"}
{"code": "static void midpoint ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( x1 + x2 ) / 2 + \" \u2581 , \u2581 \" + ( y1 + y2 ) / 2 ) ; }", "nl": "function to find the midpoint of a line"}
{"code": "public static void main ( String [ ] args ) { int x1 = - 1 , y1 = 2 ; int x2 = 3 , y2 = - 6 ; midpoint ( x1 , x2 , y1 , y2 ) ; } }", "nl": "Driver code"}
{"code": "public class Arc {", "nl": "Java program to calculate length of an arc"}
{"code": "static double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { System . out . println ( \" Angle \u2581 cannot \" + \" \u2581 be \u2581 formed \" ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }", "nl": "function to calculate arc length"}
{"code": "public static void main ( String args [ ] ) { double diameter = 25.0 ; double angle = 45.0 ; double arc_len = arcLength ( diameter , angle ) ; System . out . println ( arc_len ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG { static void checkCollision ( int a , int b , int c , int x , int y , int radius ) {", "nl": "Java program to check if a line touches or intersects or outside a circle ."}
{"code": "double dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ;", "nl": "Finding the distance of line from center ."}
{"code": "if ( radius == dist ) System . out . println ( \" Touch \" ) ; else if ( radius > dist ) System . out . println ( \" Intersect \" ) ; else System . out . println ( \" Outside \" ) ; }", "nl": "Checking if the distance is less than , greater than or equal to radius ."}
{"code": "public static void main ( String [ ] args ) { int radius = 5 ; int x = 0 , y = 0 ; int a = 3 , b = 4 , c = 25 ; checkCollision ( a , b , c , x , y , radius ) ; } }", "nl": "Driven Program"}
{"code": "import java . io . * ; import java . math . * ; class GFG {", "nl": "Java program to evaluate area of a polygon usingshoelace formula"}
{"code": "static double polygonArea ( double X [ ] , double Y [ ] , int n ) {", "nl": "( X [ i ] , Y [ i ] ) are coordinates of i 'th point."}
{"code": "double area = 0.0 ;", "nl": "Initialize area"}
{"code": "int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ;", "nl": "Calculate value of shoelace formula"}
{"code": "j = i ; }", "nl": "j is previous vertex to i"}
{"code": "return Math . abs ( area / 2.0 ) ; }", "nl": "Return absolute value"}
{"code": "public static void main ( String [ ] args ) { double X [ ] = { 0 , 2 , 4 } ; double Y [ ] = { 1 , 3 , 7 } ; int n = X . length ; System . out . println ( polygonArea ( X , Y , n ) ) ; } }", "nl": "Driver program"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int chk ( int n ) {", "nl": "Function top get LSB value of v"}
{"code": "Vector < Integer > v = new Vector < Integer > ( ) ; while ( n != 0 ) { v . add ( n % 2 ) ; n = n / 2 ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v . get ( i ) == 1 ) { return ( int ) Math . pow ( 2 , i ) ; } } return 0 ; }", "nl": "Binary conversion"}
{"code": "static void sumOfLSB ( int arr [ ] , int N ) {", "nl": "Function to find the sum of LSBs of all possible pairs of the given array"}
{"code": "Vector < Integer > lsb_arr = new Vector < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Stores the LSB of array elements"}
{"code": "lsb_arr . add ( chk ( arr [ i ] ) ) ; }", "nl": "Storing the LSB values"}
{"code": "Collections . sort ( lsb_arr ) ; int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i += 2 ) {", "nl": "Sort the array lab_arr [ ]"}
{"code": "ans += ( lsb_arr . get ( i + 1 ) ) ; }", "nl": "Taking pairwise sum to get the maximum sum of LSB"}
{"code": "System . out . print ( ans ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { int N = 5 ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ;", "nl": "Driver Code"}
{"code": "sumOfLSB ( arr , N ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int countSubsequences ( int arr [ ] , int N ) {", "nl": "Function to find count of subsequences having odd bitwise AND value"}
{"code": "int odd = 0 ;", "nl": "Stores count of odd elements"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array arr [ ]"}
{"code": "if ( ( arr [ i ] & 1 ) % 2 == 1 ) odd ++ ; }", "nl": "If x is odd increment count"}
{"code": "return ( 1 << odd ) - 1 ; }", "nl": "Return Answer"}
{"code": "public static void main ( String [ ] args ) { int N = 3 ; int arr [ ] = { 1 , 3 , 3 } ;", "nl": "Driver Code"}
{"code": "System . out . println ( countSubsequences ( arr , N ) ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int getPairsCount ( int arr [ ] , int n ) {", "nl": "Function to find the number of pairs ( i , j ) such that abs ( a [ i ] - a [ j ] ) is at least the minimum of ( a [ i ] , a [ j ] )"}
{"code": "int count = 0 ;", "nl": "Stores the resultant count of pairs"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Iterate over the range [ 0 , n ]"}
{"code": "for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) {", "nl": "Iterate from arr [ i ] - ( i % arr [ i ] ) till n with an increment of arr [ i ]"}
{"code": "if ( i < j && Math . abs ( arr [ i ] - arr [ j ] ) >= Math . min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } }", "nl": "Count the possible pairs"}
{"code": "return count ; }", "nl": "Return the total count"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int N = arr . length ; System . out . println ( getPairsCount ( arr , N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void check ( int N ) { int twos = 0 , fives = 0 ;", "nl": "Function to check if N can be changed to 1 or not ."}
{"code": "while ( N % 2 == 0 ) { N /= 2 ; twos ++ ; }", "nl": "Count the number of 2 in the prime factorisation of N"}
{"code": "while ( N % 5 == 0 ) { N /= 5 ; fives ++ ; } if ( N == 1 && twos <= fives ) { System . out . println ( 2 * fives - twos ) ; } else { System . out . println ( - 1 ) ; } }", "nl": "Count the number of 5 in the prime factorisation of N"}
{"code": "public static void main ( String [ ] args ) { int N = 50 ; check ( N ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void rangeSum ( int arr [ ] , int N , int L , int R ) {", "nl": "Function to find the sum of elements in a given range of an infinite array"}
{"code": "int sum = 0 ;", "nl": "Stores the sum of array elements from L to R"}
{"code": "for ( int i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; }", "nl": "Traverse from L to R"}
{"code": "System . out . println ( sum ) ; }", "nl": "Print the resultant sum"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = arr . length ; rangeSum ( arr , N , L , R ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void rangeSum ( int arr [ ] , int N , int L , int R ) {", "nl": "Function to find the sum of elements in a given range of an infinite array"}
{"code": "int prefix [ ] = new int [ N + 1 ] ; prefix [ 0 ] = 0 ;", "nl": "Stores the prefix sum"}
{"code": "for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; }", "nl": "Calculate the prefix sum"}
{"code": "int leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ;", "nl": "Stores the sum of elements from 1 to L - 1"}
{"code": "int rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ;", "nl": "Stores the sum of elements from 1 to R"}
{"code": "System . out . print ( rightsum - leftsum ) ; }", "nl": "Print the resultant sum"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = arr . length ; rangeSum ( arr , N , L , R ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static int ExpoFactorial ( int N ) {", "nl": "Function to find exponential factorial of a given number"}
{"code": "int res = 1 ; int mod = 1000000007 ;", "nl": "Stores the exponetial factor of N"}
{"code": "for ( int i = 2 ; i < N + 1 ; i ++ )", "nl": "Iterare over the range [ 2 , N ]"}
{"code": "res = ( int ) Math . pow ( i , res ) % mod ;", "nl": "Update res"}
{"code": "return res ; }", "nl": "Return res"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int N = 4 ;", "nl": "Input"}
{"code": "System . out . println ( ( ExpoFactorial ( N ) ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int maxSubArraySumRepeated ( int [ ] arr , int N , int K ) {", "nl": "Function to find contiguous subarray with maximum sum if array is repeated K times"}
{"code": "int sum = 0 ;", "nl": "Store the sum of the array arr [ ]"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int curr = arr [ 0 ] ;", "nl": "Traverse the array and find sum"}
{"code": "int ans = arr [ 0 ] ;", "nl": "Store the answer"}
{"code": "if ( K == 1 ) {", "nl": "If K = 1"}
{"code": "for ( int i = 1 ; i < N ; i ++ ) { curr = Math . max ( arr [ i ] , curr + arr [ i ] ) ; ans = Math . max ( ans , curr ) ; }", "nl": "Apply Kadane algorithm to find sum"}
{"code": "return ans ; }", "nl": "Return the answer"}
{"code": "ArrayList < Integer > V = new ArrayList < Integer > ( ) ;", "nl": "Stores the twice repeated array"}
{"code": "for ( int i = 0 ; i < 2 * N ; i ++ ) { V . add ( arr [ i % N ] ) ; }", "nl": "Traverse the range [ 0 , 2 * N ]"}
{"code": "int maxSuf = V . get ( 0 ) ;", "nl": "Stores the maximum suffix sum"}
{"code": "int maxPref = V . get ( 2 * N - 1 ) ; curr = V . get ( 0 ) ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr += V . get ( i ) ; maxPref = Math . max ( maxPref , curr ) ; } curr = V . get ( 2 * N - 1 ) ; for ( int i = 2 * N - 2 ; i >= 0 ; i -- ) { curr += V . get ( i ) ; maxSuf = Math . max ( maxSuf , curr ) ; } curr = V . get ( 0 ) ;", "nl": "Stores the maximum prefix sum"}
{"code": "for ( int i = 1 ; i < 2 * N ; i ++ ) { curr = Math . max ( V . get ( i ) , curr + V . get ( i ) ) ; ans = Math . max ( ans , curr ) ; }", "nl": "Apply Kadane algorithm for 2 repetition of the array"}
{"code": "if ( sum > 0 ) { int temp = sum * ( K - 2 ) ; ans = Math . max ( ans , Math . max ( temp + maxPref , temp + maxSuf ) ) ; }", "nl": "If the sum of the array is greater than 0"}
{"code": "return ans ; }", "nl": "Return the answer"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "int [ ] arr = { 10 , 20 , - 30 , - 1 , 40 } ; int N = arr . length ; int K = 10 ;", "nl": "Given Input"}
{"code": "System . out . print ( maxSubArraySumRepeated ( arr , N , K ) ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static void countSubarray ( int arr [ ] , int n ) {", "nl": "Function to find count of subarrays which have max element greater than twice maximum of all other elements"}
{"code": "int count = 0 ;", "nl": "Stores the count of subarrays"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) {", "nl": "Generate all possible subarrays"}
{"code": "int mxSubarray = 0 ;", "nl": "Stores the maximum element of the subarray"}
{"code": "int mxOther = 0 ;", "nl": "Stores the maximum of all other elements"}
{"code": "for ( int k = i ; k <= j ; k ++ ) { mxSubarray = Math . max ( mxSubarray , arr [ k ] ) ; }", "nl": "Find the maximum element in the subarray [ i , j ]"}
{"code": "for ( int k = 0 ; k < i ; k ++ ) { mxOther = Math . max ( mxOther , arr [ k ] ) ; } for ( int k = j + 1 ; k < n ; k ++ ) { mxOther = Math . max ( mxOther , arr [ k ] ) ; }", "nl": "Find the maximum of all other elements"}
{"code": "if ( mxSubarray > ( 2 * mxOther ) ) count ++ ; } }", "nl": "If the maximum of subarray is greater than twice the maximum of other elements"}
{"code": "System . out . println ( count ) ; }", "nl": "Print the maximum value obtained"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = arr . length ; countSubarray ( arr , N ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void countSubarray ( int [ ] arr , int n ) { int L = 0 , R = 0 ;", "nl": "Function to find count of subarrays which have max element greater than twice maximum of all other elements"}
{"code": "int mx = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) mx = Math . max ( mx , arr [ i ] ) ;", "nl": "Stores the maximum element of the array"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse the given array"}
{"code": "if ( arr [ i ] * 2 > mx ) {", "nl": "If the value of 2 * arr [ i ] is greater than mx"}
{"code": "L = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) {", "nl": "Update the value of L and break out of loop"}
{"code": "if ( arr [ i ] * 2 > mx ) {", "nl": "If the value 2 * arr [ i ] is greater than mx"}
{"code": "R = i ; break ; } }", "nl": "Update the value of R and break out of loop"}
{"code": "System . out . println ( ( L + 1 ) * ( n - R ) ) ; }", "nl": "Print the final answer"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = arr . length ; countSubarray ( arr , N ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static boolean isPrime ( int X ) { for ( int i = 2 ; i * i <= X ; i ++ )", "nl": "Utility function to check for primality of a number X by checking whether X has any factors other than 1 and itself ."}
{"code": "if ( X % i == 0 ) return false ; return true ; }", "nl": "Factor found"}
{"code": "static void printPrimes ( int A [ ] , int N ) {", "nl": "Function to print primes just less than and just greater than of each element in an array"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array"}
{"code": "for ( int j = A [ i ] - 1 ; ; j -- ) {", "nl": "Traverse for finding prime just less than A [ i ]"}
{"code": "if ( isPrime ( j ) ) { System . out . print ( j + \" \u2581 \" ) ; break ; } }", "nl": "Prime just less than A [ i ] found"}
{"code": "for ( int j = A [ i ] + 1 ; ; j ++ ) {", "nl": "Traverse for finding prime just greater than A [ i ]"}
{"code": "if ( isPrime ( j ) ) { System . out . print ( j + \" \u2581 \" ) ; break ; } } System . out . println ( ) ; } }", "nl": "Prime just greater than A [ i ] found"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int A [ ] = { 17 , 28 } ; int N = A . length ;", "nl": "Input"}
{"code": "printPrimes ( A , N ) ; } }", "nl": "Function call"}
{"code": "public class GFG_JAVA {", "nl": "Java program for the above approach"}
{"code": "static int KthSmallest ( int A [ ] , int B [ ] , int N , int K ) { int M = 0 ;", "nl": "Function to find the Kth smallest element that contains A [ i ] exactly B [ i ] times"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { M = Math . max ( A [ i ] , M ) ; }", "nl": "Traverse the given array"}
{"code": "int freq [ ] = new int [ M + 1 ] ;", "nl": "Stores the frequency of every elements"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { freq [ A [ i ] ] += B [ i ] ; }", "nl": "Traverse the given array"}
{"code": "int sum = 0 ;", "nl": "Initialize a variable to store the prefix sums"}
{"code": "for ( int i = 0 ; i <= M ; i ++ ) {", "nl": "Iterate over the range [ 0 , M ]"}
{"code": "sum += freq [ i ] ;", "nl": "Increment sum by freq [ i ]"}
{"code": "if ( sum >= K ) {", "nl": "If sum is greater than or equal to K"}
{"code": "return i ; } }", "nl": "Return the current element as answer"}
{"code": "return - 1 ; }", "nl": "Return - 1"}
{"code": "public static void main ( String [ ] args )", "nl": "Driver code"}
{"code": "int A [ ] = { 3 , 4 , 5 } ; int B [ ] = { 2 , 1 , 3 } ; int N = A . length ; int K = 4 ;", "nl": "{ Given Input"}
{"code": "System . out . println ( KthSmallest ( A , B , N , K ) ) ; } }", "nl": "Function call"}
{"code": "public class GFG {", "nl": "Java program for the above approach"}
{"code": "static void findbitwiseOR ( int [ ] a , int n ) {", "nl": "Function to find the Bitwise OR of Bitwise AND of all subarrays"}
{"code": "int res = 0 ;", "nl": "Stores the required result"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Generate all the subarrays"}
{"code": "int curr_sub_array = a [ i ] ;", "nl": "Store the current element"}
{"code": "res = res | curr_sub_array ; for ( int j = i ; j < n ; j ++ ) {", "nl": "Find the Bitwise OR"}
{"code": "curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } }", "nl": "Update the result"}
{"code": "System . out . println ( res ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 } ; int N = A . length ; findbitwiseOR ( A , N ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void findbitwiseOR ( int [ ] a , int n ) {", "nl": "Function to find the Bitwise OR of Bitwise AND of all consecutive subsets of the array"}
{"code": "int res = 0 ;", "nl": "Stores the required result"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) res = res | a [ i ] ;", "nl": "Traverse the given array"}
{"code": "System . out . println ( res ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { int [ ] A = { 1 , 2 , 3 } ; int N = A . length ; findbitwiseOR ( A , N ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static void check ( int n ) {", "nl": "Function to check if the sum of the digits of N is strictly greater than the product of the digits of N or not"}
{"code": "int sumOfDigit = 0 ; int prodOfDigit = 1 ; while ( n > 0 ) {", "nl": "Stores the sum and the product of the digits of N"}
{"code": "int rem ; rem = n % 10 ;", "nl": "Stores the last digit if N"}
{"code": "sumOfDigit += rem ;", "nl": "Increment the value of sumOfDigits"}
{"code": "prodOfDigit *= rem ;", "nl": "Update the prodOfDigit"}
{"code": "n /= 10 ; }", "nl": "Divide N by 10"}
{"code": "if ( sumOfDigit > prodOfDigit ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { int N = 1234 ; check ( N ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java approach for the above approach"}
{"code": "static void evenOddBitwiseXOR ( int N ) { System . out . print ( \" Even : \u2581 \" + 0 + \" \u2581 \" ) ;", "nl": "Print all distinct even & odd prefix Bitwise XORs from 1 to N"}
{"code": "for ( int i = 4 ; i <= N ; i = i + 4 ) { System . out . print ( i + \" \u2581 \" ) ; } System . out . print ( \"NEW_LINE\"); System . out . print ( \" Odd : \u2581 \" + 1 + \" \u2581 \" ) ;", "nl": "Print the even number"}
{"code": "for ( int i = 4 ; i <= N ; i = i + 4 ) { System . out . print ( i - 1 + \" \u2581 \" ) ; } if ( N % 4 == 2 ) System . out . print ( N + 1 ) ; else if ( N % 4 == 3 ) System . out . print ( N ) ; }", "nl": "Print the odd number"}
{"code": "public static void main ( String [ ] args ) { int N = 6 ; evenOddBitwiseXOR ( N ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "java program for the above approach"}
{"code": "static void findPermutation ( int [ ] arr ) { int N = arr . length ; int i = N - 2 ;", "nl": "Function to lexicographic largest permutation possible by a swap that is smaller than given array"}
{"code": "while ( i >= 0 && arr [ i ] <= arr [ i + 1 ] ) i -- ;", "nl": "Find the index of first element such that arr [ i ] > arr [ i + 1 ]"}
{"code": "if ( i == - 1 ) { System . out . print ( \" - 1\" ) ; return ; } int j = N - 1 ;", "nl": "If the array is sorted in increasing order"}
{"code": "while ( j > i && arr [ j ] >= arr [ i ] ) j -- ;", "nl": "Find the index of first element which is smaller than arr [ i ]"}
{"code": "while ( j > i && arr [ j ] == arr [ j - 1 ] ) {", "nl": "If arr [ j ] = = arr [ j - 1 ]"}
{"code": "j -- ; }", "nl": "Decrement j"}
{"code": "int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ;", "nl": "Swap the element"}
{"code": "for ( int it : arr ) { System . out . print ( it + \" \u2581 \" ) ; } }", "nl": "Print the array arr [ ]"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 5 , 3 , 4 , 6 } ; findPermutation ( arr ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void sieveOfEratosthenes ( int N , int s [ ] ) {", "nl": "Function to find the smallest prime factor of all the numbers using Sieve Of Eratosthenes"}
{"code": "boolean [ ] prime = new boolean [ N + 1 ] ;", "nl": "Stores whether any number is prime or not"}
{"code": "for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ;", "nl": "Initialize smallest factor as 2 for all the even numbers"}
{"code": "for ( int i = 3 ; i <= N ; i += 2 ) {", "nl": "Iterate over the range [ 3 , N ]"}
{"code": "if ( prime [ i ] == false ) { s [ i ] = i ;", "nl": "If i is prime"}
{"code": "for ( int j = i ; j * i <= N ; j += 2 ) {", "nl": "Iterate all multiples of i"}
{"code": "if ( ! prime [ i * j ] ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }", "nl": "i is the smallest prime factor of i * j"}
{"code": "static void findDifference ( int N ) {", "nl": "Function to find the absolute difference between the count of odd and even factors of N"}
{"code": "int [ ] s = new int [ N + 1 ] ;", "nl": "Stores the smallest prime factor of i"}
{"code": "sieveOfEratosthenes ( N , s ) ;", "nl": "Fill values in s [ ] using sieve of eratosthenes"}
{"code": "int total = 1 , odd = 1 , even = 0 ;", "nl": "Stores the total number of factors and the total number of odd and even factors"}
{"code": "int curr = s [ N ] ;", "nl": "Store the current prime factor of the number N"}
{"code": "int cnt = 1 ;", "nl": "Store the power of current prime factor"}
{"code": "while ( N > 1 ) { N /= s [ N ] ;", "nl": "Loop while N is greater than 1"}
{"code": "if ( curr == s [ N ] ) { cnt ++ ; continue ; }", "nl": "If N also has smallest prime factor as curr , then increment cnt by 1"}
{"code": "if ( curr == 2 ) { total = total * ( cnt + 1 ) ; }", "nl": "Update only total number of factors if curr is 2"}
{"code": "else { total = total * ( cnt + 1 ) ; odd = odd * ( cnt + 1 ) ; }", "nl": "Update total number of factors and total number of odd factors"}
{"code": "curr = s [ N ] ; cnt = 1 ; }", "nl": "Update current prime factor as s [ N ] and count as 1"}
{"code": "even = total - odd ;", "nl": "Calculate the number of even factors"}
{"code": "System . out . print ( Math . abs ( even - odd ) ) ; }", "nl": "Print the difference"}
{"code": "public static void main ( String [ ] args ) { int N = 12 ; findDifference ( N ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void findMedian ( int Mean , int Mode ) {", "nl": "Function to find the median of a group of data with given mean and mode"}
{"code": "double Median = ( 2 * Mean + Mode ) / 3.0 ;", "nl": "Calculate the median"}
{"code": "System . out . print ( ( int ) Median ) ; }", "nl": "Print the median"}
{"code": "public static void main ( String [ ] args ) { int mode = 6 , mean = 3 ; findMedian ( mean , mode ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "private static double vectorMagnitude ( int x , int y , int z ) {", "nl": "Function to calculate magnitude of a 3 dimensional vector"}
{"code": "int sum = x * x + y * y + z * z ;", "nl": "Stores the sum of squares of coordinates of a vector"}
{"code": "return Math . sqrt ( sum ) ; }", "nl": "Return the magnitude"}
{"code": "public static void main ( String [ ] args ) { int x = 1 ; int y = 2 ; int z = 3 ; System . out . print ( vectorMagnitude ( x , y , z ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static long multiplyByMersenne ( long N , long M ) {", "nl": "Function to find prodcut of a Mersenne number with another number"}
{"code": "long x = ( int ) ( Math . log ( M + 1 ) / Math . log ( 2 ) ) ;", "nl": "Stores the power of 2 of integer M + 1"}
{"code": "return ( ( N << x ) - N ) ; }", "nl": "Return the product"}
{"code": "public static void main ( String [ ] args ) { long N = 4 ; long M = 15 ; System . out . print ( multiplyByMersenne ( N , M ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int perfectSquare ( int num ) {", "nl": "Function to find nearest perfect square of num"}
{"code": "int sr = ( int ) ( Math . sqrt ( num ) ) ;", "nl": "Calculate square root of num"}
{"code": "int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ;", "nl": "Calculate perfect square"}
{"code": "if ( ( num - a ) < ( b - num ) ) { return a ; } else { return b ; } }", "nl": "Find the nearest perfect square"}
{"code": "static int powerOfTwo ( int num ) {", "nl": "Function to find the power of 2 nearest to the number num"}
{"code": "int lg = ( int ) ( Math . log ( num ) / Math . log ( 2 ) ) ;", "nl": "Calculate log base 2 of num"}
{"code": "int p = ( int ) ( Math . pow ( 2 , lg ) ) ; return p ; }", "nl": "Highest power of 2 which is <= num"}
{"code": "static void uniqueElement ( int arr [ ] , int N ) { boolean ans = true ;", "nl": "Function to find the nearest perfect square and the nearest power of 2 of every array element whose occurrence is 1"}
{"code": "HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ;", "nl": "Stores frequency of array elements"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { if ( freq . containsKey ( arr [ i ] ) ) { freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } }", "nl": "Traverse the array and update frequency of current array element"}
{"code": "for ( Map . Entry < Integer , Integer > el : freq . entrySet ( ) ) {", "nl": "Traverse the map freq"}
{"code": "if ( el . getValue ( ) == 1 ) { ans = false ;", "nl": "If the frequency is 1"}
{"code": "int ps = perfectSquare ( el . getKey ( ) ) ;", "nl": "Find nearest perfect square"}
{"code": "System . out . print ( powerOfTwo ( ps ) + \" \u2581 \" ) ; } }", "nl": "Print the nearest power of 2"}
{"code": "if ( ans ) System . out . print ( \" - 1\" ) ; }", "nl": "If the any does not contain any non - repeating elements"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 4 , 11 , 4 , 3 , 4 } ; int N = arr . length ; uniqueElement ( arr , N ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program of the above approach"}
{"code": "static void partitionArray ( int a [ ] , int n ) {", "nl": "Function to partition the array into two non - empty subarrays which satisfies the given condition"}
{"code": "int min [ ] = new int [ n ] ;", "nl": "Stores the suffix min array"}
{"code": "int mini = Integer . MAX_VALUE ;", "nl": "Stores the minimum of a suffix"}
{"code": "for ( int i = n - 1 ; i >= 0 ; i -- ) {", "nl": "Traverse the array in reverse"}
{"code": "mini = Math . min ( mini , a [ i ] ) ;", "nl": "Update minimum"}
{"code": "min [ i ] = mini ; }", "nl": "Store the minimum"}
{"code": "int maxi = Integer . MIN_VALUE ;", "nl": "Stores the maximum value of a prefix"}
{"code": "int ind = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) {", "nl": "Stores the index of the partition"}
{"code": "maxi = Math . max ( maxi , a [ i ] ) ;", "nl": "Update max"}
{"code": "if ( maxi < min [ i + 1 ] ) {", "nl": "If max is less than min [ i + 1 ]"}
{"code": "ind = i ;", "nl": "Store the index of partition"}
{"code": "break ; } }", "nl": "break"}
{"code": "if ( ind != - 1 ) {", "nl": "If ind is not - 1"}
{"code": "for ( int i = 0 ; i <= ind ; i ++ ) System . out . print ( a [ i ] + \" \u2581 \" ) ; System . out . println ( ) ;", "nl": "Print the first subarray"}
{"code": "for ( int i = ind + 1 ; i < n ; i ++ ) System . out . print ( a [ i ] + \" \u2581 \" ) ; }", "nl": "Print the second subarray"}
{"code": "else System . out . println ( \" Impossible \" ) ; }", "nl": "Otherwise"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 2 , 7 , 9 } ; int N = arr . length ; partitionArray ( arr , N ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int countPrimeFactors ( int n ) { int count = 0 ;", "nl": "Function to count all prime factors of a given number"}
{"code": "while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; }", "nl": "Count the number of 2 s that divides n"}
{"code": "for ( int i = 3 ; i <= ( int ) Math . sqrt ( n ) ; i = i + 2 ) {", "nl": "Since n is odd at this point , skip one element"}
{"code": "while ( n % i == 0 ) { n = n / i ; count ++ ; } }", "nl": "While i divides n , count i and divide n"}
{"code": "if ( n > 2 ) count ++ ; return ( count ) ; }", "nl": "If n is a prime number greater than 2"}
{"code": "static int findSum ( int n ) {", "nl": "Function to find the sum of first n nearly prime numbers"}
{"code": "int sum = 0 ; for ( int i = 1 , num = 2 ; i <= n ; num ++ ) {", "nl": "Store the required sum"}
{"code": "if ( countPrimeFactors ( num ) == 2 ) { sum += num ;", "nl": "Add this number if it is satisfies the condition"}
{"code": "i ++ ; } } return sum ; }", "nl": "Increment count of nearly prime numbers"}
{"code": "static void check ( int n , int k ) {", "nl": "Function to check if N can be represented as sum of K different positive integers out of which at least K - 1 of them are nearly prime"}
{"code": "int s = findSum ( k - 1 ) ;", "nl": "Store the sum of first K - 1 nearly prime numbers"}
{"code": "if ( s >= n ) System . out . print ( \" No \" ) ;", "nl": "If sum is greater than or equal to n"}
{"code": "else System . out . print ( \" Yes \" ) ; }", "nl": "Otherwise , print Yes"}
{"code": "public static void main ( String [ ] args ) { int n = 100 , k = 6 ; check ( n , k ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int gcd ( int a , int b ) {", "nl": "Function to calculate GCD of a and b using Euclidean Algorithm"}
{"code": "while ( b > 0 ) { int rem = a % b ; a = b ; b = rem ; }", "nl": "Iterate until b is non - zero"}
{"code": "return a ; }", "nl": "Return the GCD"}
{"code": "static int countNumberOfWays ( int n ) {", "nl": "Function to count the number of ways N can be expressed as x ^ y"}
{"code": "if ( n == 1 ) return - 1 ;", "nl": "Base Case"}
{"code": "int g = 0 ; int power = 0 ;", "nl": "Stores the gcd of powers"}
{"code": "while ( n % 2 == 0 ) { power ++ ; n /= 2 ; } g = gcd ( g , power ) ;", "nl": "Calculate the degree of 2 in N"}
{"code": "for ( int i = 3 ; i <= ( int ) Math . sqrt ( n ) ; i += 2 ) { power = 0 ;", "nl": "Calculate the degree of prime numbers in N"}
{"code": "while ( n % i == 0 ) { power ++ ; n /= i ; } g = gcd ( g , power ) ; }", "nl": "Calculate the degree of prime ' i ' in N"}
{"code": "if ( n > 2 ) g = gcd ( g , 1 ) ;", "nl": "If N is a prime , g becomes 1."}
{"code": "int ways = 1 ;", "nl": "Stores the number of ways to represent N as x ^ y"}
{"code": "power = 0 ; while ( g % 2 == 0 ) { g /= 2 ; power ++ ; }", "nl": "Find the number of Factors of g"}
{"code": "ways *= ( power + 1 ) ;", "nl": "Update the count of ways"}
{"code": "for ( int i = 3 ; i <= ( int ) Math . sqrt ( g ) ; i += 2 ) { power = 0 ;", "nl": "Iterate to find rest of the prime numbers"}
{"code": "while ( g % i == 0 ) { power ++ ; g /= i ; }", "nl": "Find the power of i"}
{"code": "ways *= ( power + 1 ) ; }", "nl": "Update the count of ways"}
{"code": "if ( g > 2 ) ways *= 2 ;", "nl": "If g is prime"}
{"code": "return ways ; }", "nl": "Return the total number of ways"}
{"code": "public static void main ( String [ ] args ) { int N = 64 ; System . out . print ( countNumberOfWays ( N ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static int powOfPositive ( int n ) {", "nl": "Function to return the lowest power of 2 close to given positive number"}
{"code": "int pos = ( int ) Math . floor ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ; return ( int ) Math . pow ( 2 , pos ) ; }", "nl": "Floor function is used to determine the value close to the number"}
{"code": "static int powOfNegative ( int n ) {", "nl": "Function to return the lowest power of 2 close to given negative number"}
{"code": "int pos = ( int ) Math . ceil ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ; return ( int ) ( - 1 * Math . pow ( 2 , pos ) ) ; }", "nl": "Ceil function is used for negative numbers as - 1 > - 4. It would be opposite to positive numbers where 1 < 4"}
{"code": "static void highestPowerOf2 ( int n ) {", "nl": "Function to find the highest power of 2"}
{"code": "if ( n > 0 ) { System . out . println ( powOfPositive ( n ) ) ; } else {", "nl": "To check if the given number is positive or negative"}
{"code": "n = - n ; System . out . println ( powOfNegative ( n ) ) ; } }", "nl": "If the number is negative , then the ceil of the positive number is calculated and negative sign is added"}
{"code": "public static void main ( String [ ] args ) { int n = - 24 ; highestPowerOf2 ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . lang . * ; class GFG {", "nl": "Java implementation of the above approach"}
{"code": "public static int noOfCards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; }", "nl": "Function to find number of cards needed"}
{"code": "public static void main ( String args [ ] ) { int n = 3 ; System . out . print ( noOfCards ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static String smallestPoss ( String s , int n ) {", "nl": "Function for finding the smallest possible number after swapping the digits any number of times"}
{"code": "String ans = \" \" ;", "nl": "Variable to store the final answer"}
{"code": "int arr [ ] = new int [ 10 ] ;", "nl": "Array to store the count of occurrence of each digit"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { arr [ s . charAt ( i ) - 48 ] ++ ; }", "nl": "Loop to calculate the number of occurrences of every digit"}
{"code": "for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < arr [ i ] ; j ++ ) ans = ans + String . valueOf ( i ) ; }", "nl": "Loop to get smallest number"}
{"code": "return ans ; }", "nl": "Returning the answer"}
{"code": "public static void main ( String [ ] args ) { int N = 15 ; String K = \"325343273113434\" ; System . out . print ( smallestPoss ( K , N ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static int Count_subarray ( int arr [ ] , int n ) { int subarray_sum , remaining_sum , count = 0 ;", "nl": "Function to count the number of sub - arrays with sum strictly greater than the remaining elements of array"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "For loop for beginning point of a subarray"}
{"code": "for ( int j = i ; j < n ; j ++ ) {", "nl": "For loop for ending point of the subarray"}
{"code": "subarray_sum = 0 ; remaining_sum = 0 ;", "nl": "Initialise subarray_sum and remaining_sum to 0"}
{"code": "for ( int k = i ; k <= j ; k ++ ) { subarray_sum += arr [ k ] ; }", "nl": "For loop to calculate the sum of generated subarray"}
{"code": "for ( int l = 0 ; l < i ; l ++ ) { remaining_sum += arr [ l ] ; } for ( int l = j + 1 ; l < n ; l ++ ) { remaining_sum += arr [ l ] ; }", "nl": "For loop to calculate the sum remaining array element"}
{"code": "if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; }", "nl": "Checking for condition when subarray sum is strictly greater than remaining sum of array element"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = arr . length ; System . out . print ( Count_subarray ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int Count_subarray ( int arr [ ] , int n ) { int total_sum = 0 , subarray_sum , remaining_sum , count = 0 ;", "nl": "Java implementation of the above approach"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { total_sum += arr [ i ] ; }", "nl": "Calculating total sum of given array"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "For loop for beginning point of a subarray"}
{"code": "subarray_sum = 0 ;", "nl": "initialise subarray_sum to 0"}
{"code": "for ( int j = i ; j < n ; j ++ ) {", "nl": "For loop for calculating subarray_sum and remaining_sum"}
{"code": "subarray_sum += arr [ j ] ; remaining_sum = total_sum - subarray_sum ;", "nl": "Calculating subarray_sum and corresponding remaining_sum"}
{"code": "if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; }", "nl": "Checking for the condition when subarray sum is strictly greater than the remaining sum of the array element"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = arr . length ; System . out . print ( Count_subarray ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int maxXOR ( int arr [ ] , int n ) {", "nl": "Function to return the maximized XOR after removing an element from the array"}
{"code": "int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ;", "nl": "Find XOR of the complete array"}
{"code": "int ans = 0 ;", "nl": "To store the final answer"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , ( xorArr ^ arr [ i ] ) ) ;", "nl": "Iterating through the array to find the final answer"}
{"code": "return ans ; }", "nl": "Return the final answer"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 3 } ; int n = arr . length ; System . out . println ( maxXOR ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static boolean digitDividesK ( int num , int k ) { while ( num != 0 ) {", "nl": "Function that returns true if num contains at least one digit that divides k"}
{"code": "int d = num % 10 ;", "nl": "Get the last digit"}
{"code": "if ( d != 0 && k % d == 0 ) return true ;", "nl": "If the digit is non - zero and it divides k"}
{"code": "num = num / 10 ; }", "nl": "Remove the last digit"}
{"code": "return false ; }", "nl": "There is no digit in num that divides k"}
{"code": "static int findCount ( int l , int r , int k ) {", "nl": "Function to return the required count of elements from the given range which contain at least one digit that divides k"}
{"code": "int count = 0 ;", "nl": "To store the result"}
{"code": "for ( int i = l ; i <= r ; i ++ ) {", "nl": "For every number from the range"}
{"code": "if ( digitDividesK ( i , k ) ) count ++ ; } return count ; }", "nl": "If any digit of the current number divides k"}
{"code": "public static void main ( String [ ] args ) { int l = 20 , r = 35 ; int k = 45 ; System . out . println ( findCount ( l , r , k ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation for the above approach"}
{"code": "static boolean isFactorial ( int n ) { for ( int i = 1 ; ; i ++ ) { if ( n % i == 0 ) { n /= i ; } else { break ; } } if ( n == 1 ) { return true ; } else { return false ; } }", "nl": "Function to check if the given number is a factorial of any number"}
{"code": "public static void main ( String [ ] args ) { int n = 24 ; boolean ans = isFactorial ( n ) ; if ( ans == true ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java implementation of the above approach"}
{"code": "static int lcm ( int a , int b ) { int GCD = __gcd ( a , b ) ; return ( a * b ) / GCD ; }", "nl": "Function to return the LCM of two numbers"}
{"code": "static int MinLCM ( int a [ ] , int n ) {", "nl": "Function to return the minimum LCM after removing a single element from the given array"}
{"code": "int [ ] Prefix = new int [ n + 2 ] ; int [ ] Suffix = new int [ n + 2 ] ;", "nl": "Prefix and Suffix arrays"}
{"code": "Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = lcm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; }", "nl": "Single state dynamic programming relation for storing LCM of first i elements from the left in Prefix [ i ]"}
{"code": "Suffix [ n ] = a [ n - 1 ] ;", "nl": "Initializing Suffix array"}
{"code": "for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = lcm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; }", "nl": "Single state dynamic programming relation for storing LCM of all the elements having index greater than or equal to i in Suffix [ i ]"}
{"code": "int ans = Math . min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ;", "nl": "If first or last element of the array has to be removed"}
{"code": "for ( int i = 2 ; i < n ; i += 1 ) { ans = Math . min ( ans , lcm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; }", "nl": "If any other element is replaced"}
{"code": "return ans ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; }", "nl": "Return the minimum LCM"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 5 , 15 , 9 , 36 } ; int n = a . length ; System . out . println ( MinLCM ( a , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; }", "nl": "Function to return the count of coloured 0 s in an n - level hexagon"}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( count ( n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int findMinValue ( int arr [ ] , int n ) {", "nl": "Function to return the minimum required value"}
{"code": "long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ;", "nl": "Find the sum of the array elements"}
{"code": "return ( ( int ) ( sum / n ) + 1 ) ; }", "nl": "Return the required value"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; int n = arr . length ; System . out . print ( findMinValue ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static final int MOD = 1000000007 ;", "nl": "Java implementation of the above approach"}
{"code": "static int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; }", "nl": "Function to return ( m ! % MOD )"}
{"code": "public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( modFact ( n , m ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static final int mod = ( int ) ( 1e9 + 7 ) ;", "nl": "Java implementation of the approach"}
{"code": "static long power ( int p ) { long res = 1 ; for ( int i = 1 ; i <= p ; ++ i ) { res *= 2 ; res %= mod ; } return res % mod ; }", "nl": "Function to return ( 2 ^ P % mod )"}
{"code": "static long subset_square_sum ( int A [ ] ) { int n = A . length ; long ans = 0 ;", "nl": "Function to return the sum of squares of subsets"}
{"code": "for ( int i : A ) { ans += ( 1 * i * i ) % mod ; ans %= mod ; } return ( 1 * ans * power ( n - 1 ) ) % mod ; }", "nl": "Sqauaring the elements and adding it to ans"}
{"code": "public static void main ( String [ ] args ) { int A [ ] = { 3 , 7 } ; System . out . println ( subset_square_sum ( A ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int N = 100050 ; static int [ ] lpf = new int [ N ] ; static int [ ] mobius = new int [ N ] ;", "nl": "Java program to find the number of pairs such that gcd equals to 1"}
{"code": "static void least_prime_factor ( ) { for ( int i = 2 ; i < N ; i ++ )", "nl": "Function to calculate least prime factor of each number"}
{"code": "if ( lpf [ i ] == 0 ) for ( int j = i ; j < N ; j += i )", "nl": "If it is a prime number"}
{"code": "if ( lpf [ j ] == 0 ) lpf [ j ] = i ; }", "nl": "For all multiples which are not visited yet ."}
{"code": "static void Mobius ( ) { for ( int i = 1 ; i < N ; i ++ ) {", "nl": "Function to find the value of Mobius function for all the numbers from 1 to n"}
{"code": "if ( i == 1 ) mobius [ i ] = 1 ; else {", "nl": "If number is one"}
{"code": "if ( lpf [ i / lpf [ i ] ] == lpf [ i ] ) mobius [ i ] = 0 ;", "nl": "If number has a squared prime factor"}
{"code": "else mobius [ i ] = - 1 * mobius [ i / lpf [ i ] ] ; } } }", "nl": "Multiply - 1 with the previous number"}
{"code": "static int gcd_pairs ( int a [ ] , int n ) {", "nl": "Function to find the number of pairs such that gcd equals to 1"}
{"code": "int maxi = 0 ;", "nl": "To store maximum number"}
{"code": "int [ ] fre = new int [ N ] ;", "nl": "To store frequency of each number"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { fre [ a [ i ] ] ++ ; maxi = Math . max ( a [ i ] , maxi ) ; } least_prime_factor ( ) ; Mobius ( ) ;", "nl": "Find frequency and maximum number"}
{"code": "int ans = 0 ;", "nl": "To store number of pairs with gcd equals to 1"}
{"code": "for ( int i = 1 ; i <= maxi ; i ++ ) { if ( mobius [ i ] == 0 ) continue ; int temp = 0 ; for ( int j = i ; j <= maxi ; j += i ) temp += fre [ j ] ; ans += temp * ( temp - 1 ) / 2 * mobius [ i ] ; }", "nl": "Traverse through the all possible elements"}
{"code": "return ans ; }", "nl": "Return the number of pairs"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = a . length ;", "nl": "Driver code"}
{"code": "System . out . print ( gcd_pairs ( a , n ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void compareVal ( int x , int y ) {", "nl": "Function to compare x ^ y and y ^ x"}
{"code": "double a = y * Math . log ( x ) ; double b = x * Math . log ( y ) ;", "nl": "Storing values OF x ^ y AND y ^ x"}
{"code": "if ( a > b ) System . out . print ( x + \" ^ \" + y + \" \u2581 > \u2581 \" + y + \" ^ \" + x ) ; else if ( a < b ) System . out . print ( x + \" ^ \" + y + \" \u2581 < \u2581 \" + y + \" ^ \" + x ) ; else if ( a == b ) System . out . print ( x + \" ^ \" + y + \" \u2581 = \u2581 \" + y + \" ^ \" + x ) ; }", "nl": "Comparing values"}
{"code": "public static void main ( String [ ] args ) { int x = 4 , y = 5 ; compareVal ( x , y ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {", "nl": "Java program to find zigzag sequence"}
{"code": "static void ZigZag ( int n ) {", "nl": "Function to print first n zigzag numbers"}
{"code": "long [ ] fact = new long [ n + 1 ] ; long [ ] zig = new long [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) zig [ i ] = 0 ;", "nl": "To store factorial and n 'th zig zag number"}
{"code": "fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ;", "nl": "Initialize factorial upto n"}
{"code": "zig [ 0 ] = 1 ; zig [ 1 ] = 1 ; System . out . print ( \" zig \u2581 zag \u2581 numbers : \u2581 \" ) ;", "nl": "Set first two zig zag numbers"}
{"code": "System . out . print ( zig [ 0 ] + \" \u2581 \" + zig [ 1 ] + \" \u2581 \" ) ;", "nl": "Print first two zig zag number"}
{"code": "for ( int i = 2 ; i < n ; i ++ ) { long sum = 0 ; for ( int k = 0 ; k <= i - 1 ; k ++ ) {", "nl": "Print the rest zig zag numbers"}
{"code": "sum += ( fact [ i - 1 ] / ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ; }", "nl": "Binomial ( n , k ) * a ( k ) * a ( n - k )"}
{"code": "zig [ i ] = sum / 2 ;", "nl": "Store the value"}
{"code": "System . out . print ( sum / 2 + \" \u2581 \" ) ; } }", "nl": "Print the number"}
{"code": "public static void main ( String [ ] args ) throws java . lang . Exception { int n = 10 ;", "nl": "Driver code"}
{"code": "ZigZag ( n ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to demonstrate Gijswijt 's sequence"}
{"code": "static int find_count ( Vector < Integer > ele ) {", "nl": "if the sequence is a ( 1 ) a ( 2 ) a ( 3 ) . . a ( n - 1 ) check if the sequence can be represented as x * ( y ^ k ) find the largest value of k"}
{"code": "int count = 0 ; for ( int i = 0 ; i < ele . size ( ) ; i ++ ) {", "nl": "count"}
{"code": "Vector < Integer > p = new Vector < Integer > ( ) ;", "nl": "pattern of elements of size i from the end of sequence"}
{"code": "int c = 0 ;", "nl": "count"}
{"code": "for ( int j = ele . size ( ) - 1 ; j >= ( ele . size ( ) - 1 - i ) && j >= 0 ; j -- ) { p . add ( ele . get ( j ) ) ; } int j = ele . size ( ) - 1 , k = 0 ;", "nl": "extract the pattern in a reverse order"}
{"code": "while ( j >= 0 ) {", "nl": "check how many times the pattern is repeated"}
{"code": "if ( ele . get ( j ) != p . get ( k ) ) { break ; } j -- ; k ++ ;", "nl": "if the element dosent match"}
{"code": "if ( k == p . size ( ) ) { c ++ ; k = 0 ; } } count = Math . max ( count , c ) ; }", "nl": "if the end of pattern is reached set value of k = 0 and increase the count"}
{"code": "return count ; }", "nl": "return the max count"}
{"code": "static void solve ( int n ) {", "nl": "print first n terms of Gijswijt 's sequence"}
{"code": "int count = 1 ;", "nl": "set the count"}
{"code": "Vector < Integer > ele = new Vector < Integer > ( ) ;", "nl": "stoes the element"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( count + \" , \u2581 \" ) ;", "nl": "print the first n terms of the sequence"}
{"code": "ele . add ( count ) ;", "nl": "push the element"}
{"code": "count = find_count ( ele ) ; } }", "nl": "find the count for next number"}
{"code": "public static void main ( String [ ] args ) { int n = 10 ; solve ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find N terms of the sequence"}
{"code": "static HashMap < Integer , Integer > store = new HashMap < Integer , Integer > ( ) ;", "nl": "Stores the Wedderburn Etherington numbers"}
{"code": "static int Wedderburn ( int n ) {", "nl": "Function to return the nth Wedderburn Etherington numbers"}
{"code": "if ( n <= 2 ) return store . get ( n ) ;", "nl": "Base case"}
{"code": "else if ( n % 2 == 0 ) {", "nl": "If n is even n = 2 x"}
{"code": "int x = n / 2 , ans = 0 ;", "nl": "get x"}
{"code": "for ( int i = 1 ; i < x ; i ++ ) { ans += store . get ( i ) * store . get ( n - i ) ; }", "nl": "a ( 2 x ) = a ( 1 ) a ( 2 x - 1 ) + a ( 2 ) a ( 2 x - 2 ) + ... + a ( x - 1 ) a ( x + 1 )"}
{"code": "ans += ( store . get ( x ) * ( store . get ( x ) + 1 ) ) / 2 ;", "nl": "a ( x ) ( a ( x ) + 1 ) / 2"}
{"code": "store . put ( n , ans ) ;", "nl": "Store the ans"}
{"code": "return ans ; } else {", "nl": "Return the required answer"}
{"code": "int x = ( n + 1 ) / 2 , ans = 0 ;", "nl": "If n is odd"}
{"code": "for ( int i = 1 ; i < x ; i ++ ) { ans += store . get ( i ) * store . get ( n - i ) ; }", "nl": "a ( 2 x - 1 ) = a ( 1 ) a ( 2 x - 2 ) + a ( 2 ) a ( 2 x - 3 ) + ... + a ( x - 1 ) a ( x ) ,"}
{"code": "store . put ( n , ans ) ;", "nl": "Store the ans"}
{"code": "return ans ; } }", "nl": "Return the required answer"}
{"code": "static void Wedderburn_Etherington ( int n ) {", "nl": "Function to print first N Wedderburn Etherington numbers"}
{"code": "store . put ( 0 , 0 ) ; store . put ( 1 , 1 ) ; store . put ( 2 , 1 ) ;", "nl": "Store first 3 numbers"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( Wedderburn ( i ) ) ; if ( i != n - 1 ) System . out . print ( \" \u2581 \" ) ; } }", "nl": "Print N terms"}
{"code": "public static void main ( String [ ] args ) { int n = 10 ;", "nl": "Driver code"}
{"code": "Wedderburn_Etherington ( n ) ; } }", "nl": "function call"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to maximum value after merging all elements in the array"}
{"code": "static int Max_sum ( int a [ ] , int n ) {", "nl": "Function to maximum value after merging all elements in the array"}
{"code": "int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "To check if positive and negative elements present or not"}
{"code": "if ( a [ i ] > 0 ) pos = 1 ;", "nl": "Check for positive integer"}
{"code": "else if ( a [ i ] < 0 ) neg = 1 ;", "nl": "Check for negative integer"}
{"code": "if ( ( pos == 1 ) && ( neg == 1 ) ) break ; }", "nl": "If both positive and negative elements are present"}
{"code": "int sum = 0 ; if ( ( pos == 1 ) && ( neg == 1 ) ) { for ( int i = 0 ; i < n ; i ++ ) sum += Math . abs ( a [ i ] ) ; } else if ( pos == 1 ) {", "nl": "To store maximum value possible"}
{"code": "int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; sum += a [ i ] ; }", "nl": "To find minimum value"}
{"code": "sum -= 2 * mini ; } else if ( neg == 1 ) {", "nl": "Remove minimum element"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ;", "nl": "Replace with absolute values"}
{"code": "int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; sum += a [ i ] ; }", "nl": "To find minimum value"}
{"code": "sum -= 2 * mini ; }", "nl": "Remove minimum element"}
{"code": "return sum ; }", "nl": "Return the required sum"}
{"code": "public static void main ( String [ ] args ) { int [ ] a = { 1 , 3 , 5 , - 2 , - 6 } ; int n = a . length ;", "nl": "Driver code"}
{"code": "System . out . println ( Max_sum ( a , n ) ) ; } }", "nl": "Function call"}
{"code": "import java . io . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void decimalToBinary ( int n ) {", "nl": "Recursive function to convert n to its binary equivalent"}
{"code": "if ( n == 0 ) { System . out . print ( \"0\" ) ; return ; }", "nl": "Base case"}
{"code": "decimalToBinary ( n / 2 ) ; System . out . print ( n % 2 ) ; }", "nl": "Recursive call"}
{"code": "public static void main ( String [ ] args ) { int n = 13 ; decimalToBinary ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void MinimumValue ( int x , int y ) {", "nl": "Function to find A , B and C"}
{"code": "if ( x > y ) { int temp = x ; x = y ; y = temp ; }", "nl": "Keep minimum number in x"}
{"code": "int a = 1 ; int b = x - 1 ; int c = y - b ; System . out . print ( a + \" \u2581 \" + b + \" \u2581 \" + c ) ; }", "nl": "Find the numbers"}
{"code": "public static void main ( String [ ] args ) { int x = 123 , y = 13 ;", "nl": "Driver code"}
{"code": "MinimumValue ( x , y ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static boolean canConvert ( int a , int b ) { while ( b > a ) {", "nl": "Function that returns true if A can be converted to B with the given operations"}
{"code": "if ( b % 10 == 1 ) { b /= 10 ; continue ; }", "nl": "If the current number ends with 1"}
{"code": "if ( b % 2 == 0 ) { b /= 2 ; continue ; }", "nl": "If the current number is divisible by 2"}
{"code": "return false ; }", "nl": "If above two conditions fail"}
{"code": "if ( b == a ) return true ; return false ; }", "nl": "If it is possible to convert A to B"}
{"code": "public static void main ( String [ ] args ) { int A = 2 , B = 82 ; if ( canConvert ( A , B ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "class Rectangle {", "nl": "Java program to count unique rectangles in a chessboard"}
{"code": "static int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; }", "nl": "Function to count distinct rectangles"}
{"code": "public static void main ( String args [ ] ) { int n = 4 ; System . out . print ( count ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; }", "nl": "Function to return the number of days required"}
{"code": "public static void main ( String [ ] args ) { int a = 10 , b = 20 , n = 5 ; System . out . println ( numberOfDays ( a , b , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int getAverage ( int x , int y ) {", "nl": "Function to return the average of x and y using bit operations"}
{"code": "int avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; }", "nl": "Calculate the average Floor value of ( x + y ) / 2"}
{"code": "public static void main ( String [ ] args ) { int x = 10 , y = 9 ; System . out . print ( getAverage ( x , y ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int smallestIndex ( int [ ] a , int n ) {", "nl": "Function to find the smallest index such that there are no 0 or 1 to its right"}
{"code": "int right1 = 0 , right0 = 0 ;", "nl": "Initially"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse in the array"}
{"code": "if ( a [ i ] == 1 ) right1 = i ;", "nl": "Check if array element is 1"}
{"code": "else right0 = i ; }", "nl": "a [ i ] = 0"}
{"code": "return Math . min ( right1 , right0 ) ; }", "nl": "Return minimum of both"}
{"code": "public static void main ( String [ ] args ) { int [ ] a = { 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int n = a . length ; System . out . println ( smallestIndex ( a , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int countSquares ( int r , int c , int m ) {", "nl": "Function to return the count of squares that can be visited by king in m moves"}
{"code": "int squares = 0 ;", "nl": "To store the count of squares"}
{"code": "for ( int i = 1 ; i <= 8 ; i ++ ) { for ( int j = 1 ; j <= 8 ; j ++ ) {", "nl": "Check all squares of the chessboard"}
{"code": "if ( Math . max ( Math . abs ( i - r ) , Math . abs ( j - c ) ) <= m ) squares ++ ; } }", "nl": "Check if square ( i , j ) is at a distance <= m units from king 's current position"}
{"code": "return squares ; }", "nl": "Return count of squares"}
{"code": "public static void main ( String [ ] args ) { int r = 4 , c = 4 , m = 1 ; System . out . print ( countSquares ( r , c , m ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int countQuadruples ( int a [ ] , int n ) {", "nl": "Function to return the count of quadruples"}
{"code": "HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ;", "nl": "Hash table to count the number of occurrences"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( a [ i ] ) ) { mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . put ( a [ i ] , 1 ) ; } int count = 0 ;", "nl": "Traverse and increment the count"}
{"code": "for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) {", "nl": "Run two nested loop for second and third element"}
{"code": "if ( j == k ) continue ;", "nl": "If they are same"}
{"code": "mp . put ( a [ j ] , mp . get ( a [ j ] ) - 1 ) ; mp . put ( a [ k ] , mp . get ( a [ k ] ) - 1 ) ;", "nl": "Initially decrease the count"}
{"code": "int first = a [ j ] - ( a [ k ] - a [ j ] ) ;", "nl": "Find the first element using common difference"}
{"code": "int fourth = ( a [ k ] * a [ k ] ) / a [ j ] ;", "nl": "Find the fourth element using GP y ^ 2 = x * z property"}
{"code": "if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) {", "nl": "If it is an integer"}
{"code": "if ( a [ j ] != a [ k ] ) { if ( mp . containsKey ( first ) && mp . containsKey ( fourth ) ) count += mp . get ( first ) * mp . get ( fourth ) ; }", "nl": "If not equal"}
{"code": "else if ( mp . containsKey ( first ) && mp . containsKey ( fourth ) ) count += mp . get ( first ) * ( mp . get ( fourth ) - 1 ) ; }", "nl": "Same elements"}
{"code": "if ( mp . containsKey ( a [ j ] ) ) { mp . put ( a [ j ] , mp . get ( a [ j ] ) + 1 ) ; } else { mp . put ( a [ j ] , 1 ) ; } if ( mp . containsKey ( a [ k ] ) ) { mp . put ( a [ k ] , mp . get ( a [ k ] ) + 1 ) ; } else { mp . put ( a [ k ] , 1 ) ; } } } return count ; }", "nl": "Later increase the value for future calculations"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 2 , 6 , 4 , 9 , 2 } ; int n = a . length ; System . out . print ( countQuadruples ( a , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int countNumbers ( int L , int R , int K ) { if ( K == 9 ) { K = 0 ; }", "nl": "Function to return the count of required numbers"}
{"code": "int totalnumbers = R - L + 1 ;", "nl": "Count of numbers present in given range"}
{"code": "int factor9 = totalnumbers / 9 ;", "nl": "Number of groups of 9 elements starting from L"}
{"code": "int rem = totalnumbers % 9 ;", "nl": "Left over elements not covered in factor 9"}
{"code": "int ans = factor9 ;", "nl": "One Number in each group of 9"}
{"code": "for ( int i = R ; i > R - rem ; i -- ) { int rem1 = i % 9 ; if ( rem1 == K ) { ans ++ ; } } return ans ; }", "nl": "To check if any number in rem satisfy the property"}
{"code": "public static void main ( String [ ] args ) { int L = 10 ; int R = 22 ; int K = 3 ; System . out . println ( countNumbers ( L , R , K ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int EvenSum ( int [ ] A , int index , int value ) {", "nl": "Function to return the sum of even elements after updating value at given index"}
{"code": "A [ index ] = A [ index ] + value ;", "nl": "Add given value to A [ index ]"}
{"code": "int sum = 0 ; for ( int i = 0 ; i < A . length ; i ++ )", "nl": "To store the sum of even elements"}
{"code": "if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; return sum ; }", "nl": "If current element is even"}
{"code": "static void BalanceArray ( int [ ] A , int [ ] [ ] Q ) {", "nl": "Function to print the result for every query"}
{"code": "int [ ] ANS = new int [ Q . length ] ; int i , sum ; for ( i = 0 ; i < Q . length ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ;", "nl": "Resultant vector that stores the result for every query"}
{"code": "sum = EvenSum ( A , index , value ) ;", "nl": "Get sum of even elements after updating value at given index"}
{"code": "ANS [ i ] = sum ; }", "nl": "Store sum for each query"}
{"code": "for ( i = 0 ; i < ANS . length ; i ++ ) System . out . print ( ANS [ i ] + \" \u2581 \" ) ; }", "nl": "Print the result for every query"}
{"code": "public static void main ( String [ ] args ) { int [ ] A = { 1 , 2 , 3 , 4 } ; int [ ] [ ] Q = { { 0 , 1 } , { 1 , - 3 } , { 0 , - 4 } , { 3 , 2 } } ; BalanceArray ( A , Q ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void BalanceArray ( int [ ] A , int [ ] [ ] Q ) { int [ ] ANS = new int [ A . length ] ; int i , sum = 0 ; for ( i = 0 ; i < A . length ; i ++ )", "nl": "Function to print the result for every query"}
{"code": "if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . length ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ;", "nl": "If current element is even"}
{"code": "if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ;", "nl": "If element is even then remove it from sum"}
{"code": "if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ;", "nl": "If the value becomes even after updating"}
{"code": "ANS [ i ] = sum ; }", "nl": "Store sum for each query"}
{"code": "for ( i = 0 ; i < ANS . length ; i ++ ) System . out . print ( ANS [ i ] + \" \u2581 \" ) ; }", "nl": "Print the result for every query"}
{"code": "public static void main ( String [ ] args ) { int [ ] A = { 1 , 2 , 3 , 4 } ; int [ ] [ ] Q = { { 0 , 1 } , { 1 , - 3 } , { 0 , - 4 } , { 3 , 2 } } ; BalanceArray ( A , Q ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program for implementation of the above program"}
{"code": "static int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ;", "nl": "Function that calculates number of Hamiltonian cycle"}
{"code": "int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; }", "nl": "Calculating factorial"}
{"code": "public static void main ( String [ ] args ) { int N = 5 ; int Number = Cycles ( N ) ; System . out . println ( \" Hamiltonian \u2581 cycles \u2581 = \u2581 \" + Number ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static boolean digitWell ( int n , int m , int k ) { int cnt = 0 ; while ( n > 0 ) { if ( n % 10 == m ) ++ cnt ; n /= 10 ; } return cnt == k ; }", "nl": "Function that returns true if n contains digit m exactly k times"}
{"code": "static int findInt ( int n , int m , int k ) { int i = n + 1 ; while ( true ) { if ( digitWell ( i , m , k ) ) return i ; i ++ ; } }", "nl": "Function to return the smallest integer > n with digit m occurring exactly k times"}
{"code": "public static void main ( String [ ] args ) { int n = 111 , m = 2 , k = 2 ; System . out . println ( findInt ( n , m , k ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int countOdd ( int [ ] arr , int n ) {", "nl": "Function to return the count of odd numbers in the array"}
{"code": "int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Variable to count odd numbers"}
{"code": "if ( arr [ i ] % 2 == 1 ) odd ++ ; } return odd ; }", "nl": "Odd number"}
{"code": "static int countValidPairs ( int [ ] arr , int n ) { int odd = countOdd ( arr , n ) ; return ( odd * ( odd - 1 ) ) / 2 ; }", "nl": "Function to return the count of valid pairs"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( countValidPairs ( arr , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }", "nl": "Function to return the gcd of two numbers"}
{"code": "static int lcmOfArray ( int arr [ ] , int n ) { if ( n < 1 ) return 0 ; int lcm = arr [ 0 ] ;", "nl": "Function to return the lcm of aint the elements of the array"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ;", "nl": "To calculate lcm of two numbers multiply them and divide the result by gcd of both the numbers"}
{"code": "return lcm ; }", "nl": "Return the LCM of the array elements"}
{"code": "static int minPerfectCube ( int arr [ ] , int n ) { int minPerfectCube ;", "nl": "Function to return the smaintest perfect cube divisible by aint the elements of arr [ ]"}
{"code": "int lcm = lcmOfArray ( arr , n ) ; minPerfectCube = lcm ; int cnt = 0 ; while ( lcm > 1 && lcm % 2 == 0 ) { cnt ++ ; lcm /= 2 ; }", "nl": "LCM of all the elements of arr [ ]"}
{"code": "if ( cnt % 3 == 2 ) minPerfectCube *= 2 ; else if ( cnt % 3 == 1 ) minPerfectCube *= 4 ; int i = 3 ;", "nl": "If 2 divides lcm cnt number of times"}
{"code": "while ( lcm > 1 ) { cnt = 0 ; while ( lcm % i == 0 ) { cnt ++ ; lcm /= i ; } if ( cnt % 3 == 1 ) minPerfectCube *= i * i ; else if ( cnt % 3 == 2 ) minPerfectCube *= i ; i += 2 ; }", "nl": "Check aint the numbers that divide lcm"}
{"code": "return minPerfectCube ; }", "nl": "Return the answer"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 10 , 125 , 14 , 42 , 100 } ; int n = arr . length ; System . out . println ( minPerfectCube ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to check if given number is strong prime"}
{"code": "static boolean isPrime ( int n ) {", "nl": "Utility function to check if a number is prime or not"}
{"code": "if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;", "nl": "Corner cases"}
{"code": "if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }", "nl": "This is checked so that we can skip middle five numbers in below loop"}
{"code": "static boolean isStrongPrime ( int n ) {", "nl": "Function that returns true if n is a strong prime"}
{"code": "if ( ! isPrime ( n ) n == 2 ) return false ;", "nl": "If n is not a prime number or n is the first prime then return false"}
{"code": "int previous_prime = n - 1 ; int next_prime = n + 1 ;", "nl": "Initialize previous_prime to n - 1 and next_prime to n + 1"}
{"code": "while ( ! isPrime ( next_prime ) ) next_prime ++ ;", "nl": "Find next prime number"}
{"code": "while ( ! isPrime ( previous_prime ) ) previous_prime -- ;", "nl": "Find previous prime number"}
{"code": "int mean = ( previous_prime + next_prime ) / 2 ;", "nl": "Arithmetic mean"}
{"code": "if ( n > mean ) return true ; else return false ; }", "nl": "If n is a strong prime"}
{"code": "public static void main ( String args [ ] ) { int n = 11 ; if ( isStrongPrime ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "public class GFG {", "nl": "Java Program to count the number of digits that can be removed such that number is divisible by 10 ^ K"}
{"code": "static int countDigitsToBeRemoved ( int N , int K ) {", "nl": "function to return the required number of digits to be removed"}
{"code": "String s = Integer . toString ( N ) ;", "nl": "Converting the given number into string"}
{"code": "int res = 0 ;", "nl": "variable to store number of digits to be removed"}
{"code": "int f_zero = 0 ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s . charAt ( i ) == '0' ) {", "nl": "variable to denote if atleast one zero has been found"}
{"code": "f_zero = 1 ; K -- ; } else res ++ ; }", "nl": "zero found"}
{"code": "if ( K == 0 ) return res ; else if ( f_zero == 1 ) return s . length ( ) - 1 ; return - 1 ; }", "nl": "return size - 1 if K is not zero and atleast one zero is present , otherwise result"}
{"code": "public static void main ( String [ ] args ) { int N = 10904025 ; int K = 2 ; System . out . println ( countDigitsToBeRemoved ( N , K ) ) ; N = 1000 ; K = 5 ; System . out . println ( countDigitsToBeRemoved ( N , K ) ) ; N = 23985 ; K = 2 ; System . out . println ( countDigitsToBeRemoved ( N , K ) ) ; } }", "nl": "Driver Code to test above function"}
{"code": "import java . util . Scanner ; public class HelloWorld {", "nl": "Java program to find the sum of the given series"}
{"code": "public static float getSum ( int a , int n ) {", "nl": "Function to return the sum of the series"}
{"code": "float sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) {", "nl": "variable to store the answer"}
{"code": "sum += ( i / Math . pow ( a , i ) ) ; } return sum ; }", "nl": "Math . pow ( x , y ) returns x ^ y"}
{"code": "public static void main ( String [ ] args ) { int a = 3 , n = 3 ;", "nl": "Driver code"}
{"code": "System . out . println ( getSum ( a , n ) ) ; } }", "nl": "Print the sum of the series"}
{"code": "class GFG {", "nl": "Java Program to check Unusual number"}
{"code": "static int largestPrimeFactor ( int n ) {", "nl": "Utility function to find largest prime factor of a number"}
{"code": "int max = - 1 ;", "nl": "Initialize the maximum prime factor variable with the lowest one"}
{"code": "while ( n % 2 == 0 ) { max = 2 ;", "nl": "Print the number of 2 s that divide n"}
{"code": "}", "nl": "n >>= 1 ; equivalent to n /= 2"}
{"code": "for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { max = i ; n = n / i ; } }", "nl": "n must be odd at this point , thus skip the even numbers and iterate only for odd integers"}
{"code": "if ( n > 2 ) max = n ; return max ; }", "nl": "This condition is to handle the case when n is a prime number greater than 2"}
{"code": "static boolean checkUnusual ( int n ) {", "nl": "Function to check Unusual number"}
{"code": "int factor = largestPrimeFactor ( n ) ;", "nl": "Get the largest Prime Factor of the number"}
{"code": "if ( factor > Math . sqrt ( n ) ) { return true ; } else { return false ; } }", "nl": "Check if largest prime factor is greater than sqrt ( n )"}
{"code": "public static void main ( String [ ] args ) { int n = 14 ; if ( checkUnusual ( n ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }", "nl": "Driver Code"}
{"code": "public class GFG {", "nl": "Java Program to find whether half - array reducible to 0"}
{"code": "static void isHalfReducible ( int arr [ ] , int n , int m ) { int frequencyHash [ ] = new int [ m + 1 ] ; int i ; for ( i = 0 ; i < frequencyHash . length ; i ++ ) frequencyHash [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { frequencyHash [ arr [ i ] % ( m + 1 ) ] ++ ; } for ( i = 0 ; i <= m ; i ++ ) { if ( frequencyHash [ i ] >= n / 2 ) break ; } if ( i <= m ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; }", "nl": "Function to print the desired result after computation"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 8 , 16 , 32 , 3 , 12 } ; int n = arr . length ; int m = 7 ; isHalfReducible ( arr , n , m ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static Vector < Integer > arr = new Vector < Integer > ( ) ;", "nl": "Java program to check if the given number is Ore number"}
{"code": "static void generateDivisors ( int n ) {", "nl": "Function that returns harmonic mean ."}
{"code": "for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) {", "nl": "Note that this loop runs till square root"}
{"code": "if ( n / i == i ) arr . add ( i ) ;", "nl": "If divisors are equal , store ' i '"}
{"code": "{ arr . add ( i ) ; arr . add ( n / i ) ; } } } }", "nl": "else Otherwise store ' i ' and ' n / i ' both"}
{"code": "static double harmonicMean ( int n ) { generateDivisors ( n ) ;", "nl": "Utility function to calculate harmonic mean of the divisors"}
{"code": "double sum = 0.0 ; int len = arr . size ( ) ;", "nl": "Declare sum variables and initialize with zero ."}
{"code": "for ( int i = 0 ; i < len ; i ++ ) sum = sum + n / arr . get ( i ) ; sum = sum / n ;", "nl": "calculate denominator"}
{"code": "return arr . size ( ) / sum ; }", "nl": "Calculate harmonic mean and return"}
{"code": "static boolean isOreNumber ( int n ) {", "nl": "Function to check if a number is Ore number"}
{"code": "double mean = harmonicMean ( n ) ;", "nl": "Calculate Harmonic mean of divisors of n"}
{"code": "if ( mean - Math . floor ( mean ) == 0 ) return true ; else return false ; }", "nl": "Check if Harmonic mean is an Integer or not"}
{"code": "public static void main ( String [ ] args ) { int n = 28 ; if ( isOreNumber ( n ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static int MAX = 10000 ; static HashSet < Integer > s = new HashSet < Integer > ( ) ;", "nl": "Java program to check Euclid Number"}
{"code": "static void SieveOfEratosthenes ( ) {", "nl": "Function to generate the Prime numbers and store their products"}
{"code": "boolean [ ] prime = new boolean [ MAX ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) {", "nl": "Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true ."}
{"code": "if ( prime [ p ] == true ) {", "nl": "If prime [ p ] is not changed , then it is a prime"}
{"code": "for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } }", "nl": "Update all multiples of p"}
{"code": "int product = 1 ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) {", "nl": "store prefix product of prime numbers to unordered_set ' s '"}
{"code": "product = product * p ;", "nl": "update product by multiplying next prime"}
{"code": "s . add ( product + 1 ) ; } } }", "nl": "insert ' produc + 1' to set"}
{"code": "static boolean isEuclid ( int n ) {", "nl": "Function to check the number for Euclid Number"}
{"code": "if ( s . contains ( n ) ) return true ; else return false ; }", "nl": "Check if number exist in unordered set or not If exist , return true"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "SieveOfEratosthenes ( ) ;", "nl": "Get the prime numbers"}
{"code": "int n = 31 ;", "nl": "Get n"}
{"code": "if ( isEuclid ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ;", "nl": "Check if n is Euclid Number"}
{"code": "n = 42 ;", "nl": "Get n"}
{"code": "if ( isEuclid ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Check if n is Euclid Number"}
{"code": "class GFG {", "nl": "JAVA program to check if a number is Wagstaff prime or not"}
{"code": "static boolean isPrime ( int n ) {", "nl": "Function to check if a number is prime or not"}
{"code": "if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;", "nl": "Corner cases"}
{"code": "if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }", "nl": "This is checked so that we can skip middle five numbers in below loop"}
{"code": "static boolean isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; }", "nl": "Utility function to check power of two"}
{"code": "public static void main ( String [ ] args ) { int n = 43 ;", "nl": "Driver Program"}
{"code": "if ( isPrime ( n ) && ( isPowerOfTwo ( n * 3 - 1 ) ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }", "nl": "Check if number is prime and of the form ( 2 ^ q + 1 ) / 3"}
{"code": "import java . io . * ; class GFG {", "nl": "Java Program to find the area of the square inscribed within the circle which in turn is inscribed in a hexagon"}
{"code": "static float area ( float a ) {", "nl": "Function to find the area of the square"}
{"code": "if ( a < 0 ) return - 1 ;", "nl": "side of hexagon cannot be negative"}
{"code": "float area = ( float ) Math . pow ( ( a * Math . sqrt ( 3 ) ) / ( Math . sqrt ( 2 ) ) , 2 ) ; return area ; }", "nl": "area of the square"}
{"code": "public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( area ( a ) ) ; } }", "nl": "Driver code"}
{"code": "public class GFG {", "nl": "Java program to find the N - th term of the series : 1 , 6 , 17 , 34 , 56 , 86 , 121 , 162 , ... . ."}
{"code": "static int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) - 4 * n + 2 ; }", "nl": "calculate Nth term of series"}
{"code": "public static void main ( String args [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }", "nl": "Driver code"}
{"code": "public class GFG {", "nl": "Java program to find sum of first n terms"}
{"code": "static int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + ( int ) Math . pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ; }", "nl": "Function to calculate the sum"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver code"}
{"code": "int n = 3 ;", "nl": "number of terms to be included in the sum"}
{"code": "System . out . println ( \" Sum \u2581 = \u2581 \" + calculateSum ( n ) ) ; } }", "nl": "find the Sum"}
{"code": "import java . io . * ; class GFG {", "nl": "Java code to check if arrays are permutations of eah other"}
{"code": "static boolean arePermutations ( int a [ ] , int b [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ;", "nl": "Function to check if arrays are permutations of each other ."}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; }", "nl": "Calculating sum and multiply of first array"}
{"code": "for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; }", "nl": "Calculating sum and multiply of second array"}
{"code": "return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; }", "nl": "If sum and mul of both arrays are equal , return true , else return false ."}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 2 } ; int b [ ] = { 3 , 1 , 2 } ; int n = a . length ; int m = b . length ; if ( arePermutations ( a , b , n , m ) == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "public class GFG {", "nl": "Java implementation of above approach"}
{"code": "static int Race ( int B , int C ) { int result = 0 ;", "nl": "Function to find the B start to C"}
{"code": "result = ( ( C * 100 ) / B ) ; return 100 - result ; }", "nl": "When B completed it 's 100 meter  then Completed meters by C is"}
{"code": "public static void main ( String [ ] args ) { int B = 10 ; int C = 28 ;", "nl": "Driver Code"}
{"code": "B = 100 - B ; C = 100 - C ; System . out . println ( Race ( B , C ) + \" \u2581 meters \" ) ; } }", "nl": "When A completed it 's 100 meter  Then completed meters of B and C is"}
{"code": "import java . io . * ; class GFG {", "nl": "Java implementation of above approach"}
{"code": "static float Time ( float arr [ ] , int n , float Emptypipe ) { float fill = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / ( float ) Emptypipe ) ; return 1 / fill ; }", "nl": "Function to calculate the time"}
{"code": "public static void main ( String [ ] args ) { float arr [ ] = { 12 , 14 } ; float Emptypipe = 30 ; int n = arr . length ; System . out . println ( ( int ) ( Time ( arr , n , Emptypipe ) ) + \" \u2581 Hours \" ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; import java . lang . * ; import java . io . * ; class GFG {", "nl": "Java program to check if Decimal representation of an Octal number is divisible by 7 or not"}
{"code": "static int check ( int n ) { int sum = 0 ;", "nl": "Function to check Divisibility"}
{"code": "while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; }", "nl": "Sum of all individual digits"}
{"code": "if ( sum % 7 == 0 ) return 1 ; else return 0 ; }", "nl": "Condition"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "int n = 25 ; String s = ( check ( n ) == 1 ) ? \" YES \" : \" NO \" ; System . out . println ( s ) ; } }", "nl": "Octal number"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program to find sum of prime divisors of N"}
{"code": "static boolean isPrime ( int n ) {", "nl": "Function to check if the number is prime or not ."}
{"code": "if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;", "nl": "Corner cases"}
{"code": "if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }", "nl": "This is checked so that we can skip middle five numbers in below loop"}
{"code": "static int SumOfPrimeDivisors ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 ) { if ( isPrime ( i ) ) sum += i ; } } return sum ; }", "nl": "function to find sum of prime divisors of N"}
{"code": "public static void main ( String args [ ] ) { int n = 60 ; System . out . print ( \" Sum \u2581 of \u2581 prime \u2581 divisors \u2581 of \u2581 60 \u2581 is \u2581 \" + SumOfPrimeDivisors ( n ) + \"NEW_LINE\"); } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program to find prime divisors of all numbers from 1 to n"}
{"code": "static int Sum ( int N ) { int SumOfPrimeDivisors [ ] = new int [ N + 1 ] ; for ( int i = 2 ; i <= N ; ++ i ) {", "nl": "function to find prime divisors of all numbers from 1 to n"}
{"code": "if ( SumOfPrimeDivisors [ i ] == 0 ) {", "nl": "if the number is prime"}
{"code": "for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; }", "nl": "add this prime to all it 's multiples"}
{"code": "public static void main ( String args [ ] ) { int N = 60 ; System . out . print ( \" Sum \u2581 of \u2581 prime \u2581 \" + \" divisors \u2581 of \u2581 60 \u2581 is \u2581 \" + Sum ( N ) + \"NEW_LINE\"); } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find ( a ^ b ) % m for b very large ."}
{"code": "static long power ( long x , long y , long p ) {", "nl": "Function to find power"}
{"code": "x = x % p ; while ( y > 0 ) {", "nl": "Update x if it is more than or equal to p"}
{"code": "if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ;", "nl": "If y is odd , multiply x with the result"}
{"code": "x = ( x * x ) % p ; } return res ; }", "nl": "y must be even now y = y >> 1 ; y = y / 2"}
{"code": "public static void main ( String [ ] args ) { long a = 3 ;", "nl": "Driver Code"}
{"code": "String b = \"100000000000000000000000000\" ; long remainderB = 0 ; long MOD = 1000000007 ;", "nl": "String input as b is very large"}
{"code": "for ( int i = 0 ; i < b . length ( ) ; i ++ ) remainderB = ( remainderB * 10 + b . charAt ( i ) - '0' ) % ( MOD - 1 ) ; System . out . println ( power ( a , remainderB , MOD ) ) ; } }", "nl": "Reduce the number B to a small number using Fermat Little"}
{"code": "class GFG {", "nl": "Java program to find square of these large numbers"}
{"code": "static String find_Square_369 ( String num ) { char a , b , c , d ;", "nl": "Function to find the square of 333. . .333 , 666. . .666 and 999. . .999"}
{"code": "if ( num . charAt ( 0 ) == '3' ) { a = '1' ; b = '0' ; c = '8' ; d = '9' ; }", "nl": "if the number is 333. . .333"}
{"code": "else if ( num . charAt ( 0 ) == '6' ) { a = '4' ; b = '3' ; c = '5' ; d = '6' ; }", "nl": "if the number is 666. . .666"}
{"code": "else { a = '9' ; b = '8' ; c = '0' ; d = '1' ; }", "nl": "if the number is 999. . .999"}
{"code": "String result = \" \" ;", "nl": "variable for hold result"}
{"code": "int size = num . length ( ) ;", "nl": "find the no of digit"}
{"code": "for ( int i = 1 ; i < size ; i ++ ) result += a ;", "nl": "add size - 1 time a in result"}
{"code": "result += b ;", "nl": "add one time b in result"}
{"code": "for ( int i = 1 ; i < size ; i ++ ) result += c ;", "nl": "add size - 1 time c in result"}
{"code": "result += d ;", "nl": "add one time d in result"}
{"code": "return result ; }", "nl": "return result"}
{"code": "public static void main ( String [ ] args ) { String num_3 , num_6 , num_9 ; num_3 = \"3333\" ; num_6 = \"6666\" ; num_9 = \"9999\" ; String result = \" \" ;", "nl": "Drivers code"}
{"code": "result = find_Square_369 ( num_3 ) ; System . out . println ( \" Square \u2581 of \u2581 \" + num_3 + \" \u2581 is \u2581 : \u2581 \" + result ) ;", "nl": "find square of 33. .33"}
{"code": "result = find_Square_369 ( num_6 ) ; System . out . println ( \" Square \u2581 of \u2581 \" + num_9 + \" \u2581 is \u2581 : \u2581 \" + result ) ;", "nl": "find square of 66. .66"}
{"code": "result = find_Square_369 ( num_9 ) ; System . out . println ( \" Square \u2581 of \u2581 \" + num_9 + \" \u2581 is \u2581 : \u2581 \" + result ) ; } }", "nl": "find square of 66. .66"}
{"code": "import java . io . * ; class GFG {", "nl": "Java code to find number of ways to multiply n elements with an associative operation"}
{"code": "static int fact ( int n ) { if ( n == 0 n == 1 ) return 1 ; int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ans ; }", "nl": "Function to find the required factorial"}
{"code": "static int nCr ( int n , int r ) { int Nr = n , Dr = 1 , ans = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { ans = ( ans * Nr ) / ( Dr ) ; Nr -- ; Dr ++ ; } return ans ; }", "nl": "Function to find nCr"}
{"code": "static int solve ( int n ) { int N = 2 * n - 2 ; int R = n - 1 ; return nCr ( N , R ) * fact ( n - 1 ) ; }", "nl": "function to find the number of ways"}
{"code": "public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( solve ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG { static void pythagoreanTriplet ( int n ) {", "nl": "Java program to find Pythagorean Triplet of given sum ."}
{"code": "for ( int i = 1 ; i <= n / 3 ; i ++ ) {", "nl": "Considering triplets in sorted order . The value of first element in sorted triplet can be at - most n / 3."}
{"code": "for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { System . out . print ( i + \" , \u2581 \" + j + \" , \u2581 \" + k ) ; return ; } } } System . out . print ( \" No \u2581 Triplet \" ) ; }", "nl": "The value of second element must be less than equal to n / 2"}
{"code": "public static void main ( String arg [ ] ) { int n = 12 ; pythagoreanTriplet ( n ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to print terms of binomial series and also calculate sum of series ."}
{"code": "static int factorial ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; }", "nl": "function to calculate factorial of a number"}
{"code": "static void series ( int A , int X , int n ) {", "nl": "function to print the series"}
{"code": "int nFact = factorial ( n ) ;", "nl": "calculating the value of n !"}
{"code": "for ( int i = 0 ; i < n + 1 ; i ++ ) {", "nl": "loop to display the series"}
{"code": "int niFact = factorial ( n - i ) ; int iFact = factorial ( i ) ;", "nl": "For calculating the value of nCr"}
{"code": "int aPow = ( int ) Math . pow ( A , n - i ) ; int xPow = ( int ) Math . pow ( X , i ) ;", "nl": "calculating the value of A to the power k and X to the power k"}
{"code": "System . out . print ( ( nFact * aPow * xPow ) / ( niFact * iFact ) + \" \u2581 \" ) ; } }", "nl": "display the series"}
{"code": "public static void main ( String [ ] args ) { int A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ; } }", "nl": "main function started"}
{"code": "import java . io . * ; import java . lang . * ; import java . util . * ; class GFG {", "nl": "Java program to find sum of series with alternate signed square AP sums ."}
{"code": "static int seiresSum ( int n , int [ ] a ) { int res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }", "nl": "function to calculate series sum"}
{"code": "public static void main ( String args [ ] ) { int n = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; System . out . println ( seiresSum ( n , a ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find power of a prime number ' r ' in n !"}
{"code": "static int power ( int n , int r ) {", "nl": "Function to return power of a no . ' r ' in factorial of n"}
{"code": "int count = 0 ; for ( int i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; }", "nl": "Keep dividing n by powers of ' r ' and update count"}
{"code": "public static void main ( String [ ] args ) { int n = 6 , r = 3 ; System . out . print ( power ( n , r ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find average of sum of first n odd natural numbers ."}
{"code": "static int avg_of_odd_num ( int n ) {", "nl": "Returns the Avg of first n odd numbers"}
{"code": "int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ;", "nl": "sum of first n odd number"}
{"code": "return sum / n ; }", "nl": "Average of first n odd numbers"}
{"code": "public static void main ( String [ ] args ) { int n = 20 ; avg_of_odd_num ( n ) ; System . out . println ( avg_of_odd_num ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "java Program to find the average of sum of first n odd numbers"}
{"code": "static int avg_of_odd_num ( int n ) { return n ; }", "nl": "Return the average of sum of first n odd numbers"}
{"code": "public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( avg_of_odd_num ( n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java Implementation for Fibonacci triangle"}
{"code": "static void fib ( int f [ ] , int N ) {", "nl": "function to fill Fibonacci Numbers in f [ ]"}
{"code": "f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( int i = 3 ; i <= N ; i ++ )", "nl": "1 st and 2 nd number of the series are 1 and 1"}
{"code": "f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; } static void fiboTriangle ( int n ) {", "nl": "Add the previous 2 numbers in the series and store it"}
{"code": "int N = n * ( n + 1 ) / 2 ; int f [ ] = new int [ N + 1 ] ; fib ( f , N ) ;", "nl": "Fill Fibonacci numbers in f [ ] using fib ( ) . We need N = n * ( n + 1 ) / 2 Fibonacci numbers to make a triangle of height n"}
{"code": "int fiboNum = 1 ;", "nl": "To store next Fibonacci Number to print"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) {", "nl": "for loop to keep track of number of lines"}
{"code": "for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( f [ fiboNum ++ ] + \" \u2581 \" ) ; System . out . println ( ) ; } }", "nl": "For loop to keep track of numbers in each line"}
{"code": "public static void main ( String args [ ] ) { int n = 5 ; fiboTriangle ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Program to find average of odd numbers till a given odd number ."}
{"code": "static int averageOdd ( int n ) { if ( n % 2 == 0 ) { System . out . println ( \" Invalid \u2581 Input \" ) ; return - 1 ; } int sum = 0 , count = 0 ; while ( n >= 1 ) {", "nl": "Function to calculate the average of odd numbers"}
{"code": "count ++ ;", "nl": "count odd numbers"}
{"code": "sum += n ; n = n - 2 ; } return sum / count ; }", "nl": "store the sum of odd numbers"}
{"code": "public static void main ( String args [ ] ) { int n = 15 ; System . out . println ( averageOdd ( n ) ) ; } }", "nl": "driver function"}
{"code": "import java . io . * ; class GFG {", "nl": "Program to find average of odd numbers till a given odd number ."}
{"code": "static int averageOdd ( int n ) { if ( n % 2 == 0 ) { System . out . println ( \" Invalid \u2581 Input \" ) ; return - 1 ; } return ( n + 1 ) / 2 ; }", "nl": "Function to calculate the average of odd numbers"}
{"code": "public static void main ( String args [ ] ) { int n = 15 ; System . out . println ( averageOdd ( n ) ) ; } }", "nl": "driver function"}
{"code": "class GFG { static class Rational { int nume , deno ; public Rational ( int nume , int deno ) { this . nume = nume ; this . deno = deno ; } } ;", "nl": "JAVA program to find max between two Rational numbers"}
{"code": "static int lcm ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; }", "nl": "Get lcm of two number 's"}
{"code": "static Rational maxRational ( Rational first , Rational sec ) {", "nl": "Get max rational number"}
{"code": "int k = lcm ( first . deno , sec . deno ) ;", "nl": "Find the LCM of first . denominator and sec . denominator"}
{"code": "int nume1 = first . nume ; int nume2 = sec . nume ; nume1 *= k / ( first . deno ) ; nume2 *= k / ( sec . deno ) ; return ( nume2 < nume1 ) ? first : sec ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; }", "nl": "Declare nume1 and nume2 for get the value of first numerator and second numerator"}
{"code": "public static void main ( String [ ] args ) { Rational first = new Rational ( 3 , 2 ) ; Rational sec = new Rational ( 3 , 4 ) ; Rational res = maxRational ( first , sec ) ; System . out . print ( res . nume + \" / \" + res . deno ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; import java . lang . * ; public class GfG {", "nl": "Java Program to print trinomial triangle ."}
{"code": "public static int TrinomialValue ( int n , int k ) {", "nl": "Function to find the trinomial triangle value ."}
{"code": "if ( n == 0 && k == 0 ) return 1 ;", "nl": "base case"}
{"code": "if ( k < - n k > n ) return 0 ;", "nl": "base case"}
{"code": "return TrinomialValue ( n - 1 , k - 1 ) + TrinomialValue ( n - 1 , k ) + TrinomialValue ( n - 1 , k + 1 ) ; }", "nl": "recursive step ."}
{"code": "public static void printTrinomial ( int n ) {", "nl": "Function to print Trinomial Triangle of height n ."}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "printing n rows ."}
{"code": "for ( int j = - i ; j <= 0 ; j ++ ) System . out . print ( TrinomialValue ( i , j ) + \" \u2581 \" ) ;", "nl": "printing first half of triangle"}
{"code": "for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( TrinomialValue ( i , j ) + \" \u2581 \" ) ; System . out . println ( ) ; } }", "nl": "printing second half of triangle ."}
{"code": "public static void main ( String argc [ ] ) { int n = 4 ; printTrinomial ( n ) ; } }", "nl": "driver function"}
{"code": "import java . util . * ; import java . lang . * ; public class GfG { private static final int MAX = 10 ;", "nl": "Java Program to print trinomial triangle ."}
{"code": "public static int TrinomialValue ( int dp [ ] [ ] , int n , int k ) {", "nl": "Function to find the trinomial triangle value ."}
{"code": "if ( k < 0 ) k = - k ;", "nl": "Using property of trinomial triangle ."}
{"code": "if ( dp [ n ] [ k ] != 0 ) return dp [ n ] [ k ] ;", "nl": "If value already calculated , return that ."}
{"code": "if ( n == 0 && k == 0 ) return 1 ;", "nl": "base case"}
{"code": "if ( k < - n k > n ) return 0 ;", "nl": "base case"}
{"code": "return ( dp [ n ] [ k ] = TrinomialValue ( dp , n - 1 , k - 1 ) + TrinomialValue ( dp , n - 1 , k ) + TrinomialValue ( dp , n - 1 , k + 1 ) ) ; }", "nl": "recursive step and storing the value ."}
{"code": "public static void printTrinomial ( int n ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ;", "nl": "Function to print Trinomial Triangle of height n ."}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "printing n rows ."}
{"code": "for ( int j = - i ; j <= 0 ; j ++ ) System . out . print ( TrinomialValue ( dp , i , j ) + \" \u2581 \" ) ;", "nl": "printing first half of triangle"}
{"code": "for ( int j = 1 ; j <= i ; j ++ ) System . out . print ( TrinomialValue ( dp , i , j ) + \" \u2581 \" ) ; System . out . println ( ) ; } }", "nl": "printing second half of triangle ."}
{"code": "public static void main ( String argc [ ] ) { int n = 4 ; printTrinomial ( n ) ; } }", "nl": "driver function"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java implementation to find sum of largest prime factor of each number less than equal to n"}
{"code": "static int sumOfLargePrimeFactor ( int n ) {", "nl": "function to find sum of largest prime factorof each number less than equal to n"}
{"code": "int prime [ ] = new int [ n + 1 ] , sum = 0 ; Arrays . fill ( prime , 0 ) ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) {", "nl": "Create an integer array \" prime [ 0 . . n ] \" and initialize all entries of it as 0. A value in prime [ i ] will finally be 0 if ' i ' is a prime , else it will contain the largest prime factor of ' i ' ."}
{"code": "if ( prime [ p ] == 0 ) {", "nl": "If prime [ p ] is '0' , then it is a prime number"}
{"code": "for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } }", "nl": "Update all multiples of p"}
{"code": "for ( int p = 2 ; p <= n ; p ++ ) {", "nl": "Sum up the largest prime factor of all the numbers"}
{"code": "if ( prime [ p ] != 0 ) sum += prime [ p ] ;", "nl": "if ' p ' is a non - prime number then prime [ p ] gives its largesr prime factor"}
{"code": "else sum += p ; }", "nl": "' p ' is a prime number"}
{"code": "return sum ; }", "nl": "required sum"}
{"code": "public static void main ( String args [ ] ) { int n = 12 ; System . out . println ( \" Sum \u2581 = \u2581 \" + sumOfLargePrimeFactor ( n ) ) ; } }", "nl": "Driver program"}
{"code": "class GFG {", "nl": "Java program to find sum of multiples of a number up to N efficiently"}
{"code": "static int calculate_sum ( int a , int N ) {", "nl": "Function for calculating sum of multiples of a upto N"}
{"code": "int m = N / a ;", "nl": "Number of multiples"}
{"code": "int sum = m * ( m + 1 ) / 2 ;", "nl": "sum of first m natural numbers"}
{"code": "int ans = a * sum ; return ans ; }", "nl": "sum of multiples"}
{"code": "public static void main ( String [ ] args ) { int a = 7 , N = 49 ; System . out . println ( \" Sum \u2581 of \u2581 multiples \u2581 of \u2581 \" + a + \" \u2581 up \u2581 to \u2581 \" + N + \" \u2581 = \u2581 \" + calculate_sum ( a , N ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find whether a number is power of 2 or not"}
{"code": "static int isPowerOf2 ( String s ) { char [ ] str = s . toCharArray ( ) ; int len_str = s . length ( ) ;", "nl": "returns 1 when str is power of 2 return 0 when str is not a power of 2"}
{"code": "int num = 0 ;", "nl": "sum stores the intermediate dividend while dividing ."}
{"code": "if ( len_str == 1 && str [ len_str - 1 ] == '1' ) return 0 ;", "nl": "if the input is \"1\" then return 0 because 2 ^ k = 1 where k >= 1 and here k = 0"}
{"code": "while ( len_str != 1 str [ len_str - 1 ] != '1' ) {", "nl": "Divide the number until it gets reduced to 1 if we are successfully able to reduce the number to 1 it means input string is power of two if in between an odd number appears at the end it means string is not divisible by two hence not a power of 2."}
{"code": "if ( ( str [ len_str - 1 ] - '0' ) % 2 == 1 ) return 0 ;", "nl": "if the last digit is odd then string is not divisible by 2 hence not a power of two return 0."}
{"code": "int j = 0 ; for ( int i = 0 ; i < len_str ; i ++ ) { num = num * 10 + ( int ) str [ i ] - ( int ) '0' ;", "nl": "divide the whole string by 2. i is used to track index in current number . j is used to track index for next iteration ."}
{"code": "if ( num < 2 ) {", "nl": "if num < 2 then we have to take another digit to the right of A [ i ] to make it bigger than A [ i ] . E . g . 214 / 2 -- > 107"}
{"code": "if ( i != 0 ) str [ j ++ ] = '0' ;", "nl": "if it 's not the first index. E.g 214  then we have to include 0."}
{"code": "continue ; } str [ j ++ ] = ( char ) ( ( int ) ( num / 2 ) + ( int ) '0' ) ; num = ( num ) - ( num / 2 ) * 2 ; } str [ j ] = ' \\0' ;", "nl": "for eg . \"124\" we will not write 064 so if it is the first index just ignore"}
{"code": "len_str = j ; }", "nl": "After every division by 2 the length of string is changed ."}
{"code": "return 1 ; }", "nl": "if the string reaches to 1 then the str is a power of 2."}
{"code": "public static void main ( String [ ] args ) { String str1 = \"124684622466842024680246842024662202000002\" ; String str2 = \"1\" ; String str3 = \"128\" ; System . out . println ( isPowerOf2 ( str1 ) + \"NEW_LINE\"+isPowerOf2(str2) +NEW_LINE\"NEW_LINE\"+isPowerOf2(str3)); } }", "nl": "Driver code ."}
{"code": "class GfG {", "nl": "Java program to find whether a number is power of 2 or not"}
{"code": "static long ispowerof2 ( long num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; }", "nl": "Function to check whether a number is power of 2 or not"}
{"code": "public static void main ( String [ ] args ) { long num = 549755813888L ; System . out . println ( ispowerof2 ( num ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "A simple Java program to count divisors in array multiplication ."}
{"code": "static int counDivisors ( int X ) {", "nl": "To count number of factors in a number"}
{"code": "int count = 0 ;", "nl": "Initialize count with 0"}
{"code": "for ( int i = 1 ; i <= X ; ++ i ) { if ( X % i == 0 ) { count ++ ; } }", "nl": "Increment count for every factor of the given number X ."}
{"code": "return count ; }", "nl": "Return number of factors"}
{"code": "static int countDivisorsMult ( int arr [ ] , int n ) {", "nl": "Returns number of divisors in array multiplication"}
{"code": "int mul = 1 ; for ( int i = 0 ; i < n ; ++ i ) mul *= arr [ i ] ;", "nl": "Multipliying all elements of the given array ."}
{"code": "return counDivisors ( mul ) ; }", "nl": "Calling function which count number of factors of the number"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 } ; int n = arr . length ; System . out . println ( countDivisorsMult ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG { static void SieveOfEratosthenes ( int largest , ArrayList < Integer > prime ) {", "nl": "Java program to count divisors in array multiplication ."}
{"code": "boolean [ ] isPrime = new boolean [ largest + 1 ] ; Arrays . fill ( isPrime , true ) ; for ( int p = 2 ; p * p <= largest ; p ++ ) {", "nl": "Create a boolean array \" isPrime [ 0 . . n ] \" and initialize all entries it as true . A value in isPrime [ i ] will finally be false if i is Not a isPrime , else true ."}
{"code": "if ( isPrime [ p ] == true ) {", "nl": "If isPrime [ p ] is not changed , then it is a isPrime"}
{"code": "for ( int i = p * 2 ; i <= largest ; i += p ) isPrime [ i ] = false ; } }", "nl": "Update all multiples of p"}
{"code": "for ( int p = 2 ; p <= largest ; p ++ ) if ( isPrime [ p ] ) prime . add ( p ) ; }", "nl": "Print all isPrime numbers"}
{"code": "static long countDivisorsMult ( int [ ] arr , int n ) {", "nl": "Returns number of divisors in array multiplication"}
{"code": "int largest = 0 ; for ( int a : arr ) { largest = Math . max ( largest , a ) ; } ArrayList < Integer > prime = new ArrayList < Integer > ( ) ; SieveOfEratosthenes ( largest , prime ) ;", "nl": "Find all prime numbers smaller than the largest element ."}
{"code": "Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < prime . size ( ) ; j ++ ) { while ( arr [ i ] > 1 && arr [ i ] % prime . get ( j ) == 0 ) { arr [ i ] /= prime . get ( j ) ; if ( mp . containsKey ( prime . get ( j ) ) ) { mp . put ( prime . get ( j ) , mp . get ( prime . get ( j ) ) + 1 ) ; } else { mp . put ( prime . get ( j ) , 1 ) ; } } } if ( arr [ i ] != 1 ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } }", "nl": "Find counts of occurrences of each prime factor"}
{"code": "long res = 1 ; for ( int it : mp . keySet ( ) ) res *= ( mp . get ( it ) + 1L ) ; return res ; }", "nl": "Compute count of all divisors using counts prime factors ."}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 } ; int n = arr . length ; System . out . println ( countDivisorsMult ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class solution {", "nl": "Java program for the above approach"}
{"code": "static void findPrimeNos ( int L , int R , Map < Integer , Integer > M , int K ) {", "nl": "Function to generate prime numbers in the given range [ L , R ]"}
{"code": "for ( int i = L ; i <= R ; i ++ ) { if ( M . get ( i ) != null ) M . put ( i , M . get ( i ) + 1 ) ; else M . put ( i , 1 ) ; }", "nl": "Store all value in the range"}
{"code": "if ( M . get ( 1 ) != null ) { M . remove ( 1 ) ; }", "nl": "Erase 1 as its non - prime"}
{"code": "for ( int i = 2 ; i <= Math . sqrt ( R ) ; i ++ ) { int multiple = 2 ; while ( ( i * multiple ) <= R ) {", "nl": "Perform Sieve of Eratosthenes"}
{"code": "if ( M . get ( i * multiple ) != null ) {", "nl": "Find current multiple"}
{"code": "M . remove ( i * multiple ) ; }", "nl": "Erase as it is a non - prime"}
{"code": "multiple ++ ; } }", "nl": "Increment multiple"}
{"code": "for ( Map . Entry < Integer , Integer > entry : M . entrySet ( ) ) {", "nl": "Traverse the Map M"}
{"code": "if ( M . get ( entry . getKey ( ) + K ) != null ) { System . out . print ( \" ( \" + entry . getKey ( ) + \" , \u2581 \" + ( entry . getKey ( ) + K ) + \" ) \u2581 \" ) ; } } }", "nl": "If it . first & ( it . first + K ) is prime then print this pair"}
{"code": "static void getPrimePairs ( int L , int R , int K ) { Map < Integer , Integer > M = new HashMap < Integer , Integer > ( ) ;", "nl": "Function to print all the prime pairs in the given range that differs by K"}
{"code": "findPrimeNos ( L , R , M , K ) ; }", "nl": "Generate all prime number"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "int L = 1 , R = 19 ;", "nl": "Given range"}
{"code": "int K = 6 ;", "nl": "Given K"}
{"code": "getPrimePairs ( L , R , K ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java program to find N - th Enneacontahexagon Number"}
{"code": "static int enneacontahexagonNum ( int n ) { return ( 94 * n * n - 92 * n ) / 2 ; }", "nl": "Function to find the nth Enneacontahexagon Number"}
{"code": "public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( enneacontahexagonNum ( n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java code to Find two Composite Numbers such that there difference is N"}
{"code": "static void find_composite_nos ( int n ) { System . out . println ( 9 * n + \" \u2581 \" + 8 * n ) ; }", "nl": "Function to find the two composite numbers"}
{"code": "public static void main ( String [ ] args ) { int n = 4 ; find_composite_nos ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Arrays ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int freqPairs ( int arr [ ] , int n ) {", "nl": "Function to find number of unordered pairs"}
{"code": "int max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ;", "nl": "Maximum element from the array"}
{"code": "int freq [ ] = new int [ max + 1 ] ;", "nl": "Array to store the frequency of each element"}
{"code": "int count = 0 ;", "nl": "Stores the number of unordered pairs"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; }", "nl": "Store the frequency of each element"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 * arr [ i ] ; j <= max ; j += arr [ i ] ) {", "nl": "Find the number of unordered pairs"}
{"code": "if ( freq [ j ] >= 1 ) { count += freq [ j ] ; } }", "nl": "If the number j divisible by ith element is present in the array"}
{"code": "if ( freq [ arr [ i ] ] > 1 ) { count += freq [ arr [ i ] ] - 1 ; freq [ arr [ i ] ] -- ; } } return count ; }", "nl": "If the ith element of the array has frequency more than one"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 4 , 2 , 6 } ; int n = arr . length ; System . out . println ( freqPairs ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; import java . lang . * ; class GFG {", "nl": "Java program to find Nth term of the series : 1 + 2 + 6 + 15 + 31 + 56 + ..."}
{"code": "static double Nth_Term ( int n ) { return ( 2 * Math . pow ( n , 3 ) - 3 * Math . pow ( n , 2 ) + n + 6 ) / 6 ; }", "nl": "calculate Nth term of given series"}
{"code": "static public void main ( String args [ ] ) { int N = 8 ; System . out . println ( Nth_Term ( N ) ) ; } }", "nl": "Driver code"}
{"code": "class FindNth {", "nl": "Java program to find n - th number in a series made of digits 3 and 5"}
{"code": "static int printNthElement ( int n ) {", "nl": "Function to find n - th number in series made of 3 and 5"}
{"code": "int arr [ ] = new int [ n + 1 ] ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( int i = 3 ; i <= n ; i ++ ) {", "nl": "create an array of size ( n + 1 )"}
{"code": "if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; }", "nl": "If i is odd"}
{"code": "public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( printNthElement ( n ) ) ; } }", "nl": "main function"}
{"code": "import java . io . * ; class Nth { public int nthTerm ( int N ) {", "nl": "Class to calculate Nth term of series"}
{"code": "return ( N * ( ( N / 2 ) + ( ( N % 2 ) * 2 ) + N ) ) ; } }", "nl": "By using above formula"}
{"code": "class GFG { public static void main ( String [ ] args ) {", "nl": "Main class for main method"}
{"code": "int N = 5 ;", "nl": "get the value of N"}
{"code": "Nth a = new Nth ( ) ;", "nl": "create object of Class Nth"}
{"code": "System . out . println ( \" Nth \u2581 term \u2581 for \u2581 N \u2581 = \u2581 \" + N + \" \u2581 : \u2581 \" + a . nthTerm ( N ) ) ; } }", "nl": "Calculate and print the Nth term"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to print terms of binomial series and also calculate sum of series ."}
{"code": "static void series ( int A , int X , int n ) {", "nl": "function to print the series"}
{"code": "int term = ( int ) Math . pow ( A , n ) ; System . out . print ( term + \" \u2581 \" ) ;", "nl": "Calculating and printing first term"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) {", "nl": "Computing and printing remaining terms"}
{"code": "term = term * X * ( n - i + 1 ) / ( i * A ) ; System . out . print ( term + \" \u2581 \" ) ; } }", "nl": "Find current term using previous terms We increment power of X by 1 , decrement power of A by 1 and compute nCi using previous term by multiplying previous term with ( n - i + 1 ) / i"}
{"code": "public static void main ( String [ ] args ) { int A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ; } }", "nl": "main function started"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program to check whether the number is divisible by 8 or not using bitwise operator"}
{"code": "static boolean Div_by_8 ( int n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; }", "nl": "function to check number is div by 8 or not using bitwise operator"}
{"code": "public static void main ( String [ ] args ) { int n = 16 ; if ( Div_by_8 ( n ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Program to find average of even numbers till a given even number ."}
{"code": "static int averageEven ( int n ) { if ( n % 2 != 0 ) { System . out . println ( \" Invalid \u2581 Input \" ) ; return - 1 ; } int sum = 0 , count = 0 ; while ( n >= 2 ) {", "nl": "Function to calculate the average of even numbers"}
{"code": "count ++ ;", "nl": "count even numbers"}
{"code": "sum += n ; n = n - 2 ; } return sum / count ; }", "nl": "store the sum of even numbers"}
{"code": "public static void main ( String args [ ] ) { int n = 16 ; System . out . println ( averageEven ( n ) ) ; } }", "nl": "driver function"}
{"code": "import java . io . * ; class GFG {", "nl": "Program to find average of even numbers till a given even number ."}
{"code": "static int averageEven ( int n ) { if ( n % 2 != 0 ) { System . out . println ( \" Invalid \u2581 Input \" ) ; return - 1 ; } return ( n + 2 ) / 2 ; }", "nl": "Function to calculate the average of even numbers"}
{"code": "public static void main ( String args [ ] ) { int n = 16 ; System . out . println ( averageEven ( n ) ) ; } }", "nl": "driver function"}
{"code": "import java . io . * ; class GFG {", "nl": "java program to find the Largest Coprime Divisor"}
{"code": "static int gcd ( int a , int b ) {", "nl": "Recursive function to return gcd of a and b"}
{"code": "if ( a == 0 b == 0 ) return 0 ;", "nl": "Everything divides 0"}
{"code": "if ( a == b ) return a ;", "nl": "base case"}
{"code": "if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }", "nl": "a is greater"}
{"code": "static int cpFact ( int x , int y ) { while ( gcd ( x , y ) != 1 ) { x = x / gcd ( x , y ) ; } return x ; }", "nl": "function to find largest coprime divisor"}
{"code": "public static void main ( String [ ] args ) { int x = 15 ; int y = 3 ; System . out . println ( cpFact ( x , y ) ) ; x = 14 ; y = 28 ; System . out . println ( cpFact ( x , y ) ) ; x = 7 ; y = 3 ; System . out . println ( cpFact ( x , y ) ) ; } }", "nl": "divisor code"}
{"code": "import java . util . * ; import java . lang . * ; public class GfG {", "nl": "Simple Java program to count numbers with last digit as k in given range ."}
{"code": "public static int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }", "nl": "Returns count of numbers with k as last digit ."}
{"code": "public static void main ( String args [ ] ) { int low = 3 , high = 35 , k = 3 ; System . out . println ( counLastDigitK ( low , high , k ) ) ; } }", "nl": "driver function"}
{"code": "import java . util . * ; class GFG { public static void printTaxicab2 ( int N ) {", "nl": "JAVA Code for Taxicab Numbers"}
{"code": "int i = 1 , count = 0 ; while ( count < N ) { int int_count = 0 ;", "nl": "Starting from 1 , check every number if it is Taxicab until count reaches N ."}
{"code": "for ( int j = 1 ; j <= Math . pow ( i , 1.0 / 3 ) ; j ++ ) for ( int k = j + 1 ; k <= Math . pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ;", "nl": "Try all possible pairs ( j , k ) whose cube sums can be i ."}
{"code": "if ( int_count == 2 ) { count ++ ; System . out . println ( count + \" \u2581 \" + i ) ; } i ++ ; } }", "nl": "Taxicab ( 2 ) found"}
{"code": "public static void main ( String [ ] args ) { int N = 5 ; printTaxicab2 ( N ) ; } }", "nl": "Driver program to test above function"}
{"code": "import java . io . * ; class Composite { static boolean isComposite ( int n ) {", "nl": "/ An optimized method based Java program to check if a number is Composite or not ."}
{"code": "if ( n <= 1 ) System . out . println ( \" False \" ) ; if ( n <= 3 ) System . out . println ( \" False \" ) ;", "nl": "Corner cases"}
{"code": "if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }", "nl": "This is checked so that we can skip middle five numbers in below loop"}
{"code": "public static void main ( String args [ ] ) { System . out . println ( isComposite ( 11 ) ? \" true \" : \" false \" ) ; System . out . println ( isComposite ( 15 ) ? \" true \" : \" false \" ) ; } }", "nl": "Driver Program to test above function"}
{"code": "class GFG {", "nl": "Java program to find minimum number to insert in array so their sum is prime"}
{"code": "static boolean isPrime ( int n ) {", "nl": "function to check if a number is prime or not"}
{"code": "if ( n <= 1 ) return false ;", "nl": "Corner case"}
{"code": "for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }", "nl": "Check from 2 to n - 1"}
{"code": "static int findPrime ( int n ) { int num = n + 1 ;", "nl": "Find prime number greater than a number"}
{"code": "while ( num > 0 ) {", "nl": "find prime greater than n"}
{"code": "if ( isPrime ( num ) ) return num ;", "nl": "check if num is prime"}
{"code": "num = num + 1 ; } return 0 ; }", "nl": "increment num"}
{"code": "static int minNumber ( int arr [ ] , int n ) { int sum = 0 ;", "nl": "To find number to be added so sum of array is prime"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ;", "nl": "To find sum of array elements"}
{"code": "if ( isPrime ( sum ) ) return 0 ;", "nl": "if sum is already prime return 0"}
{"code": "int num = findPrime ( sum ) ;", "nl": "To find prime number greater than sum"}
{"code": "return num - sum ; }", "nl": "Return difference of sum and num"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; int n = arr . length ; System . out . println ( minNumber ( arr , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; import java . util . * ; public class Division {", "nl": "Java program to find sum of proper divisor of factorial of a number"}
{"code": "static int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }", "nl": "function to calculate factorial"}
{"code": "static int div ( int x ) { int ans = 0 ; for ( int i = 1 ; i <= x ; i ++ ) if ( x % i == 0 ) ans += i ; return ans ; }", "nl": "function to calculate sum of divisor"}
{"code": "static int sumFactDiv ( int n ) { return div ( fact ( n ) ) ; }", "nl": "Returns sum of divisors of n !"}
{"code": "public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( sumFactDiv ( n ) ) ; } }", "nl": "driver program"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find sum of divisors in n !"}
{"code": "static ArrayList < Integer > allPrimes = new ArrayList < Integer > ( ) ;", "nl": "allPrimes [ ] stores all prime numbers less than or equal to n ."}
{"code": "static void sieve ( int n ) {", "nl": "Fills above vector allPrimes [ ] for a given n"}
{"code": "boolean [ ] prime = new boolean [ n + 1 ] ;", "nl": "Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is not a prime , else true ."}
{"code": "for ( int p = 2 ; p * p <= n ; p ++ ) {", "nl": "Loop to update prime [ ]"}
{"code": "if ( prime [ p ] == false ) {", "nl": "If prime [ p ] is not changed , then it is a prime"}
{"code": "for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } }", "nl": "Update all multiples of p"}
{"code": "for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] == false ) allPrimes . add ( p ) ; }", "nl": "Store primes in the vector allPrimes"}
{"code": "static int factorialDivisors ( int n ) {", "nl": "Function to find all result of factorial number"}
{"code": "int result = 1 ;", "nl": "Initialize result"}
{"code": "for ( int i = 0 ; i < allPrimes . size ( ) ; i ++ ) {", "nl": "find exponents of all primes which divides n and less than n"}
{"code": "int p = allPrimes . get ( i ) ;", "nl": "Current divisor"}
{"code": "int exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * allPrimes . get ( i ) ; }", "nl": "Find the highest power ( stored in exp ) ' \u2581 \u2581 of \u2581 allPrimes [ i ] \u2581 that \u2581 divides \u2581 n \u2581 using \u2581 \u2581 Legendre ' s formula ."}
{"code": "result = result * ( ( int ) Math . pow ( allPrimes . get ( i ) , exp + 1 ) - 1 ) / ( allPrimes . get ( i ) - 1 ) ; }", "nl": "Using the divisor function to calculate the sum"}
{"code": "return result ; }", "nl": "return total divisors"}
{"code": "public static void main ( String [ ] args ) { System . out . println ( factorialDivisors ( 4 ) ) ; } }", "nl": "Driver program to run the cases"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to check if a number is pandigital in given base ."}
{"code": "static boolean checkPandigital ( int b , String n ) {", "nl": "Return true if n is pandigit else return false ."}
{"code": "if ( n . length ( ) < b ) return false ; boolean hash [ ] = new boolean [ b ] ; Arrays . fill ( hash , false ) ;", "nl": "Checking length is less than base"}
{"code": "for ( int i = 0 ; i < n . length ( ) ; i ++ ) {", "nl": "Traversing each digit of the number ."}
{"code": "if ( n . charAt ( i ) >= '0' && n . charAt ( i ) <= '9' ) hash [ n . charAt ( i ) - '0' ] = true ;", "nl": "If digit is integer"}
{"code": "else if ( n . charAt ( i ) - ' A ' <= b - 11 ) hash [ n . charAt ( i ) - ' A ' + 10 ] = true ; }", "nl": "If digit is alphabet"}
{"code": "for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; }", "nl": "Checking hash array , if any index is unmarked ."}
{"code": "public static void main ( String [ ] args ) { int b = 13 ; String n = \"1298450376ABC \" ; if ( checkPandigital ( b , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "class ConvertNum {", "nl": "Java implementation to convert a number m to n using minimum number of given operations"}
{"code": "static int convert ( int m , int n ) { if ( m == n ) return 0 ;", "nl": "function to find minimum number of given operations to convert m to n"}
{"code": "if ( m > n ) return m - n ;", "nl": "only way is to do - 1 ( m - n ) times"}
{"code": "if ( m <= 0 && n > 0 ) return - 1 ;", "nl": "not possible"}
{"code": "if ( n % 2 == 1 )", "nl": "n is greater and n is odd"}
{"code": "return 1 + convert ( m , n + 1 ) ;", "nl": "perform ' - 1' on m ( or + 1 on n )"}
{"code": "else", "nl": "n is even"}
{"code": "return 1 + convert ( m , n / 2 ) ; }", "nl": "perform ' * 2' on m ( or n / 2 on n )"}
{"code": "public static void main ( String [ ] args ) { int m = 3 , n = 11 ; System . out . println ( \" Minimum \u2581 number \u2581 of \u2581 \" + \" operations \u2581 : \u2581 \" + convert ( m , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFg { static int MAX = 10000 ; static int [ ] prodDig = new int [ MAX ] ;", "nl": "Java program to find Seed of a number"}
{"code": "static int getDigitProduct ( int x ) {", "nl": "Stores product of digits of x in prodDig [ x ]"}
{"code": "if ( x < 10 ) return x ;", "nl": "If x has single digit"}
{"code": "if ( prodDig [ x ] != 0 ) return prodDig [ x ] ;", "nl": "If digit product is already computed"}
{"code": "int prod = ( x % 10 ) * getDigitProduct ( x / 10 ) ; return ( prodDig [ x ] = prod ) ; }", "nl": "If digit product is not computed before ."}
{"code": "static void findSeed ( int n ) {", "nl": "Prints all seeds of n"}
{"code": "List < Integer > res = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= n / 2 ; i ++ ) if ( i * getDigitProduct ( i ) == n ) res . add ( i ) ;", "nl": "Find all seeds using prodDig [ ]"}
{"code": "if ( res . size ( ) == 0 ) { System . out . println ( \" NO \u2581 seed \u2581 exists \" ) ; return ; }", "nl": "If there was no seed"}
{"code": "for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + \" \u2581 \" ) ; }", "nl": "Print seeds"}
{"code": "public static void main ( String [ ] args ) { int n = 138 ; findSeed ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . Arrays ; public class GFG {", "nl": "Java program to find integer having maximum number of prime factor in first N natural numbers ."}
{"code": "static int maxPrimefactorNum ( int N ) { int arr [ ] = new int [ N + 5 ] ; Arrays . fill ( arr , 0 ) ;", "nl": "Return smallest number having maximum prime factors ."}
{"code": "for ( int i = 2 ; i * i <= N ; i ++ ) { if ( arr [ i ] == 0 ) { for ( int j = 2 * i ; j <= N ; j += i ) { arr [ j ] ++ ; } } arr [ i ] = 1 ; } int maxval = 0 , maxint = 1 ;", "nl": "Sieve of eratosthenes method to count number of prime factors ."}
{"code": "for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > maxval ) { maxval = arr [ i ] ; maxint = i ; } } return maxint ; }", "nl": "Finding number having maximum number of prime factor ."}
{"code": "public static void main ( String [ ] args ) { int N = 40 ; System . out . println ( maxPrimefactorNum ( N ) ) ; } }", "nl": "Driver program"}
{"code": "class GFG {", "nl": "Efficient Java program to compute sum of subarray elements"}
{"code": "public static long SubArraySum ( int arr [ ] , int n ) { long result = 0 ;", "nl": "function compute sum all sub - array"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ;", "nl": "computing sum of subarray using formula"}
{"code": "return result ; }", "nl": "return all subarray sum"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . println ( \" Sum \u2581 of \u2581 SubArray \u2581 \" + SubArraySum ( arr , n ) ) ; } }", "nl": "Driver program to test above function"}
{"code": "class GFG { static int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) {", "nl": "Java program to find highest power of 2 smaller than or equal to n ."}
{"code": "if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; }", "nl": "If i is a power of 2"}
{"code": "public static void main ( String [ ] args ) { int n = 10 ; System . out . print ( highestPowerof2 ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find pairs that can represent the given number as sum of two cubes"}
{"code": "static void findPairs ( int n ) {", "nl": "Function to find pairs that can represent the given number as sum of two cubes"}
{"code": "int cubeRoot = ( int ) Math . pow ( n , 1.0 / 3.0 ) ;", "nl": "find cube root of n"}
{"code": "int cube [ ] = new int [ cubeRoot + 1 ] ;", "nl": "create a array of size of size ' cubeRoot '"}
{"code": "for ( int i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ;", "nl": "for index i , cube [ i ] will contain i ^ 3"}
{"code": "int l = 1 ; int r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { System . out . println ( \" ( \" + l + \" , \u2581 \" + r + \" ) \" ) ; l ++ ; r -- ; } } }", "nl": "Find all pairs in above sorted array cube [ ] whose sum is equal to n"}
{"code": "public static void main ( String [ ] args ) { int n = 20683 ; findPairs ( n ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } }", "nl": "Java program to find pairs that can represent the given number as sum of two cubes"}
{"code": "static void findPairs ( int n ) {", "nl": "Function to find pairs that can represent the given number as sum of two cubes"}
{"code": "int cubeRoot = ( int ) Math . pow ( n , 1.0 / 3.0 ) ;", "nl": "find cube root of n"}
{"code": "HashMap < Integer , pair > s = new HashMap < Integer , pair > ( ) ;", "nl": "create an empty map"}
{"code": "for ( int x = 1 ; x < cubeRoot ; x ++ ) { for ( int y = x + 1 ; y <= cubeRoot ; y ++ ) {", "nl": "Consider all pairs such with values less than cuberoot"}
{"code": "int sum = x * x * x + y * y * y ;", "nl": "find sum of current pair ( x , y )"}
{"code": "if ( sum != n ) continue ;", "nl": "do nothing if sum is not equal to given number"}
{"code": "if ( s . containsKey ( sum ) ) { System . out . print ( \" ( \" + s . get ( sum ) . first + \" , \u2581 \" + s . get ( sum ) . second + \" ) \u2581 and \u2581 ( \" + x + \" , \u2581 \" + y + \" ) \" + \"NEW_LINE\"); } else", "nl": "if sum is seen before , we found two pairs"}
{"code": "s . put ( sum , new pair ( x , y ) ) ; } } }", "nl": "if sum is seen for the first time"}
{"code": "public static void main ( String [ ] args ) { int n = 13832 ; findPairs ( n ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to find the minimum difference between any two terms of two tables"}
{"code": "static int gcd ( int a , int b ) { while ( b != 0 ) { int t = b ; b = a % b ; a = t ; } return a ; }", "nl": "Utility function to find GCD of a and b"}
{"code": "static int findMinDiff ( int a , int b , int x , int y ) {", "nl": "Returns minimum difference between any two terms of shifted tables of ' a ' and ' b ' . ' x ' is shift in table of ' a ' and ' y ' is shift in table of ' b ' ."}
{"code": "int g = gcd ( a , b ) ;", "nl": "Calculate gcd of a nd b"}
{"code": "int diff = Math . abs ( x - y ) % g ; return Math . min ( diff , g - diff ) ; }", "nl": "Calculate difference between x and y"}
{"code": "public static void main ( String [ ] args ) { int a = 20 , b = 52 , x = 5 , y = 7 ; System . out . println ( findMinDiff ( a , b , x , y ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . Vector ; class Test {", "nl": "A O ( sqrt ( n ) ) java program that prints all divisors in sorted order"}
{"code": "static void printDivisors ( int n ) {", "nl": "method to print the divisors"}
{"code": "Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) {", "nl": "Vector to store half of the divisors"}
{"code": "if ( n / i == i ) System . out . printf ( \" % d \u2581 \" , i ) ; else { System . out . printf ( \" % d \u2581 \" , i ) ;", "nl": "check if divisors are equal"}
{"code": "v . add ( n / i ) ; } } }", "nl": "push the second divisor in the vector"}
{"code": "for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) System . out . printf ( \" % d \u2581 \" , v . get ( i ) ) ; }", "nl": "The vector will be printed in reverse"}
{"code": "public static void main ( String args [ ] ) { System . out . println ( \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 \" ) ; printDivisors ( 100 ) ; } }", "nl": "Driver method"}
{"code": "import java . lang . Math ; class GFG {", "nl": "A O ( sqrt ( n ) ) program that prints all divisors in sorted order"}
{"code": "public static void printDivisors ( int n ) { int i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) System . out . print ( i + \" \u2581 \" ) ; } if ( i - ( n / i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) System . out . print ( n / i + \" \u2581 \" ) ; } }", "nl": "Function to print the divisors"}
{"code": "public static void main ( String [ ] args ) { System . out . println ( \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 \" ) ; printDivisors ( 100 ) ; } }", "nl": "Driver code"}
{"code": "class Test {", "nl": "Java implementation of Naive method to print all divisors"}
{"code": "static void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) System . out . print ( i + \" \u2581 \" ) ; }", "nl": "method to print the divisors"}
{"code": "public static void main ( String args [ ] ) { System . out . println ( \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 \" ) ; printDivisors ( 100 ) ; ; } }", "nl": "Driver method"}
{"code": "class Test {", "nl": "A Better ( than Naive ) Solution to find all divisors"}
{"code": "static void printDivisors ( int n ) {", "nl": "method to print the divisors"}
{"code": "for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) {", "nl": "Note that this loop runs till square root"}
{"code": "if ( n / i == i ) System . out . print ( \" \u2581 \" + i ) ;", "nl": "If divisors are equal , print only one"}
{"code": "System . out . print ( i + \" \u2581 \" + n / i + \" \u2581 \" ) ; } } }", "nl": "else Otherwise print both"}
{"code": "public static void main ( String args [ ] ) { System . out . println ( \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 \" ) ; printDivisors ( 100 ) ; ; } }", "nl": "Driver method"}
{"code": "class GFG { static int SieveOfAtkin ( int limit ) {", "nl": "Java program for implementation of Sieve of Atkin"}
{"code": "if ( limit > 2 ) System . out . print ( 2 + \" \u2581 \" ) ; if ( limit > 3 ) System . out . print ( 3 + \" \u2581 \" ) ;", "nl": "2 and 3 are known to be prime"}
{"code": "boolean sieve [ ] = new boolean [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) sieve [ i ] = false ;", "nl": "Initialise the sieve array with false values"}
{"code": "for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) {", "nl": "Mark sieve [ n ] is true if one of the following is true : a ) n = ( 4 * x * x ) + ( y * y ) has odd number of solutions , i . e . , there exist odd number of distinct pairs ( x , y ) that satisfy the equation and n % 12 = 1 or n % 12 = 5. b ) n = ( 3 * x * x ) + ( y * y ) has odd number of solutions and n % 12 = 7 c ) n = ( 3 * x * x ) - ( y * y ) has odd number of solutions , x > y and n % 12 = 11"}
{"code": "int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } }", "nl": "Main part of Sieve of Atkin"}
{"code": "for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } }", "nl": "Mark all multiples of squares as non - prime"}
{"code": "for ( int a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) System . out . print ( a + \" \u2581 \" ) ; return 0 ; }", "nl": "Print primes using sieve [ ]"}
{"code": "public static void main ( String [ ] args ) { int limit = 20 ; SieveOfAtkin ( limit ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static boolean isInside ( int circle_x , int circle_y , int rad , int x , int y ) {", "nl": "Java program to check if a point lies inside a circle or not"}
{"code": "if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; }", "nl": "Compare radius of circle with distance of its center from given point"}
{"code": "public static void main ( String arg [ ] ) { int x = 1 , y = 1 ; int circle_x = 0 , circle_y = 1 , rad = 2 ; if ( isInside ( circle_x , circle_y , rad , x , y ) ) System . out . print ( \" Inside \" ) ; else System . out . print ( \" Outside \" ) ; } }", "nl": "Driver Program to test above function"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to evaluate all possible values of a expression"}
{"code": "static int eval ( int a , char op , int b ) { if ( op == ' + ' ) { return a + b ; } if ( op == ' - ' ) { return a - b ; } if ( op == ' * ' ) { return a * b ; } return Integer . MAX_VALUE ; }", "nl": "Utility function to evaluate a simple expression with one operator only ."}
{"code": "static Vector < Integer > evaluateAll ( String expr , int low , int high ) {", "nl": "This function evaluates all possible values and returns a list of evaluated values ."}
{"code": "Vector < Integer > res = new Vector < Integer > ( ) ;", "nl": "To store result ( all possible evaluations of given expression ' expr ' )"}
{"code": "if ( low == high ) { res . add ( expr . charAt ( low ) - '0' ) ; return res ; }", "nl": "If there is only one character , it must be a digit ( or operand ) , return it ."}
{"code": "if ( low == ( high - 2 ) ) { int num = eval ( expr . charAt ( low ) - '0' , expr . charAt ( low + 1 ) , expr . charAt ( low + 2 ) - '0' ) ; res . add ( num ) ; return res ; }", "nl": "If there are only three characters , middle one must be operator and corner ones must be operand"}
{"code": "for ( int i = low + 1 ; i <= high ; i += 2 ) {", "nl": "every i refers to an operator"}
{"code": "Vector < Integer > l = evaluateAll ( expr , low , i - 1 ) ;", "nl": "l refers to all the possible values in the left of operator ' expr [ i ] '"}
{"code": "Vector < Integer > r = evaluateAll ( expr , i + 1 , high ) ;", "nl": "r refers to all the possible values in the right of operator ' expr [ i ] '"}
{"code": "for ( int s1 = 0 ; s1 < l . size ( ) ; s1 ++ ) {", "nl": "Take above evaluated all possible values in left side of ' i '"}
{"code": "for ( int s2 = 0 ; s2 < r . size ( ) ; s2 ++ ) {", "nl": "Take above evaluated all possible values in right side of ' i '"}
{"code": "int val = eval ( l . get ( s1 ) , expr . charAt ( i ) , r . get ( s2 ) ) ; res . add ( val ) ; } } } return res ; }", "nl": "Calculate value for every pair and add the value to result ."}
{"code": "public static void main ( String [ ] args ) { String expr = \"1*2 + 3*4\" ; int len = expr . length ( ) ; Vector < Integer > ans = evaluateAll ( expr , 0 , len - 1 ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . println ( ans . get ( i ) ) ; } } }", "nl": "Driver program"}
{"code": "class GFG {", "nl": "Java program to check if a given number is lucky"}
{"code": "static boolean isLucky ( int n ) {", "nl": "This function returns true if n is lucky"}
{"code": "boolean arr [ ] = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ;", "nl": "Create an array of size 10 and initialize all elements as false . This array is used to check if a digit is already seen or not ."}
{"code": "while ( n > 0 ) {", "nl": "Traverse through all digits of given number"}
{"code": "int digit = n % 10 ;", "nl": "Find the last digit"}
{"code": "if ( arr [ digit ] ) return false ;", "nl": "If digit is already seen , return false"}
{"code": "arr [ digit ] = true ;", "nl": "Mark this digit as seen"}
{"code": "n = n / 10 ; } return true ; }", "nl": "Remove the last digit from number"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1291 , 897 , 4566 , 1232 , 80 , 700 } ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) if ( isLucky ( arr [ i ] ) ) System . out . print ( arr [ i ] + \" is Lucky NEW_LINE\"); else System . out . print ( arr [ i ] + \" is not Lucky NEW_LINE\"); } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static void printSquares ( int n ) {", "nl": "Java program to print squares of first ' n ' natural numbers without using * , / and -"}
{"code": "int square = 0 , odd = 1 ;", "nl": "Initialize ' square ' and first odd number"}
{"code": "for ( int x = 0 ; x < n ; x ++ ) {", "nl": "Calculate and print squares"}
{"code": "System . out . print ( square + \" \u2581 \" ) ;", "nl": "Print square"}
{"code": "square = square + odd ; odd = odd + 2 ; } }", "nl": "Update ' square ' and ' odd '"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; printSquares ( n ) ; } }", "nl": "Driver Code"}
{"code": "class GFG { static int rev_num = 0 ; static int base_pos = 1 ; static int reversDigits ( int num ) { if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; }", "nl": "Recursive function to reverse digits of num"}
{"code": "public static void main ( String [ ] args ) { int num = 4562 ; System . out . println ( reversDigits ( num ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program that find the minimum possible maximum"}
{"code": "static int RecursiveFunction ( ArrayList < Integer > ref , int bit ) {", "nl": "Recursive function that find the minimum value after exclusive - OR"}
{"code": "if ( ref . size ( ) == 0 bit < 0 ) return 0 ; ArrayList < Integer > curr_on = new ArrayList < > ( ) ; ArrayList < Integer > curr_off = new ArrayList < > ( ) ; for ( int i = 0 ; i < ref . size ( ) ; i ++ ) {", "nl": "Condition if ref size is zero or bit is negative then return 0"}
{"code": "if ( ( ( ref . get ( i ) >> bit ) & 1 ) == 0 ) curr_off . add ( ref . get ( i ) ) ;", "nl": "Condition if current bit is off then push current value in curr_off vector"}
{"code": "else curr_on . add ( ref . get ( i ) ) ; }", "nl": "Condition if current bit is on then push current value in curr_on vector"}
{"code": "if ( curr_off . size ( ) == 0 ) return RecursiveFunction ( curr_on , bit - 1 ) ;", "nl": "Condition if curr_off is empty then call recursive function on curr_on vector"}
{"code": "if ( curr_on . size ( ) == 0 ) return RecursiveFunction ( curr_off , bit - 1 ) ;", "nl": "Condition if curr_on is empty then call recursive function on curr_off vector"}
{"code": "return Math . min ( RecursiveFunction ( curr_off , bit - 1 ) , RecursiveFunction ( curr_on , bit - 1 ) ) + ( 1 << bit ) ; }", "nl": "Return the minimum of curr_off and curr_on and add power of 2 of current bit"}
{"code": "static void PrintMinimum ( int a [ ] , int n ) { ArrayList < Integer > v = new ArrayList < > ( ) ;", "nl": "Function that print the minimum value after exclusive - OR"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) v . add ( a [ i ] ) ;", "nl": "Pushing values in vector"}
{"code": "System . out . println ( RecursiveFunction ( v , 30 ) ) ; }", "nl": "Printing answer"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 } ; int size = arr . length ; PrintMinimum ( arr , size ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int cntElements ( int arr [ ] , int n ) {", "nl": "Function to return the count of elements which are equal to the XOR of the next two elements"}
{"code": "int cnt = 0 ;", "nl": "To store the required count"}
{"code": "for ( int i = 0 ; i < n - 2 ; i ++ ) {", "nl": "For every element of the array such that it has at least two elements appearing after it in the array"}
{"code": "if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; }", "nl": "If current element is equal to the XOR of the next two elements in the array"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 1 , 3 , 7 , 8 } ; int n = arr . length ; System . out . println ( cntElements ( arr , n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program to find Number of triplets in array having subarray xor equal"}
{"code": "static int xor_triplet ( int arr [ ] , int n ) {", "nl": "Function to return the count"}
{"code": "int ans = 0 ;", "nl": "Initialise result"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Pick 1 st element of the triplet"}
{"code": "for ( int j = i + 1 ; j < n ; j ++ ) {", "nl": "Pick 2 nd element of the triplet"}
{"code": "for ( int k = j ; k < n ; k ++ ) { int xor1 = 0 , xor2 = 0 ;", "nl": "Pick 3 rd element of the triplet"}
{"code": "for ( int x = i ; x < j ; x ++ ) { xor1 ^= arr [ x ] ; }", "nl": "Taking xor in the first subarray"}
{"code": "for ( int x = j ; x <= k ; x ++ ) { xor2 ^= arr [ x ] ; }", "nl": "Taking xor in the second subarray"}
{"code": "if ( xor1 == xor2 ) { ans ++ ; } } } } return ans ; }", "nl": "If both xor is equal"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ;", "nl": "Driver Code"}
{"code": "System . out . println ( xor_triplet ( arr , n ) ) ; } }", "nl": "Function Calling"}
{"code": "class GFG {", "nl": "Java trie based program to find the Number of triplets in array having subarray xor equal"}
{"code": "static int lg = 31 ;", "nl": "maximum number of bits in an integer <= 1e9"}
{"code": "static class TrieNode {", "nl": "Structure of a Trie Node"}
{"code": "TrieNode children [ ] ;", "nl": "[ 0 ] index is bit 0 and [ 1 ] index is bit 1"}
{"code": "int sum_of_indexes ;", "nl": "Sum of indexes inserted at at a node"}
{"code": "int number_of_indexes ;", "nl": "Number of indexes inserted at a node"}
{"code": "TrieNode ( ) { children = new TrieNode [ 2 ] ; this . children [ 0 ] = null ; this . children [ 1 ] = null ; this . sum_of_indexes = 0 ; this . number_of_indexes = 0 ; } } ;", "nl": "Constructor to initialize a newly created node"}
{"code": "static void insert ( TrieNode node , int num , int index ) {", "nl": "Function to insert curr_xor into the trie"}
{"code": "for ( int bits = lg ; bits >= 0 ; bits -- ) {", "nl": "Iterate from the 31 st bit to the 0 th bit of curr_xor number"}
{"code": "int curr_bit = ( num >> bits ) & 1 ;", "nl": "Check if the current bit is set or not"}
{"code": "if ( node . children [ curr_bit ] == null ) { node . children [ curr_bit ] = new TrieNode ( ) ; } node = node . children [ curr_bit ] ; }", "nl": "If this node isn 't already  present in the trie structure  insert it into the trie."}
{"code": "node . sum_of_indexes += index ;", "nl": "Increase the sum of indexes by the current index value"}
{"code": "node . number_of_indexes ++ ; }", "nl": "Increase the number of indexes by 1"}
{"code": "static int query ( TrieNode node , int num , int index ) {", "nl": "Function to check if curr_xor is present in trie or not"}
{"code": "for ( int bits = lg ; bits >= 0 ; bits -- ) {", "nl": "Iterate from the 31 st bit to the 0 th bit of curr_xor number"}
{"code": "int curr_bit = ( num >> bits ) & 1 ;", "nl": "Check if the current bit is set or not"}
{"code": "if ( node . children [ curr_bit ] == null ) { return 0 ; } node = node . children [ curr_bit ] ; }", "nl": "If this node isn 't already  present in the trie structure  that means no sub array till  current index has 0 xor so  return 0"}
{"code": "int sz = node . number_of_indexes ;", "nl": "Calculate the number of index inserted at final node"}
{"code": "int sum = node . sum_of_indexes ; int ans = ( sz * index ) - ( sum ) ; return ans ; }", "nl": "Calculate the sum of index inserted at final node"}
{"code": "static int no_of_triplets ( int arr [ ] , int n ) {", "nl": "Function to return the count of valid triplets"}
{"code": "int curr_xor = 0 ; int number_of_triplets = 0 ;", "nl": "To store cumulative xor"}
{"code": "TrieNode root = new TrieNode ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ;", "nl": "The root of the trie"}
{"code": "insert ( root , curr_xor , i ) ;", "nl": "Insert the curr_xor in the trie"}
{"code": "curr_xor ^= x ;", "nl": "Update the cumulative xor"}
{"code": "number_of_triplets += query ( root , curr_xor , i ) ; } return number_of_triplets ; }", "nl": "Check if the cumulative xor is present in the trie or not if present then add ( sz * index ) - sum"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 5 , 2 , 7 } ; int n = arr . length ; System . out . println ( no_of_triplets ( arr , n ) ) ; } }", "nl": "Given array"}
{"code": "import java . util . * ; class GFG { static final int N = 100005 ; static int n , k ;", "nl": "Java implementation of the approach"}
{"code": "@ SuppressWarnings ( \" unchecked \" ) static Vector < Integer > [ ] al = new Vector [ N ] ; static long Ideal_pair ; static long [ ] bit = new long [ N ] ; static boolean [ ] root_node = new boolean [ N ] ;", "nl": "Adjacency list"}
{"code": "static long bit_q ( int i , int j ) { long sum = 0 ; while ( j > 0 ) { sum += bit [ j ] ; j -= ( j & ( j * - 1 ) ) ; } i -- ; while ( i > 0 ) { sum -= bit [ i ] ; i -= ( i & ( i * - 1 ) ) ; } return sum ; }", "nl": "bit : bit array i and j are starting and ending index INCLUSIVE"}
{"code": "static void bit_up ( int i , long diff ) { while ( i <= n ) { bit [ i ] += diff ; i += i & - i ; } }", "nl": "bit : bit array n : size of bit array i is the index to be updated diff is ( new_val - old_val )"}
{"code": "static void dfs ( int node ) { Ideal_pair += bit_q ( Math . max ( 1 , node - k ) , Math . min ( n , node + k ) ) ; bit_up ( node , 1 ) ; for ( int i = 0 ; i < al [ node ] . size ( ) ; i ++ ) dfs ( al [ node ] . get ( i ) ) ; bit_up ( node , - 1 ) ; }", "nl": "DFS function to find ideal pairs"}
{"code": "static void initialise ( ) { Ideal_pair = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { root_node [ i ] = true ; bit [ i ] = 0 ; } }", "nl": "Function for initialisation"}
{"code": "static void Add_Edge ( int x , int y ) { al [ x ] . add ( y ) ; root_node [ y ] = false ; }", "nl": "Function to add an edge"}
{"code": "static long Idealpairs ( ) {", "nl": "Function to find number of ideal pairs"}
{"code": "int r = - 1 ; for ( int i = 1 ; i <= n ; i ++ ) if ( root_node [ i ] ) { r = i ; break ; } dfs ( r ) ; return Ideal_pair ; }", "nl": "Find root of the tree"}
{"code": "public static void main ( String [ ] args ) { n = 6 ; k = 3 ; for ( int i = 0 ; i < al . length ; i ++ ) al [ i ] = new Vector < Integer > ( ) ; initialise ( ) ;", "nl": "Driver code"}
{"code": "Add_Edge ( 1 , 2 ) ; Add_Edge ( 1 , 3 ) ; Add_Edge ( 3 , 4 ) ; Add_Edge ( 3 , 5 ) ; Add_Edge ( 3 , 6 ) ;", "nl": "Add edges"}
{"code": "System . out . print ( Idealpairs ( ) ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java program to print all bitwise subsets of N ( Efficient approach )"}
{"code": "static void printSubsets ( int n ) { for ( int i = n ; i > 0 ; i = ( i - 1 ) & n ) System . out . print ( i + \" \u2581 \" ) ; System . out . print ( \" \u2581 0 \u2581 \" ) ; }", "nl": "function to find bitwise subsets Efficient approach"}
{"code": "public static void main ( String [ ] args ) { int n = 9 ; printSubsets ( n ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to check if a number is divisible by 17 or not using bitwise operator ."}
{"code": "static boolean isDivisibleby17 ( int n ) {", "nl": "function to check recursively if the number is divisible by 17 or not"}
{"code": "if ( n == 0 n == 17 ) return true ;", "nl": "if n = 0 or n = 17 then yes"}
{"code": "if ( n < 17 ) return false ;", "nl": "if n is less then 17 , not divisible by 17"}
{"code": "return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) ; }", "nl": "reducing the number by floor ( n / 16 ) - n % 16"}
{"code": "public static void main ( String [ ] args ) { int n = 35 ; if ( isDivisibleby17 ( n ) == true ) System . out . printf ( \" % d \u2581 is \u2581 divisible \u2581 by \u2581 17\" , n ) ; else System . out . printf ( \" % d \u2581 is \u2581 not \u2581 divisible \u2581 by \u2581 17\" , n ) ; } }", "nl": "driver function"}
{"code": "public class GFG {", "nl": "java program to find largest number smaller than equal to n with m set bits then m - 1 0 bits ."}
{"code": "static long answer ( long n ) {", "nl": "Returns largest number with m set bits then m - 1 0 bits ."}
{"code": "long m = 2 ;", "nl": "Start with 2 bits ."}
{"code": "long ans = 1 ; long r = 1 ;", "nl": "initial answer is 1 which meets the given condition"}
{"code": "while ( r < n ) {", "nl": "check for all numbers"}
{"code": "r = ( ( long ) Math . pow ( 2 , m ) - 1 ) * ( ( long ) Math . pow ( 2 , m - 1 ) ) ;", "nl": "compute the number"}
{"code": "if ( r < n ) ans = r ;", "nl": "if less then N"}
{"code": "m ++ ; } return ans ; }", "nl": "increment m to get the next number"}
{"code": "public static void main ( String args [ ] ) { long n = 7 ; System . out . println ( answer ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; }", "nl": "Simple Java program to find MSB number for given n ."}
{"code": "public static void main ( String [ ] args ) { int n = 0 ; System . out . println ( setBitNumber ( n ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static int setBitNumber ( int n ) {", "nl": "Java program to find MSB number for given n ."}
{"code": "n |= n >> 1 ;", "nl": "Suppose n is 273 ( binary is 100010001 ) . It does following 100010001 | 010001000 = 110011001"}
{"code": "n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ;", "nl": "This makes sure 4 bits ( From MSB and including MSB ) are set . It does following 110011001 | 001100110 = 111111111"}
{"code": "n = n + 1 ;", "nl": "Increment n by 1 so that there is only one set bit which is just before original MSB . n now becomes 1000000000"}
{"code": "return ( n >> 1 ) ; }", "nl": "Return original MSB after shifting . n now becomes 100000000"}
{"code": "public static void main ( String arg [ ] ) { int n = 273 ; System . out . print ( setBitNumber ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { public static int countTrailingZero ( int x ) { int count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; }", "nl": "Simple Java code for counting trailing zeros in binary representation of a number"}
{"code": "public static void main ( String [ ] args ) { System . out . println ( countTrailingZero ( 11 ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG { static int countTrailingZero ( int x ) {", "nl": "Java code for counting trailing zeros in binary representation of a number"}
{"code": "int lookup [ ] = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ;", "nl": "Map a bit value mod 37 to its position"}
{"code": "return lookup [ ( - x & x ) % 37 ] ; }", "nl": "Only difference between ( x and - x ) is the value of signed magnitude ( leftmostbit ) negative numbers signed bit is 1"}
{"code": "public static void main ( String [ ] args ) { System . out . println ( countTrailingZero ( 48 ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG { static int multiplyBySevenByEight ( int n ) {", "nl": "Java program to evaluate ceil ( 7 n / 8 ) without using * and"}
{"code": "return ( n - ( n >> 3 ) ) ; }", "nl": "Note the inner bracket here . This is needed because precedence of ' - ' operator is higher than ' < < '"}
{"code": "public static void main ( String args [ ] ) { int n = 9 ; System . out . println ( multiplyBySevenByEight ( n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static int multiplyBySevenByEight ( int n ) {", "nl": "Java program to evaluate 7 n / 8 without using * and /"}
{"code": "return ( ( n << 3 ) - n ) >> 3 ; }", "nl": "Step 1 ) First multiply number by 7 i . e . 7 n = ( n << 3 ) - n * Step 2 ) Divide result by 8"}
{"code": "public static void main ( String args [ ] ) { int n = 15 ; System . out . println ( multiplyBySevenByEight ( n ) ) ; } }", "nl": "Driver program"}
{"code": "import java . util . * ; public class Main {", "nl": "Java program for the above approach"}
{"code": "static int countNumbers ( int L , int R , int K ) {", "nl": "Function to find the maximum size of group of palindrome numbers having difference between maximum and minimum element at most K"}
{"code": "ArrayList < Integer > list = new ArrayList < > ( ) ;", "nl": "Stores the all the palindromic numbers in the range [ L , R ]"}
{"code": "for ( int i = L ; i <= R ; i ++ ) {", "nl": "Traverse over the range [ L , R ]"}
{"code": "if ( isPalindrome ( i ) ) {", "nl": "If i is a palindrome"}
{"code": "list . add ( i ) ; } }", "nl": "Append the number in the list"}
{"code": "int count = 0 ;", "nl": "Stores count of maximum palindromic numbers"}
{"code": "for ( int i = 0 ; i < list . size ( ) ; i ++ ) {", "nl": "Iterate each element in the list"}
{"code": "int right_index = search ( list , list . get ( i ) + K - 1 ) ;", "nl": "Calculate rightmost index in the list < current element + K"}
{"code": "if ( right_index != - 1 ) count = Math . max ( count , right_index - i + 1 ) ; }", "nl": "Check if there is rightmost index from the current index"}
{"code": "return count ; }", "nl": "Return the count"}
{"code": "static int search ( ArrayList < Integer > list , int num ) { int low = 0 , high = list . size ( ) - 1 ;", "nl": "Function to search the rightmost index of given number"}
{"code": "int ans = - 1 ; while ( low <= high ) {", "nl": "Store the rightmost index"}
{"code": "int mid = low + ( high - low ) / 2 ;", "nl": "Calculate the mid"}
{"code": "if ( list . get ( mid ) <= num ) {", "nl": "If given number <= num"}
{"code": "ans = mid ;", "nl": "Assign ans = mid"}
{"code": "low = mid + 1 ; } else", "nl": "Update low"}
{"code": "high = mid - 1 ; }", "nl": "Update high"}
{"code": "return ans ; }", "nl": "return ans"}
{"code": "static boolean isPalindrome ( int n ) { int rev = 0 ; int temp = n ;", "nl": "Function to check if the given number is palindrome or not"}
{"code": "while ( n > 0 ) { rev = rev * 10 + n % 10 ; n /= 10 ; }", "nl": "Generate reverse of the given number"}
{"code": "return rev == temp ; }", "nl": "If n is a palindrome"}
{"code": "public static void main ( String args [ ] ) { int L = 98 , R = 112 ; int K = 13 ; System . out . print ( countNumbers ( L , R , K ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; public class GFG {", "nl": "Java Program to implement the above approach"}
{"code": "public static int findMaximumSum ( int [ ] a , int n ) {", "nl": "Function to find the maximum sum by subtracting same value from all elements of a Subarray"}
{"code": "int prev_smaller [ ] = findPrevious ( a , n ) ;", "nl": "Stores previous smaller element"}
{"code": "int next_smaller [ ] = findNext ( a , n ) ; int max_value = 0 ; for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Stores next smaller element"}
{"code": "max_value = Math . max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) ; }", "nl": "Calculate contribution of each element"}
{"code": "return max_value ; }", "nl": "Return answer"}
{"code": "public static int [ ] findPrevious ( int [ ] a , int n ) { int ps [ ] = new int [ n ] ;", "nl": "Function to generate previous smaller element for each array element"}
{"code": "ps [ 0 ] = - 1 ;", "nl": "The first element has no previous smaller"}
{"code": "Stack < Integer > stack = new Stack < > ( ) ;", "nl": "Stack to keep track of elements that have occurred previously"}
{"code": "stack . push ( 0 ) ; for ( int i = 1 ; i < a . length ; i ++ ) {", "nl": "Push the first index"}
{"code": "while ( stack . size ( ) > 0 && a [ stack . peek ( ) ] >= a [ i ] ) stack . pop ( ) ;", "nl": "Pop all the elements until the previous element is smaller than current element"}
{"code": "ps [ i ] = stack . size ( ) > 0 ? stack . peek ( ) : - 1 ;", "nl": "Store the previous smaller element"}
{"code": "stack . push ( i ) ; }", "nl": "Push the index of the current element"}
{"code": "return ps ; }", "nl": "Return the array"}
{"code": "public static int [ ] findNext ( int [ ] a , int n ) { int ns [ ] = new int [ n ] ; ns [ n - 1 ] = n ;", "nl": "Function to generate next smaller element for each array element"}
{"code": "Stack < Integer > stack = new Stack < > ( ) ; stack . push ( n - 1 ) ;", "nl": "Stack to keep track of elements that have occurring next"}
{"code": "for ( int i = n - 2 ; i >= 0 ; i -- ) {", "nl": "Iterate in reverse order for calculating next smaller"}
{"code": "while ( stack . size ( ) > 0 && a [ stack . peek ( ) ] >= a [ i ] ) stack . pop ( ) ;", "nl": "Pop all the elements until the next element is smaller than current element"}
{"code": "ns [ i ] = stack . size ( ) > 0 ? stack . peek ( ) : a . length ;", "nl": "Store the next smaller element"}
{"code": "stack . push ( i ) ; }", "nl": "Push the index of the current element"}
{"code": "return ns ; }", "nl": "Return the array"}
{"code": "public static void main ( String args [ ] ) { int n = 3 ; int a [ ] = { 80 , 48 , 82 } ; System . out . println ( findMaximumSum ( a , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static boolean compare ( int [ ] arr1 , int [ ] arr2 ) { for ( int i = 0 ; i < 256 ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }", "nl": "This function returns true if contents of arr1 [ ] and arr2 [ ] are same , otherwise false ."}
{"code": "static boolean search ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ;", "nl": "This function search for all permutations of pat [ ] in txt [ ]"}
{"code": "int [ ] countP = new int [ 256 ] ; int [ ] countTW = new int [ 256 ] ; for ( int i = 0 ; i < 256 ; i ++ ) { countP [ i ] = 0 ; countTW [ i ] = 0 ; } for ( int i = 0 ; i < M ; i ++ ) { ( countP [ pat . charAt ( i ) ] ) ++ ; ( countTW [ txt . charAt ( i ) ] ) ++ ; }", "nl": "countP [ ] : Store count of all characters of pattern countTW [ ] : Store count of current window of text"}
{"code": "for ( int i = M ; i < N ; i ++ ) {", "nl": "Traverse through remaining characters of pattern"}
{"code": "if ( compare ( countP , countTW ) ) return true ;", "nl": "Compare counts of current window of text with counts of pattern [ ]"}
{"code": "( countTW [ txt . charAt ( i ) ] ) ++ ;", "nl": "Add current character to current window"}
{"code": "countTW [ txt . charAt ( i - M ) ] -- ; }", "nl": "Remove the first character of previous window"}
{"code": "if ( compare ( countP , countTW ) ) return true ; return false ; }", "nl": "Check for the last window in text"}
{"code": "public static void main ( String [ ] args ) { String txt = \" BACDGABCDA \" ; String pat = \" ABCD \" ; if ( search ( pat , txt ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" NO \" ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static double getMaxMedian ( int [ ] arr , int n , int k ) { int size = n + k ;", "nl": "Function to return the maximized median"}
{"code": "Arrays . sort ( arr ) ;", "nl": "Sort the array"}
{"code": "if ( size % 2 == 0 ) { double median = ( double ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; }", "nl": "If size is even"}
{"code": "double median1 = arr [ size / 2 ] ; return median1 ; }", "nl": "If size is odd"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 3 , 2 , 3 , 4 , 2 } ; int n = arr . length ; int k = 2 ; System . out . print ( ( int ) getMaxMedian ( arr , n , k ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static void printSorted ( int a , int b , int c ) {", "nl": "Java program to print three numbers in sorted order using max function"}
{"code": "int get_max = Math . max ( a , Math . max ( b , c ) ) ;", "nl": "Find maximum element"}
{"code": "int get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; System . out . print ( get_min + \" \u2581 \" + get_mid + \" \u2581 \" + get_max ) ; }", "nl": "Find minimum element"}
{"code": "public static void main ( String [ ] args ) { int a = 4 , b = 1 , c = 9 ; printSorted ( a , b , c ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG { static int binarySearch ( int a [ ] , int item , int low , int high ) { while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( item == a [ mid ] ) return mid + 1 ; else if ( item > a [ mid ] ) low = mid + 1 ; else high = mid - 1 ; } return low ; }", "nl": "iterative implementation"}
{"code": "static void insertionSort ( int a [ ] , int n ) { int i , loc , j , k , selected ; for ( i = 1 ; i < n ; ++ i ) { j = i - 1 ; selected = a [ i ] ;", "nl": "Function to sort an array a [ ] of size ' n '"}
{"code": "loc = binarySearch ( a , selected , 0 , j ) ;", "nl": "find location where selected should be inseretd"}
{"code": "while ( j >= loc ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = selected ; } }", "nl": "Move all elements after location to create space"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 37 , 23 , 0 , 17 , 12 , 72 , 31 , 46 , 100 , 88 , 54 } ; int n = a . length , i ; insertionSort ( a , n ) ; System . out . println ( \" Sorted \u2581 array : \" ) ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + \" \u2581 \" ) ; } }", "nl": "Driver Code"}
{"code": "class InsertionSort {", "nl": "Java program for implementation of Insertion Sort"}
{"code": "void sort ( int arr [ ] ) { int n = arr . length ; for ( int i = 1 ; i < n ; ++ i ) { int key = arr [ i ] ; int j = i - 1 ;", "nl": "Function to sort array using insertion sort"}
{"code": "while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } }", "nl": "Move elements of arr [ 0. . i - 1 ] , that are greater than key , to one position ahead of their current position"}
{"code": "static void printArray ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; System . out . println ( ) ; }", "nl": "A utility function to print array of size n"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; InsertionSort ob = new InsertionSort ( ) ; ob . sort ( arr ) ; printArray ( arr ) ; } }", "nl": "Driver method"}
{"code": "import java . util . HashMap ; class GFG {", "nl": "Importing HashMap class"}
{"code": "static int validPermutations ( String str ) { HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ;", "nl": "Function to calculate total number of valid permutations"}
{"code": "int count = str . length ( ) , ans = 0 ;", "nl": "Creating count which is equal to the Total number of characters present and ans that will store the number of unique permutations"}
{"code": "for ( int i = 0 ; i < str . length ( ) ; i ++ ) { m . put ( str . charAt ( i ) , m . getOrDefault ( str . charAt ( i ) , 0 ) + 1 ) ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) {", "nl": "Storing frequency of each character present in the string"}
{"code": "ans += count - m . get ( str . charAt ( i ) ) ;", "nl": "Adding count of characters by excluding characters equal to current char"}
{"code": "m . put ( str . charAt ( i ) , m . get ( str . charAt ( i ) ) - 1 ) ; count -- ; }", "nl": "Reduce the frequency of the current character and count by 1 , so that it cannot interfere with the calculations of the same elements present to the right of it ."}
{"code": "return ans + 1 ; } public static void main ( String [ ] args ) { String str = \" sstt \" ; System . out . println ( validPermutations ( str ) ) ; } }", "nl": "Return ans + 1 ( Because the given string is also a unique permutation )"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to count total number of paths from a point to origin"}
{"code": "static int countPaths ( int n , int m ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ;", "nl": "DP based function to count number of paths"}
{"code": "for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ;", "nl": "Fill entries in bottommost row and leftmost columns"}
{"code": "for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }", "nl": "Fill DP in bottom up manner"}
{"code": "public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( \" \u2581 Number \u2581 of \u2581 Paths \u2581 \" + countPaths ( n , m ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Recursive JAVA program for coin change problem ."}
{"code": "static int count ( int S [ ] , int m , int n ) {", "nl": "Returns the count of ways we can sum S [ 0. . . m - 1 ] coins to get sum n"}
{"code": "if ( n == 0 ) return 1 ;", "nl": "If n is 0 then there is 1 solution ( do not include any coin )"}
{"code": "if ( n < 0 ) return 0 ;", "nl": "If n is less than 0 then no solution exists"}
{"code": "if ( m <= 0 && n >= 1 ) return 0 ;", "nl": "If there are no coins and n is greater than 0 , then no solution exist"}
{"code": "return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }", "nl": "count is sum of solutions ( i ) including S [ m - 1 ] ( ii ) excluding S [ m - 1 ]"}
{"code": "public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 } ; int m = arr . length ; System . out . println ( count ( arr , m , 4 ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG { static int coinchange ( int [ ] a , int v , int n , int [ ] [ ] dp ) { if ( v == 0 ) return dp [ n ] [ v ] = 1 ; if ( n == 0 ) return 0 ; if ( dp [ n ] [ v ] != - 1 ) return dp [ n ] [ v ] ; if ( a [ n - 1 ] <= v ) {", "nl": "Java program for the above approach"}
{"code": "return dp [ n ] [ v ] = coinchange ( a , v - a [ n - 1 ] , n , dp ) + coinchange ( a , v , n - 1 , dp ) ; }", "nl": "Either Pick this coin or not"}
{"code": "return dp [ n ] [ v ] = coinchange ( a , v , n - 1 , dp ) ; }", "nl": "else We have no option but to leave this coin"}
{"code": "public static void main ( String [ ] args ) { int tc = 1 ; while ( tc != 0 ) { int n , v ; n = 3 ; v = 4 ; int [ ] a = { 1 , 2 , 3 } ; int [ ] [ ] dp = new int [ n + 1 ] [ v + 1 ] ; for ( int [ ] row : dp ) Arrays . fill ( row , - 1 ) ; int res = coinchange ( a , v , n , dp ) ; System . out . println ( res ) ; tc -- ; } } }", "nl": "Driver code"}
{"code": "class GFG { static boolean equalIgnoreCase ( String str1 , String str2 ) { int i = 0 ;", "nl": "Function to compare two Strings ignoring their cases"}
{"code": "str1 = str1 . toUpperCase ( ) ; str2 = str2 . toUpperCase ( ) ;", "nl": "Convert to lowercase using toUpperCase function"}
{"code": "int x = str1 . compareTo ( str2 ) ;", "nl": "Comparing both using inbuilt function"}
{"code": "if ( x != 0 ) { return false ; } else { return true ; } }", "nl": "if Strings are equal , return true otherwise false"}
{"code": "static void equalIgnoreCaseUtil ( String str1 , String str2 ) { boolean res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) { System . out . println ( \" Same \" ) ; } else { System . out . println ( \" Not \u2581 Same \" ) ; } }", "nl": "Function to print the same or not same if Strings are equal or not equal"}
{"code": "public static void main ( String [ ] args ) { String str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; import java . lang . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static String replaceConsonants ( String str ) {", "nl": "Function to return the converted string after replacing every consonant sequence with its length"}
{"code": "String res = \" \" ; int i = 0 , count = 0 ;", "nl": "To store the resultant string"}
{"code": "while ( i < str . length ( ) ) {", "nl": "Checking each character for consonant sequence"}
{"code": "if ( str . charAt ( i ) != ' a ' && str . charAt ( i ) != ' e ' && str . charAt ( i ) != ' i ' && str . charAt ( i ) != ' o ' && str . charAt ( i ) != ' u ' ) { i ++ ; count ++ ; } else {", "nl": "Count the length of consonants sequence"}
{"code": "if ( count > 0 ) res += count ;", "nl": "Add the length in the string"}
{"code": "res += str . charAt ( i ) ; i ++ ; count = 0 ; } }", "nl": "Add the vowel"}
{"code": "if ( count > 0 ) res += count ;", "nl": "Check for the last consonant sequence in the string"}
{"code": "return res ; }", "nl": "Return the resultant string"}
{"code": "public static void main ( String [ ] args ) { String str = \" abcdeiop \" ; System . out . println ( replaceConsonants ( str ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java Program to Encrypt String with product of number of vowels and consonants in every substring of size k"}
{"code": "static boolean isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; }", "nl": "isVowel ( ) is a function that returns true for a vowel and false otherwise ."}
{"code": "static String encryptString ( String s , int n , int k ) { int countVowels = 0 ; int countConsonants = 0 ; String ans = \" \" ;", "nl": "function to Encrypt the dtring"}
{"code": "for ( int l = 0 ; l <= n - k ; l ++ ) { countVowels = 0 ; countConsonants = 0 ;", "nl": "for each substring"}
{"code": "for ( int r = l ; r <= l + k - 1 ; r ++ ) {", "nl": "substring of size k"}
{"code": "if ( isVowel ( s . charAt ( r ) ) == true ) { countVowels ++ ; } else { countConsonants ++ ; } }", "nl": "counting number of vowels and consonants"}
{"code": "ans += String . valueOf ( countVowels * countConsonants ) ; } return ans ; }", "nl": "append product to answer ."}
{"code": "static public void main ( String [ ] args ) { String s = \" hello \" ; int n = s . length ( ) ; int k = 2 ; System . out . println ( encryptString ( s , n , k ) ) ; } }", "nl": "Driven Program"}
{"code": "class GFG { private static StringBuilder charBuffer = new StringBuilder ( ) ; public static String processWords ( String input ) {", "nl": "Java implementation of the above approach"}
{"code": "String s [ ] = input . split ( \" ( \\\\ s ) + \" ) ; for ( String values : s ) {", "nl": "we are splitting the input based on spaces ( s ) + : this regular expression will handle scenarios where we have words separated by multiple spaces"}
{"code": "charBuffer . append ( values . charAt ( 0 ) ) ; } return charBuffer . toString ( ) ; }", "nl": "charAt ( 0 ) will pick only the first character from the string and append to buffer"}
{"code": "public static void main ( String [ ] args ) { String input = \" geeks \u2581 forgeeks \u2581 geeksfor \u2581 geeks \" ; System . out . println ( processWords ( input ) ) ; } }", "nl": "main function"}
{"code": "import java . util . * ; import java . lang . * ; public class BinaryS {", "nl": "Java program to Generate all binary string without consecutive 1 's of size K"}
{"code": "public static String toString ( char [ ] a ) { String string = new String ( a ) ; return string ; } static void generate ( int k , char [ ] ch , int n ) {", "nl": "Array conversion to String --"}
{"code": "if ( n == k ) {", "nl": "Base Condition when we reached at the end of Array * *"}
{"code": "System . out . print ( toString ( ch ) + \" \u2581 \" ) ; return ; }", "nl": "Printing the Generated String * * Return to the previous case *"}
{"code": "if ( ch [ n - 1 ] == '0' ) { ch [ n ] = '0' ; generate ( k , ch , n + 1 ) ; ch [ n ] = '1' ; generate ( k , ch , n + 1 ) ; }", "nl": "If the first Character is Zero then adding * *"}
{"code": "if ( ch [ n - 1 ] == '1' ) { ch [ n ] = '0' ;", "nl": "If the Character is One then add Zero to next * *"}
{"code": "generate ( k , ch , n + 1 ) ; } } static void fun ( int k ) { if ( k <= 0 ) { return ; } char [ ] ch = new char [ k ] ;", "nl": "Calling Recursively for the next value of Array"}
{"code": "ch [ 0 ] = '0' ;", "nl": "Initializing first character to Zero"}
{"code": "generate ( k , ch , 1 ) ;", "nl": "Generating Strings starting with Zero --"}
{"code": "ch [ 0 ] = '1' ; generate ( k , ch , 1 ) ; } public static void main ( String args [ ] ) { int k = 3 ;", "nl": "Initialized first Character to one --"}
{"code": "fun ( k ) ;", "nl": "Calling function fun with argument k"}
{"code": "} }", "nl": "This code is Contributed by Praveen Tiwari"}
{"code": "import java . io . * ; class GFG {", "nl": "Java Program to find the biggest right circular cylinder that can be fit within a cube"}
{"code": "static float findVolume ( float a ) {", "nl": "Function to find the biggest right circular cylinder"}
{"code": "if ( a < 0 ) return - 1 ;", "nl": "side cannot be negative"}
{"code": "float r = a / 2 ;", "nl": "radius of right circular cylinder"}
{"code": "float h = a ;", "nl": "height of right circular cylinder"}
{"code": "float V = ( float ) ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; }", "nl": "volume of right circular cylinder"}
{"code": "public static void main ( String [ ] args ) { float a = 5 ; System . out . print ( findVolume ( a ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; import java . lang . * ; class GfG {", "nl": "Java Program for volume of Pyramid ."}
{"code": "public static float volumeTriangular ( int a , int b , int h ) { float vol = ( float ) ( 0.1666 ) * a * b * h ; return vol ; }", "nl": "Function to find the volume of triangular pyramid"}
{"code": "public static float volumeSquare ( int b , int h ) { float vol = ( float ) ( 0.33 ) * b * b * h ; return vol ; }", "nl": "Function to find the volume of square pyramid"}
{"code": "public static float volumePentagonal ( int a , int b , int h ) { float vol = ( float ) ( 0.83 ) * a * b * h ; return vol ; }", "nl": "Function to find the volume of pentagonal pyramid"}
{"code": "public static float volumeHexagonal ( int a , int b , int h ) { float vol = ( float ) a * b * h ; return vol ; }", "nl": "Function to find the volume of hexagonal pyramid"}
{"code": "public static void main ( String argc [ ] ) { int b = 4 , h = 9 , a = 4 ; System . out . println ( \" Volume \u2581 of \u2581 triangular \" + \" \u2581 base \u2581 pyramid \u2581 is \u2581 \" + volumeTriangular ( a , b , h ) ) ; System . out . println ( \" Volume \u2581 of \u2581 square \u2581 base \" + \" \u2581 pyramid \u2581 is \u2581 \" + volumeSquare ( b , h ) ) ; System . out . println ( \" Volume \u2581 of \u2581 pentagonal \" + \" \u2581 base \u2581 pyramid \u2581 is \u2581 \" + volumePentagonal ( a , b , h ) ) ; System . out . println ( \" Volume \u2581 of \u2581 Hexagonal \" + \" \u2581 base \u2581 pyramid \u2581 is \u2581 \" + volumeHexagonal ( a , b , h ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to calculate area of a trapezoid"}
{"code": "static double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; }", "nl": "Function for the area"}
{"code": "public static void main ( String [ ] args ) { int base1 = 8 , base2 = 10 , height = 6 ; double area = Area ( base1 , base2 , height ) ; System . out . println ( \" Area \u2581 is : \u2581 \" + area ) ; } }", "nl": "Driver Code"}
{"code": "public class Diagonals { static int numberOfDiagonals ( int n ) { return n * ( n - 3 ) / 2 ; }", "nl": "Java function to find number of diagonals in n sided convex polygon"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; System . out . print ( n + \" \u2581 sided \u2581 convex \u2581 polygon \u2581 have \u2581 \" ) ; System . out . println ( numberOfDiagonals ( n ) + \" \u2581 diagonals \" ) ; } }", "nl": "driver code to test above function"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to find area of largest Rectangle without hole within a given Rectangle"}
{"code": "static void maximumArea ( int l , int b , int x , int y ) {", "nl": "Function to find the maximum area such that it does not contains any hole"}
{"code": "int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ;", "nl": "Area for all the possible positions of the cut"}
{"code": "System . out . print ( Math . max ( Math . max ( left , right ) , Math . max ( above , below ) ) ) ; }", "nl": "Find the maximum area among the above rectangles"}
{"code": "public static void main ( String [ ] args ) { int L = 8 , B = 8 ; int X = 0 , Y = 0 ;", "nl": "Driver Code"}
{"code": "maximumArea ( L , B , X , Y ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; public class GFG {", "nl": "Java program for the above approach"}
{"code": "static int delCost ( String s , int [ ] cost ) {", "nl": "Function to find the minimum cost of removing characters to make the string unique"}
{"code": "int ans = 0 ;", "nl": "Store the minimum cost required"}
{"code": "HashMap < Character , Integer > forMax = new HashMap < > ( ) ;", "nl": "Create a dictionary to store the maximum cost of removal a character"}
{"code": "HashMap < Character , Integer > forTot = new HashMap < > ( ) ;", "nl": "Create a dictionary to store the total deletion cost of a character"}
{"code": "for ( int i = 0 ; i < s . length ( ) ; i ++ ) {", "nl": "Traverse the string , S"}
{"code": "if ( ! forMax . containsKey ( s . charAt ( i ) ) ) { forMax . put ( s . charAt ( i ) , cost [ i ] ) ; } else {", "nl": "Keep track of maximum cost of each character"}
{"code": "forMax . put ( s . charAt ( i ) , Math . max ( cost [ i ] , forMax . get ( s . charAt ( i ) ) ) ) ; }", "nl": "Update the maximum deletion cost"}
{"code": "if ( ! forTot . containsKey ( s . charAt ( i ) ) ) { forTot . put ( s . charAt ( i ) , cost [ i ] ) ; } else {", "nl": "Keep track of the total cost of each character"}
{"code": "forTot . put ( s . charAt ( i ) , forTot . get ( s . charAt ( i ) ) + cost [ i ] ) ; } }", "nl": "Update the total deletion cost"}
{"code": "for ( Map . Entry < Character , Integer > i : forMax . entrySet ( ) ) {", "nl": "Traverse through all the unique characters"}
{"code": "ans += forTot . get ( i . getKey ( ) ) - i . getValue ( ) ; }", "nl": "Keep the maximum cost character and delete the rest"}
{"code": "return ans ; }", "nl": "Return the answer"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "String s = \" AAABBB \" ;", "nl": "Given string"}
{"code": "int [ ] cost = { 1 , 2 , 3 , 4 , 5 , 6 } ;", "nl": "Given cost array"}
{"code": "System . out . println ( delCost ( s , cost ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static final int MAX = 10000 ; static Vector < Integer > [ ] divisors = new Vector [ MAX + 1 ] ;", "nl": "Define macros"}
{"code": "static void computeDivisors ( ) { for ( int i = 1 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j += i ) {", "nl": "Stores divisors for all numbers in the vector divisors"}
{"code": "divisors [ j ] . add ( i ) ; } } }", "nl": "i is the divisor and j is the multiple"}
{"code": "static int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; }", "nl": "Function to compare the closeness of the given target"}
{"code": "static int findClosest ( Vector < Integer > array , int n , int target ) { Integer [ ] arr = array . toArray ( new Integer [ array . size ( ) ] ) ;", "nl": "Function to find the element closest to target in divisors vector"}
{"code": "if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ;", "nl": "Corner cases"}
{"code": "int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ;", "nl": "Perform binary search"}
{"code": "if ( target < arr [ mid ] ) {", "nl": "Check if target is less than the array element then search in left half"}
{"code": "if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ;", "nl": "Check if target is greater than previous to mid , return closest of two"}
{"code": "j = mid ; }", "nl": "Repeat for left half"}
{"code": "else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ;", "nl": "Check if target is greater than mid"}
{"code": "i = mid + 1 ; } }", "nl": "Update i"}
{"code": "return arr [ mid ] ; }", "nl": "Only single element left after search"}
{"code": "static void printClosest ( int N , int X ) {", "nl": "Function to print the divisor of N closest to X"}
{"code": "computeDivisors ( ) ;", "nl": "Function call to calculate and stores divisors of all numbers in a vector"}
{"code": "int ans = findClosest ( divisors [ N ] , divisors [ N ] . size ( ) , X ) ;", "nl": "Stores the closest value to target"}
{"code": "System . out . print ( ans ) ; }", "nl": "Print the answer"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 16 , X = 5 ; for ( int i = 0 ; i < divisors . length ; i ++ ) divisors [ i ] = new Vector < Integer > ( ) ;", "nl": "Given N & X"}
{"code": "printClosest ( N , X ) ; } }", "nl": "Function Call"}
{"code": "import java . io . Console ; import java . util . HashMap ; import java . util . Map ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int maxMatch ( int [ ] A , int [ ] B ) {", "nl": "Function to count maximum matched elements from the arrays A [ ] and B [ ]"}
{"code": "HashMap < Integer , Integer > Aindex = new HashMap < Integer , Integer > ( ) ;", "nl": "Stores position of elements of array A [ ] in the array B [ ]"}
{"code": "HashMap < Integer , Integer > diff = new HashMap < Integer , Integer > ( ) ;", "nl": "Keep track of difference between the indices"}
{"code": "for ( int i = 0 ; i < A . length ; i ++ ) { Aindex . put ( A [ i ] , i ) ; }", "nl": "Traverse the array A [ ]"}
{"code": "for ( int i = 0 ; i < B . length ; i ++ ) {", "nl": "Traverse the array B [ ]"}
{"code": "if ( i - Aindex . get ( B [ i ] ) < 0 ) { if ( ! diff . containsKey ( A . length + i - Aindex . get ( B [ i ] ) ) ) { diff . put ( A . length + i - Aindex . get ( B [ i ] ) , 1 ) ; } else { diff . put ( A . length + i - Aindex . get ( B [ i ] ) , diff . get ( A . length + i - Aindex . get ( B [ i ] ) ) + 1 ) ; } }", "nl": "If difference is negative , add N to it"}
{"code": "else { if ( ! diff . containsKey ( i - Aindex . get ( B [ i ] ) ) ) { diff . put ( i - Aindex . get ( B [ i ] ) , 1 ) ; } else { diff . put ( i - Aindex . get ( B [ i ] ) , diff . get ( i - Aindex . get ( B [ i ] ) ) + 1 ) ; } } }", "nl": "Keep track of the number of shifts required to place elements at same indices"}
{"code": "int max = 0 ; for ( Map . Entry < Integer , Integer > ele : diff . entrySet ( ) ) { if ( ele . getValue ( ) > max ) { max = ele . getValue ( ) ; } } return max ; }", "nl": "Return the max matches"}
{"code": "public static void main ( String [ ] args ) { int [ ] A = { 5 , 3 , 7 , 9 , 8 } ; int [ ] B = { 8 , 7 , 3 , 5 , 9 } ;", "nl": "Driver Code"}
{"code": "System . out . println ( maxMatch ( A , B ) ) ; } }", "nl": "Returns the count of matched elements"}
{"code": "import java . io . * ; import java . util . * ; class GFG { static int N = 9 ;", "nl": "Java program to implement the above approach"}
{"code": "static boolean isinRange ( int [ ] [ ] board ) {", "nl": "Function to check if all elements of the board [ ] [ ] array store value in the range [ 1 , 9 ]"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) {", "nl": "Traverse board [ ] [ ] array"}
{"code": "if ( board [ i ] [ j ] <= 0 board [ i ] [ j ] > 9 ) { return false ; } } } return true ; }", "nl": "Check if board [ i ] [ j ] lies in the range"}
{"code": "static boolean isValidSudoku ( int board [ ] [ ] ) {", "nl": "Function to check if the solution of sudoku puzzle is valid or not"}
{"code": "if ( isinRange ( board ) == false ) { return false ; }", "nl": "Check if all elements of board [ ] [ ] stores value in the range [ 1 , 9 ]"}
{"code": "boolean [ ] unique = new boolean [ N + 1 ] ;", "nl": "Stores unique value from 1 to N"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse each row of the given array"}
{"code": "Arrays . fill ( unique , false ) ;", "nl": "Initialize unique [ ] array to false"}
{"code": "for ( int j = 0 ; j < N ; j ++ ) {", "nl": "Traverse each column of current row"}
{"code": "int Z = board [ i ] [ j ] ;", "nl": "Stores the value of board [ i ] [ j ]"}
{"code": "if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } }", "nl": "Check if current row stores duplicate value"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse each column of the given array"}
{"code": "Arrays . fill ( unique , false ) ;", "nl": "Initialize unique [ ] array to false"}
{"code": "for ( int j = 0 ; j < N ; j ++ ) {", "nl": "Traverse each row of current column"}
{"code": "int Z = board [ j ] [ i ] ;", "nl": "Stores the value of board [ j ] [ i ]"}
{"code": "if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } }", "nl": "Check if current column stores duplicate value"}
{"code": "for ( int i = 0 ; i < N - 2 ; i += 3 ) {", "nl": "Traverse each block of size 3 * 3 in board [ ] [ ] array"}
{"code": "for ( int j = 0 ; j < N - 2 ; j += 3 ) {", "nl": "j stores first column of each 3 * 3 block"}
{"code": "Arrays . fill ( unique , false ) ;", "nl": "Initialize unique [ ] array to false"}
{"code": "for ( int k = 0 ; k < 3 ; k ++ ) { for ( int l = 0 ; l < 3 ; l ++ ) {", "nl": "Traverse current block"}
{"code": "int X = i + k ;", "nl": "Stores row number of current block"}
{"code": "int Y = j + l ;", "nl": "Stores column number of current block"}
{"code": "int Z = board [ X ] [ Y ] ;", "nl": "Stores the value of board [ X ] [ Y ]"}
{"code": "if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } } }", "nl": "Check if current block stores duplicate value"}
{"code": "return true ; }", "nl": "If all conditions satisfied"}
{"code": "public static void main ( String [ ] args ) { int [ ] [ ] board = { { 7 , 9 , 2 , 1 , 5 , 4 , 3 , 8 , 6 } , { 6 , 4 , 3 , 8 , 2 , 7 , 1 , 5 , 9 } , { 8 , 5 , 1 , 3 , 9 , 6 , 7 , 2 , 4 } , { 2 , 6 , 5 , 9 , 7 , 3 , 8 , 4 , 1 } , { 4 , 8 , 9 , 5 , 6 , 1 , 2 , 7 , 3 } , { 3 , 1 , 7 , 4 , 8 , 2 , 9 , 6 , 5 } , { 1 , 3 , 6 , 7 , 4 , 8 , 5 , 9 , 2 } , { 9 , 7 , 4 , 2 , 1 , 5 , 6 , 3 , 8 } , { 5 , 2 , 8 , 6 , 3 , 9 , 4 , 1 , 7 } } ; if ( isValidSudoku ( board ) ) { System . out . println ( \" Valid \" ) ; } else { System . out . println ( \" Not \u2581 Valid \" ) ; } } }", "nl": "Driver Code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "public static boolean palindrome ( int [ ] a , int i , int j ) { while ( i < j ) {", "nl": "Function to check if a number is Palindrome or not here i is the starting index and j is the last index of the subarray"}
{"code": "if ( a [ i ] != a [ j ] ) return false ;", "nl": "If the integer at i is not equal to j then the subarray is not palindrome"}
{"code": "i ++ ; j -- ; }", "nl": "Otherwise"}
{"code": "return true ; }", "nl": "all a [ i ] is equal to a [ j ] then the subarray is palindrome"}
{"code": "static int findSubArray ( int [ ] arr , int k ) { int n = arr . length ;", "nl": "Function to find a subarray whose concatenation forms a palindrome and return its starting index"}
{"code": "for ( int i = 0 ; i <= n - k ; i ++ ) { if ( palindrome ( arr , i , i + k - 1 ) ) return i ; }", "nl": "Iterating over subarray of length k and checking if that subarray is palindrome"}
{"code": "return - 1 ; }", "nl": "If no subarray is palindrome"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 5 , 1 , 3 } ; int k = 4 ; int ans = findSubArray ( arr , k ) ; if ( ans == - 1 ) System . out . print ( - 1 + \"NEW_LINE\"); else { for ( int i = ans ; i < ans + k ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; System . out . print ( \"NEW_LINE\"); } } }", "nl": "Driver code"}
{"code": "import java . awt . Point ; import java . util . HashSet ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void isCrossed ( String path ) { if ( path . length ( ) == 0 ) return ;", "nl": "Function to check if the man crosses previous visited coordinate or not"}
{"code": "boolean ans = false ;", "nl": "Stores the count of crossed vertex"}
{"code": "HashSet < Point > set = new HashSet < Point > ( ) ;", "nl": "Stores ( x , y ) coordinates"}
{"code": "int x = 0 , y = 0 ; set . add ( new Point ( x , y ) ) ;", "nl": "The coordinates for the origin"}
{"code": "for ( int i = 0 ; i < path . length ( ) ; i ++ ) {", "nl": "Iterate over the String"}
{"code": "if ( path . charAt ( i ) == ' N ' ) set . add ( new Point ( x , y ++ ) ) ; if ( path . charAt ( i ) == ' S ' ) set . add ( new Point ( x , y -- ) ) ; if ( path . charAt ( i ) == ' E ' ) set . add ( new Point ( x ++ , y ) ) ; if ( path . charAt ( i ) == ' W ' ) set . add ( new Point ( x -- , y ) ) ;", "nl": "Condition to increment X or Y co - ordinates respectively"}
{"code": "if ( set . contains ( new Point ( x , y ) ) ) { ans = true ; break ; } }", "nl": "Check if ( x , y ) is already visited"}
{"code": "if ( ans ) System . out . print ( \" Crossed \" ) ; else System . out . print ( \" Not \u2581 Crossed \" ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "String path = \" NESW \" ;", "nl": "Given String"}
{"code": "isCrossed ( path ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int maxWidth ( int N , int M , ArrayList < Integer > cost , ArrayList < ArrayList < Integer > > s ) {", "nl": "Function to find the maximum width of the tree using level order traversal"}
{"code": "ArrayList < ArrayList < Integer > > adj = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { adj . add ( new ArrayList < Integer > ( ) ) ; } for ( int i = 0 ; i < M ; i ++ ) { adj . get ( s . get ( i ) . get ( 0 ) ) . add ( s . get ( i ) . get ( 1 ) ) ; }", "nl": "Store the edges of the tree"}
{"code": "int result = 0 ;", "nl": "Stores maximum width of the tree"}
{"code": "Queue < Integer > q = new LinkedList < > ( ) ;", "nl": "Stores the nodes of each level"}
{"code": "q . add ( 0 ) ;", "nl": "Insert root node"}
{"code": "while ( q . size ( ) != 0 ) {", "nl": "Perform level order traversal on the tree"}
{"code": "int count = q . size ( ) ;", "nl": "Stores the size of the queue"}
{"code": "result = Math . max ( count , result ) ;", "nl": "Update maximum width"}
{"code": "while ( count -- > 0 ) {", "nl": "Push the nodes of the next level and pop the elements of the current level"}
{"code": "int temp = q . remove ( ) ;", "nl": "Get element from the front the Queue"}
{"code": "for ( int i = 0 ; i < adj . get ( temp ) . size ( ) ; i ++ ) { q . add ( adj . get ( temp ) . get ( i ) ) ; } } }", "nl": "Push all nodes of the next level ."}
{"code": "return result ; }", "nl": "Return the result ."}
{"code": "public static void main ( String [ ] args ) { int N = 11 , M = 10 ; ArrayList < ArrayList < Integer > > edges = new ArrayList < ArrayList < Integer > > ( ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 0 , 1 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 0 , 2 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 0 , 3 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 1 , 4 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 1 , 5 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 3 , 6 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 4 , 7 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 6 , 10 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 6 , 8 ) ) ) ; edges . add ( new ArrayList < Integer > ( Arrays . asList ( 6 , 9 ) ) ) ; ArrayList < Integer > cost = new ArrayList < Integer > ( Arrays . asList ( 1 , 2 , - 1 , 3 , 4 , 5 , 8 , 2 , 6 , 12 , 7 ) ) ;", "nl": "Driver Code"}
{"code": "System . out . println ( maxWidth ( N , M , cost , edges ) ) ; } }", "nl": "Constructed tree is : 1 / | \\ 2 - 1 3 / \\ \\ 4 5 8 / / | \\ 2 6 12 7"}
{"code": "import java . util . * ; class GFG { static final int MAX = 10000000 ;", "nl": "Java program to implement the above approach"}
{"code": "static boolean [ ] isPrime = new boolean [ MAX + 1 ] ;", "nl": "Stores if an index is a prime / non - prime value"}
{"code": "static Vector < Integer > primes = new Vector < Integer > ( ) ;", "nl": "Stores the prime"}
{"code": "static void SieveOfEratosthenes ( ) { Arrays . fill ( isPrime , true ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) {", "nl": "Function to generate all prime numbers"}
{"code": "if ( isPrime [ p ] == true ) {", "nl": "If current element is prime"}
{"code": "for ( int i = p * p ; i <= MAX ; i += p ) isPrime [ i ] = false ; } }", "nl": "Set all its multiples non - prime"}
{"code": "for ( int p = 2 ; p <= MAX ; p ++ ) if ( isPrime [ p ] ) primes . add ( p ) ; }", "nl": "Store all prime numbers"}
{"code": "static int prime_search ( Vector < Integer > primes , int diff ) {", "nl": "Function to find the closest prime to a particular number"}
{"code": "int low = 0 ; int high = primes . size ( ) - 1 ; int res = - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ;", "nl": "Applying binary search on primes vector"}
{"code": "if ( primes . get ( mid ) == diff ) {", "nl": "If the prime added makes the elements equal"}
{"code": "return primes . get ( mid ) ; }", "nl": "Return this as the closest prime"}
{"code": "else if ( primes . get ( mid ) < diff ) {", "nl": "If the array remains non - decreasing"}
{"code": "low = mid + 1 ; }", "nl": "Search for a bigger prime number"}
{"code": "else { res = primes . get ( mid ) ;", "nl": "Otherwise"}
{"code": "high = mid - 1 ; } }", "nl": "Check if a smaller prime can make array non - decreasing or not"}
{"code": "return res ; }", "nl": "Return closest number"}
{"code": "static int minCost ( int arr [ ] , int n ) {", "nl": "Function to find the minimum cost"}
{"code": "SieveOfEratosthenes ( ) ;", "nl": "Find all primes"}
{"code": "int res = 0 ;", "nl": "Store the result"}
{"code": "for ( int i = 1 ; i < n ; i ++ ) {", "nl": "Iterate over the array"}
{"code": "if ( arr [ i ] < arr [ i - 1 ] ) { int diff = arr [ i - 1 ] - arr [ i ] ;", "nl": "Current element is less than the previous element"}
{"code": "int closest_prime = prime_search ( primes , diff ) ;", "nl": "Find the closest prime which makes the array non decreasing"}
{"code": "res += closest_prime ;", "nl": "Add to overall cost"}
{"code": "arr [ i ] += closest_prime ; } }", "nl": "Update current element"}
{"code": "return res ; }", "nl": "Return the minimum cost"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 2 , 1 , 5 , 4 , 3 } ; int n = 5 ;", "nl": "Given array"}
{"code": "System . out . print ( minCost ( arr , n ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; import java . lang . * ; class GFG {", "nl": "Java implementation for the above approach"}
{"code": "static int count ( String s ) {", "nl": "Function to return ways to split a string into three parts with the equal number of 0"}
{"code": "int cnt = 0 ;", "nl": "Store total count of 0 s"}
{"code": "for ( char c : s . toCharArray ( ) ) { cnt += c == '0' ? 1 : 0 ; }", "nl": "Count total no . of 0 s character in given string"}
{"code": "if ( cnt % 3 != 0 ) return 0 ; int res = 0 , k = cnt / 3 , sum = 0 ;", "nl": "If total count of 0 character is not divisible by 3"}
{"code": "Map < Integer , Integer > map = new HashMap < > ( ) ;", "nl": "Initialize map to store frequency of k"}
{"code": "for ( int i = 0 ; i < s . length ( ) ; i ++ ) {", "nl": "Traverse string to find ways to split string"}
{"code": "sum += s . charAt ( i ) == '0' ? 1 : 0 ;", "nl": "Increment count if 0 appears"}
{"code": "if ( sum == 2 * k && map . containsKey ( k ) && i < s . length ( ) - 1 && i > 0 ) { res += map . get ( k ) ; }", "nl": "Increment result if sum equal to 2 * k and k exists in map"}
{"code": "map . put ( sum , map . getOrDefault ( sum , 0 ) + 1 ) ; }", "nl": "Insert sum in map"}
{"code": "return res ; }", "nl": "Return result"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "String str = \"01010\" ;", "nl": "Given string"}
{"code": "System . out . println ( count ( str ) ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for above approach"}
{"code": "static int splitstring ( String s ) { int n = s . length ( ) ;", "nl": "Function to calculate the number of ways to split"}
{"code": "int zeros = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( s . charAt ( i ) == '0' ) zeros ++ ;", "nl": "Calculating the total number of zeros"}
{"code": "if ( zeros % 3 != 0 ) return 0 ;", "nl": "Case1 If total count of zeros is not divisible by 3"}
{"code": "if ( zeros == 0 ) return ( ( n - 1 ) * ( n - 2 ) ) / 2 ;", "nl": "Case2 if total count of zeros is zero"}
{"code": "int zerosInEachSubstring = zeros / 3 ;", "nl": "Number of zeros in each substring"}
{"code": "int waysOfFirstCut = 0 ; int waysOfSecondCut = 0 ;", "nl": "Initialising zero to the number of ways for first and second cut"}
{"code": "int count = 0 ;", "nl": "Initializing the count"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traversing from the beginning"}
{"code": "if ( s . charAt ( i ) == '0' ) count ++ ;", "nl": "Incrementing the count if the element is '0'"}
{"code": "if ( count == zerosInEachSubstring ) waysOfFirstCut ++ ;", "nl": "Incrementing the ways for the 1 st cut if count is equal to zeros required in each substring"}
{"code": "else if ( count == 2 * zerosInEachSubstring ) waysOfSecondCut ++ ; }", "nl": "Incrementing the ways for the 2 nd cut if count is equal to 2 * ( zeros required in each substring )"}
{"code": "return waysOfFirstCut * waysOfSecondCut ; }", "nl": "Total number of ways to split is multiplication of ways for the 1 st and 2 nd cut"}
{"code": "public static void main ( String args [ ] ) { String s = \"01010\" ;", "nl": "Driver Code"}
{"code": "System . out . println ( \" The \u2581 number \u2581 of \u2581 \" + \" ways \u2581 to \u2581 split \u2581 is \u2581 \" + splitstring ( s ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static boolean canTransform ( String str1 , String str2 ) { String s1 = \" \" ; String s2 = \" \" ;", "nl": "Function to check if it is possible to transform start to end"}
{"code": "for ( char c : str1 . toCharArray ( ) ) { if ( c != ' C ' ) { s1 += c ; } } for ( char c : str2 . toCharArray ( ) ) { if ( c != ' C ' ) { s2 += c ; } }", "nl": "Check the sequence of A , B in both Strings str1 and str2"}
{"code": "if ( ! s1 . equals ( s2 ) ) return false ; int i = 0 ; int j = 0 ; int n = str1 . length ( ) ;", "nl": "If both the Strings are not equal"}
{"code": "while ( i < n && j < n ) { if ( str1 . charAt ( i ) == ' C ' ) { i ++ ; } else if ( str2 . charAt ( j ) == ' C ' ) { j ++ ; }", "nl": "Traverse the Strings"}
{"code": "else { if ( ( str1 . charAt ( i ) == ' A ' && i < j ) || ( str1 . charAt ( i ) == ' B ' && i > j ) ) { return false ; } i ++ ; j ++ ; } } return true ; }", "nl": "Check for indexes of A and B"}
{"code": "public static void main ( String [ ] args ) { String str1 = \" BCCABCBCA \" ; String str2 = \" CBACCBBAC \" ;", "nl": "Driver Code"}
{"code": "if ( canTransform ( str1 , str2 ) ) { System . out . print ( \" Yes \" ) ; } else { System . out . print ( \" No \" ) ; } } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int maxsubStringLength ( char [ ] S , int N ) { int arr [ ] = new int [ N ] ;", "nl": "Function to return the length of the longest subString having equal number of vowel and consonant"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' a ' S [ i ] == ' e ' S [ i ] == ' i ' S [ i ] == ' o ' S [ i ] == ' u ' ) arr [ i ] = 1 ; else arr [ i ] = - 1 ;", "nl": "Generate the array"}
{"code": "int maxLen = 0 ;", "nl": "Initialize variable to store result"}
{"code": "int curr_sum = 0 ;", "nl": "Stores the sum of subarray"}
{"code": "HashMap < Integer , Integer > hash = new HashMap < > ( ) ;", "nl": "Map to store indices of the sum"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ;", "nl": "Loop through the array"}
{"code": "if ( curr_sum == 0 )", "nl": "If sum is 0"}
{"code": "maxLen = Math . max ( maxLen , i + 1 ) ;", "nl": "Count of vowels and consonants are equal"}
{"code": "if ( hash . containsKey ( curr_sum ) ) maxLen = Math . max ( maxLen , i - hash . get ( curr_sum ) ) ;", "nl": "Update the maximum length of subString in HashMap"}
{"code": "else hash . put ( curr_sum , i ) ; }", "nl": "Store the index of the sum"}
{"code": "return maxLen ; }", "nl": "Return the maximum length of required subString"}
{"code": "public static void main ( String [ ] args ) { String S = \" geeksforgeeks \" ; int n = S . length ( ) ; System . out . print ( maxsubStringLength ( S . toCharArray ( ) , n ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int [ ] [ ] mat = new int [ 1001 ] [ 1001 ] ; static int r , c , x , y ;", "nl": "Java program to implement the above approach"}
{"code": "static int dx [ ] = { 0 , - 1 , - 1 , - 1 , 0 , 1 , 1 , 1 } ; static int dy [ ] = { 1 , 1 , 0 , - 1 , - 1 , - 1 , 0 , 1 } ;", "nl": "Stores the accessible directions"}
{"code": "static void FindMinimumDistance ( ) {", "nl": "Function to find the minimum distance from a given cell to all other cells in the matrix"}
{"code": "Queue < pair > q = new LinkedList < > ( ) ;", "nl": "Stores the accessible cells from current cell"}
{"code": "q . add ( new pair ( x , y ) ) ; mat [ x ] [ y ] = 0 ;", "nl": "Insert pair ( x , y )"}
{"code": "while ( ! q . isEmpty ( ) ) {", "nl": "Iterate untill queue is empty"}
{"code": "x = q . peek ( ) . first ; y = q . peek ( ) . second ;", "nl": "Extract the pair"}
{"code": "q . remove ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) { int a = x + dx [ i ] ; int b = y + dy [ i ] ;", "nl": "Pop them"}
{"code": "if ( a < 0 a >= r b >= c b < 0 ) continue ;", "nl": "Checking boundary condition"}
{"code": "if ( mat [ a ] [ b ] == 0 ) {", "nl": "If the cell is not visited"}
{"code": "mat [ a ] [ b ] = mat [ x ] [ y ] + 1 ;", "nl": "Assign the minimum distance"}
{"code": "q . add ( new pair ( a , b ) ) ; } } } }", "nl": "Insert the traversed neighbour into the queue"}
{"code": "public static void main ( String [ ] args ) { r = 5 ; c = 5 ; x = 1 ; y = 1 ; int t = x ; int l = y ; mat [ x ] [ y ] = 0 ; FindMinimumDistance ( ) ; mat [ t ] [ l ] = 0 ;", "nl": "Driver Code"}
{"code": "for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { System . out . print ( mat [ i ] [ j ] + \" \u2581 \" ) ; } System . out . println ( ) ; } } }", "nl": "Print the required distances"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "public static int minOperations ( String S , int K ) {", "nl": "Function that returns the minimum number of flips to convert the s into a concatenation of K - length sub - string"}
{"code": "int ans = 0 ;", "nl": "Stores the result"}
{"code": "for ( int i = 0 ; i < K ; i ++ ) {", "nl": "Iterate through string index"}
{"code": "int zero = 0 , one = 0 ;", "nl": "Stores count of 0 s & 1 s"}
{"code": "for ( int j = i ; j < S . length ( ) ; j += K ) {", "nl": "Iterate making K jumps"}
{"code": "if ( S . charAt ( j ) == '0' ) zero ++ ;", "nl": "Count 0 's"}
{"code": "else one ++ ; }", "nl": "Count 1 's"}
{"code": "ans += Math . min ( zero , one ) ; }", "nl": "Add minimum flips for index i"}
{"code": "return ans ; }", "nl": "Return minimum number of flips"}
{"code": "public static void main ( String args [ ] ) { String S = \"110100101\" ; int K = 3 ; System . out . println ( minOperations ( S , K ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "static int missingElement ( int arr [ ] , int n ) {", "nl": "Function to get the missing element"}
{"code": "int max_ele = arr [ 0 ] ;", "nl": "For maximum Element in the array"}
{"code": "int min_ele = arr [ 0 ] ;", "nl": "For minimum Element in the array"}
{"code": "int x = 0 ;", "nl": "For xor of all elements"}
{"code": "int d ;", "nl": "Common difference of AP series"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; if ( arr [ i ] < min_ele ) min_ele = arr [ i ] ; }", "nl": "find maximum and minimum element"}
{"code": "d = ( max_ele - min_ele ) / n ;", "nl": "Calculating common difference"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { x = x ^ arr [ i ] ; }", "nl": "Calculate the XOR of all elements"}
{"code": "for ( int i = 0 ; i <= n ; i ++ ) { x = x ^ ( min_ele + ( i * d ) ) ; }", "nl": "Perform XOR with actual AP series resultant x will be the ans"}
{"code": "return x ; }", "nl": "Return the missing element"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int arr [ ] = new int [ ] { 12 , 3 , 6 , 15 , 18 } ; int n = arr . length ;", "nl": "Given array"}
{"code": "int element = missingElement ( arr , n ) ;", "nl": "Function Call"}
{"code": "System . out . print ( element ) ; } }", "nl": "Print the missing element"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static void Printksubstring ( String str , int n , int k ) {", "nl": "Function to prints kth sub - string"}
{"code": "int total = ( n * ( n + 1 ) ) / 2 ;", "nl": "Total sub - strings possible"}
{"code": "if ( k > total ) { System . out . printf ( \"-1NEW_LINE\"); return ; }", "nl": "If k is greater than total number of sub - strings"}
{"code": "int substring [ ] = new int [ n + 1 ] ; substring [ 0 ] = 0 ;", "nl": "To store number of sub - strings starting with ith character of the string"}
{"code": "int temp = n ; for ( int i = 1 ; i <= n ; i ++ ) {", "nl": "Compute the values"}
{"code": "substring [ i ] = substring [ i - 1 ] + temp ; temp -- ; }", "nl": "substring [ i - 1 ] is added to store the cumulative sum"}
{"code": "int l = 1 ; int h = n ; int start = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( substring [ m ] > k ) { start = m ; h = m - 1 ; } else if ( substring [ m ] < k ) { l = m + 1 ; } else { start = m ; break ; } }", "nl": "Binary search to find the starting index of the kth sub - string"}
{"code": "int end = n - ( substring [ start ] - k ) ;", "nl": "To store the ending index of the kth sub - string"}
{"code": "for ( int i = start - 1 ; i < end ; i ++ ) { System . out . print ( str . charAt ( i ) ) ; } }", "nl": "Print the sub - string"}
{"code": "public static void main ( String [ ] args ) { String str = \" abc \" ; int k = 4 ; int n = str . length ( ) ; Printksubstring ( str , n , k ) ; } }", "nl": "Driver code"}
{"code": "public class AQES {", "nl": "Java program to find the lower insertion point of an element in a sorted array"}
{"code": "static int LowerInsertionPoint ( int arr [ ] , int n , int X ) {", "nl": "Function to return the lower insertion point of an element in a sorted array"}
{"code": "if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; }", "nl": "Base cases"}
{"code": "while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }", "nl": "Final check for the remaining elements which are < X"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 4 , 5 , 6 , 7 , 9 } ; int n = arr . length ; int X = 4 ; System . out . println ( LowerInsertionPoint ( arr , n , X ) ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; class GFG {", "nl": "Java Program to count the number of positions with same address in row major and column major order"}
{"code": "static int getCount ( int M , int N ) { int count = 0 ;", "nl": "Returns count of required positions"}
{"code": "if ( M == 1 ) return N ;", "nl": "horizontal 1D array"}
{"code": "if ( N == 1 ) return M ; if ( N > M ) {", "nl": "vertical 1D array"}
{"code": "for ( int i = 1 ; i <= M ; i ++ ) { int numerator = N * i - N + M - i ; int denominator = M - 1 ;", "nl": "iterating for all possible i"}
{"code": "if ( numerator % denominator == 0 ) { int j = numerator / denominator ;", "nl": "checking if j is integer"}
{"code": "if ( j >= 1 && j <= N ) count ++ ; } } } else {", "nl": "checking if j lies b / w 1 to N"}
{"code": "for ( int j = 1 ; j <= N ; j ++ ) { int numerator = M * j - M + N - j ; int denominator = N - 1 ;", "nl": "iterating for all possible j"}
{"code": "if ( numerator % denominator == 0 ) { int i = numerator / denominator ;", "nl": "checking if i is integer"}
{"code": "if ( i >= 1 && i <= M ) count ++ ; } } } return count ; }", "nl": "checking if i lies b / w 1 to M"}
{"code": "public static void main ( String [ ] args ) { int M = 3 , N = 5 ; System . out . println ( getCount ( M , N ) ) ; } }", "nl": "Driver Code"}
{"code": "class GFG {", "nl": "Java program to make array sorted"}
{"code": "static boolean swapElement ( int [ ] arr1 , int [ ] arr2 , int n ) {", "nl": "Function to check whether there is any swappable element present to make the first array sorted"}
{"code": "int wrongIdx = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr1 [ i ] < arr1 [ i - 1 ] ) { wrongIdx = i ; } } int maximum = Integer . MIN_VALUE ; int maxIdx = - 1 ; boolean res = false ;", "nl": "wrongIdx is the index of the element which is making the first array unsorted"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) { if ( arr2 [ i ] > maximum && arr2 [ i ] >= arr1 [ wrongIdx - 1 ] ) { if ( wrongIdx + 1 <= n - 1 && arr2 [ i ] <= arr1 [ wrongIdx + 1 ] ) { maximum = arr2 [ i ] ; maxIdx = i ; res = true ; } } }", "nl": "Find the maximum element which satisfies the above mentioned neighboring conditions"}
{"code": "if ( res ) { swap ( arr1 , wrongIdx , arr2 , maxIdx ) ; } return res ; } static void swap ( int [ ] a , int wrongIdx , int [ ] b , int maxIdx ) { int c = a [ wrongIdx ] ; a [ wrongIdx ] = b [ maxIdx ] ; b [ maxIdx ] = c ; }", "nl": "if res is true then swap the element and make the first array sorted"}
{"code": "static void getSortedArray ( int arr1 [ ] , int arr2 [ ] , int n ) { if ( swapElement ( arr1 , arr2 , n ) ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr1 [ i ] + \" \u2581 \" ) ; } } else { System . out . println ( \" Not \u2581 Possible \" ) ; } }", "nl": "Function to print the sorted array if elements are swapped ."}
{"code": "public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 3 , 7 , 4 , 10 } ; int arr2 [ ] = { 2 , 1 , 6 , 8 , 9 } ; int n = arr1 . length ; getSortedArray ( arr1 , arr2 , n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class Middle {", "nl": "Java program to find middle of three distinct numbers"}
{"code": "public static int middleOfThree ( int a , int b , int c ) {", "nl": "Function to find the middle of three number"}
{"code": "if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else {", "nl": "Compare each three number to find middle number . Enter only if a > b"}
{"code": "if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }", "nl": "Decided a is not greater than b ."}
{"code": "public static void main ( String [ ] args ) { int a = 20 , b = 30 , c = 40 ; System . out . println ( middleOfThree ( a , b , c ) ) ; } }", "nl": "driver code"}
{"code": "import java . util . * ; import java . util . Arrays ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static int [ ] [ ] transpose ( int [ ] [ ] mat , int row , int col ) {", "nl": "Function to find the transpose of the matrix mat [ ]"}
{"code": "int [ ] [ ] tr = new int [ col ] [ row ] ;", "nl": "Stores the transpose of matrix mat [ ] [ ]"}
{"code": "for ( int i = 0 ; i < row ; i ++ ) {", "nl": "Traverse each row of the matrix"}
{"code": "for ( int j = 0 ; j < col ; j ++ ) {", "nl": "Traverse each column of the matrix"}
{"code": "tr [ j ] [ i ] = mat [ i ] [ j ] ; } } return tr ; }", "nl": "Transpose matrix elements"}
{"code": "static void RowWiseSort ( int [ ] [ ] B ) {", "nl": "Function to sort the given matrix in row wise manner"}
{"code": "for ( int i = 0 ; i < ( int ) B . length ; i ++ ) {", "nl": "Traverse the row"}
{"code": "Arrays . sort ( B [ i ] ) ; } }", "nl": "Row - Wise Sorting"}
{"code": "static void sortCol ( int [ ] [ ] mat , int N , int M ) {", "nl": "Function to print the matrix in column wise sorted manner"}
{"code": "int [ ] [ ] B = transpose ( mat , N , M ) ;", "nl": "Function call to find transpose of the the matrix mat [ ] [ ]"}
{"code": "RowWiseSort ( B ) ;", "nl": "Sorting the matrix row - wise"}
{"code": "mat = transpose ( B , M , N ) ;", "nl": "Calculate transpose of B [ ] [ ]"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { System . out . print ( mat [ i ] [ j ] + \" \u2581 \" ) ; } System . out . println ( ) ; } }", "nl": "Print the matrix mat [ ] [ ]"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int [ ] [ ] mat = { { 1 , 6 , 10 } , { 8 , 5 , 9 } , { 9 , 4 , 15 } , { 7 , 3 , 60 } } ; int N = mat . length ; int M = mat [ 0 ] . length ;", "nl": "Input"}
{"code": "sortCol ( mat , N , M ) ; } }", "nl": "Function call to print the matrix in column wise sorted manner"}
{"code": "import java . lang . * ; import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void largestArea ( int N , int M , int [ ] H , int [ ] V ) {", "nl": "Function to find the largest area when a series of horizontal & vertical bars are removed"}
{"code": "Set < Integer > s1 = new HashSet < > ( ) ; Set < Integer > s2 = new HashSet < > ( ) ;", "nl": "Stores all bars"}
{"code": "for ( int i = 1 ; i <= N + 1 ; i ++ ) s1 . add ( i ) ;", "nl": "Insert horizontal bars"}
{"code": "for ( int i = 1 ; i <= M + 1 ; i ++ ) s2 . add ( i ) ;", "nl": "Insert vertictal bars"}
{"code": "for ( int i = 0 ; i < H . length ; i ++ ) { s1 . remove ( H [ i ] ) ; }", "nl": "Remove horizontal separators from s1"}
{"code": "for ( int i = 0 ; i < V . length ; i ++ ) { s2 . remove ( V [ i ] ) ; }", "nl": "Remove vertical separators from s2"}
{"code": "int [ ] list1 = new int [ s1 . size ( ) ] ; int [ ] list2 = new int [ s2 . size ( ) ] ; int i = 0 ; Iterator it1 = s1 . iterator ( ) ; while ( it1 . hasNext ( ) ) { list1 [ i ++ ] = ( int ) it1 . next ( ) ; } i = 0 ; Iterator it2 = s2 . iterator ( ) ; while ( it2 . hasNext ( ) ) { list2 [ i ++ ] = ( int ) it2 . next ( ) ; }", "nl": "Stores left out horizontal and vertical separators"}
{"code": "Arrays . sort ( list1 ) ; Arrays . sort ( list2 ) ; int maxH = 0 , p1 = 0 , maxV = 0 , p2 = 0 ;", "nl": "Sort both list in ascending order"}
{"code": "for ( int j = 0 ; j < list1 . length ; j ++ ) { maxH = Math . max ( maxH , list1 [ j ] - p1 ) ; p1 = list1 [ j ] ; }", "nl": "Find maximum difference of neighbors of list1"}
{"code": "for ( int j = 0 ; j < list2 . length ; j ++ ) { maxV = Math . max ( maxV , list2 [ j ] - p2 ) ; p2 = list2 [ j ] ; }", "nl": "Find max difference of neighbors of list2"}
{"code": "System . out . println ( maxV * maxH ) ; }", "nl": "Print largest volume"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 3 , M = 3 ;", "nl": "Given value of N & M"}
{"code": "int [ ] H = { 2 } ; int [ ] V = { 2 } ;", "nl": "Given arrays"}
{"code": "largestArea ( N , M , H , V ) ; } }", "nl": "Function call to find the largest area when a series of horizontal & vertical bars are removed"}
{"code": "import java . io . * ; class GFG {", "nl": "Java program of the above approach"}
{"code": "static boolean checkifSorted ( int A [ ] , int B [ ] , int N ) {", "nl": "Function to check if array , A [ ] can be converted into sorted array by swapping ( A [ i ] , A [ j ] ) if B [ i ] not equal to B [ j ]"}
{"code": "boolean flag = false ;", "nl": "Stores if array A [ ] is sorted in descending order or not"}
{"code": "for ( int i = 0 ; i < N - 1 ; i ++ ) {", "nl": "Traverse the array A [ ]"}
{"code": "if ( A [ i ] > A [ i + 1 ] ) {", "nl": "If A [ i ] is greater than A [ i + 1 ]"}
{"code": "flag = true ; break ; } }", "nl": "Update flag"}
{"code": "if ( ! flag ) { return true ; }", "nl": "If array is sorted in ascending order"}
{"code": "int count = 0 ;", "nl": "count = 2 : Check if 0 s and 1 s both present in the B [ ]"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array"}
{"code": "if ( B [ i ] == 0 ) {", "nl": "If current element is 0"}
{"code": "count ++ ; break ; } }", "nl": "Update count"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Traverse the array B [ ]"}
{"code": "if ( B [ i ] == 1 ) { count ++ ; break ; } }", "nl": "If current element is 1"}
{"code": "if ( count == 2 ) { return true ; } return false ; }", "nl": "If both 0 s and 1 s are present in the array"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int A [ ] = { 3 , 1 , 2 } ;", "nl": "Input array A [ ]"}
{"code": "int B [ ] = { 0 , 1 , 1 } ; int N = A . length ;", "nl": "Input array B [ ]"}
{"code": "boolean check = checkifSorted ( A , B , N ) ;", "nl": "Function call"}
{"code": "if ( check ) { System . out . println ( \" YES \" ) ; }", "nl": "If true , print YES"}
{"code": "else { System . out . println ( \" NO \" ) ; } } }", "nl": "Else print NO"}
{"code": "import java . util . * ; import java . lang . * ; class GFG {", "nl": "Java program for above approach"}
{"code": "static int minSteps ( StringBuilder A , StringBuilder B , int M , int N ) { if ( A . charAt ( 0 ) > B . charAt ( 0 ) ) return 0 ; if ( B . charAt ( 0 ) > A . charAt ( 0 ) ) { return 1 ; }", "nl": "Function to find the minimum number of steps to make A > B"}
{"code": "if ( M <= N && A . charAt ( 0 ) == B . charAt ( 0 ) && count ( A , A . charAt ( 0 ) ) == M && count ( B , B . charAt ( 0 ) ) == N ) return - 1 ;", "nl": "If all character are same and M <= N"}
{"code": "for ( int i = 1 ; i < N ; i ++ ) { if ( B . charAt ( i ) > B . charAt ( 0 ) ) return 1 ; }", "nl": "If there lies any character in B which is greater than B [ 0 ]"}
{"code": "for ( int i = 1 ; i < M ; i ++ ) { if ( A . charAt ( i ) < A . charAt ( 0 ) ) return 1 ; }", "nl": "If there lies any character in A which is smaller than A [ 0 ]"}
{"code": "for ( int i = 1 ; i < M ; i ++ ) { if ( A . charAt ( i ) > A . charAt ( 0 ) ) { swap ( A , i , B , 0 ) ; swap ( A , 0 , B , 0 ) ; return 2 ; } }", "nl": "If there lies a character which is in A and greater than A [ 0 ]"}
{"code": "for ( int i = 1 ; i < N ; i ++ ) { if ( B . charAt ( i ) < B . charAt ( 0 ) ) { swap ( A , 0 , B , i ) ; swap ( A , 0 , B , 0 ) ; return 2 ; } }", "nl": "If there lies a character which is in B and less than B [ 0 ]"}
{"code": "return 0 ; } static int count ( StringBuilder a , char c ) { int count = 0 ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) if ( a . charAt ( i ) == c ) count ++ ; return count ; } static void swap ( StringBuilder s1 , int index1 , StringBuilder s2 , int index2 ) { char c = s1 . charAt ( index1 ) ; s1 . setCharAt ( index1 , s2 . charAt ( index2 ) ) ; s2 . setCharAt ( index2 , c ) ; }", "nl": "Otherwise"}
{"code": "public static void main ( String [ ] args ) { StringBuilder A = new StringBuilder ( \" adsfd \" ) ; StringBuilder B = new StringBuilder ( \" dffff \" ) ; int M = A . length ( ) ; int N = B . length ( ) ; System . out . println ( minSteps ( A , B , M , N ) ) ; } }", "nl": "Driver function"}
{"code": "import java . util . * ; class GFG {", "nl": "Java algorithm for above approach"}
{"code": "public static class Pair { int val ; int idx ; Pair ( int val , int idx ) { this . val = val ; this . idx = idx ; } }", "nl": "Pair class which will store element of array with its index"}
{"code": "public static void main ( String [ ] args ) { int n = 5 ; int [ ] arr = { 4 , 7 , 2 , 3 , 9 } ; System . out . println ( minOperations ( arr , n ) ) ; }", "nl": "Driver code"}
{"code": "public static int minOperations ( int [ ] arr , int n ) {", "nl": "Function to find minimum number of operation required so that array becomes meaningful"}
{"code": "Pair [ ] num = new Pair [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { num [ i ] = new Pair ( arr [ i ] , i ) ; }", "nl": "Initializing array of Pair type which can be used to sort arr with respect to its values"}
{"code": "Arrays . sort ( num , ( Pair a , Pair b ) -> a . val - b . val ) ;", "nl": "Sorting array num on the basis of value"}
{"code": "int res = 1 ; int streak = 1 ; int prev = num [ 0 ] . idx ; for ( int i = 1 ; i < n ; i ++ ) { if ( prev < num [ i ] . idx ) { res ++ ;", "nl": "Initializing variables used to find maximum length of increasing streak in index"}
{"code": "streak = Math . max ( res , streak ) ; } else res = 1 ; prev = num [ i ] . idx ; }", "nl": "Updating streak"}
{"code": "return n - streak ; } }", "nl": "Returning number of elements left except streak"}
{"code": "import java . util . * ; import java . lang . * ; class GFG { static final int maxN = 201 ;", "nl": "Java program for above approach"}
{"code": "static int n1 , n2 , n3 ;", "nl": "Variables which represent the size of the array"}
{"code": "static int [ ] [ ] [ ] dp = new int [ maxN ] [ maxN ] [ maxN ] ;", "nl": "Stores the results"}
{"code": "static int getMaxSum ( int i , int j , int k , int arr1 [ ] , int arr2 [ ] , int arr3 [ ] ) {", "nl": "Function to return the maximum possible sum"}
{"code": "int cnt = 0 ; if ( i >= n1 ) cnt ++ ; if ( j >= n2 ) cnt ++ ; if ( k >= n3 ) cnt ++ ;", "nl": "Stores the count of arrays processed"}
{"code": "if ( cnt >= 2 ) return 0 ;", "nl": "If more than two arrays have been processed"}
{"code": "if ( dp [ i ] [ j ] [ k ] != - 1 ) return dp [ i ] [ j ] [ k ] ; int ans = 0 ;", "nl": "If an already computed subproblem occurred"}
{"code": "if ( i < n1 && j < n2 )", "nl": "Explore all the possible pairs"}
{"code": "ans = Math . max ( ans , getMaxSum ( i + 1 , j + 1 , k , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr2 [ j ] ) ; if ( i < n1 && k < n3 ) ans = Math . max ( ans , getMaxSum ( i + 1 , j , k + 1 , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr3 [ k ] ) ; if ( j < n2 && k < n3 ) ans = Math . max ( ans , getMaxSum ( i , j + 1 , k + 1 , arr1 , arr2 , arr3 ) + arr2 [ j ] * arr3 [ k ] ) ;", "nl": "Recursive function call"}
{"code": "dp [ i ] [ j ] [ k ] = ans ;", "nl": "Memoize the maximum"}
{"code": "return dp [ i ] [ j ] [ k ] ; } static void reverse ( int [ ] tmp ) { int i , k , t ; int n = tmp . length ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = tmp [ i ] ; tmp [ i ] = tmp [ n - i - 1 ] ; tmp [ n - i - 1 ] = t ; } }", "nl": "Returning the value"}
{"code": "static int maxProductSum ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] ) {", "nl": "Function to return the maximum sum of products of pairs possible"}
{"code": "for ( int i = 0 ; i < dp . length ; i ++ ) for ( int j = 0 ; j < dp [ 0 ] . length ; j ++ ) for ( int k = 0 ; k < dp [ j ] [ 0 ] . length ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ;", "nl": "Initialising the dp array to - 1"}
{"code": "Arrays . sort ( arr1 ) ; reverse ( arr1 ) ; Arrays . sort ( arr2 ) ; reverse ( arr2 ) ; Arrays . sort ( arr3 ) ; reverse ( arr3 ) ; return getMaxSum ( 0 , 0 , 0 , arr1 , arr2 , arr3 ) ; }", "nl": "Sort the arrays in descending order"}
{"code": "public static void main ( String [ ] args ) { n1 = 2 ; int arr1 [ ] = { 3 , 5 } ; n2 = 2 ; int arr2 [ ] = { 2 , 1 } ; n3 = 3 ; int arr3 [ ] = { 4 , 3 , 5 } ; System . out . println ( maxProductSum ( arr1 , arr2 , arr3 ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to implement the the above approach"}
{"code": "static void findTriplet ( int arr [ ] , int N ) {", "nl": "Function to find lexicographically largest triplet that forms a triangle in the given array"}
{"code": "Arrays . sort ( arr ) ; int flag = 0 , i ;", "nl": "Sort the array"}
{"code": "for ( i = N - 1 ; i - 2 >= 0 ; i -- ) {", "nl": "Iterate from the end of the array"}
{"code": "if ( arr [ i - 2 ] + arr [ i - 1 ] > arr [ i ] ) { flag = 1 ; break ; } }", "nl": "If the triplet forms a triangle"}
{"code": "if ( flag != 0 ) {", "nl": "If triplet found"}
{"code": "System . out . println ( arr [ i - 2 ] + \" \u2581 \" + arr [ i - 1 ] + \" \u2581 \" + arr [ i ] ) ; }", "nl": "Print the triplet"}
{"code": "else { System . out . println ( - 1 ) ; } }", "nl": "Otherwise"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 10 , 3 , 5 } ; int N = arr . length ; findTriplet ( arr , N ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . Arrays ; class GFG {", "nl": "Java program for the above"}
{"code": "static int numberofpairs ( int [ ] arr , int N ) {", "nl": "Function to return the count of all pairs having minimal absolute difference"}
{"code": "int answer = 0 ;", "nl": "Stores the count of pairs"}
{"code": "Arrays . sort ( arr ) ;", "nl": "Sort the array"}
{"code": "int minDiff = 10000000 ; for ( int i = 0 ; i < N - 1 ; i ++ )", "nl": "Stores the minimum difference between adjacent pairs"}
{"code": "minDiff = Math . min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff )", "nl": "Update the minimum difference between pairs"}
{"code": "answer ++ ; }", "nl": "Increase count of pairs with difference equal to that of minimum difference"}
{"code": "return answer ; }", "nl": "Return the final count"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int arr [ ] = { 4 , 2 , 1 , 3 } ; int N = arr . length ;", "nl": "Given array arr [ ]"}
{"code": "System . out . print ( numberofpairs ( arr , N ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java Program to implement the above approach"}
{"code": "static int max_length = 0 ;", "nl": "Initialise maximum possible length of subsequence"}
{"code": "static Vector < Integer > store = new Vector < Integer > ( ) ;", "nl": "Store elements to compare max_length with its size and change the value of max_length accordingly"}
{"code": "static Vector < Integer > ans = new Vector < Integer > ( ) ;", "nl": "Store the elements of the longest subsequence"}
{"code": "static void find_max_length ( int [ ] arr , int index , int sum , int k ) { sum = sum + arr [ index ] ; store . add ( arr [ index ] ) ; if ( sum == k ) { if ( max_length < store . size ( ) ) {", "nl": "Function to find the length of longest subsequence"}
{"code": "max_length = store . size ( ) ;", "nl": "Update max_length"}
{"code": "ans = store ; } } for ( int i = index + 1 ; i < arr . length ; i ++ ) { if ( sum + arr [ i ] <= k ) {", "nl": "Store the subsequence elements"}
{"code": "find_max_length ( arr , i , sum , k ) ;", "nl": "Recursively proceed with obtained sum"}
{"code": "store . remove ( store . size ( ) - 1 ) ; }", "nl": "poping elements from back of vector store"}
{"code": "else return ; } return ; } static int longestSubsequence ( int [ ] arr , int n , int k ) {", "nl": "if sum > 0 then we don 't  required thatsubsequence  so return and continue  with earlier elements"}
{"code": "Arrays . sort ( arr ) ;", "nl": "Sort the given array"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse the array"}
{"code": "if ( max_length >= n - i ) break ; store . clear ( ) ; find_max_length ( arr , i , 0 , k ) ; } return max_length ; }", "nl": "If max_length is already greater than or equal than remaining length"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { - 3 , 0 , 1 , 1 , 2 } ; int n = arr . length ; int k = 1 ; System . out . print ( longestSubsequence ( arr , n , k ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation to sort decreasing permutation of N using triple swaps"}
{"code": "static void sortArray ( int A [ ] , int N ) {", "nl": "Function to sort array"}
{"code": "int x = 0 , y = 0 , z = 0 ;", "nl": "The three indices that has to be chosen"}
{"code": "if ( N % 4 == 0 N % 4 == 1 ) {", "nl": "Check if possible to sort array"}
{"code": "for ( int i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; }", "nl": "Swapping to bring element at required position Bringing at least one element at correct position"}
{"code": "A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; }", "nl": "Tracing changes in array"}
{"code": "System . out . print ( \" Sorted \u2581 Array : \u2581 \" ) ; for ( int i = 0 ; i < N ; i ++ ) System . out . print ( A [ i ] + \" \u2581 \" ) ; }", "nl": "Print the sorted array"}
{"code": "else { System . out . print ( \" - 1\" ) ; } }", "nl": "If not possible to sort"}
{"code": "public static void main ( String [ ] args ) { int A [ ] = { 5 , 4 , 3 , 2 , 1 } ; int N = A . length ; sortArray ( A , N ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation of the approach"}
{"code": "static int findK ( int arr [ ] , int size , int N ) {", "nl": "Function to return K such that changing all elements greater than K to K will make array sum N otherwise return - 1"}
{"code": "Arrays . sort ( arr ) ; int temp_sum = 0 ;", "nl": "Sorting the array in increasing order"}
{"code": "for ( int i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ;", "nl": "Loop through all the elements of the array"}
{"code": "if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return - 1 ; }", "nl": "Checking if sum of array equals N"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 3 , 1 , 10 , 4 , 8 } ; int size = arr . length ; int N = 16 ; System . out . print ( findK ( arr , size , N ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static boolean existsTriplet ( int a [ ] , int b [ ] , int c [ ] , int x , int l1 , int l2 , int l3 ) {", "nl": "Function that returns true if there exists a triplet with sum x"}
{"code": "if ( l2 <= l1 && l2 <= l3 ) { swap ( l2 , l1 ) ; swap ( a , b ) ; } else if ( l3 <= l1 && l3 <= l2 ) { swap ( l3 , l1 ) ; swap ( a , c ) ; }", "nl": "Sorting arrays such that a [ ] represents smallest array"}
{"code": "for ( int i = 0 ; i < l1 ; i ++ ) {", "nl": "Iterating the smallest array"}
{"code": "int j = 0 , k = l3 - 1 ; while ( j < l2 && k >= 0 ) {", "nl": "Two pointers on second and third array"}
{"code": "if ( a [ i ] + b [ j ] + c [ k ] == x ) return true ; if ( a [ i ] + b [ j ] + c [ k ] < x ) j ++ ; else k -- ; } } return false ; }", "nl": "If a valid triplet is found"}
{"code": "public static void main ( String [ ] args ) { int a [ ] = { 2 , 7 , 8 , 10 , 15 } ; int b [ ] = { 1 , 6 , 7 , 8 } ; int c [ ] = { 4 , 5 , 5 } ; int l1 = a . length ; int l2 = b . length ; int l3 = c . length ; int x = 14 ; if ( existsTriplet ( a , b , c , x , l1 , l2 , l3 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "public static void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] ) ; }", "nl": "Utility function to print the contents of an array"}
{"code": "public static int compare ( int num1 , int num2 ) {", "nl": "A comparison function that return negative if ' AB ' is smaller than ' BA ' when we concatenate two numbers ' A ' and ' B ' For example , it will return negative value if we pass 12 and 24 as arguments . This function will be used during sort"}
{"code": "String A = Integer . toString ( num1 ) ;", "nl": "Convert first number to string format"}
{"code": "String B = Integer . toString ( num2 ) ;", "nl": "Convert second number to string format"}
{"code": "return ( A + B ) . compareTo ( B + A ) ; }", "nl": "Check if ' AB ' is smaller or ' BA ' and return integer value"}
{"code": "public static void printSmallest ( int N , int [ ] arr ) {", "nl": "Function to print the arrangement with the smallest value"}
{"code": "for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( compare ( arr [ i ] , arr [ j ] ) > 0 ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } }", "nl": "Sort using compare function which is defined above"}
{"code": "printArr ( arr , N ) ; }", "nl": "Print the sorted array"}
{"code": "public static void main ( String [ ] args ) { int [ ] arr = { 5 , 6 , 2 , 9 , 21 , 1 } ; int N = arr . length ; printSmallest ( N , arr ) ; } }", "nl": "Driver code"}
{"code": "class GFG { static void stableSelectionSort ( int [ ] a , int n ) {", "nl": "Java program for modifying Selection Sort so that it becomes stable ."}
{"code": "for ( int i = 0 ; i < n - 1 ; i ++ ) {", "nl": "Iterate through array elements"}
{"code": "int min = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ min ] > a [ j ] ) min = j ;", "nl": "Find minimum element from arr [ i ] to arr [ n - 1 ] ."}
{"code": "int key = a [ min ] ; while ( min > i ) { a [ min ] = a [ min - 1 ] ; min -- ; } a [ i ] = key ; } } static void printArray ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + \" \u2581 \" ) ; System . out . println ( ) ; }", "nl": "Move minimum element at current i ."}
{"code": "public static void main ( String [ ] args ) { int [ ] a = { 4 , 5 , 3 , 2 , 4 , 1 } ; int n = a . length ; stableSelectionSort ( a , n ) ; printArray ( a , n ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to check whether permutation of two arrays satisfy the condition a [ i ] + b [ i ] >= k ."}
{"code": "static boolean isPossible ( Integer a [ ] , int b [ ] , int n , int k ) {", "nl": "Check whether any permutation exists which satisfy the condition ."}
{"code": "Arrays . sort ( a , Collections . reverseOrder ( ) ) ;", "nl": "Sort the array a [ ] in decreasing order ."}
{"code": "Arrays . sort ( b ) ;", "nl": "Sort the array b [ ] in increasing order ."}
{"code": "for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }", "nl": "Checking condition on each index ."}
{"code": "public static void main ( String [ ] args ) { Integer a [ ] = { 2 , 1 , 3 } ; int b [ ] = { 7 , 8 , 9 } ; int k = 10 ; int n = a . length ; if ( isPossible ( a , b , n , k ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }", "nl": "Driver code"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program to implement simple approach to sort an array according to count of set bits ."}
{"code": "static int setBitCount ( int num ) { int count = 0 ; while ( num != 0 ) { if ( ( num & 1 ) != 0 ) count ++ ; num >>= 1 ; } return count ; }", "nl": "Function to count setbits"}
{"code": "static void sortBySetBitCount ( int [ ] arr , int n ) { ArrayList < ArrayList < Integer > > count = new ArrayList < ArrayList < Integer > > ( ) ;", "nl": "Function to sort By SetBitCount"}
{"code": "for ( int i = 0 ; i < n ; ++ i ) { count . add ( new ArrayList < Integer > ( Arrays . asList ( ( - 1 ) * setBitCount ( arr [ i ] ) , arr [ i ] ) ) ) ; } Collections . sort ( count , new Comparator < ArrayList < Integer > > ( ) { @ Override public int compare ( ArrayList < Integer > o1 , ArrayList < Integer > o2 ) { return o1 . get ( 0 ) . compareTo ( o2 . get ( 0 ) ) ; } } ) ; for ( int i = 0 ; i < count . size ( ) ; i ++ ) { System . out . print ( count . get ( i ) . get ( 1 ) + \" \u2581 \" ) ; } }", "nl": "Iterate over all values and insert into multimap"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; sortBySetBitCount ( arr , n ) ; } }", "nl": "Driver code"}
{"code": "public class GFG {", "nl": "Java program for the above approach"}
{"code": "static int canReach ( String s , int L , int R ) {", "nl": "Function to check if it is possible to reach the end of the binary string using the given jumps"}
{"code": "int dp [ ] = new int [ s . length ( ) ] ;", "nl": "Stores the DP states"}
{"code": "dp [ 0 ] = 1 ;", "nl": "Initial state"}
{"code": "int pre = 0 ;", "nl": "Stores count of indices from which it is possible to reach index i"}
{"code": "for ( int i = 1 ; i < s . length ( ) ; i ++ ) {", "nl": "Traverse the given string"}
{"code": "if ( i >= L ) { pre += dp [ i - L ] ; }", "nl": "Update the values of pre accordingly"}
{"code": "if ( i > R ) { pre -= dp [ i - R - 1 ] ; } if ( pre > 0 && s . charAt ( i ) == '0' ) dp [ i ] = 1 ; else dp [ i ] = 0 ; }", "nl": "If the jump size is out of the range [ L , R ]"}
{"code": "return dp [ s . length ( ) - 1 ] ; }", "nl": "Return answer"}
{"code": "public static void main ( String [ ] args ) { String S = \"01101110\" ; int L = 2 , R = 3 ; if ( canReach ( S , L , R ) == 1 ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }", "nl": "Driver Code"}
{"code": "public class GFG {", "nl": "Java program for the above approach"}
{"code": "static int maxXORUtil ( int arr [ ] , int N , int xrr , int orr ) {", "nl": "Recursive function to find all the possible breaking of arrays into subarrays and find the maximum Bitwise XOR"}
{"code": "if ( N == 0 ) return xrr ^ orr ;", "nl": "If the value of N is 0"}
{"code": "int x = maxXORUtil ( arr , N - 1 , xrr ^ orr , arr [ N - 1 ] ) ;", "nl": "Stores the result if the new group is formed with the first element as arr [ i ]"}
{"code": "int y = maxXORUtil ( arr , N - 1 , xrr , orr arr [ N - 1 ] ) ;", "nl": "Stores if the result if the arr [ i ] is included in the last group"}
{"code": "return Math . max ( x , y ) ; }", "nl": "Returns the maximum of x and y"}
{"code": "static int maximumXOR ( int arr [ ] , int N ) {", "nl": "Function to find the maximum possible Bitwise XOR of all possible values of the array after breaking the arrays into subarrays"}
{"code": "return maxXORUtil ( arr , N , 0 , 0 ) ; }", "nl": "Return the result"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 7 } ; int N = arr . length ; System . out . println ( maximumXOR ( arr , N ) ) ; } }", "nl": "Driver code"}
{"code": "import java . lang . * ; import java . io . * ; import java . util . * ; class GFG { static int N = 100000 + 5 ;", "nl": "Java program to implement the above approach"}
{"code": "static int visited [ ] = new int [ N ] ;", "nl": "Keep track of visited nodes"}
{"code": "static void construct_tree ( int weights [ ] , int n ) { int minimum = Arrays . stream ( weights ) . min ( ) . getAsInt ( ) ; int maximum = Arrays . stream ( weights ) . max ( ) . getAsInt ( ) ;", "nl": "Function to construct a tree such that there are no two adjacent nodes with the same weight"}
{"code": "if ( minimum == maximum ) {", "nl": "If minimum and maximum elements are equal , i . e . array contains one distinct element"}
{"code": "System . out . println ( \" No \" ) ; return ; }", "nl": "Tree cannot be constructed"}
{"code": "else {", "nl": "Otherwise"}
{"code": "System . out . println ( \" Yes \" ) ; }", "nl": "Tree can be constructed"}
{"code": "int root = weights [ 0 ] ;", "nl": "Choose weights [ 0 ] as root"}
{"code": "visited [ 1 ] = 1 ;", "nl": "First Node is visited"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Traverse the array"}
{"code": "if ( weights [ i ] != root && visited [ i + 1 ] == 0 ) { System . out . println ( 1 + \" \u2581 \" + ( i + 1 ) + \" \u2581 \" ) ;", "nl": "Otherwise , make an edge"}
{"code": "visited [ i + 1 ] = 1 ; } }", "nl": "Mark this node as visited"}
{"code": "int notroot = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root ) { notroot = i + 1 ; break ; } }", "nl": "Find a weight not same as the root & make edges with that node"}
{"code": "for ( int i = 0 ; i < n ; i ++ ) {", "nl": "Join non - roots with remaining nodes"}
{"code": "if ( weights [ i ] == root && visited [ i + 1 ] == 0 ) { System . out . println ( notroot + \" \u2581 \" + ( i + 1 ) ) ; visited [ i + 1 ] = 1 ; } } }", "nl": "Check if current node ' s \u2581 weight \u2581 \u2581 is \u2581 same \u2581 as \u2581 root \u2581 node ' s weight and if it is not visited or not"}
{"code": "public static void main ( String [ ] args ) { int weights [ ] = { 1 , 2 , 1 , 2 , 5 } ; int N = weights . length ;", "nl": "Driver Code"}
{"code": "construct_tree ( weights , N ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; import java . lang . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void minCost ( String s , int k ) {", "nl": "Function to find minimum cost to convert given string into string of K length same substring"}
{"code": "int n = s . length ( ) ;", "nl": "Stores length of string"}
{"code": "int ans = 0 ;", "nl": "Stores the minimum cost"}
{"code": "for ( int i = 0 ; i < k ; i ++ ) {", "nl": "Traverse left substring of k length"}
{"code": "int [ ] a = new int [ 26 ] ; for ( int j = i ; j < n ; j += k ) { a [ s . charAt ( j ) - ' a ' ] ++ ; }", "nl": "Stores the frequency"}
{"code": "int min_cost = Integer . MAX_VALUE ;", "nl": "Stores minimum cost for sequence of S [ i ] % k indices"}
{"code": "for ( int ch = 0 ; ch < 26 ; ch ++ ) { int cost = 0 ;", "nl": "Check for optimal character"}
{"code": "for ( int tr = 0 ; tr < 26 ; tr ++ ) cost += Math . abs ( ch - tr ) * a [ tr ] ;", "nl": "Find sum of distance ' a ' + ch from character S [ i ] % k indices"}
{"code": "min_cost = Math . min ( min_cost , cost ) ; }", "nl": "Choose minimum cost for each index i"}
{"code": "ans += min_cost ; }", "nl": "Increment ans"}
{"code": "System . out . println ( ans ) ; }", "nl": "Print minimum cost to convert string"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "String S = \" abcdefabc \" ; int K = 3 ;", "nl": "Given string S"}
{"code": "minCost ( S , K ) ; } }", "nl": "Function Call"}
{"code": "import java . io . * ; import java . util . * ; class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int minAbsDiff ( int N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; }", "nl": "Function to split the first N natural numbers into two sets having minimum absolute difference of their sums"}
{"code": "public static void main ( String [ ] args ) { int N = 6 ; System . out . println ( minAbsDiff ( N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG { static final int N = 10000 ;", "nl": "Java program for the above approach"}
{"code": "@ SuppressWarnings ( \" unchecked \" ) static Vector < Integer > [ ] adj = new Vector [ N ] ; static int used [ ] = new int [ N ] ; static int max_matching ;", "nl": "Adjacency list to store edges"}
{"code": "static void AddEdge ( int u , int v ) {", "nl": "Add an edge between U and V in tree"}
{"code": "adj [ u ] . add ( v ) ;", "nl": "Edge from u to v"}
{"code": "adj [ v ] . add ( u ) ; }", "nl": "Edge from V to U"}
{"code": "static void Matching_dfs ( int u , int p ) { for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) {", "nl": "Function that finds the maximum matching of the DFS"}
{"code": "if ( adj [ u ] . get ( i ) != p ) { Matching_dfs ( adj [ u ] . get ( i ) , u ) ; } }", "nl": "Go further as we are not allowed to go towards its parent"}
{"code": "if ( used [ u ] == 0 && used [ p ] == 0 && p != 0 ) {", "nl": "If U and its parent P is not taken then we must take & mark them as taken"}
{"code": "max_matching ++ ; used [ u ] = used [ p ] = 1 ; } }", "nl": "Increment size of edge set"}
{"code": "static void maxMatching ( ) {", "nl": "Function to find the maximum matching in a graph"}
{"code": "Matching_dfs ( 1 , 0 ) ;", "nl": "Taking 1 as a root of the tree"}
{"code": "System . out . print ( max_matching + \"NEW_LINE\"); }", "nl": "Print maximum Matching"}
{"code": "public static void main ( String [ ] args ) { for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ;", "nl": "Driver Code"}
{"code": "AddEdge ( 1 , 2 ) ; AddEdge ( 1 , 3 ) ; AddEdge ( 3 , 4 ) ; AddEdge ( 3 , 5 ) ;", "nl": "Joining edge between two nodes in tree"}
{"code": "maxMatching ( ) ; } }", "nl": "Function call"}
{"code": "class GFG {", "nl": "Java program to implement the above approach"}
{"code": "static int getMinCost ( int [ ] A , int [ ] B , int N ) { int mini = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { mini = Math . min ( mini , Math . min ( A [ i ] , B [ i ] ) ) ; }", "nl": "Function to calculate and return the minimum cost required to swap two arrays"}
{"code": "return mini * ( 2 * N - 1 ) ; }", "nl": "Return the total minimum cost"}
{"code": "public static void main ( String [ ] args ) { int N = 3 ; int [ ] A = { 1 , 4 , 2 } ; int [ ] B = { 10 , 6 , 12 } ; System . out . print ( getMinCost ( A , B , N ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void printVector ( ArrayList < Integer > arr ) { if ( arr . size ( ) != 1 ) {", "nl": "Function to print the values stored in vector arr"}
{"code": "for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { System . out . print ( arr . get ( i ) + \" \u2581 \" ) ; } System . out . println ( ) ; } }", "nl": "Traverse the vector arr"}
{"code": "static void findWays ( ArrayList < Integer > arr , int i , int n ) {", "nl": "Recursive function to print different ways in which N can be written as a sum of at 2 or more positive integers"}
{"code": "if ( n == 0 ) printVector ( arr ) ;", "nl": "If n is zero then print this ways of breaking numbers"}
{"code": "for ( int j = i ; j <= n ; j ++ ) {", "nl": "Start from previous element in the representation till n"}
{"code": "arr . add ( j ) ;", "nl": "Include current element from representation"}
{"code": "findWays ( arr , j , n - j ) ;", "nl": "Call function again with reduced sum"}
{"code": "arr . remove ( arr . size ( ) - 1 ) ; } }", "nl": "Backtrack to remove current element from representation"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver code"}
{"code": "int n = 4 ;", "nl": "Given sum N"}
{"code": "ArrayList < Integer > arr = new ArrayList < Integer > ( ) ;", "nl": "To store the representation of breaking N"}
{"code": "findWays ( arr , 1 , n ) ; } }", "nl": "Function call"}
{"code": "import java . util . HashMap ; import java . util . Map ; public class Main {", "nl": "Java program for rearrange array to generate maximum decreasing subsequences"}
{"code": "public static void Maximum_subsequence ( int [ ] A , int N ) {", "nl": "Function to count maximum subsequence"}
{"code": "HashMap < Integer , Integer > frequency = new HashMap < > ( ) ;", "nl": "Stores the frequency of array elements"}
{"code": "int max_freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) {", "nl": "Stores maximum frequency"}
{"code": "if ( frequency . containsKey ( A [ i ] ) ) { frequency . replace ( A [ i ] , frequency . get ( A [ i ] ) + 1 ) ; } else { frequency . put ( A [ i ] , 1 ) ; } } for ( Map . Entry it : frequency . entrySet ( ) ) {", "nl": "Update frequency of A [ i ]"}
{"code": "if ( ( int ) it . getValue ( ) > max_freq ) { max_freq = ( int ) it . getValue ( ) ; } }", "nl": "Update maximum subsequences"}
{"code": "System . out . println ( max_freq ) ; }", "nl": "Print the result"}
{"code": "public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 6 , 5 , 2 , 4 , 5 , 2 } ; int N = arr . length ; Maximum_subsequence ( arr , N ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above problem"}
{"code": "public static void DivideString ( String s , int n , int k ) { int i , c = 0 , no = 1 ; int c1 = 0 , c2 = 0 ;", "nl": "Function to print the arrangement of characters"}
{"code": "int [ ] fr = new int [ 26 ] ; char [ ] ans = new char [ n ] ; for ( i = 0 ; i < n ; i ++ ) { fr [ s . charAt ( i ) - ' a ' ] ++ ; } char ch = ' a ' , ch1 = ' a ' ; for ( i = 0 ; i < 26 ; i ++ ) {", "nl": "Stores frequency of characters"}
{"code": "if ( fr [ i ] == k ) { c ++ ; }", "nl": "Count the character having frequency K"}
{"code": "if ( fr [ i ] > k && fr [ i ] != 2 * k ) { c1 ++ ; ch = ( char ) ( i + ' a ' ) ; } if ( fr [ i ] == 2 * k ) { c2 ++ ; ch1 = ( char ) ( i + ' a ' ) ; } } for ( i = 0 ; i < n ; i ++ ) ans [ i ] = '1' ; HashMap < Character , Integer > mp = new HashMap < > ( ) ; if ( c % 2 == 0 c1 > 0 c2 > 0 ) { for ( i = 0 ; i < n ; i ++ ) {", "nl": "Count the character having frequency greater than K and not equal to 2 K"}
{"code": "if ( fr [ s . charAt ( i ) - ' a ' ] == k ) { if ( mp . containsKey ( s . charAt ( i ) ) ) { ans [ i ] = '2' ; } else { if ( no <= ( c / 2 ) ) { ans [ i ] = '2' ; no ++ ; mp . replace ( s . charAt ( i ) , 1 ) ; } } } }", "nl": "Case 1"}
{"code": "if ( ( c % 2 == 1 ) && ( c1 > 0 ) ) { no = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ch && no <= k ) { ans [ i ] = '2' ; no ++ ; } } }", "nl": "Case 2"}
{"code": "if ( c % 2 == 1 && c1 == 0 ) { no = 1 ; int flag = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ch1 && no <= k ) { ans [ i ] = '2' ; no ++ ; } if ( fr [ s . charAt ( i ) - ' a ' ] == k && flag == 0 && ans [ i ] == '1' ) { ans [ i ] = '2' ; flag = 1 ; } } } System . out . println ( ans ) ; } else {", "nl": "Case 3"}
{"code": "System . out . println ( \" NO \" ) ; } }", "nl": "If all cases fail"}
{"code": "public static void main ( String [ ] args ) { String S = \" abbbccc \" ; int N = S . length ( ) ; int K = 1 ; DivideString ( S , N , K ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to check if two items can be selected from two different categories without exceeding the total price"}
{"code": "static String check ( int S , int prices [ ] , int type [ ] , int n ) {", "nl": "Function to check if two items can be selected from two different categories without exceeding the total price"}
{"code": "for ( int j = 0 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) {", "nl": "Loop to choose two different pairs using two nested loops"}
{"code": "if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return \" Yes \" ; } } } } return \" No \" ; }", "nl": "Condition to check if the price of these two elements is less than S"}
{"code": "public static void main ( String [ ] args ) { int prices [ ] = { 3 , 8 , 6 , 5 } ; int type [ ] = { 0 , 1 , 1 , 0 } ; int S = 10 ; int n = 4 ;", "nl": "Driver Code"}
{"code": "System . out . print ( check ( S , prices , type , n ) ) ; } }", "nl": "Function Call"}
{"code": "class GFG {", "nl": "Java implementation to find the largest value of a + b satisfying the given condition"}
{"code": "static int getLargestSum ( int N ) {", "nl": "Function to return the maximum sum of a + b satisfying the given condition"}
{"code": "int max_sum = 0 ;", "nl": "Initialize max_sum"}
{"code": "for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) {", "nl": "Consider all possible pairs and check the sum divides product property"}
{"code": "int k = N / j ; int a = k * i ; int b = k * j ;", "nl": "To find the largest factor k"}
{"code": "if ( a <= N && b <= N && a * b % ( a + b ) == 0 )", "nl": "Check if the product is divisible by the sum"}
{"code": "max_sum = Math . max ( max_sum , a + b ) ; } }", "nl": "Storing the maximum sum in the max_sum variable"}
{"code": "return max_sum ; }", "nl": "Return the max_sum value"}
{"code": "public static void main ( String [ ] args ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; System . out . print ( max_sum + \"NEW_LINE\"); } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java implementation of the approach"}
{"code": "static String encryptString ( String str , int n ) { int i = 0 , cnt = 0 ; String encryptedStr = \" \" ; while ( i < n ) {", "nl": "Function to return the encrypted String"}
{"code": "cnt = i + 1 ;", "nl": "Number of times the current character will be repeated"}
{"code": "while ( cnt -- > 0 ) encryptedStr += str . charAt ( i ) ; i ++ ; } return encryptedStr ; }", "nl": "Repeat the current character in the encrypted String"}
{"code": "public static void main ( String [ ] args ) { String str = \" geeks \" ; int n = str . length ( ) ; System . out . println ( encryptString ( str , n ) ) ; } }", "nl": "Driver code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program to find the minimum difference ."}
{"code": "static int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ;", "nl": "Function to return required minimum difference"}
{"code": "for ( int i = 0 ; i < n ; ++ i ) { mn = Math . min ( mn , A [ i ] ) ; mx = Math . max ( mx , A [ i ] ) ; }", "nl": "finding minimum and maximum values"}
{"code": "return Math . max ( 0 , mx - mn - 2 * x ) ; }", "nl": "returning minimum possible difference"}
{"code": "public static void main ( String [ ] args ) { int n = 3 , x = 3 ; int A [ ] = { 1 , 3 , 6 } ;", "nl": "Driver program"}
{"code": "System . out . println ( minDiff ( n , x , A ) ) ; } }", "nl": "function to return the answer"}
{"code": "public class BalanceParan { static long swapCount ( String s ) { char [ ] chars = s . toCharArray ( ) ;", "nl": "Java Program to count swaps required to balance string"}
{"code": "int countLeft = 0 , countRight = 0 ;", "nl": "stores total number of Left and Right brackets encountered"}
{"code": "int swap = 0 , imbalance = 0 ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( chars [ i ] == ' [ ' ) {", "nl": "swap stores the number of swaps required imbalance maintains the number of imbalance pair"}
{"code": "countLeft ++ ; if ( imbalance > 0 ) {", "nl": "increment count of Left bracket"}
{"code": "swap += imbalance ;", "nl": "swaps count is last swap count + total number imbalanced brackets"}
{"code": "imbalance -- ; } } else if ( chars [ i ] == ' ] ' ) {", "nl": "imbalance decremented by 1 as it solved only one imbalance of Left and Right"}
{"code": "countRight ++ ;", "nl": "increment count of Right bracket"}
{"code": "imbalance = ( countRight - countLeft ) ; } } return swap ; }", "nl": "imbalance is reset to current difference between Left and Right brackets"}
{"code": "public static void main ( String args [ ] ) { String s = \" [ ] ] [ ] [ \" ; System . out . println ( swapCount ( s ) ) ; s = \" [ [ ] [ ] ] \" ; System . out . println ( swapCount ( s ) ) ; } }", "nl": "Driver code"}
{"code": "class GFG {", "nl": "Java program for the above approach"}
{"code": "public static void longestSubSequence ( int [ ] [ ] A , int N ) {", "nl": "Function to find the length of the longest subsequence of pairs whose first element is increasing and second is decreasing"}
{"code": "int [ ] dp = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) {", "nl": "dp [ i ] : Stores the longest subsequence upto i"}
{"code": "dp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) {", "nl": "Base case"}
{"code": "if ( A [ j ] [ 0 ] < A [ i ] [ 0 ] && A [ j ] [ 1 ] > A [ i ] [ 1 ] ) { dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } }", "nl": "When the conditions hold"}
{"code": "System . out . println ( dp [ N - 1 ] ) ; }", "nl": "Finally , print the required answer"}
{"code": "public static void main ( String args [ ] ) {", "nl": "Driver Code"}
{"code": "int [ ] [ ] A = { { 1 , 2 } , { 2 , 2 } , { 3 , 1 } } ; int N = A . length ;", "nl": "Given Input"}
{"code": "longestSubSequence ( A , N ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java Program for the above approach"}
{"code": "static int findWays ( int N , int dp [ ] ) {", "nl": "Function to calculate the total number of ways to have sum N"}
{"code": "if ( N == 0 ) { return 1 ; }", "nl": "Base Case"}
{"code": "if ( dp [ N ] != - 1 ) { return dp [ N ] ; } int cnt = 0 ;", "nl": "Return already stored result"}
{"code": "for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i , dp ) ; } }", "nl": "Recur for all 6 states"}
{"code": "return dp [ N ] = cnt ; }", "nl": "Return the result"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 4 ;", "nl": "Given sum N"}
{"code": "int [ ] dp = new int [ N + 1 ] ; for ( int i = 0 ; i < dp . length ; i ++ ) dp [ i ] = - 1 ;", "nl": "Initialize the dp array"}
{"code": "System . out . print ( findWays ( N , dp ) ) ; } }", "nl": "Function Call"}
{"code": "import java . util . * ; class GFG {", "nl": "Java program for the above approach"}
{"code": "static void findWays ( int N ) {", "nl": "Function to calculate the total number of ways to have sum N"}
{"code": "int [ ] dp = new int [ N + 1 ] ; dp [ 0 ] = 1 ;", "nl": "Initialize dp array"}
{"code": "for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ;", "nl": "Iterate over all the possible intermediate values to reach N"}
{"code": "for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } }", "nl": "Calculate the sum for all 6 faces"}
{"code": "System . out . print ( dp [ N ] ) ; }", "nl": "Print the total number of ways"}
{"code": "public static void main ( String [ ] args ) {", "nl": "Driver Code"}
{"code": "int N = 4 ;", "nl": "Given sum N"}
{"code": "findWays ( N ) ; } }", "nl": "Function call"}
{"code": "import java . util . * ; class GFG { static int INF = ( int ) ( 1e9 + 9 ) ;", "nl": "Java implementation to split the String into minimum number of parts such that each part is also present in the another String"}
{"code": "static class TrieNode { TrieNode [ ] child = new TrieNode [ 26 ] ; } ;", "nl": "Node of Trie"}
{"code": "static void insert ( int idx , String s , TrieNode root ) { TrieNode temp = root ; for ( int i = idx ; i < s . length ( ) ; i ++ ) {", "nl": "Function to insert a node in the Trie Data Structure"}
{"code": "if ( temp . child [ s . charAt ( i ) - ' a ' ] == null )", "nl": "Inserting every character from idx till end to String into trie"}
{"code": "temp . child [ s . charAt ( i ) - ' a ' ] = new TrieNode ( ) ; temp = temp . child [ s . charAt ( i ) - ' a ' ] ; } }", "nl": "If there is no edge corresponding to the ith character , then make a new node"}
{"code": "static int minCuts ( String S1 , String S2 ) { int n1 = S1 . length ( ) ; int n2 = S2 . length ( ) ;", "nl": "Function to find the minimum number of parts such that each part is present into another String"}
{"code": "TrieNode root = new TrieNode ( ) ; for ( int i = 0 ; i < n2 ; i ++ ) {", "nl": "Making a new trie"}
{"code": "insert ( i , S2 , root ) ; }", "nl": "Inserting every subString of S2 in trie"}
{"code": "int [ ] dp = new int [ n1 + 1 ] ; Arrays . fill ( dp , INF ) ;", "nl": "Creating dp array and init it with infinity"}
{"code": "dp [ 0 ] = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) {", "nl": "Base Case"}
{"code": "TrieNode temp = root ; for ( int j = i + 1 ; j <= n1 ; j ++ ) { if ( temp . child [ S1 . charAt ( j - 1 ) - ' a ' ] == null )", "nl": "Starting the cut from ith character taking temporary node pointer for checking whether the subString [ i , j ) is present in trie of not"}
{"code": "break ;", "nl": "If the jth character is not in trie we 'll break"}
{"code": "dp [ j ] = Math . min ( dp [ j ] , dp [ i ] + 1 ) ;", "nl": "Updating the the ending of jth character with dp [ i ] + 1"}
{"code": "temp = temp . child [ S1 . charAt ( j - 1 ) - ' a ' ] ; } }", "nl": "Descending the trie pointer"}
{"code": "if ( dp [ n1 ] >= INF ) return - 1 ; else return dp [ n1 ] ; }", "nl": "Answer not possible"}
{"code": "public static void main ( String [ ] args ) { String S1 = \" abcdab \" ; String S2 = \" dabc \" ; System . out . print ( minCuts ( S1 , S2 ) ) ; } }", "nl": "Driver Code"}
{"code": "import java . util . * ; class GFG {", "nl": "Java implementation to find the largest square in the matrix such that it contains atmost K 1 's"}
{"code": "static void largestSquare ( int matrix [ ] [ ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ ] [ ] = new int [ R ] [ C ] ; for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) countDP [ i ] [ j ] = 0 ;", "nl": "Function to find the largest square in the matrix such that it contains atmost K 1 's"}
{"code": "countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ;", "nl": "Precomputation of the countDP prefix sum of the matrix"}
{"code": "for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 , l = 0 , u = min_dist ;", "nl": "Loop to solve each query"}
{"code": "while ( l <= u ) { int mid = ( l + u ) / 2 ; int x1 = i - mid , x2 = i + mid ; int y1 = j - mid , y2 = j + mid ;", "nl": "Binary Search to the side which have atmost in K 1 's in square"}
{"code": "int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ;", "nl": "Count total number of 1 s in the sub square considered"}
{"code": "if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } System . out . println ( ans ) ; } }", "nl": "If the count is less than or equals to the maximum move to right half"}
{"code": "public static void main ( String args [ ] ) { int matrix [ ] [ ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; } }", "nl": "Driver code"}
